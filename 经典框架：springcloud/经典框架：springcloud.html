<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>经典框架：SpringCloud - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="经典框架：SpringCloud" class="main-title"></div></div></header><article><h1 id="gmsmnfKgEDdbaHtgzgW7De" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">SpringCloud<span class="jill"></span>断路器的作用是什么？</span></h1><div id="oyRY2DitDfTnMetwxZdXgR" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring Cloud<span class="jill"></span>断路器（Hystrix）是一种用于构建弹性、容错和容灾机制的开源库。它提供了一种通过隔离和控制远程服务调用的方式，以防止由于服务故障或延迟而导致的级联故障。</span></div></div><div id="x5xYbr5p5W5kWWZHwqcdpW" class="wolai-block wolai-text"><div><span class="inline-wrap">断路器的作用如下：</span></div></div><ol class="wolai-block"><li id="8Ae5r7bVTaeoACv62n55qd"><div class="marker"></div><span class="inline-wrap"><b>故障隔离</b></span><span class="inline-wrap">：断路器通过将远程服务调用封装在一个独立的断路器中，可以隔离故障的影响范围。当远程服务发生故障或延迟时，断路器可以快速失败并返回预定义的默认值，而不会影响整个系统的稳定性。</span></li><li id="nGbhcNEFn7wVtdQPfqnZQ6"><div class="marker"></div><span class="inline-wrap"><b>容错处理</b></span><span class="inline-wrap">：断路器可以在远程服务不可用时提供备用方案。通过配置降级逻辑，可以在远程服务故障时返回预先定义的备用数据，以保证系统的可用性和稳定性。</span></li><li id="pnoDzGGhK52DtUsG9iSKNY"><div class="marker"></div><span class="inline-wrap"><b>自动恢复</b></span><span class="inline-wrap">：断路器具备自我修复的能力。它会定期尝试恢复远程服务的调用，以检查其可用性。当远程服务恢复正常时，断路器会逐渐恢复对该服务的调用，并重新建立正常的调用链路。</span></li><li id="xotRqjr9LuJNQtDZmAEbod"><div class="marker"></div><span class="inline-wrap"><b>实时监控</b></span><span class="inline-wrap">：断路器提供了实时监控和度量功能，可以收集和展示远程服务调用的各项指标，如调用次数、失败率、响应时间等。这些指标可以帮助开发人员和运维人员了解系统的健康状况，并进行故障排查和性能优化。</span></li></ol><div id="efbStdUGzxFtR6zcieLPE9" class="wolai-block wolai-text"><div><span class="inline-wrap">通过使用<span class="jill"></span>Spring Cloud<span class="jill"></span>断路器，可以有效地处理分布式系统中的服务故障和延迟问题，提高系统的容错性和可用性。它是构建弹性和可靠微服务架构的重要组件之一。</span></div></div><div id="nLF9wLyZBN5ta4k8o1Eb26" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9EzbKcqZWn14FjsB1yTFHh" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">SpringCloud<span class="jill"></span>的核心组件有哪些？它们的作用分别是什么？</span></h1><h2 id="h3vuYFvVehoxk2rNioRuGZ" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">Netflix<span class="jill"></span>系列组件</span></h2><div id="vZXNGMJWiisFQrtiXiHNCL" class="wolai-block"><figure class="wolai-center" style="width: 537.0370275526218px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><h3 id="ta1FX84cgV4LZN33giQ3kb" class="wolai-block"><span class="wolai-serial-number">2.1.1</span><span class="inline-wrap">Eureka：服务注册与发现</span></h3><h4 id="rg4ZHpBQU6fnc8QBwjysn2" class="wolai-block"><span class="wolai-serial-number">2.1.1.1</span><span class="inline-wrap">服务注册</span></h4><div id="rphhdv7qFwm6ZUgoyXjnV6" class="wolai-block wolai-text"><div><span class="inline-wrap">每个服务都向<span class="jill"></span>Eureka<span class="jill"></span>登记自己提供服务的元数据，包括服务的<span class="jill"></span>IP<span class="jill"></span>地址、端口号、版本号、通信协议等。</span></div></div><div id="b1jTBDcBH9VKmmCTLkLepG" class="wolai-block wolai-text"><div><span class="inline-wrap">Eureka<span class="jill"></span>将各个服务维护在了一个服务清单中（双层<span class="jill"></span>Map，第一层<span class="jill"></span>key<span class="jill"></span>是服务名，第二层<span class="jill"></span>key<span class="jill"></span>是实例名，value<span class="jill"></span>是服务地址加端口）。</span></div></div><div id="8KGQikC2E7imj6NvFCZ8eV" class="wolai-block wolai-text"><div><span class="inline-wrap">同时对服务维持心跳，剔除不可用的服务，Eureka<span class="jill"></span>集群各节点相互注册每个实例中都有一样的服务清单。</span></div></div><div id="vaWJ6KKZMULbn8oDHNfdfa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="a7zRWkoDxFptJgJ3ZmZ5nr" class="wolai-block"><span class="wolai-serial-number">2.1.1.2</span><span class="inline-wrap">服务发现</span></h4><div id="fjRzQcu6u26dWCFng95eLm" class="wolai-block wolai-text"><div><span class="inline-wrap">eureka<span class="jill"></span>注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单(缓存到本地)，然后实现服务的请求访问。</span></div></div><div id="cF14JPG6GwSAnbHsua28GS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="rKhBsBFsUXJAhyVUYsywTK" class="wolai-block"><span class="wolai-serial-number">2.1.2</span><span class="inline-wrap">Ribbon：负载均衡</span></h3><div id="rxN2J6gNHNe2GF1MjrKpGt" class="wolai-block wolai-text"><div><span class="inline-wrap">服务间发起请求的时候，基于<span class="jill"></span>Ribbon<span class="jill"></span>做负载均衡，从⼀个服务的多台机器中选择⼀台 （被调用方的服务地址有多个），Ribbon<span class="jill"></span>也是通过发起<span class="jill"></span>http<span class="jill"></span>请求，来进行的调用，只不过是通过调用服务名的地址来实现的。虽然说<span class="jill"></span>Ribbon<span class="jill"></span>不用去具体请求服务实例的<span class="jill"></span>ip<span class="jill"></span>地址或域名了，但是每调用一个接口都还要手动去发起<span class="jill"></span>Http<span class="jill"></span>请求。</span></div></div><div id="7WoAPCRnqGnPWhJcbQfNTD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="dGURMg9tLYstwH51WH5Wh5" class="wolai-block"><span class="wolai-serial-number">2.1.3</span><span class="inline-wrap">Hystrix：熔断降级</span></h3><div id="ng2KLASBL6heXre3QZy6ob" class="wolai-block wolai-text"><div><span class="inline-wrap">发起请求是通过<span class="jill"></span>Hystrix<span class="jill"></span>的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级。</span></div></div><div id="9GveXpBNdU6eWXzNzwmEaA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vghBk843ZZyj6szzMutzdb" class="wolai-block"><span class="wolai-serial-number">2.1.4</span><span class="inline-wrap">Zuul：网关</span></h3><div id="ay7i1R2fXd3boRy8HssGs" class="wolai-block wolai-text"><div><span class="inline-wrap">如果前端、移动端要调⽤后端系统，统⼀从<span class="jill"></span>Zuul<span class="jill"></span>网关进⼊，由<span class="jill"></span>Zuul<span class="jill"></span>网关转发请求给对应的服务，通过与<span class="jill"></span>Eureka<span class="jill"></span>进行整合，将自身注册为<span class="jill"></span>Eureka<span class="jill"></span>下的应用，从<span class="jill"></span>Eureka<span class="jill"></span>下获取所有服务的实例，来进行服务的路由。Zuul<span class="jill"></span>还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。</span></div></div><div id="wBQF8St8eouGWjzup87gBr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="uGUsZAJpJZQk5HBTtKg1Z3" class="wolai-block"><span class="wolai-serial-number">2.1.5</span><span class="inline-wrap">SpringCloud Config：配置中心</span></h3><div id="aF1bfxJhGeRP6iGVF5UH1h" class="wolai-block wolai-text"><div><span class="inline-wrap">提供服务器端和客户端。服务器存储后端的默认实现使用<span class="jill"></span>git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。这个还是静态的，需要得配合<span class="jill"></span>Spring Cloud Bus<span class="jill"></span>实现动态的配置更新。</span></div></div><div id="gLspYja8mmPYGd5SaaZeMM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dQomDuREkK7kKEceChuFag" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">Spring Cloud Alibaba<span class="jill"></span>系列</span></h2><ol class="wolai-block"><li id="nQZFfbPWmFKhsQJc3pZJTC"><div class="marker"></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：作为服务注册中心和配置中心，Nacos<span class="jill"></span>提供了服务发现和动态配置的功能。它支持多种负载均衡策略，并且可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级的监控数据。</span></li><li id="envWJNq3SMuKeNhGE2VMMw"><div class="marker"></div><span class="inline-wrap"><b>Sentinel</b></span><span class="inline-wrap">：Sentinel<span class="jill"></span>是一个面向分布式服务架构的流量控制和熔断降级组件。它可以保护服务的稳定性，防止因流量突增导致的系统崩溃。</span></li><li id="2w1fF2MfUUpEn1r5igSoTA"><div class="marker"></div><span class="inline-wrap"><b>RocketMQ</b></span><span class="inline-wrap">：RocketMQ<span class="jill"></span>是一款高性能、高可靠性的消息中间件，适用于大规模分布式系统中的异步消息传递。它支持发布-订阅模式和点对点模式。</span></li><li id="hx7goyT74s6LtnoA8ukLpJ"><div class="marker"></div><span class="inline-wrap"><b>Seata</b></span><span class="inline-wrap">：Seata<span class="jill"></span>是一个易于使用的高性能微服务分布式事务解决方案，支持<span class="jill"></span>ACID<span class="jill"></span>特性，确保在分布式环境下事务的一致性。</span></li><li id="r1wit5YmC371jHbW9xbpr1"><div class="marker"></div><span class="inline-wrap"><b>Dubbo</b></span><span class="inline-wrap">：Dubbo<span class="jill"></span>是高性能<span class="jill"></span>Java RPC<span class="jill"></span>框架，提供透明的远程过程调用（RPC），使得开发者可以像调用本地方法一样调用远程服务。</span></li></ol><div id="3xxB7TWv2aAdDCNESKA75X" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="jA77GzAgbB7mryk6DjPhd9" class="wolai-block"><span class="wolai-serial-number">2.3</span><span class="inline-wrap">其它新生代组件</span></h2><ol class="wolai-block"><li id="phVTpY9wohGyB2PSGgXmgk"><div class="marker"></div><span class="inline-wrap"><b>Spring Cloud Gateway</b></span><ul class="wolai-block"><li id="nUgP5p34odBpiFi9AMLHpV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：Spring Cloud Gateway<span class="jill"></span>是一个基于<span class="jill"></span>Spring Framework 5，Project Reactor<span class="jill"></span>和<span class="jill"></span>Spring Boot 2.0<span class="jill"></span>构建的<span class="jill"></span>API<span class="jill"></span>网关服务。</span></li><li id="jzcLVbFS8TfKdL7hZdzK7K"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>主要功能</b></span><span class="inline-wrap">：提供路由转发、负载均衡、动态路由、路径重写、权限校验等功能。作为微服务架构中的入口，负责将外部请求路由到内部的各个微服务上，同时提供安全、监控和管理等功能。</span></li></ul></li><li id="t2F55KxL91f1j4zFBjhM8n"><div class="marker"></div><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><ul class="wolai-block"><li id="q1eTmTC18qJMs41U46T1LR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：Spring Cloud LoadBalancer<span class="jill"></span>是由<span class="jill"></span>SpringCloud<span class="jill"></span>官方提供的一个开源的、简单易用的客户端负载均衡器，它包含在<span class="jill"></span>SpringCloud-commons<span class="jill"></span>中，用它来替换以前的<span class="jill"></span>Ribbon<span class="jill"></span>组件。</span></li><li id="2u8CWpuaY9dGHvu7wksHSL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>主要功能</b></span><span class="inline-wrap">：为服务调用提供负载均衡策略，如轮询、随机等。通过与注册中心（如<span class="jill"></span>Eureka、Consul<span class="jill"></span>等）集成，获取可用的服务实例列表，并根据负载均衡策略选择一个实例进行访问。</span></li></ul></li><li id="pVYaK8BbsbWDA4ci2FxdAe"><div class="marker"></div><span class="inline-wrap"><b>Spring Cloud OpenFeign</b></span><ul class="wolai-block"><li id="cF4tE5SQrGShaxVtqwJfWn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：Spring Cloud OpenFeign<span class="jill"></span>是一个声明式的<span class="jill"></span>Web<span class="jill"></span>服务客户端，它使得编写<span class="jill"></span>Web<span class="jill"></span>服务客户端变得更简单。</span></li><li id="oJADhaNVb5hZxfe1CbqkS2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>主要功能</b></span><span class="inline-wrap">：通过注解的方式定义接口，然后由<span class="jill"></span>OpenFeign<span class="jill"></span>框架自动生成实现代码并注入<span class="jill"></span>Spring<span class="jill"></span>容器中。支持负载均衡，可以通过与<span class="jill"></span>Spring Cloud LoadBalancer<span class="jill"></span>或<span class="jill"></span>Ribbon<span class="jill"></span>集成来实现。简化了<span class="jill"></span>HTTP<span class="jill"></span>客户端的开发，提高了开发效率。</span></li></ul></li></ol><div id="9MYhnxVLeEwPzTbQFZTLNb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="p5X37ZUwbwpWdR7XneBCrg" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vwC2EojbbMSrNm3NuWDG1a" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">Feign<span class="jill"></span>和<span class="jill"></span>Open Feign<span class="jill"></span>是两个不同的组件吗？它们有什么区别？</span></h1><div id="udMvvaovNBArdksVdkB5fK" class="wolai-block wolai-text"><div><span class="inline-wrap">Feign<span class="jill"></span>和<span class="jill"></span>Open Feign<span class="jill"></span>是两个不同的组件，它们在</span><span class="inline-wrap"><b>定义、依赖关系以及配置方式</b></span><span class="inline-wrap">等方面存在区别。以下是具体分析：</span></div></div><ol class="wolai-block"><li id="dX48qNE8oQb2HHxwei2EvL"><div class="marker"></div><span class="inline-wrap"><b>定义</b></span><ul class="wolai-block"><li id="dTBn7uwbncFcdGu6mgNsno"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Feign</b></span><span class="inline-wrap">：Feign<span class="jill"></span>是一个轻量级的声明式<span class="jill"></span>Web<span class="jill"></span>服务客户端，由<span class="jill"></span>Netflix<span class="jill"></span>开发。它使得编写<span class="jill"></span>Java HTTP<span class="jill"></span>客户端变得更容易，通过定义接口和使用注解来描述<span class="jill"></span>HTTP<span class="jill"></span>请求的细节。</span></li><li id="gAgmDbisUaSMAV4yH5b4GJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Open Feign</b></span><span class="inline-wrap">：Open Feign<span class="jill"></span>是<span class="jill"></span>Spring Cloud<span class="jill"></span>对<span class="jill"></span>Feign<span class="jill"></span>的封装和扩展，使其支持<span class="jill"></span>Spring MVC<span class="jill"></span>标准注解和<span class="jill"></span>HttpMessageConverters。Open Feign<span class="jill"></span>不仅继承了<span class="jill"></span>Feign<span class="jill"></span>的所有功能，还增加了与<span class="jill"></span>Spring Cloud<span class="jill"></span>生态系统的集成，如负载均衡、熔断降级等。</span></li></ul></li><li id="ufDojpu1P1nZ425HWSJerH"><div class="marker"></div><span class="inline-wrap"><b>依赖关系</b></span><ul class="wolai-block"><li id="oJB7QgJDqXGMtf6K5jgMEh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Feign</b></span><span class="inline-wrap">：作为一个独立的项目，Feign<span class="jill"></span>可以与任何<span class="jill"></span>Java<span class="jill"></span>应用程序一起使用。</span></li><li id="4BYq6wS3ci16d2To7ijdeL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Open Feign</b></span><span class="inline-wrap">：Open Feign<span class="jill"></span>是<span class="jill"></span>Spring Cloud<span class="jill"></span>中的一个组件，需要依赖<span class="jill"></span>Spring Cloud<span class="jill"></span>来使用。</span></li></ul></li><li id="p25Bh3uALhqRgK5zWyx5AU"><div class="marker"></div><span class="inline-wrap"><b>配置方式</b></span><ul class="wolai-block"><li id="paGXqixmDYpBA4YyLNWDqn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Feign</b></span><span class="inline-wrap">：配置是通过接口上的注解来完成的，例如使用</span><span class="inline-wrap"><code>@RequestMapping</code></span><span class="inline-wrap">注解定义请求路径、HTTP<span class="jill"></span>方法等。</span></li><li id="46wzs8WqmizkmZ271XC37P"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Open Feign</b></span><span class="inline-wrap">：提供了更多的配置选项，可以使用<span class="jill"></span>Spring Cloud<span class="jill"></span>的配置方式，例如通过属性文件、配置中心等来配置<span class="jill"></span>Feign<span class="jill"></span>客户端。</span></li></ul></li><li id="4Rm6QWztEerKx2VQC5YajV"><div class="marker"></div><span class="inline-wrap"><b>功能扩展</b></span><ul class="wolai-block"><li id="8okGaYhKGrk9ffpKzc4tiJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Feign</b></span><span class="inline-wrap">：Feign<span class="jill"></span>本身并不包含服务降级、熔断、请求重试等功能。</span></li><li id="kbviiWzNndALjZPPWVNbQE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Open Feign</b></span><span class="inline-wrap">：Open Feign<span class="jill"></span>在<span class="jill"></span>Feign<span class="jill"></span>的基础上进行了扩展，提供了更多的功能，如服务降级、熔断、请求重试等，并且默认集成了<span class="jill"></span>Ribbon<span class="jill"></span>和<span class="jill"></span>Hystrix。</span></li></ul></li><li id="gJ3BrWAXKj5sr6mDGvMB6Q"><div class="marker"></div><span class="inline-wrap"><b>默认集成</b></span><ul class="wolai-block"><li id="5EjDbErTqZAqYNAMzkBex7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Feign</b></span><span class="inline-wrap">：不包含对<span class="jill"></span>Spring Cloud<span class="jill"></span>其他组件（如<span class="jill"></span>Eureka、Ribbon）的默认集成。</span></li><li id="chhNTFQGwHs8Gx17y4MFL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Open Feign</b></span><span class="inline-wrap">：默认集成了<span class="jill"></span>Ribbon<span class="jill"></span>和<span class="jill"></span>Hystrix，可以通过注解和配置来启用这些功能。</span></li></ul></li></ol><div id="4XoascF9Kip1whVB6D9HqA" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，Feign<span class="jill"></span>和<span class="jill"></span>Open Feign<span class="jill"></span>都是用于简化微服务架构中服务间调用的工具，但<span class="jill"></span>Open Feign<span class="jill"></span>作为<span class="jill"></span>Spring Cloud<span class="jill"></span>的一部分，提供了更丰富的功能和更紧密的集成。如果您的项目已经在使用<span class="jill"></span>Spring Cloud，那么推荐使用<span class="jill"></span>Open Feign<span class="jill"></span>以获得更好的兼容性和功能支持。</span></div></div><div id="uJoDRTLnjsaJt7anY5R4sk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="2qwsG9x9YR4AV2q8nYs2yw" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="amkjoy3K6t171Z7R5cW7Hk" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">Ribbon<span class="jill"></span>和</span><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><span class="inline-wrap">的区别是什么？</span></h1><div id="mbkrVMqYzwd3mXX4DHTiFg" class="wolai-block wolai-text"><div><span class="inline-wrap">Ribbon<span class="jill"></span>和<span class="jill"></span>Spring Cloud LoadBalancer<span class="jill"></span>都是<span class="jill"></span>Spring Cloud<span class="jill"></span>中用于实现客户端负载均衡的组件，它们在</span><span class="inline-wrap"><b>实现方式、易用性以及生态完整</b></span><span class="inline-wrap">等方面存在区别。以下是具体分析：</span></div></div><ol class="wolai-block"><li id="rxSaoFxhUp4LhygUWTnFm7"><div class="marker"></div><span class="inline-wrap"><b>实现方式</b></span><ul class="wolai-block"><li id="3mVryt7v1Veqaj3WwPuvWk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Ribbon</b></span><span class="inline-wrap">：是一个独立的第三方库，需要单独引入到项目中。</span></li><li id="mKx1xLiT5piKpnnynyjVms"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><span class="inline-wrap">：作为<span class="jill"></span>Spring Cloud<span class="jill"></span>的一个组件，集成在<span class="jill"></span>Spring Cloud<span class="jill"></span>中，可以直接使用。</span></li></ul></li><li id="4CoqzJkaGtpUzokus9HquA"><div class="marker"></div><span class="inline-wrap"><b>易用性</b></span><ul class="wolai-block"><li id="71Y7K4P5hdNEM2iuFuXUPR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Ribbon</b></span><span class="inline-wrap">：作为一个较为底层的负载均衡器，开发人员需要手动配置负载均衡策略和服务发现机制。</span></li><li id="sRvJzDoUBG5sFBjuTU22XK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><span class="inline-wrap">：提供了一个更高层次的抽象，将负载均衡策略和服务发现机制的实现进行了封装，使开发人员更容易使用。</span></li></ul></li><li id="tkYpXdhEELz6VsrH1Uv6uz"><div class="marker"></div><span class="inline-wrap"><b>生态完整</b></span><ul class="wolai-block"><li id="5mmSkJUsvVSgPvT7jVszC1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Ribbon</b></span><span class="inline-wrap">：与<span class="jill"></span>Eureka<span class="jill"></span>紧密集成，但随着<span class="jill"></span>Eureka<span class="jill"></span>的废弃，Ribbon<span class="jill"></span>的支持也受到了影响。</span></li><li id="83LvX3Mz6ZTM2uh4f1X5Dh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><span class="inline-wrap">：与<span class="jill"></span>Spring Cloud<span class="jill"></span>的其他组件（如服务发现、配置中心等）紧密集成，形成了统一的架构风格，方便开发和维护。</span></li></ul></li><li id="pv1Qb7V5BRmg832iGcNpq4"><div class="marker"></div><span class="inline-wrap"><b>性能稳定性</b></span><ul class="wolai-block"><li id="dfmQXmW9P1LhgBZzuANkcH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Ribbon</b></span><span class="inline-wrap">：虽然<span class="jill"></span>Ribbon<span class="jill"></span>曾经是一个优秀的负载均衡器，但由于其与<span class="jill"></span>Eureka<span class="jill"></span>的紧密关联以及<span class="jill"></span>Eureka<span class="jill"></span>的废弃，导致<span class="jill"></span>Ribbon<span class="jill"></span>的性能和稳定性可能受到影响。</span></li><li id="cXBTt5aDgUFD12fLDLo1kx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud LoadBalancer</b></span><span class="inline-wrap">：经过优化和改进，具有卓越的性能和稳定性。</span></li></ul></li></ol><div id="wkg99uUsDheGKX2gZtbJTk" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Spring Cloud LoadBalancer<span class="jill"></span>作为<span class="jill"></span>Spring Cloud<span class="jill"></span>官方推出的负载均衡组件，与<span class="jill"></span>Ribbon<span class="jill"></span>相比，提供了更好的易用性、生态完整性和性能稳定性。对于新项目或需要升级的项目来说，考虑使用<span class="jill"></span>Spring Cloud LoadBalancer<span class="jill"></span>可能会是一个更好的选择。然而，在一些已经使用<span class="jill"></span>Ribbon<span class="jill"></span>并且满足需求的项目中，继续使用<span class="jill"></span>Ribbon<span class="jill"></span>也是可行的。</span></div></div><div id="8CGF5LzbNpbuyeumAEb8s8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="vWBRgn8Pq9HV6Qm3HomH7d" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="sBJ5fByMagFeUhUTkxTje" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">作为服务注册中心，Nacos<span class="jill"></span>和<span class="jill"></span>Eureka<span class="jill"></span>的区别是什么？</span></h1><div id="axFNe7LNjomCQgvHKEQpff" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>和<span class="jill"></span>Eureka<span class="jill"></span>作为服务注册中心，在</span><span class="inline-wrap"><b>数据存储、健康检查以及部署安装</b></span><span class="inline-wrap">等方面存在区别。以下是具体分析：</span></div></div><ol class="wolai-block"><li id="vjnN4P6yK8vyCsAtZS747f"><div class="marker"></div><span class="inline-wrap"><b>数据存储</b></span><ul class="wolai-block"><li id="uNWnZMoeRE6NBTvh5oSCU2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：使用数据库存储来维护服务注册表，支持多种数据库，如<span class="jill"></span>MySQL、Oracle<span class="jill"></span>等。</span></li><li id="xaAcndD6PdgueJte8kp7g3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Eureka</b></span><span class="inline-wrap">：采用内存存储来维护服务注册表，每个<span class="jill"></span>Eureka<span class="jill"></span>服务器都会维护完整的服务注册表，多个服务器之间通过复制的方式完成数据的同步。</span></li></ul></li><li id="wwvPm4ZetaSv6RenAsQozj"><div class="marker"></div><span class="inline-wrap"><b>健康检查</b></span><ul class="wolai-block"><li id="3jLLsvLJzbi25DWwzmzDZ6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：临时实例采用心跳模式，非临时实例采用主动检测模式。支持服务端主动检测提供者状态，并且当临时实例宕机时会被剔除，而非临时实例则不会被剔除。</span></li><li id="h2NNPt6gNTw35imD9WZjWK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Eureka</b></span><span class="inline-wrap">：主要通过客户端向<span class="jill"></span>Eureka Server<span class="jill"></span>发送心跳信号来进行健康检查，如果在一定时间内没有收到心跳信号，则会将服务标记为下线。</span></li></ul></li><li id="7hJNGwx9gv5mTdUKtxe5b4"><div class="marker"></div><span class="inline-wrap"><b>部署安装</b></span><ul class="wolai-block"><li id="4bGC87NKvVvERXhJRSbjs9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：提供了单节点、集群以及云原生等多种部署方式，能够满足不同规模的需求。</span></li><li id="dF6vV4ig2BuGsAm9JUJpCM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Eureka</b></span><span class="inline-wrap">：需要创建<span class="jill"></span>Spring Boot<span class="jill"></span>项目，并将<span class="jill"></span>Eureka<span class="jill"></span>服务端通过<span class="jill"></span>gav<span class="jill"></span>的方式加载进来进行部署。</span></li></ul></li><li id="iGmN6fdGQu7LayY7zKHNH4"><div class="marker"></div><span class="inline-wrap"><b>稳定扩展性</b></span><ul class="wolai-block"><li id="4FipVmsKvM9QCdGTMt1tp3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：采用了<span class="jill"></span>AP（可用性和分区容忍性）的设计原则，能够在网络分区的情况下保证服务的可用性。提供了丰富的扩展点，方便用户根据实际需求进行定制。</span></li><li id="e66EcdHWiGnVQnwGqqEuV4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Eureka</b></span><span class="inline-wrap">：采用了<span class="jill"></span>CP（一致性和分区容忍性）的设计原则，在网络分区的情况下可能会牺牲部分可用性。</span></li></ul></li></ol><div id="jopG4ADWo8QUECdGmfQZEy" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>在功能上更为全面，适用于构建云原生应用，而<span class="jill"></span>Eureka<span class="jill"></span>则更专注于注册中心的功能，且与<span class="jill"></span>Spring Cloud<span class="jill"></span>的集成更为紧密。在选择时，需要根据项目的具体需求和技术栈来权衡各自的优势。</span></div></div><div id="rEWMxX9wxW7SymgojmRPH8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="b8qLRraTsmShx7NT8rzW6H" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3ejoFhGnbFjFRTk7o3LmTr" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">作为服务配置中心，Nacos<span class="jill"></span>和<span class="jill"></span>SpringCloud Config<span class="jill"></span>的区别是什么？</span></h1><div id="vxJPY71XuYKgNkUnUaRncX" class="wolai-block wolai-text"><div><span class="inline-wrap">作为服务配置中心，Nacos<span class="jill"></span>和<span class="jill"></span>SpringCloud Config<span class="jill"></span>在</span><span class="inline-wrap"><b>数据存储、动态刷新以及环境管理</b></span><span class="inline-wrap">等方面存在区别。具体分析如下：</span></div></div><ol class="wolai-block"><li id="uU3YPihJ3AKmRh6ih18tQm"><div class="marker"></div><span class="inline-wrap"><b>数据存储</b></span><ul class="wolai-block"><li id="cudJ14WNL2tUAyUYgoZg4G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：支持多种格式如<span class="jill"></span>Properties、YAML、JSON<span class="jill"></span>等，并且可以基于命名空间进行配置的隔离和管理[^1^]。</span></li><li id="wRjgtfQ8mkeEysfgaAYarV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud Config</b></span><span class="inline-wrap">：默认使用<span class="jill"></span>Git<span class="jill"></span>仓库来存储配置文件，支持版本控制，通过分支和标签管理不同版本的配置[^6^]。</span></li></ul></li><li id="ua9xwQ2DHXjFMxdTvGesA2"><div class="marker"></div><span class="inline-wrap"><b>动态刷新</b></span><ul class="wolai-block"><li id="dVqmt3DFCuoR73NVLauSWJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：实时监听配置变化并推送更新至消费者，无需应用重启即可实现配置的动态更新[^1^]。</span></li><li id="JVGJa67E86k8BrxVBk6jR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud Config</b></span><span class="inline-wrap">：虽然支持动态刷新，但通常需要依赖<span class="jill"></span>Spring Cloud Bus<span class="jill"></span>和消息代理来实现[^5^]。</span></li></ul></li><li id="hNdmzCu7o2FgmVc94tKBPd"><div class="marker"></div><span class="inline-wrap"><b>环境管理</b></span><ul class="wolai-block"><li id="eVrx3YsMUR62vPpF8oYwi4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：通过命名空间和分组功能，轻松实现多环境（如开发、测试、生产）的配置管理[^1^]。</span></li><li id="9NJXfnjgMVdTFE6yU15q4E"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud Config</b></span><span class="inline-wrap">：通过<span class="jill"></span>Profile<span class="jill"></span>方式隔离不同环境的配置，客户端启动时指定<span class="jill"></span>Profile<span class="jill"></span>以访问对应配置文件[^6^]。</span></li></ul></li><li id="maEarL7C5Yo5spbt4Rauj2"><div class="marker"></div><span class="inline-wrap"><b>安全性</b></span><ul class="wolai-block"><li id="koeKMDNmrGwg74yzgTJaiZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：提供了丰富的安全特性，包括权限控制和加密传输，确保配置的安全性[^7^]。</span></li><li id="in2ncgrtf9NejudjH6kyyx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud Config</b></span><span class="inline-wrap">：依赖于<span class="jill"></span>Git<span class="jill"></span>的权限管理能力，可以通过<span class="jill"></span>Git<span class="jill"></span>的权限设置来控制配置的访问和修改[^8^]。</span></li></ul></li><li id="nk1Rr3nmStWT9vqqxW1aU4"><div class="marker"></div><span class="inline-wrap"><b>部署方式</b></span><ul class="wolai-block"><li id="kid6kCrGuPKGYnVe4VkkUa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Nacos</b></span><span class="inline-wrap">：提供单节点部署、集群部署以及云原生部署等多种方式，适应不同的需求和场景[^1^]。</span></li><li id="uD2VWk5BdY9cY8BxJeSVvd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud Config</b></span><span class="inline-wrap">：通常与<span class="jill"></span>Spring Cloud<span class="jill"></span>的其他组件一起部署，形成完整的微服务架构体系[^5^]。</span></li></ul></li></ol><div id="tB7DBgxPvb1MQrnA4PR1kt" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>以其强大的功能、灵活的部署方式和易用性，成为众多企业构建现代化微服务架构的首选。而<span class="jill"></span>SpringCloud Config<span class="jill"></span>则凭借其在<span class="jill"></span>Spring Cloud<span class="jill"></span>生态中的深度集成和广泛的应用基础，继续发挥着重要作用。在选择配置中心时，建议根据项目的具体需求和技术栈进行综合考虑。</span></div></div><div id="hkaDQfNWDcw7yj2HFoaWnc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6yfSwo3hR2rESyzyKa8V8w" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="iHtZYz1eC7XUDr5kGBqKc" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap"><b>Spring Cloud </b></span><span class="inline-wrap">Gateway<span class="jill"></span>和<span class="jill"></span>Zuul<span class="jill"></span>的区别是什么？</span></h1><div id="dWG8MH8YBYb7HdhLqk5n3Z" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring Cloud Gateway<span class="jill"></span>和<span class="jill"></span>Zuul<span class="jill"></span>在</span><span class="inline-wrap"><b>开源组织、底层实现以及内嵌<span class="jill"></span>Web<span class="jill"></span>容器</b></span><span class="inline-wrap">等方面存在区别。以下是具体分析：</span></div></div><ol class="wolai-block"><li id="te9aLyLJdrPUaruueR6TfG"><div class="marker"></div><span class="inline-wrap"><b>开源组织</b></span><ul class="wolai-block"><li id="embHBGhLBhmtFnBbk24phS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud Gateway</b></span><span class="inline-wrap">：是<span class="jill"></span>Spring Cloud<span class="jill"></span>微服务平台的一个子项目，属于<span class="jill"></span>Spring<span class="jill"></span>开源社区。</span></li><li id="5cjR1wmioqAXT35tH5kuit"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Zuul</b></span><span class="inline-wrap">：是<span class="jill"></span>Netflix<span class="jill"></span>公司的开源项目，Spring Cloud<span class="jill"></span>在<span class="jill"></span>Netflix<span class="jill"></span>项目中也已经集成了<span class="jill"></span>Zuul。</span></li></ul></li><li id="kfkJ4kbWMyAwnWYJGWVFHH"><div class="marker"></div><span class="inline-wrap"><b>底层实现</b></span><ul class="wolai-block"><li id="8Tarkz8AVZwexc2TsaLRqA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud Gateway</b></span><span class="inline-wrap">：基于<span class="jill"></span>Spring 5+<span class="jill"></span>构建，使用响应式、非阻塞式的<span class="jill"></span>API，支持<span class="jill"></span>WebSockets。</span></li><li id="m3Q7QWFkTLhQH1AfDqb7ri"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Zuul</b></span><span class="inline-wrap">：构建于<span class="jill"></span>Servlet 2.5，使用的是阻塞式的<span class="jill"></span>API，不支持长连接，比如<span class="jill"></span>WebSockets。</span></li></ul></li><li id="tU82yuBD2qfdU1fKHmtSzo"><div class="marker"></div><span class="inline-wrap"><b>内嵌<span class="jill"></span>Web<span class="jill"></span>容器</b></span><ul class="wolai-block"><li id="jfWtrUiZyyaarC2F79Qh4H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud Gateway</b></span><span class="inline-wrap">：默认使用<span class="jill"></span>NettyWebServer。</span></li><li id="i1qcDP4ToCD1Y1axYcomAr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Zuul</b></span><span class="inline-wrap">：默认使用<span class="jill"></span>Tomcat<span class="jill"></span>作为<span class="jill"></span>Web<span class="jill"></span>容器。</span></li></ul></li><li id="hwtvr3fiaGvHt3Qrfxv1Wt"><div class="marker"></div><span class="inline-wrap"><b>性能表现</b></span><ul class="wolai-block"><li id="iRUjTLMhasLa3Y6tDByDMu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Spring Cloud Gateway</b></span><span class="inline-wrap">：基于反应式编程，性能通常优于<span class="jill"></span>Zuul，特别是在高并发和后端服务响应慢的场景下。</span></li><li id="hwwPfMJng8563tpfU7HTJA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Zuul</b></span><span class="inline-wrap">：基于同步的<span class="jill"></span>Servlet API，可能在高并发场景下表现不如<span class="jill"></span>Spring Cloud Gateway。</span></li></ul></li></ol><div id="omwEfPS1ndsNELKAGqZabb" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Spring Cloud Gateway<span class="jill"></span>在性能、易用性和与<span class="jill"></span>Spring<span class="jill"></span>生态系统的整合方面具有明显优势，而<span class="jill"></span>Zuul<span class="jill"></span>则在一些特定场景下仍有其应用价值。在选择时，建议根据项目的具体需求和技术栈进行综合考虑。</span></div></div><div id="cT6JfeHE9Gow3fqkT7Ma5u" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="tZ6F4LQhnMccjmef4cNCXu" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="7kvQP1Bnr8fzsVNb2tZ274" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">Nacos<span class="jill"></span>服务注册功能是如何实现的？</span></h1><div id="4sshLuMC2Y1Pz7bXjpwZdm" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>的服务注册功能通过</span><span class="inline-wrap"><b>服务提供者注册、服务信息存储以及心跳机制</b></span><span class="inline-wrap">等步骤实现。以下是这些步骤的详细分析：</span></div></div><ol class="wolai-block"><li id="nEWLb23xCqc2egZV1dfKbX"><div class="marker"></div><span class="inline-wrap"><b>服务提供者注册</b></span><ul class="wolai-block"><li id="7ycUv1biFeGrr7M9XLtyBW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>启动时注册</b></span><span class="inline-wrap">：当服务提供者启动时，会将自己的服务实例信息（如服务名称、IP<span class="jill"></span>地址、端口号等）发送到<span class="jill"></span>Nacos<span class="jill"></span>服务器进行注册[^3^]。</span></li><li id="wRZK4r3uF1wibnnn2Ujhrc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用<span class="jill"></span>HTTP<span class="jill"></span>或<span class="jill"></span>gRPC<span class="jill"></span>协议</b></span><span class="inline-wrap">：服务提供者通常通过<span class="jill"></span>HTTP<span class="jill"></span>或<span class="jill"></span>gRPC<span class="jill"></span>协议连接到<span class="jill"></span>Nacos<span class="jill"></span>服务器，并发送注册请求[^3^]。</span></li><li id="3DQkQSi5S1SP3u7Fp7NY9n"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>自动装配与事件监听</b></span><span class="inline-wrap">：在<span class="jill"></span>Spring Cloud<span class="jill"></span>环境中，服务注册可以通过自动装配和事件监听机制来实现。例如，DubboServiceRegistrationNonWebApplicationAutoConfiguration<span class="jill"></span>类会监听<span class="jill"></span>ApplicationStartedEvent<span class="jill"></span>事件，当应用启动完成后触发注册动作[^1^]。</span></li></ul></li><li id="8xMsjeezQWwL6LEJXDTiRf"><div class="marker"></div><span class="inline-wrap"><b>服务信息存储</b></span><ul class="wolai-block"><li id="7UuxaiuZTCL2GBnNjowEXn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>内存存储</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>服务器接收到服务提供者的注册请求后，会将服务实例信息存储在内存中，以便快速查询[^2^][^3^]。</span></li><li id="7F9hytKVDHx6kdpftGyLKy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>持久化存储</b></span><span class="inline-wrap">：为了确保数据的一致性和持久性，Nacos<span class="jill"></span>还支持将服务实例信息持久化到数据库中（如<span class="jill"></span>MySQL、Derby<span class="jill"></span>等）[^2^][^3^]。</span></li></ul></li><li id="3FNmMgfZ7FeBT1p52oCGfy"><div class="marker"></div><span class="inline-wrap"><b>心跳机制</b></span><ul class="wolai-block"><li id="ahVuafh7e2qVyCd53pDtty"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定时发送心跳</b></span><span class="inline-wrap">：注册完成后，服务提供者会定期向<span class="jill"></span>Nacos<span class="jill"></span>服务器发送心跳包，以表明自己的服务实例仍在运行中[^3^]。</span></li><li id="nwEn8DQ2hccCTMMWuTTrFX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>健康状态检查</b></span><span class="inline-wrap">：如果在一定时间内（默认<span class="jill"></span>5<span class="jill"></span>秒）没有收到心跳包，Nacos<span class="jill"></span>会将该服务标记为不可用[^3^]。</span></li></ul></li><li id="cu3iGLxjo52gEmx4NMPSf5"><div class="marker"></div><span class="inline-wrap"><b>服务消费者发现</b></span><ul class="wolai-block"><li id="31ojxDLVS7XFayVVdtXsz3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>查询服务列表</b></span><span class="inline-wrap">：服务消费者启动时，会向<span class="jill"></span>Nacos<span class="jill"></span>服务器发送服务发现请求，获取当前可用的服务实例列表[^3^]。</span></li><li id="38jeBJzWn45HkaBpQhT76f"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缓存机制</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>客户端会缓存服务实例列表，并定期（默认<span class="jill"></span>5<span class="jill"></span>秒）同步更新，以减少频繁查询<span class="jill"></span>Nacos<span class="jill"></span>服务器的压力[^3^]。</span></li></ul></li><li id="9n5rqX7neoVhonTioiQT8r"><div class="marker"></div><span class="inline-wrap"><b>负载均衡策略</b></span><ul class="wolai-block"><li id="4RL8kg9wizokaFhLJoi3Wb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>选择服务实例</b></span><span class="inline-wrap">：服务消费者可以根据不同的负载均衡策略（如轮询、随机、权重等）选择一个合适的服务实例进行调用[^2^][^3^]。</span></li></ul></li><li id="5gndtPpoRwQGcTkN3zuxRR"><div class="marker"></div><span class="inline-wrap"><b>数据模型与通信协议</b></span><ul class="wolai-block"><li id="sde9RiEiJnMvQ8h5Jx4KSs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>命名空间与服务模型</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>使用命名空间来隔离不同环境或租户的服务，并通过服务、集群、实例三层模型来管理服务实例[^4^]。</span></li><li id="jKqbrFxAHpog9X5BmJFp4t"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>通信协议</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>默认使用<span class="jill"></span>HTTP<span class="jill"></span>协议进行通信，但也支持<span class="jill"></span>gRPC<span class="jill"></span>协议以提高性能和降低延迟[^3^]。</span></li></ul></li></ol><div id="9KVoHcUNiqjfPKw7Ehtiki" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>的服务注册功能通过上述多个步骤和机制实现了服务的动态注册、发现和管理。这些特性使得<span class="jill"></span>Nacos<span class="jill"></span>成为构建云原生应用的理想选择，能够有效地支持微服务架构中的服务治理需求。</span></div></div><div id="8KDnCK5ZdRECTUBtA7QQik" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="mt3gDw1nDog8c2bdzKe1hd" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="gxFHpfUcv93PUfehviNEPW" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">微服务优点是什么？</span></h1><div id="eH4j4xt2b3Da7DqD8zGj7c" class="wolai-block wolai-text"><div><span class="inline-wrap">微服务架构的优点主要包括</span><span class="inline-wrap"><b>可扩展性、灵活性、敏捷性以及容错性</b></span><span class="inline-wrap">。以下是对这些优点的详细分析：</span></div></div><ol class="wolai-block"><li id="gWHniZ2VYh8x1y2dSRHwHo"><div class="marker"></div><span class="inline-wrap"><b>可扩展性</b></span><ul class="wolai-block"><li id="8hjK3iqNWQvDBETX2SPmzv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>独立部署</b></span><span class="inline-wrap">：每个微服务可以独立部署和扩展，这意味着可以根据单个服务的需求来增加资源，而不需要对整个应用程序进行扩展[^1^]。</span></li><li id="pGaorQQRNTNLxepfjXQi2A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>水平扩展</b></span><span class="inline-wrap">：微服务架构支持水平扩展，即通过增加更多的服务实例来处理增加的负载[^2^]。</span></li></ul></li><li id="bYcAJWmx9Sgvvbs4AfzF9p"><div class="marker"></div><span class="inline-wrap"><b>灵活性</b></span><ul class="wolai-block"><li id="tUphgLaMNJnUos7XA8mDRw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>技术多样性</b></span><span class="inline-wrap">：不同的微服务可以使用不同的技术栈，这为团队提供了选择最适合特定服务的技术的自由度[^3^]。</span></li><li id="tmJNtnZKdBuAe5LvipKVqD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>独立更新</b></span><span class="inline-wrap">：由于微服务是独立的，一个服务的更新或更改不会影响其他服务，这使得快速迭代和部署成为可能[^4^]。</span></li></ul></li><li id="t6Z77hKCwiThwGBJCUzxQD"><div class="marker"></div><span class="inline-wrap"><b>敏捷性</b></span><ul class="wolai-block"><li id="7MxzsdnQX33gWg7QcDJhGG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>快速开发</b></span><span class="inline-wrap">：微服务允许小团队专注于特定的业务功能，从而加快开发速度并缩短上市时间[^5^]。</span></li><li id="kvZeeTpVoQ9ssB4FQJmq8V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>持续交付</b></span><span class="inline-wrap">：微服务架构与持续集成和持续交付（CI/CD）流程相结合，可以实现更频繁的发布周期和更快的市场响应[^6^]。</span></li></ul></li><li id="sErjZBQkc5ZHfG4m3QDNNx"><div class="marker"></div><span class="inline-wrap"><b>容错性</b></span><ul class="wolai-block"><li id="rzmTtzNstoiqP17czaeT4L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>隔离故障</b></span><span class="inline-wrap">：如果一个微服务出现故障，它不会直接影响到整个系统，因为其他服务仍然可以正常运行[^7^]。</span></li><li id="5yAsk4G1XKKiEnhhFeQN6e"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>弹性设计</b></span><span class="inline-wrap">：微服务架构鼓励构建具有弹性的服务，这些服务能够自动恢复并在面对失败时继续提供服务[^8^]。</span></li></ul></li><li id="uDazhw9pfhLcEoeubwP8h7"><div class="marker"></div><span class="inline-wrap"><b>技术异构性</b></span><ul class="wolai-block"><li id="5duk62EFxBDoCFqiS3yhc6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>多语言支持</b></span><span class="inline-wrap">：微服务可以使用不同的编程语言实现，这为开发者提供了更多的选择，可以根据服务的需求选择最合适的语言[^9^]。</span></li><li id="pspkEFgHUozytUMQvDAweY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>协议无关性</b></span><span class="inline-wrap">：微服务之间的通信可以通过多种协议进行，如<span class="jill"></span>HTTP/REST、gRPC<span class="jill"></span>等，这增加了系统的灵活性[^10^]。</span></li></ul></li><li id="mvf7CwsAeTJw6zqyanXMVs"><div class="marker"></div><span class="inline-wrap"><b>组织与文化变革</b></span><ul class="wolai-block"><li id="kW328q2wYUnRtwd7F7tTPP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>小团队自主</b></span><span class="inline-wrap">：微服务架构促进了小团队的自主性，每个团队负责自己的服务，这有助于提高团队的责任感和满足感[^11^]。</span></li><li id="rShNABhhHxSiYWeBJtr3PL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>跨职能合作</b></span><span class="inline-wrap">：微服务架构鼓励跨职能团队的合作，包括开发、运维和<span class="jill"></span>QA<span class="jill"></span>团队成员共同参与服务的生命周期管理[^12^]。</span></li></ul></li></ol><div id="e1sSjq1F61JUcwZWEgi8bg" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，微服务架构为现代软件开发提供了一种灵活、可扩展且高效的方法。它不仅能够提高开发效率和系统稳定性，还能够促进组织文化的变革，使得团队更加敏捷和自给自足。</span></div></div><div id="gyW838uWiLEevES7hDRqRr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="dBiDgWytrpG8CmMcvcQytE" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="rAc7V74L5CuybfHsXHMrCt" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">微服务的缺点是什么？</span></h1><div id="gQjvs1eyNYGnN6DSoRwYTk" class="wolai-block wolai-text"><div><span class="inline-wrap">微服务架构虽然具有许多优点，但也存在一些缺点。以下是对微服务缺点的详细分析：</span></div></div><ol class="wolai-block"><li id="4fDHBjo5Hg9uaYWWCg8gcD"><div class="marker"></div><span class="inline-wrap"><b>复杂性增加</b></span><ul class="wolai-block"><li id="dGG9G3kXkGaVKa2JCfTnnP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>部署复杂性</b></span><span class="inline-wrap">：每个微服务都需要独立部署，这增加了部署和运维的复杂性[^1^]。</span></li><li id="oUkGnov6oZAZZuuRqqVgjT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>通信复杂性</b></span><span class="inline-wrap">：服务之间的通信需要通过网络进行，这可能会引入网络延迟和通信故障的风险[^2^]。</span></li></ul></li><li id="t11xWzD4c1x2arLBWeV8Sd"><div class="marker"></div><span class="inline-wrap"><b>数据一致性问题</b></span><ul class="wolai-block"><li id="jYDcnBnFSoBUk6f7MNo84a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>分布式事务</b></span><span class="inline-wrap">：在微服务架构中，保持数据一致性变得更加困难，因为数据可能分布在多个服务中[^3^]。</span></li><li id="67s5KVoVu4tJNoBGJLaUB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>最终一致性</b></span><span class="inline-wrap">：微服务通常采用最终一致性模型，这意味着在某些情况下，用户可能会看到不一致的数据[^4^]。</span></li></ul></li><li id="cp8fqJqseW3G7ymnP2NvBX"><div class="marker"></div><span class="inline-wrap"><b>网络延迟和故障</b></span><ul class="wolai-block"><li id="5LR91VYsftWWVBUCbx8jyA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>跨网络通信</b></span><span class="inline-wrap">：服务之间的通信需要通过网络进行，这可能会引入额外的延迟[^5^]。</span></li><li id="kzNEGWPtrxSu1FPFyVzstN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>网络分区</b></span><span class="inline-wrap">：在网络分区的情况下，服务之间的通信可能会中断，影响系统的稳定性[^6^]。</span></li></ul></li><li id="qCtYujET777LKYaLufqM8L"><div class="marker"></div><span class="inline-wrap"><b>安全性挑战</b></span><ul class="wolai-block"><li id="nS4HW9WVjfAmC2LXzpMvSa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>更多的暴露面</b></span><span class="inline-wrap">：每个微服务都可能是一个攻击面，需要单独保护，增加了安全风险[^7^]。</span></li><li id="iDfohu7NB8VUnjpLNECztJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>身份验证和授权</b></span><span class="inline-wrap">：在微服务架构中，实现跨服务的身份验证和授权机制更加复杂[^8^]。</span></li></ul></li><li id="4h62vMhe8hDH4TMqT51rXW"><div class="marker"></div><span class="inline-wrap"><b>测试难度增加</b></span><ul class="wolai-block"><li id="m6jkVhpJiucVdZL6byn4AY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>端到端测试</b></span><span class="inline-wrap">：由于服务是分布式的，进行端到端的集成测试变得更加困难[^9^]。</span></li><li id="gQZdhBBhRw1odbGEHyFa1E"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>模拟外部依赖</b></span><span class="inline-wrap">：测试一个微服务时，可能需要模拟其依赖的其他服务，这增加了测试的复杂性[^10^]。</span></li></ul></li><li id="9NRMSwyVhXpwhyqXVpFChW"><div class="marker"></div><span class="inline-wrap"><b>监控和日志管理</b></span><ul class="wolai-block"><li id="kohmHr1XXzqy6XNKxjCRP2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>分布式跟踪</b></span><span class="inline-wrap">：在微服务架构中，跟踪请求的完整路径需要分布式跟踪工具，这增加了监控的复杂性[^11^]。</span></li><li id="qYyCJtHN9cfpUinrwKCbK4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>日志聚合</b></span><span class="inline-wrap">：由于日志分布在多个服务中，收集和分析日志变得更加困难[^12^]。</span></li></ul></li><li id="3UqiFjUW6E7EaRFvtjVfWK"><div class="marker"></div><span class="inline-wrap"><b>成本增加</b></span><ul class="wolai-block"><li id="4GVsXcYQcd2HXvCwxPKBH9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基础设施成本</b></span><span class="inline-wrap">：每个微服务都需要自己的运行环境，这可能会导致基础设施成本的增加[^13^]。</span></li><li id="ohMfLq355oFnYJ93N1JREE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>人力成本</b></span><span class="inline-wrap">：开发和维护大量小型服务的团队需要更多的协调和管理，这可能会增加人力成本[^14^]。</span></li></ul></li></ol><div id="tSwqFcc6mr5sYZp2om4Nkt" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，微服务架构虽然提供了灵活性和可扩展性，但也带来了额外的复杂性和挑战。在决定是否采用微服务架构时，组织需要仔细权衡这些优缺点，并根据自己的业务需求和技术能力做出决策。</span></div></div><div id="cyMLefzNkLgTHPQUepfxSE" class="wolai-block wolai-text"><div></div></div><div id="2ttixYzPkMZkSC5jjceha1" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="a6zmtQ3SsKZsEBtQiUdwu8" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">对比区分服务熔断和降级</span></h1><div id="rHPgCCnnpGE1iKYNynEMCv" class="wolai-block"><figure class="wolai-center" style="width: 571.3333333333334px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="bW5n3sxwDqrdrWvFT9XxWf" class="wolai-block wolai-text"><div><span class="inline-wrap">服务熔断和降级是微服务架构中常用的两种容错机制，它们在</span><span class="inline-wrap"><b>触发条件、恢复机制以及影响范围</b></span><span class="inline-wrap">等方面存在区别。以下是详细的对比分析：</span></div></div><ol class="wolai-block"><li id="cgRzhrUuvqTenjZwAhMhgD"><div class="marker"></div><span class="inline-wrap"><b>触发条件</b></span><ul class="wolai-block"><li id="iv9zKD1bKCGdL1zSTWFgsw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：当一个服务因为某种原因（如响应时间过长、错误率过高）连续失败达到一定阈值时，熔断器会启动，暂时切断对该服务的调用。</span></li><li id="m7gkzrXf9Teb52aJknikv8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：降级通常是基于预设的规则或策略，当系统检测到某些指标（如<span class="jill"></span>CPU<span class="jill"></span>使用率、内存使用量）超过阈值时，或者在特定条件下（如维护模式、非高峰时段），主动降低服务质量。</span></li></ul></li><li id="eMhnbsqaCDibK5SdFM79C"><div class="marker"></div><span class="inline-wrap"><b>恢复机制</b></span><ul class="wolai-block"><li id="qNP7hY7qtKsNWpttf5gvP2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：熔断器会在一定时间后尝试半开状态，如果服务恢复正常，则完全打开；如果仍然失败，则继续保持熔断状态。</span></li><li id="bj1C8U64WoMR2ZCHZehPkC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：降级后的服务通常会保持降级状态直到系统恢复正常，或者手动切换回正常服务。</span></li></ul></li><li id="dn5MCH5cDNrSY4Ug3k8Qvx"><div class="marker"></div><span class="inline-wrap"><b>影响范围</b></span><ul class="wolai-block"><li id="nQeRjLdig5jb8RkTHtjG5R"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：熔断器只影响单个失败的服务，不会影响到其他正常运行的服务。</span></li><li id="hTmiey6bBGcvpn3XSLcTDT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：降级可能会影响整个系统或多个服务，因为它是基于系统整体状态的决策。</span></li></ul></li><li id="jPi5gUfj6rqadyoMBpMe7F"><div class="marker"></div><span class="inline-wrap"><b>用户体验</b></span><ul class="wolai-block"><li id="7PfBjiEZz9okv8RpsRimWx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：对于用户来说，熔断可能会导致请求失败，但通常这种失败是暂时的，一旦服务恢复，用户可以重新发起请求。</span></li><li id="oGnx7JoqBDjesFTW35yfcP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：降级可能会提供有限的功能或降低的服务质量，但至少保证了服务的基本可用性。</span></li></ul></li><li id="4xtZ4aQxLWvAx8qrYtz33g"><div class="marker"></div><span class="inline-wrap"><b>实施难度</b></span><ul class="wolai-block"><li id="jjtaDBwDx1EY8Gjy7oHgmZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：实现服务熔断需要额外的逻辑来监控服务状态并控制熔断器的行为。</span></li><li id="eyXEPeuGDwkw4h3bfsfrut"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：降级策略的实施相对简单，通常只需要在系统中预设一些规则和阈值即可。</span></li></ul></li><li id="xifJvrKC6gwgW8wxgGXuK1"><div class="marker"></div><span class="inline-wrap"><b>适用场景</b></span><ul class="wolai-block"><li id="qdYUMiYzHefUXLfRPgbBRc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务熔断</b></span><span class="inline-wrap">：适用于服务间依赖关系明确，且某个服务故障不会对整个系统造成严重影响的场景。</span></li><li id="31s51WzR4biKypxaKd9Q6B"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：适用于系统资源紧张或需要进行维护时，通过降低服务质量来保证核心功能的可用性。</span></li></ul></li></ol><div id="4ePMBjLAJS8AZnXktKcfTs" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，服务熔断和服务降级都是提高系统稳定性和可用性的重要手段。它们在不同的场景下有各自的优势和适用性。在实际应用中，可以根据系统的具体需求和特点选择合适的容错机制。</span></div></div><div id="voEGNufV53zUsyfJvV6kN7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kgqJiuM9zHpTSVacar1zTC" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="uMWNh6ibrfXGS91DJFjEwh" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">负载均衡的意义是什么？</span></h1><div id="tTFr1818U3Dh8BcvrFL5KX" class="wolai-block wolai-text"><div><span class="inline-wrap">负载均衡（Load Balancing）是指将网络或计算资源分配给多个服务器或设备，以达到提高系统性能、可扩展性和可靠性的目的。它在分布式系统中起到重要的作用，具有以下几个重要的意义：</span></div></div><ol class="wolai-block"><li id="jjfYbNiU3VUYzEKgRqgWKL"><div class="marker"></div><span class="inline-wrap">提高系统性能：负载均衡将请求均匀地分配给多个服务器，避免了单个服务器过载的情况。通过合理地分配负载，可以充分利用系统的资源，提高系统的吞吐量和响应速度。</span></li><li id="3hiT4e68wxWWvP8bUQoAsf"><div class="marker"></div><span class="inline-wrap">实现高可用性：通过将请求分发到多个服务器，即使其中某个服务器发生故障或不可用，仍然可以继续提供服务。负载均衡器能够检测到故障服务器，并将请求转发到其他正常工作的服务器，从而实现系统的高可用性和容错性。</span></li><li id="8a1J8nwJM4nSqBDKWsjCcq"><div class="marker"></div><span class="inline-wrap">支持系统扩展：随着用户量和业务需求的增加，单个服务器可能无法满足系统的需求。负载均衡器可以根据实际情况动态地添加或删除服务器，实现系统的水平扩展。通过增加服务器数量，可以提高系统的处理能力和并发性能。</span></li><li id="fWofUUhokR6mLnVVdBKanK"><div class="marker"></div><span class="inline-wrap">优化资源利用：负载均衡器可以根据服务器的负载情况智能地分配请求，使每个服务器的负载相对均衡。这样可以避免某些服务器过载而其他服务器处于空闲状态的情况，最大限度地提高资源的利用率。</span></li><li id="sTbbUkf7d1SGPENP113GTj"><div class="marker"></div><span class="inline-wrap">简化系统管理：通过使用负载均衡器，可以将多个服务器组织成一个逻辑集群，对外提供统一的入口。这样可以简化系统的管理和维护工作，减少对客户端的影响，提高系统的可维护性和可管理性。</span></li></ol><div id="jEsSFznysPEEZVoYDN4Qys" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，负载均衡在分布式系统中具有重要的意义。它能够提高系统性能、可用性和可扩展性，优化资源利用，简化系统管理。通过合理地分配负载，负载均衡器能够实现高效、稳定和可靠的系统运行。</span></div></div><div id="qbJSaXKqsm9g2pWN2yfdj9" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tpxKEohKNaCyd5abeSSE9y" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">SpringBoot<span class="jill"></span>和<span class="jill"></span>SpringCloud<span class="jill"></span>有什么联系和区别？</span></h1><div id="e6dug93JJ57aR5za55gnP3" class="wolai-block wolai-text"><div><span class="inline-wrap">SpringBoot<span class="jill"></span>和<span class="jill"></span>SpringCloud<span class="jill"></span>都是现代<span class="jill"></span>Java<span class="jill"></span>开发中极为重要的框架，它们在</span><span class="inline-wrap"><b>目标、功能以及独立性</b></span><span class="inline-wrap">等方面存在区别，下面是详细的对比分析：</span></div></div><ol class="wolai-block"><li id="5yUMjp8buMFAF7NDX2y9M4"><div class="marker"></div><span class="inline-wrap"><b>目标</b></span><ul class="wolai-block"><li id="xt21pRj5wb3QJbkc4Y4SPS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringBoot</b></span><span class="inline-wrap">：目标是简化<span class="jill"></span>Spring<span class="jill"></span>应用的开发流程，通过自动配置和约定优于配置的原则，帮助开发者快速启动和运行<span class="jill"></span>Spring<span class="jill"></span>应用[^2^]。</span></li><li id="oT17P2whsqtBH3KTUQW99H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud</b></span><span class="inline-wrap">：旨在构建微服务架构，提供一整套解决方案来简化分布式系统的开发、部署和管理。它基于<span class="jill"></span>SpringBoot，并集成了多个成熟的开源组件来实现微服务所需的各种功能[^2^]。</span></li></ul></li><li id="j5CZncguUwL2PJ6wsVQito"><div class="marker"></div><span class="inline-wrap"><b>功能</b></span><ul class="wolai-block"><li id="bmmWseZUx62HLStPugCv8F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringBoot</b></span><span class="inline-wrap">：提供了自动配置、内嵌服务器（如<span class="jill"></span>Tomcat、Jetty）、健康检查、度量指标等功能，使得开发者可以快速搭建独立运行的生产级<span class="jill"></span>Spring<span class="jill"></span>应用[^3^]。</span></li><li id="37xQ8ZJkwCmnp1LpyyJoYP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud</b></span><span class="inline-wrap">：包括服务注册与发现（如<span class="jill"></span>Eureka、Consul）、配置管理（Config Server）、断路器（Hystrix）、智能路由（Zuul<span class="jill"></span>或<span class="jill"></span>Gateway）、消息总线（Spring Cloud Stream）等，这些功能都是为了支持微服务架构而设计的[^2^][^6^]。</span></li></ul></li><li id="nz3MwtcXXwL3AFnFzE1i3L"><div class="marker"></div><span class="inline-wrap"><b>独立性</b></span><ul class="wolai-block"><li id="sZkzR6XkkRJBEDEdaJNnWm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringBoot</b></span><span class="inline-wrap">：可以独立使用，不需要依赖其他框架即可运行<span class="jill"></span>Spring<span class="jill"></span>应用[^5^]。</span></li><li id="wvi4ZdkCKByhkyVnZQ1a5P"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud</b></span><span class="inline-wrap">：依赖于<span class="jill"></span>SpringBoot，它必须与<span class="jill"></span>SpringBoot<span class="jill"></span>一起使用才能发挥其微服务治理的功能[^4^][^6^]。</span></li></ul></li><li id="cvyFQ9iP9JhFLgiEHQK5S7"><div class="marker"></div><span class="inline-wrap"><b>设计理念</b></span><ul class="wolai-block"><li id="mWb8p7gj7vuJFYmCAj9zkm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringBoot</b></span><span class="inline-wrap">：强调快速开发和部署单个<span class="jill"></span>Spring<span class="jill"></span>应用，注重于简化配置和提高开发效率[^7^]。</span></li><li id="n562J8xTtC9xkmt4VVWt93"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SpringCloud</b></span><span class="inline-wrap">：关注于全局的微服务协调治理，它将多个单体微服务整合起来，提供配置管理、服务发现、断路器等高级功能[^7^]。</span></li></ul></li></ol><div id="28GtEd265vQ4LJ24d4mt4H" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，SpringBoot<span class="jill"></span>专注于快速开发和部署单个<span class="jill"></span>Spring<span class="jill"></span>应用，而<span class="jill"></span>SpringCloud<span class="jill"></span>则是一个更广泛的微服务架构解决方案，它依赖于<span class="jill"></span>SpringBoot<span class="jill"></span>并在此基础上增加了许多高级功能来支持微服务的开发和管理。两者结合使用，可以极大地简化微服务架构的开发和维护工作。</span></div></div><div id="jNrwXcjLAFjD6ZRRjaLisW" class="wolai-block wolai-text"><div></div></div><div id="pXvp9HywtcYeFzcPPsnGNd" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4sC3K7FGZWpjJkNLUmdPQT" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">面对众多可用产品，项目中的注册中心该如何选型？</span></h1><div id="6XfDw6Kw6Z2rB9yW7x3YF9" class="wolai-block wolai-text"><div><span class="inline-wrap">在项目中选择合适的注册中心是构建微服务架构的关键决策之一。以下是一些选型时需要考虑的因素和步骤：</span></div></div><ol class="wolai-block"><li id="odJRcXe3z6mNNp8z7XuoyH"><div class="marker"></div><span class="inline-wrap"><b>功能需求</b></span><ul class="wolai-block"><li id="28wSzZusUWkp5Gt24BzWc4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务发现</b></span><span class="inline-wrap">：确保注册中心支持高效的服务发现机制，这对于动态扩展和维护微服务至关重要[^1^]。</span></li><li id="b3jGGAxi7TUDpqJQom1sd3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>健康检查</b></span><span class="inline-wrap">：注册中心应能够定期检查服务的健康状态，自动剔除不健康的服务实例[^2^]。</span></li><li id="eZVFLe54ASxjq2yYQqMUhQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>负载均衡</b></span><span class="inline-wrap">：支持客户端负载均衡，以便在多个服务实例之间均匀分配请求[^3^]。</span></li></ul></li><li id="e8kdXYDPmoCkxbejCpxoPB"><div class="marker"></div><span class="inline-wrap"><b>性能考量</b></span><ul class="wolai-block"><li id="sWbdjtFtvAFjwnjmKFXiEH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>响应时间</b></span><span class="inline-wrap">：注册中心的响应时间应该足够快，以避免成为系统瓶颈[^4^]。</span></li><li id="jDkvbnHL3xSUjaHXoYDunM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>吞吐量</b></span><span class="inline-wrap">：评估注册中心能够处理的请求量，确保它能够满足项目的负载需求[^5^]。</span></li></ul></li><li id="qZfeqVN5d7ZQ4fnTXuiGxQ"><div class="marker"></div><span class="inline-wrap"><b>可扩展性</b></span><ul class="wolai-block"><li id="7mEJpSnCvEWkKatFp6JPxb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>水平扩展</b></span><span class="inline-wrap">：注册中心应支持水平扩展，以应对服务数量的增长[^6^]。</span></li><li id="czjSoc3p2NfVT47CSe2f7B"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>集群部署</b></span><span class="inline-wrap">：支持集群部署，以提高可用性和容错性[^7^]。</span></li></ul></li><li id="39N51L3MZvV5ugLxz4Y5gv"><div class="marker"></div><span class="inline-wrap"><b>高可用性</b></span><ul class="wolai-block"><li id="c6Dn19LsaLd8Y4kE84xYRW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>故障转移</b></span><span class="inline-wrap">：注册中心应具备故障转移机制，确保在部分组件失效时仍能继续提供服务[^8^]。</span></li><li id="6ieeLDrhrFqnaoeh3LcTva"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据持久化</b></span><span class="inline-wrap">：支持数据的持久化存储，防止因系统重启或故障导致的数据丢失[^9^]。</span></li></ul></li><li id="ujRkmLxUHdjnQ4Rstiya5S"><div class="marker"></div><span class="inline-wrap"><b>安全性</b></span><ul class="wolai-block"><li id="fszxVCumdxx1XbWPJzS4Kd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>认证授权</b></span><span class="inline-wrap">：注册中心应提供安全机制，如认证和授权，以保护服务信息不被未授权访问[^10^]。</span></li><li id="i4hXHXbzRmLf9tYL9JqZr8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>加密通信</b></span><span class="inline-wrap">：支持加密通信协议，确保数据传输的安全性[^11^]。</span></li></ul></li><li id="u8vvcKHEvoLqw31PVn4Fd9"><div class="marker"></div><span class="inline-wrap"><b>社区和支持</b></span><ul class="wolai-block"><li id="719ne5TdRbUozQ21i1Sibh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>活跃度</b></span><span class="inline-wrap">：选择一个有活跃社区支持的注册中心，这样可以更容易地找到帮助和资源[^12^]。</span></li><li id="rEeD1E4Y59SBfpFrbwHwga"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>文档完善</b></span><span class="inline-wrap">：确保注册中心有良好的文档和完善的支持体系[^13^]。</span></li></ul></li><li id="9sTzk3wbAbTUa6KNPRNe4d"><div class="marker"></div><span class="inline-wrap"><b>兼容性和集成</b></span><ul class="wolai-block"><li id="whmYZ3GuMNkdKpZA2BWsyT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>技术栈兼容</b></span><span class="inline-wrap">：注册中心应与项目现有的技术栈兼容，包括编程语言、框架和其他工具[^14^]。</span></li><li id="2pyVPWLnAibLrXF95H32ej"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>易于集成</b></span><span class="inline-wrap">：注册中心应易于与现有系统集成，减少开发和迁移成本[^15^]。</span></li></ul></li></ol><div id="uy76vuYfWNoRy63j1sAMjE" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，在选择注册中心时，需要综合考虑项目的具体需求、预期的系统规模、团队的技术能力以及长期维护的可行性。建议在做出决定前，进行充分的市场调研和技术评估，并在可能的情况下，进行原型验证或小规模试点。</span></div></div><div id="2exj6zmPMMbjrNpdmZRMV4" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dU2bSS1dhjx7se7a9S9hRK" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">简单介绍一下<span class="jill"></span>Nacos<span class="jill"></span>和它的主要功能</span></h1><div id="8Mzwc5T3kLp4uj76gEo5uA" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>是阿里巴巴开源的一款动态服务发现、配置管理和服务管理平台，它主要面向微服务架构中的服务注册与发现、配置管理以及动态<span class="jill"></span>DNS<span class="jill"></span>服务。以下是对<span class="jill"></span>Nacos<span class="jill"></span>及其主要功能的详细介绍：</span></div></div><ol class="wolai-block"><li id="Ym8RtB1AZEWiteUmk1nBy"><div class="marker"></div><span class="inline-wrap"><b>服务发现与注册</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>支持基于健康检查的动态服务发现，并能够自动剔除不健康的服务实例。它提供了完整的服务生命周期管理，包括服务的注册、注销、下线和上线等操作。通过<span class="jill"></span>Nacos，服务消费者可以实时感知到服务提供者的状态变化，从而实现灵活的服务调用。</span></li><li id="wJwUHR69KvQuipiEnXzxfi"><div class="marker"></div><span class="inline-wrap"><b>配置管理</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>具备分布式系统中外部化配置管理能力，支持配置的集中管理和动态更新。它允许用户在运行时动态调整配置，无需重启服务，极大地提高了系统的灵活性和可维护性。同时，Nacos<span class="jill"></span>还支持配置的版本控制和历史记录查询，方便用户进行配置变更的追踪和回滚。</span></li><li id="3tCsvu31Vmh3sLVnNra891"><div class="marker"></div><span class="inline-wrap"><b>动态<span class="jill"></span>DNS<span class="jill"></span>服务</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>借助其内建的<span class="jill"></span>DNS<span class="jill"></span>功能，支持权重路由，并且与<span class="jill"></span>Kubernetes<span class="jill"></span>等容器编排系统有很好的兼容性。这使得<span class="jill"></span>Nacos<span class="jill"></span>可以轻松地与云平台对接，为用户提供更加灵活和高效的服务部署和管理方案。</span></li><li id="vTQ8GZEc79jMey8TJCqeii"><div class="marker"></div><span class="inline-wrap"><b>服务及其元数据管理</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>允许用户为每个服务添加丰富的元数据，如版本、作者信息和使用指南等。这些元数据可以帮助开发者更好地理解和维护服务，提高开发效率和质量。</span></li><li id="q7f67Zr4eiv39XMJHPMxZ3"><div class="marker"></div><span class="inline-wrap"><b>健康检查</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>客户端会向<span class="jill"></span>Nacos<span class="jill"></span>服务器上报自己的健康状态，而<span class="jill"></span>Nacos Server<span class="jill"></span>端也会对注册的服务实例进行健康检查。这有助于及时发现并处理故障实例，确保系统的高可用性和稳定性。</span></li></ol><div id="bjm3NmMo1FHaWm35MytxA3" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，Nacos<span class="jill"></span>作为一款功能强大的动态服务发现、配置管理和服务管理平台，为微服务架构提供了全面的解决方案。它不仅简化了服务治理的过程，还提高了系统的可靠性和可扩展性。</span></div></div><div id="xpEsR1WjX9FnCfAcG4WGR8" class="wolai-block wolai-text"><div></div></div><div id="wkjnztqGoP1vauJscHDECa" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cLAhpXDeaA7egzeUX91L5e" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">Nacos<span class="jill"></span>是<span class="jill"></span>AP<span class="jill"></span>的还是<span class="jill"></span>CP<span class="jill"></span>的？</span></h1><div id="4QzF2CZ7dnstPAjDYgURHZ" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Nacos<span class="jill"></span>是<span class="jill"></span>AP<span class="jill"></span>的，但也可以配置为<span class="jill"></span>CP<span class="jill"></span>模式</b></span><span class="inline-wrap">。

Nacos<span class="jill"></span>是一个开源的动态服务发现、配置管理和服务管理平台，它支持<span class="jill"></span>AP（可用性优先）和<span class="jill"></span>CP（一致性优先）两种模式。在默认情况下，Nacos<span class="jill"></span>采用<span class="jill"></span>AP<span class="jill"></span>模式，这种模式下系统会优先保证服务的可用性，即使部分节点数据不一致，也能正常对外提供服务。然而，根据具体的业务需求和场景，用户也可以选择使用<span class="jill"></span>CP<span class="jill"></span>模式，通过配置来切换。

在<span class="jill"></span>AP<span class="jill"></span>模式下，Nacos<span class="jill"></span>注重服务的高可用性和可靠性，即使在网络分区或部分节点故障的情况下，仍然能够提供服务。而在<span class="jill"></span>CP<span class="jill"></span>模式下，Nacos<span class="jill"></span>则强调数据的一致性，当发生网络分区时，系统会尽可能地保证数据的一致性，但可能会出现部分服务不可用的情况。

总的来说，Nacos<span class="jill"></span>既支持<span class="jill"></span>AP<span class="jill"></span>模式也支持<span class="jill"></span>CP<span class="jill"></span>模式，具体使用哪种模式取决于项目的实际需求和场景。在选择时，需要综合考虑系统的可用性、一致性、性能以及容错能力等因素。</span></div></div><div id="f9YGfJ6bFoCMLZhL6H6ume" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="8uJqWxNTykdam3V2iZPquA" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kmM4jnXJgSde9w64kBeV3N" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">Nacos<span class="jill"></span>如何实现在配置变化时让客户端可以实时感知到？</span></h1><div id="j1GZ58N5pPaWsy3RvXgxqL" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>通过</span><span class="inline-wrap"><b>长轮询机制、配置注册与监听以及配置更新通知流程</b></span><span class="inline-wrap">实现在配置变化时让客户端可以实时感知到。以下是对这三个核心机制的详细解释：</span></div></div><ol class="wolai-block"><li id="rXNBDoLL5StFpwct66d4iv"><div class="marker"></div><span class="inline-wrap"><b>长轮询机制</b></span><ul class="wolai-block"><li id="wUNYTABrjDn8qa2P1JTDCS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>建立长连接</b></span><span class="inline-wrap">：当<span class="jill"></span>Nacos<span class="jill"></span>客户端需要监听配置变化时，它会向服务端发起一个长轮询请求，从而建立一个持久的<span class="jill"></span>HTTP<span class="jill"></span>连接。</span></li><li id="cbbcTxb67sBihF17tGp4T9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>挂起请求</b></span><span class="inline-wrap">：若无配置更新，服务端会将此请求挂起，不立即响。</span></li><li id="kx9XaeYEZVr5mCifx1Zwbr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>配置变更通知</b></span><span class="inline-wrap">：一旦有配置变更，服务端会立刻唤醒挂起的请求，并将最新的配置发送给客户端。</span></li></ul></li><li id="ccd9QMo7DMmUtM53x7ZPvy"><div class="marker"></div><span class="inline-wrap"><b>配置注册与监听</b></span><ul class="wolai-block"><li id="asXf8W1DcWfRDcBHvVHB8B"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>服务注册</b></span><span class="inline-wrap">：服务启动时会向<span class="jill"></span>Nacos<span class="jill"></span>服务端注册，这样服务端就能追踪到哪些服务在监听哪些配置。</span></li><li id="a9yjAfvRmFb4axT2iKxkBH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>监听器注册</b></span><span class="inline-wrap">：同时，服务会为其关心的配置注册一个监听器，确保当配置发生变化时能够得到通知。</span></li></ul></li><li id="4YaqKP7RYEBp5JxG4Dh1qr"><div class="marker"></div><span class="inline-wrap"><b>配置更新通知流程</b></span><ul class="wolai-block"><li id="hqDEsjEPL3T3fnPThBUDPA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>配置变更记录</b></span><span class="inline-wrap">：当配置发生变更，无论是通过<span class="jill"></span>Nacos<span class="jill"></span>的管理界面还是<span class="jill"></span>API，服务端都会记录下这个变化。</span></li><li id="jkp8RscFMxN6qMbPoGhuDp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>查找并通知监听器</b></span><span class="inline-wrap">：服务端会查找所有注册了对应配置监听器的客户端，并通过之前建立的长连接发送更新通知。</span></li><li id="pV3nE5cwUd8zWU8RBcWSAD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>拉取并应用新配置</b></span><span class="inline-wrap">：客户端在收到通知后，会从服务端拉取最新的配置，并应用到服务中。</span></li></ul></li></ol><div id="op8vcKwKY1o5ArsXSyPNt4" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>通过上述机制实现了配置的热更新，使得应用程序能够在配置变化时即时作出响应，无需重启。这种即时的更新机制确保了应用程序始终运行在最新的配置环境下，为应用程序提供了一种灵活、高效的方式来动态调整其运行时的配置。</span></div></div><div id="kN7zeERKCj6CmRu3FsSv8F" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="erppJUbzxV4KGRiwZidMKF" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">为什么<span class="jill"></span>Nacos<span class="jill"></span>同时具备<span class="jill"></span>AP<span class="jill"></span>和<span class="jill"></span>CP<span class="jill"></span>两种工作模式的能力？</span></h1><div id="82bx47wjpdYM4bi9L4FBCT" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>能够同时实现<span class="jill"></span>AP（可用性和分区容忍性）和<span class="jill"></span>CP（一致性和分区容忍性）的原理是通过引入不同的组件和机制来实现的。</span></div></div><div id="hP1yyKXEri6rff3ur9yjR" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Nacos<span class="jill"></span>中，服务注册和发现模块采用了<span class="jill"></span>AP<span class="jill"></span>模型，通过将服务实例的注册信息存储在多个节点上，实现了服务的高可用性和分区容忍性。当某个节点发生故障或网络分区时，其他节点仍然可以提供服务注册和发现的功能。</span></div></div><div id="jiNSDN1qdYzUMR536suZG5" class="wolai-block wolai-text"><div><span class="inline-wrap">而配置管理模块则采用了<span class="jill"></span>CP<span class="jill"></span>模型，通过使用<span class="jill"></span>Raft<span class="jill"></span>协议来实现一致性。当客户端更新配置时，Nacos<span class="jill"></span>会将配置写入多个节点的<span class="jill"></span>Raft<span class="jill"></span>日志中，经过多数节点的确认后才会认为配置写入成功。这保证了配置的一致性。在配置变更时，通过<span class="jill"></span>Raft<span class="jill"></span>协议的复制机制，确保配置变更在集群中的所有节点上同步，保证了配置的一致性和可靠性。</span></div></div><div id="2Pu4QLDgMLMjkKokswgRs3" class="wolai-block wolai-text"><div><span class="inline-wrap">通过这种方式，Nacos<span class="jill"></span>在不同的模块中根据需求选择了合适的一致性和可用性模型，从而同时实现了<span class="jill"></span>AP<span class="jill"></span>和<span class="jill"></span>CP<span class="jill"></span>的特性。这使得<span class="jill"></span>Nacos<span class="jill"></span>能够满足分布式系统在服务注册、发现和配置管理等方面的需求，提供高可用性、弹性和可靠性的服务。</span></div></div><div id="gbbvN69PLs2qjjAZiw7kqN" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="thV4ALtgjFaQ7GjNaiVx5n" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">Nacos<span class="jill"></span>服务发现的原理</span></h1><div id="o9XueRrThBGwEQ14ykn9V8" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>的服务发现原理主要基于</span><span class="inline-wrap"><b>服务注册、服务同步以及客户端服务发现</b></span><span class="inline-wrap">这三大核心机制。以下是对这三个核心机制的详细解释：</span></div></div><ol class="wolai-block"><li id="fPS6T4oP6Td2XkqZgQv6Pj"><div class="marker"></div><span class="inline-wrap"><b>服务注册</b></span><ul class="wolai-block"><li id="sVefejYbF1quVLgfpGNzqQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>实例信息上报</b></span><span class="inline-wrap">：当一个微服务启动时，它会通过<span class="jill"></span>Nacos<span class="jill"></span>客户端向<span class="jill"></span>Nacos<span class="jill"></span>服务器发送一个注册请求，这个请求包含了服务的基本信息，如服务名、IP<span class="jill"></span>地址、端口号等。</span></li><li id="92jUeqQiTAh4bRRoVX2KPy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据存储</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>服务器接收到注册请求后，会将这些信息存储在一个内部的数据结构中，通常是使用<span class="jill"></span>Map<span class="jill"></span>来保存这些信息，以便于快速检索和更新。</span></li><li id="iKgK96FuW489xyfn7X1asw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>健康检查</b></span><span class="inline-wrap">：为了确保服务列表的准确性，Nacos<span class="jill"></span>会定期对所有注册的服务进行健康检查。如果发现某个服务实例不再响应，Nacos<span class="jill"></span>会将其从服务列表中移除。</span></li></ul></li><li id="hYzjVug1FzQC5mnFFdb55x"><div class="marker"></div><span class="inline-wrap"><b>服务同步</b></span><ul class="wolai-block"><li id="cKJHCpr3DKGutcuJoCt445"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据复制</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>支持集群部署，这意味着在多个<span class="jill"></span>Nacos<span class="jill"></span>服务器之间需要进行数据同步，以保证每个节点上的服务列表是一致的。</span></li><li id="ueFunJupX2q1vV7vweJcS4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>一致性保证</b></span><span class="inline-wrap">：为了保证数据的一致性，Nacos<span class="jill"></span>采用了基于<span class="jill"></span>Raft<span class="jill"></span>协议的一致性算法，确保即使在部分节点出现故障的情况下，整个系统的服务列表仍然保持一致。</span></li></ul></li><li id="bYvvTkV2gZvzXUrxcSKWd9"><div class="marker"></div><span class="inline-wrap"><b>客户端服务发现</b></span><ul class="wolai-block"><li id="fnLtvwGw5RRCyghPRKQdVJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>获取服务列表</b></span><span class="inline-wrap">：当一个服务消费者需要调用另一个服务时，它会通过<span class="jill"></span>Nacos<span class="jill"></span>客户端向<span class="jill"></span>Nacos<span class="jill"></span>服务器查询所需服务的服务列表。</span></li><li id="959pAtLzERp5H5whxLqFp1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>负载均衡</b></span><span class="inline-wrap">：客户端在获取到服务列表后，会根据某种负载均衡策略（如随机、轮询等）选择一个服务实例进行调用。</span></li><li id="rckhtfGRXjmnVpVKcnGTni"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>实时更新</b></span><span class="inline-wrap">：如果服务列表发生变化，Nacos<span class="jill"></span>服务器会主动推送最新的服务列表给客户端，或者客户端可以通过长连接定时拉取最新的服务列表，以确保客户端持有的服务列表是最新的。</span></li></ul></li></ol><div id="8T99FAATAfFdk9kR3jAyZH" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>通过上述机制实现了高效的服务发现，使得微服务架构中的服务能够动态地加入或退出，而消费者可以实时感知到这些变化，从而保证了微服务系统的高可用性和灵活性。</span></div></div><div id="scKbGVzkTXrXpUfoftkWGw" class="wolai-block wolai-text"><div></div></div><div id="dn1GDrR1GiLF4QqtrkKpst" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6ki2rvvEi3rxwcR5RLFcE4" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">Nacos<span class="jill"></span>服务发现的原理</span></h1><div id="eC2hYaSCwBWfRc7pJ8n9M1" class="wolai-block wolai-text"><div><span class="inline-wrap">Nacos<span class="jill"></span>注册中心的内部原理涉及</span><span class="inline-wrap"><b>服务注册、服务发现以及健康检查等</b></span><span class="inline-wrap">多个方面。以下是对其内部原理的详细阐述：</span></div></div><ol class="wolai-block"><li id="4uWEep8E343hbKgkXGdfrp"><div class="marker"></div><span class="inline-wrap"><b>服务注册</b></span><ul class="wolai-block"><li id="S7YAAbR2r3c5fcYz7SoXj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>注册流程</b></span><span class="inline-wrap">：服务实例在启动时，会通过<span class="jill"></span>Nacos<span class="jill"></span>客户端向<span class="jill"></span>Nacos Server<span class="jill"></span>发送注册请求，包含服务的基本信息如服务名、IP<span class="jill"></span>地址、端口号等[^2^][^4^]。Nacos Server<span class="jill"></span>接收到注册请求后，将这些信息存储在内存中，通常是使用<span class="jill"></span>Map<span class="jill"></span>结构进行索引和查找[^3^]。</span></li><li id="wrxv64KztTMVzQAH68yyq3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>心跳机制</b></span><span class="inline-wrap">：为了保持注册信息的有效性，服务实例会定期向<span class="jill"></span>Nacos Server<span class="jill"></span>发送心跳消息，包含服务实例的健康状态和可用性等信息。Nacos Server<span class="jill"></span>通过接收和处理心跳消息，及时更新服务实例的状态[^1^][^2^][^5^]。</span></li></ul></li><li id="aA1EgFCfch4a2eSdwf1ApC"><div class="marker"></div><span class="inline-wrap"><b>服务发现</b></span><ul class="wolai-block"><li id="kv1EceUdKxqGzFLdfZ19fE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>查询流程</b></span><span class="inline-wrap">：当一个服务需要调用另一个服务时，它会向<span class="jill"></span>Nacos Server<span class="jill"></span>发起查询请求，以获取目标服务的服务列表[^2^][^4^]。Nacos Server<span class="jill"></span>会根据查询请求返回相应的服务实例列表，包括它们的网络地址和其他附加信息[^1^]。</span></li><li id="ogP21mrgtHCHKMCQZm25mi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>负载均衡</b></span><span class="inline-wrap">：调用者可以根据返回的服务实例列表，使用某种负载均衡算法（如随机、轮询等）选择一个服务实例进行通信[^2^]。</span></li></ul></li><li id="gxgQXEwpHCJU3DRJmdoh9p"><div class="marker"></div><span class="inline-wrap"><b>健康检查</b></span><ul class="wolai-block"><li id="3FUc6PjAbaL2qL6BAmcUrA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>内置机制</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>提供了健康监测功能，通过内置的健康检查机制，可以实时监测服务的健康状态[^3^]。对于不健康的实例，Nacos<span class="jill"></span>会自动将其从服务列表中剔除，从而保证服务的可用性[^3^][^5^]。</span></li></ul></li><li id="xaSxSs1aqZXbUik9MALwUw"><div class="marker"></div><span class="inline-wrap"><b>数据一致性与高可用性</b></span><ul class="wolai-block"><li id="uZHpdv2sigHMzGsJZy38sA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>集群部署与数据复制</b></span><span class="inline-wrap">：Nacos<span class="jill"></span>支持集群部署和数据复制，以确保不同节点之间的数据一致性。通过将多个<span class="jill"></span>Nacos Server<span class="jill"></span>实例组成集群，可以提供冗余和负载均衡，以应对单点故障[^1^]。同时，Nacos Server<span class="jill"></span>之间会互相同步服务实例信息，以保证数据的一致性[^3^]。</span></li></ul></li></ol><div id="aqVtexVWArnYbbJBLFtziq" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Nacos<span class="jill"></span>注册中心通过上述机制实现了服务的自动注册与发现、健康检查以及高可用性和数据一致性的保障。这些特性使得<span class="jill"></span>Nacos<span class="jill"></span>成为微服务架构下不可或缺的组件之一。</span></div></div><div id="gP27RSQxYxKsLNvQ52BRVT" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vh27UWQZv4v2w6XP2rc5ZX" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">Feign<span class="jill"></span>的调用原理</span></h1><div id="xqYJHmrNSm1LJwU3pYMusL" class="wolai-block wolai-text"><div><span class="inline-wrap">首先，如果你对某个接口定义了<span class="jill"></span>@FeignClient<span class="jill"></span>注解，Feign<span class="jill"></span>就会针对这个接口创建一个动态代理<span class="jill"></span>Feign<span class="jill"></span>的动态代理会根据你在接口上的<span class="jill"></span>@RequestMapping<span class="jill"></span>等注解，来动态构造出你要请求的服务的地址最后针对这个地址，发起请求、解析响应。</span></div></div><div id="r1gkLSkoQSv8GAJV75Zxrb" class="wolai-block"><figure class="wolai-center" style="width: 540px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="nWnVDN3cB8WUPBKqM9Mt7" class="wolai-block wolai-text"><div></div></div><div id="aX7mxmWNg6QaMW4z3TNMyH" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="skQW3Z9Siesu8XDqPefQEV" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">Feign+Nacos<span class="jill"></span>注册中心原理</span></h1><div id="qQxwc7xE9Ud815YMYN7vrw" class="wolai-block"><figure class="wolai-center" style="width: 760.6666666666666px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><div id="jdrRHnjdSmdnASJYy4e1QU" class="wolai-block wolai-text"><div></div></div><div id="b9bVojneHheb2MTMYNMwo1" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9ssrvU7hF1pMvJ7zumdiha" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">Feign<span class="jill"></span>的底层调用源码大致流程</span></h1><ol class="wolai-block"><li id="c5SAwEsXVqCPTpwupNadH4"><div class="marker"></div><span class="inline-wrap">判断当前代理的方式是不是<span class="jill"></span>equals()、hashCode()、toString().如果是 直接结束，因为本地服务有这些方法，压根不需要从远程来要。</span></li><li id="g1b2m3UeRwbBYLDWepKva9"><div class="marker"></div><span class="inline-wrap">dispatch.get(method).invoke(args) ：核心代理逻辑从一个派发器中获取解析当前方法的处理器 ---派发器的结构是一个<span class="jill"></span>Map--- Map&lt;Method, MethodHandler&gt;来获取解析这个方法的处理器。默认从这个<span class="jill"></span>Map<span class="jill"></span>中找到的方法处理器是<span class="jill"></span>SynchronousMethodHandler---同步方法处理器</span></li><li id="rb3pViq8wbJ1rxz4863xEL"><div class="marker"></div><span class="inline-wrap">SynchronousMethodHandler.invoke(args)</span><ol class="wolai-block"><li id="2SFWNnMtr3n9PkN5bnRnzP"><div class="marker"></div><span class="inline-wrap">构建一个<span class="jill"></span>RequestTemplate。作用是为了发请求的是时候用这个模版造一个请求。细节：根据老的请求模版构建一个新的请求模版，接着会将老的请求模版中的一些参数放到新的请求模版中，但是请求头中参数如果没有在<span class="jill"></span>Feign<span class="jill"></span>中去指定的话， 那么这个老模版中就没有头，而新模板中也就没有请求头数据。因此后面在用这个新模版创建请求的时候，该请求就没有请求头数据，所以<span class="jill"></span>Feign<span class="jill"></span>在远程调用时出现了请求头丢失问题。</span></li><li id="cTc4qp65Qonyos2V56qadJ"><div class="marker"></div><span class="inline-wrap">支持<span class="jill"></span>Options---可以独立对自己的业务远程接口去指定一些连接超时时间和读取的超时时间。</span></li><li id="89AjpzmZdBDNsuVbHCx5N"><div class="marker"></div><span class="inline-wrap">得到一个重试器<span class="jill"></span>Retryer<span class="jill"></span>如果在发送远程调用的时候，出现异常，那么<span class="jill"></span>feign<span class="jill"></span>在底层会用<span class="jill"></span>catch<span class="jill"></span>捕捉到，然后进行重试--- retryer.continueOrPropagate(e);但是对于重试<span class="jill"></span>feign<span class="jill"></span>自己也有规则：如果一旦在重试期间出现了异常，直接将异常抛出，结束这一次远程调用。如果在重试期间没有出现异常，但是<span class="jill"></span>feign<span class="jill"></span>通过最大次数（5<span class="jill"></span>次调用）如果到了最大次数<span class="jill"></span>5 那么<span class="jill"></span>feign<span class="jill"></span>仍然是会抛出异常，结束这一次远程调用。</span></li><li id="87EVs46LWarSWwmFUR3x85"><div class="marker"></div><span class="inline-wrap">executeAndDecode---执行并解码（执行：指的是要去给远程发请求 解码：远程给我的数据都是字节流 我要将自字节流转成我业务能用的对象【反序列化】）</span><ol class="wolai-block"><li id="6HRPPGAA6rsGLEEfKGNm1E"><div class="marker"></div><span class="inline-wrap">发送请求<span class="jill"></span>response = client.execute();---根据服务名从<span class="jill"></span>Nacos<span class="jill"></span>找到该服务下的所有客户端，然后负载均衡的掉用某一个。并且在第一次找该客户端的时候，会将第一次找到的这个客户端放到缓存中去，下一次再来发起远程调用的时候，直接从缓存中获取该客户端。</span></li><li id="8JZpDgne2dZ6DmMdKVExAZ"><div class="marker"></div><span class="inline-wrap">对响应的数据进行反序列化<span class="jill"></span>handleResponse();</span></li></ol></li></ol></li></ol><div id="nyAf4eiU33EEcAjwPn5nsf" class="wolai-block wolai-text"><div></div></div><div id="pZCYkCbq2jY3zAbCBH9Ghg" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kAm6PoTgYxpdz9amtwtTTC" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">远程调用的本质</span></h1><div id="2YHQyV6WUKuHTxiaN8T52v" class="wolai-block wolai-text"><div><span class="inline-wrap">1、建立连接  </span></div></div><div id="qZUKpFVG4MNzdoievif5zt" class="wolai-block wolai-text"><div><span class="inline-wrap">2、给远程发送请求  </span></div></div><div id="kVUTp75c1yxsnLXkoyoLEw" class="wolai-block wolai-text"><div><span class="inline-wrap">3、远程处理数据  </span></div></div><div id="9aqt2gkzW65yD6Q5WT7jRU" class="wolai-block wolai-text"><div><span class="inline-wrap">4、远程响应数据  </span></div></div><div id="hFuY8fjUaQnbMKwUoJ3xS3" class="wolai-block wolai-text"><div><span class="inline-wrap">5、将数据进行渲染</span></div></div></article><footer></footer></body></html>