<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>MySQL：内部原理与SQL优化 - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="MySQL：内部原理与SQL优化" class="main-title"></div></div></header><article><h1 id="jfhRYc9Qkiizd8oi7NGiGx" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">索引的基本原理</span></h1><div id="gCiJwQDMz9G2oU1NpwYmGK" class="wolai-block wolai-text"><div><span class="inline-wrap">索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。  </span></div></div><div id="kZGCosm345vion7euXZAJ7" class="wolai-block wolai-text"><div><span class="inline-wrap">索引的原理：就是把无序的数据变成有序的查询</span></div></div><ol class="wolai-block"><li id="t7vFQR5zPa9iwmGNCsXuRV"><div class="marker"></div><span class="inline-wrap">把创建了索引的列的内容进行排序。</span></li><li id="hCpxBS5Q7j1pdGDEz2ijMz"><div class="marker"></div><span class="inline-wrap">对排序结果生成倒排表。</span></li><li id="3Av86Ys3g786bTsMTrrcpT"><div class="marker"></div><span class="inline-wrap">在倒排表内容上拼上数据地址链。</span></li><li id="tvAsBiavqzG3uKuuZ5z2Ls"><div class="marker"></div><span class="inline-wrap">在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</span></li></ol><div id="91d7MzvJUNREtvGYFEaXCp" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="sagzKLvpfEJAgGv8TtTBwQ" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">说一下索引的优势和劣势？</span></h1><div id="sRzYcPaoEeTpun56h3Um4T" class="wolai-block wolai-text"><div><span class="inline-wrap">优势：适当使用索引可以大大提高查询速度</span></div></div><div id="6FBDU4UPB3YDGZiMGkSTw4" class="wolai-block wolai-text"><div><span class="inline-wrap">劣势：</span></div></div><ul class="wolai-block"><li id="7GpNaVQWZGWQSqyujzuvse"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">针对创建索引的数据执行增、删、改操作会导致索引重新计算，拉低了增、删、改操作的执行速度</span></li><li id="ccGACMK1RXzc7u7Uq6N92o"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在数据表中数据本身之外，索引还要占用物理空间</span></li><li id="e8PWBxTpHozsGGtkXHByx6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">维护索引很昂贵，特别是插入新行或者主键被更新导致要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过<span class="jill"></span>OPTIMIZE TABLE<span class="jill"></span>优化表，因为必须被移动的行数据可能造成碎片，而使用独享表空间可以弱化碎片。</span></li><li id="3Kv7b69Rr1EyTKxLx4Lraa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">表如果使用<span class="jill"></span>UUID（随机<span class="jill"></span>ID）作为主键，则会使数据存储稀疏，这就会出现使用聚簇索引有可能有比全表扫描更慢，所以建议使用<span class="jill"></span>int<span class="jill"></span>的<span class="jill"></span>auto_increment<span class="jill"></span>作为主键</span></li><li id="vrax5vmXtazqiN3Hfivurm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间。  </span></li></ul><blockquote id="cTEJtg7YUWzSeSGNxMuvWw" class="wolai-block"><span class="inline-wrap">这里的“劣势”表述为“代价”更准确，所以总的逻辑是：为了达到快速查询的目的，即使付出再多代价也在所不惜。
而且很多问题是可以避免的，比如：不在频繁增、删、改的表或字段上创建索引；尽量基于主键索引或唯一索引查询；尽量实现覆盖索引；优化<span class="jill"></span>SQL<span class="jill"></span>语句使其和索引结构更加匹配</span></blockquote><div id="kfgTDaKnvwmAyR9qeJTVce" class="wolai-block wolai-text"><div></div></div><div id="r48W2DCzymbRWtxj6RbAv" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4ZeU8anBZkXmCvYQz6GMYn" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">MySQL<span class="jill"></span>聚簇和非聚簇索引的区别</span></h1><div id="6fMaY7UBLrK9T3uBpHwooV" class="wolai-block wolai-text"><div><span class="inline-wrap">聚簇和非聚簇索引都是<span class="jill"></span>B+<span class="jill"></span>树的数据结构</span></div></div><h2 id="dqejBqn6XGdT7AkdPo4oey" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="iPy92JvR89FEhNi7a86z5v"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">聚簇索引：索引和数据在一起</span></li><li id="ahjjb9iinu8AYUR3VHXWhs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非聚簇索引：索引和数据不在一起</span></li></ul><div id="aprdpJbYbBVHTKfYmBn53r" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="tFUgpZvvXu9r3eVVpus9CX" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">理解</span></h2><h3 id="3p1yP8z6KYvRqaJKqKLahY" class="wolai-block"><span class="wolai-serial-number">3.2.1</span><span class="inline-wrap">聚簇索引</span></h3><div id="966g6SyuZ8aK1i6hPUNAPS" class="wolai-block wolai-text"><div><span class="inline-wrap">聚簇索引是直接在数据本身的基础上创建的，索引和数据一体。聚簇索引建立的依据是排序后的主键值，所以聚簇索引和主键索引是等同的，是同一个事物侧重不同角度时的不同名称而已。</span></div></div><div id="hhNe7HHfGD4cwSLqavS97H" class="wolai-block wolai-text"><div><span class="inline-wrap">由于聚簇索引是将数据存储与索引放到了一块、并且是按照一定的顺序组织的，所以找到索引也就找到了数据。又因为数据的物理存放顺序与索引顺序是一致的，所以只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</span></div></div><div id="d5iFBZoqsdWEkkzkypsnnV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vD1Ztk4HxWb6twx4scpBQQ" class="wolai-block"><span class="wolai-serial-number">3.2.2</span><span class="inline-wrap">非聚簇索引</span></h3><div id="pbMoCetv1gPQLyZ5Np5dWk" class="wolai-block wolai-text"><div><span class="inline-wrap">叶子节点除了被索引的那个字段之外不存储其它数据。那么为了能够找到所在行的其它数据，非聚簇索引的叶子节点需要存储所在行的主键值。</span></div></div><div id="c4U7mVYiRxLhxcjiPZTWSJ" class="wolai-block wolai-text"><div><span class="inline-wrap">将来在查询过程中涉及两种情况：</span></div></div><ul class="wolai-block"><li id="jAmXkAUK37zQivKTaXXSAv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不需要回表：当前非聚簇索引包含了全部要查询的字段（这种情况就是我们常说的覆盖索引，你可以理解成：索引中字段的范围把<span class="jill"></span>select<span class="jill"></span>子句所需字段范围给覆盖住了）</span></li><li id="434NhEiY8mLbZiGgnsu5HY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">需要回表：select<span class="jill"></span>子句要查询的字段涉及到当前非聚簇索引之外的其它字段（非覆盖索引，没覆盖住）</span></li></ul><div id="gduZbCNKzaCrvdtP6yqAvv" class="wolai-block wolai-text"><div><span class="inline-wrap">所谓回表就是通过非聚簇索引查询到数据之后，拿到主键值；再根据主键值回到聚簇索引查询所需数据。</span></div></div><div id="wWCikQiJxyUMGr6TscTWgx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="xwpatdCb4i9dhW3qEeiDGx" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vDTtrtDAn182tiTTTuuqpe" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">InnoDB<span class="jill"></span>和<span class="jill"></span>MyISAM<span class="jill"></span>中索引的区别</span></h1><h2 id="dLFjEx3drxUGKkT93uEwXu" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">InnoDB</span></h2><div id="inQR3ow5Eqgkvz1i4ueMvH" class="wolai-block wolai-text"><div><span class="inline-wrap">InnoDB<span class="jill"></span>中一定有主键，主键一定是聚簇索引。如果不手动设置、则会使用<span class="jill"></span>unique<span class="jill"></span>索引；如果连<span class="jill"></span>unique<span class="jill"></span>索引都没有，则会使用数据库内部的一个行的隐藏<span class="jill"></span>id<span class="jill"></span>来当作主键索引。</span></div></div><div id="9fVdp4rZ25BypYNs4DhsxN" class="wolai-block wolai-text"><div><span class="inline-wrap">在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</span></div></div><div id="sGdmcsqeFgjVFDkXKEACTw" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5jdAvjyJZBGtmkdLNfTBB1" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">MyISAM</span></h2><div id="3UYwMVHHb5o83wKg5FN5Ev" class="wolai-block wolai-text"><div><span class="inline-wrap">MyISM<span class="jill"></span>没有聚簇索引，所有索引都是非聚簇索引。非聚簇索引的两棵<span class="jill"></span>B+<span class="jill"></span>树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已。</span></div></div><div id="6u41mfiDgRY93NJYEoUzRr" class="wolai-block wolai-text"><div><span class="inline-wrap">主键索引<span class="jill"></span>B+<span class="jill"></span>树的叶子节点存储了主键，辅助键索引<span class="jill"></span>B+<span class="jill"></span>树存储了辅助键。</span></div></div><div id="aepNdeafYqGzF5Ris1Ga4Z" class="wolai-block wolai-text"><div><span class="inline-wrap">表数据另外存储在独立的地方，这两颗<span class="jill"></span>B+<span class="jill"></span>树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。</span></div></div><div id="oW7Dn7G1bUF3HJoUEWHgWx" class="wolai-block wolai-text"><div><span class="inline-wrap">由于索引树是独立的，通过辅助键检索时无需访问主键的索引树。  </span></div></div><div id="cVWvVFE5SjJf5hNJM3j9mH" class="wolai-block wolai-text"><div><span class="inline-wrap">如果涉及到大数据量的排序、全表扫描、count<span class="jill"></span>之类的操作的话，还是<span class="jill"></span>MyISAM<span class="jill"></span>占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</span></div></div><div id="8qYDJaHjv7MXTn29qLcBFn" class="wolai-block wolai-text"><div></div></div><div id="aw4nsQZ59Cvt8zNjVoLeAM" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kPHgnJQyCvcvRtprsp23jx" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">MySQL<span class="jill"></span>中索引有哪些数据结构可以选择？</span></h1><div id="jwSizrmRVxVK6Sd7K3b2yz" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，可以使用的索引数据结构主要包括以下几种：</span></div></div><ul class="wolai-block"><li id="wvANPfqhRrWBfczXxmHm6T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>B+<span class="jill"></span>树索引</b></span><span class="inline-wrap">：这是最常见的一种索引类型，InnoDB<span class="jill"></span>存储引擎的默认索引实现，适用于大多数情况下的查询操作，包括范围查询和排序操作。</span></li><li id="8SmRb69F75KTAKH4xoSdDs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Hash<span class="jill"></span>索引</b></span><span class="inline-wrap">：</span><span class="inline-wrap">底层的数据结构就是哈希表，因此</span><span class="inline-wrap">主要用于等值查询，效率非常高，但不支持范围查询或排序。</span></li><li id="b7E69amNtY18T3s7fA2QbC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全文索引 (Full-text Index)</b></span><span class="inline-wrap">：这种索引用于全文搜索，适用于对文本字段进行复杂的搜索操作。它支持自然语言处理和布尔搜索等功能。</span></li><li id="me8YAAzwhfFJiQ4aoEZC3H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>R<span class="jill"></span>树索引</b></span><span class="inline-wrap">：这种索引主要用于地理空间数据类型，如点、线、面等。它支持空间查询，如距离计算、区域查询等。</span></li><li id="7StqSi3AU6Mkzz6K8n2Jzh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>空间索引 (Spatial Index)</b></span><span class="inline-wrap">：类似于<span class="jill"></span>R-Tree<span class="jill"></span>索引，但更通用，适用于任何类型的空间数据。它也支持空间查询和距离计算等功能。</span></li></ul><div id="75FPwdF81RghKHizZJseLk" class="wolai-block wolai-text"><div><span class="inline-wrap">每种索引类型都有其适用场景和限制，选择合适的索引类型可以显著提高查询性能。</span></div></div><div id="kZWT4NVTfCyNiKZYQ5sue9" class="wolai-block wolai-text"><div></div></div><div id="uwLmm2TNDGT5pd4Do7ZHnm" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pSydYqB8pn3qmKEdutUM6g" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">比较<span class="jill"></span>B+<span class="jill"></span>树和<span class="jill"></span>HASH<span class="jill"></span>两种索引结构的优劣</span></h1><h2 id="5kFbEMTR7xwYe8EjGbsspx" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">B+<span class="jill"></span>树</span></h2><h3 id="x1NdRBirizdXzr5ED9FcMz" class="wolai-block"><span class="wolai-serial-number">6.1.1</span><span class="inline-wrap">B+<span class="jill"></span>树的特点</span></h3><ul class="wolai-block"><li id="fhKByoiZ87HZZGP9n4v5Fw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B+<span class="jill"></span>树是一个</span><span class="blue inline-wrap"><u><b>平衡</b></u></span><span class="inline-wrap">的</span><span class="red inline-wrap"><u><b>多叉</b></u></span><span class="inline-wrap">树，从根节点到每个叶子节点的高度差值不超过<span class="jill"></span>1（意思是：所有叶子节点都在同一层）</span></li><li id="tJ1zdYi8c91qnjPPcPKNRe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">同层级的节点间有指针相互链接</span></li><li id="vWPgaQHfDQvZURLc6asgtb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于<span class="jill"></span>B+<span class="jill"></span>树是平衡的多叉树，其高度是最小的。这意味着从根节点到任何叶子节点的路径长度是相同的</span></li></ul><div id="dEBvJgPHfmpUuhfCq33uJR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="foJzyZGEXFRqv8DTQCkTHw" class="wolai-block"><span class="wolai-serial-number">6.1.2</span><span class="inline-wrap">B+<span class="jill"></span>树的优势</span></h3><ol class="wolai-block"><li id="bkzNCy9Co2BNPQJkhL76YE"><div class="marker"></div><span class="inline-wrap"><b>树的高度</b></span><span class="inline-wrap">：从根节点到任何叶子节点的路径长度相同，因此搜索效率不会因为路径长度的不同而出现大幅波动。</span></li><li id="aUMrwRidjYftHTZr9CLsQE"><div class="marker"></div><span class="inline-wrap"><b>节点的子节点数</b></span><span class="inline-wrap">：在<span class="jill"></span>B+<span class="jill"></span>树中，每个节点可以有多个子节点，但必须满足一定的平衡条件。具体来说，除了根节点外，每个节点必须至少有⌈m/2⌉个子节点（其中<span class="jill"></span>m<span class="jill"></span>是节点的最大子节点数），且最多有<span class="jill"></span>m<span class="jill"></span>个子节点。这种结构确保了树的高度保持相对稳定，从而保证了搜索效率的一致性。</span></li><li id="7WC5dgh2wo22EozhADqEUR"><div class="marker"></div><span class="inline-wrap"><b>搜索过程</b></span><span class="inline-wrap">：在<span class="jill"></span>B+<span class="jill"></span>树上进行常规检索时，搜索过程是从根节点开始，逐层向下遍历子节点，直到找到目标叶子节点。由于树的高度是固定的，因此搜索过程中需要访问的节点数量也是固定的。这意味着搜索效率不会因为数据量的变化而出现大幅波动。</span></li><li id="tkcjZTcVPdCffidbWcbAZK"><div class="marker"></div><span class="inline-wrap"><b>磁盘<span class="jill"></span>I/O<span class="jill"></span>操作</b></span><span class="inline-wrap">：在数据库系统中，B+<span class="jill"></span>树通常用于索引结构，以减少磁盘<span class="jill"></span>I/O<span class="jill"></span>操作次数。由于<span class="jill"></span>B+<span class="jill"></span>树的高度固定，每次检索所需的磁盘<span class="jill"></span>I/O<span class="jill"></span>操作次数也是固定的。这进一步保证了搜索效率的稳定性。</span></li><li id="eTtBVLM3MuK6HJfj8GvNFN"><div class="marker"></div><span class="inline-wrap"><b>同层指针</b></span><span class="inline-wrap">：基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高</span></li></ol><div id="ntftu4Mkf8uoo1g57Mk69S" class="wolai-block wolai-text"><div><span class="inline-wrap">因此<span class="jill"></span>B+<span class="jill"></span>树索引被广泛应用于数据库、文件系统等场景</span></div></div><div id="uGP6oVc2SStW4ZMLnqf7oZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="m5MQwZ4tUeshmpjnN7TLBJ" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">哈希索引</span></h2><div id="peYZZsNN2DfHXfcg2qDVv5" class="wolai-block wolai-text"><div><span class="inline-wrap">哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似<span class="jill"></span>B+<span class="jill"></span>树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</span></div></div><div id="vg3RRToGom3MUXK9EbFSk9" class="wolai-block"><figure class="wolai-center" style="width: 534px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="r2KbScdbKUSwW5DnEjzaff" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；  </span></div></div><div id="2sCFFZL51hN779ZpZxzNpW" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；  </span></div></div><div id="sfTEPN7Z9KENJgCvbhYcoh" class="wolai-block wolai-text"><div><span class="inline-wrap">哈希索引也没办法利用索引完成排序，以及<span class="jill"></span>like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</span></div></div><div id="49J6iFzfhP8eYK6xVw6YdV" class="wolai-block wolai-text"><div><span class="inline-wrap">哈希索引也不支持多列联合索引的最左匹配规则；</span></div></div><div id="imDFST6bofVQPptacieHJf" class="wolai-block wolai-text"><div><span class="inline-wrap">在有大量重复键值情况下，哈希索引的效率极低，因为存在哈希碰撞问题。</span></div></div><div id="2hTVB1w5MYsGufnA29Vigx" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="df6dqcwh54dNfXtzv6b2rW" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">MySQL<span class="jill"></span>索引的设计原则</span></h1><h2 id="9EMH6ZDpqS6cMtRibwNRru" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">总体原则</span></h2><div id="vKZNZg7iigrzbPFVemtvQ9" class="wolai-block wolai-text"><div><span class="inline-wrap">查询更快、占用空间更小</span></div></div><div id="pvNhVshkkFabZKPfqtWCVi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="73bBjYt4RbWNkpkNieXtNa" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">详细描述</span></h2><ol class="wolai-block"><li id="mSTjr7wtpQ1vBMbpD4fpVM"><div class="marker"></div><span class="inline-wrap">适合索引的列是出现在<span class="jill"></span>where<span class="jill"></span>子句中的列，或者连接子句中指定的列。</span></li><li id="2P9fGqzcSu49UXqNQ4drTj"><div class="marker"></div><span class="inline-wrap">基数（数据库表中的记录数）较小的表，索引效果较差，没有必要在此列建立索引</span></li><li id="9FKqBv3tGsKX99C2YHftQV"><div class="marker"></div><span class="inline-wrap">使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配  </span></li><li id="2DrG4L2ZRiYwqQfdi5Bzdu"><div class="marker"></div><span class="inline-wrap">不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</span></li><li id="oox5ovhAeBXSvwzGD5km32"><div class="marker"></div><span class="inline-wrap">定义了外键的数据列一定要建立索引。</span></li><li id="qTBWY8nW2Zm9Ne6aa9ix28"><div class="marker"></div><span class="inline-wrap">更新频繁字段不适合创建索引。</span></li><li id="kx5wZrpsyUXvdET9T9hWE"><div class="marker"></div><span class="inline-wrap">若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</span></li><li id="qE6AdYZrRsEaYXWFcLv6Nu"><div class="marker"></div><span class="inline-wrap">对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</span></li><li id="nBgSzffVH7A4eqHBsvsGSt"><div class="marker"></div><span class="inline-wrap">对于定义为<span class="jill"></span>text、image<span class="jill"></span>和<span class="jill"></span>bit<span class="jill"></span>的数据类型的列不要建立索引。</span></li></ol><div id="hPrLri2XLN2Da6QEYGU5Aj" class="wolai-block wolai-text"><div></div></div><div id="7hvooy6ZGdqSHGuZmWHX7S" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wze36PVVRDSrTJ83oxGLEt" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">MySQL<span class="jill"></span>中<span class="jill"></span>B+<span class="jill"></span>树和<span class="jill"></span>B<span class="jill"></span>树的区别</span></h1><h2 id="vYgfVmDoNwzUSjs5N4kLwZ" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">非叶子节点数据不同</span></h2><div id="8TQZ1QTCJNEvimNQD97gPh" class="wolai-block wolai-text"><div><span class="inline-wrap">B+<span class="jill"></span>树的非叶子节点的数据都在叶子节点中出现过，也就是叶子节点中的数据都在非叶子节点冗余一 份。</span></div></div><div id="45o5d25nnHi3qggEgDAk2V" class="wolai-block wolai-text"><div><span class="inline-wrap">B<span class="jill"></span>树中非叶子节点中元素不会冗余。  </span></div></div><div id="rKjSiYNz62S4wdSBUc7hZu" class="wolai-block wolai-text"><div><span class="inline-wrap">B+<span class="jill"></span>树非叶子节点只存放指针，不存放数据，B<span class="jill"></span>树所有节点（叶子节点）都存放数据。  </span></div></div><div id="vWMhPut4y18SATNsa4wgdj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="uEZwU6Vssv6n9XtuknYuKf" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">叶子节点数据不同</span></h2><div id="bf2ytYiE4DymVkozTLg9gZ" class="wolai-block wolai-text"><div><span class="inline-wrap">B+<span class="jill"></span>树叶子节点存放数据，B<span class="jill"></span>树所有节点（非叶子节）点存放数据。数据遍布整个树结构。  </span></div></div><div id="aESDPcGZrt1ZjkWAtdUAdQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ijbwrKDvFgTzMtpzhqJoMG" class="wolai-block"><span class="wolai-serial-number">8.3</span><span class="inline-wrap">时间复杂度不同</span></h2><div id="s7Fi9GQQN5nfJr3stdHx4H" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>B+<span class="jill"></span>树的数据都存在叶子节点，因此<span class="jill"></span>B+<span class="jill"></span>树的时间复杂度固定为<span class="jill"></span>o(log n)，而<span class="jill"></span>B<span class="jill"></span>树的数据分布在每个节点中，因此时间复杂度不固定，最好的情况是<span class="jill"></span>o(1)</span></div></div><div id="fkN28S2YpvsQ5F9G6znMCx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hEqp6z3LkdtseeufPrHvRR" class="wolai-block"><span class="wolai-serial-number">8.4</span><span class="inline-wrap">叶子节点连接不同</span></h2><div id="eYmBsoHEECEXSPuy3HVAX5" class="wolai-block wolai-text"><div><span class="inline-wrap">B+<span class="jill"></span>树的叶子节点通过有序的双向链表相连，B<span class="jill"></span>树叶子节点不相连</span></div></div><div id="rAbp7nUjnX8iwsDmgTZ1zM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="tWjmXig7CsBYAB9PTPce2N" class="wolai-block"><span class="wolai-serial-number">8.5</span><span class="inline-wrap">区间查询效率不同</span></h2><div id="xjLi3rRJ5AvApWLcFVJ854" class="wolai-block wolai-text"><div><span class="inline-wrap">因为第<span class="jill"></span>4<span class="jill"></span>点的原因，所以<span class="jill"></span>B+<span class="jill"></span>树范围查询效率更快，而<span class="jill"></span>B<span class="jill"></span>树范围查询比较慢。 </span></div></div><div id="5oJ7B42BMxL4R3UNezEm5" class="wolai-block wolai-text"><div><span class="inline-wrap">因此，存在大量范围查询的场景，适合使用<span class="jill"></span>B+<span class="jill"></span>树而对大量单个<span class="jill"></span>key<span class="jill"></span>查询的场景，可以考虑<span class="jill"></span>B<span class="jill"></span>树或<span class="jill"></span>HASH</span></div></div><div id="5VcDhSpmQ6Qfdq2F2UTyZ4" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tjpNgT1FucFCoFiEG6frRD" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">MySQL<span class="jill"></span>中的锁类型有哪些？</span></h1><h2 id="p9N75pQ4skAyddMU7YWC3S" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="sT6AtizUmyvkaLGmPLJrbs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于锁的属性分类：共享锁、排他锁。  </span></li><li id="cVW6vQKvayHwU742Y5Ybxn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于锁的粒度分类：</span><ul class="wolai-block"><li id="dAfsPZ5n6jjVQErmPSU2Zk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">行级锁(INNODB)</span></li><li id="44rnHNBGBTDtxfQCHmJqef"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">表级锁(INNODB、MYISAM)</span></li><li id="qd51tfgUED2ivYAD4JNyT6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">页级锁(BDB<span class="jill"></span>引擎 )</span></li><li id="oz8rytPSt7qmaeoqquT1ip"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">记录锁</span></li><li id="67kp8fL3jyRJ4oBNgoFSgS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">间隙锁</span></li><li id="3vV8DwKxWy2WuFEV3f6ai1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">临键锁</span></li></ul></li></ul><div id="muqFn3jVaAaDujroLXCGJz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hbUdteZJ4HDkxEz3R1NoNR" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">理解</span></h2><h3 id="cHWRPHmSMXfJeLSUxGK39j" class="wolai-block"><span class="wolai-serial-number">9.2.1</span><span class="inline-wrap">共享锁(Share Lock)</span></h3><div id="qxPBXVE7kDUG7axUwTKLnV" class="wolai-block wolai-text"><div><span class="inline-wrap">共享锁又称读锁，简称<span class="jill"></span>S<span class="jill"></span>锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能加写锁。</span></div></div><div id="oBEMXQZjr1aCGnd95LYbeL" class="wolai-block wolai-text"><div><span class="inline-wrap">共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，可以避免出现不可重复读的问题。  </span></div></div><div id="99sFgYxrj9PetgEKFJTJaH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="mkVU9BE3z4zpTMRmFkMg1F" class="wolai-block"><span class="wolai-serial-number">9.2.2</span><span class="inline-wrap">排他锁（Exclusive Lock）</span></h3><div id="3fXhWcdRcy1nvpLMpcVZ2P" class="wolai-block wolai-text"><div><span class="inline-wrap">排他锁又称写锁，简称<span class="jill"></span>X<span class="jill"></span>锁；</span></div></div><div id="kpkBMsfBegBU8Xs6XJHazY" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。</span></div></div><div id="bezbCJEGcvWdJb4xUMFVKE" class="wolai-block wolai-text"><div><span class="inline-wrap">排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题</span></div></div><div id="4u9uU5whqmgu2yMbJk45kB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vvk8e1Eu4VeRfc9ckRtykD" class="wolai-block"><span class="wolai-serial-number">9.2.3</span><span class="inline-wrap">表锁</span></h3><div id="wTExY9FgK9KH1MrMQPdECe" class="wolai-block wolai-text"><div><span class="inline-wrap">表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问</span></div></div><div id="2k9dcK3pemyjSoEzuW8H2o" class="wolai-block wolai-text"><div><span class="inline-wrap">特点： 粒度大，加锁简单，容易冲突</span></div></div><div id="gjUerohwr4ZVQP9N5AvZ1j" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="j6RHf7cCQtxB2A7fAbxvco" class="wolai-block"><span class="wolai-serial-number">9.2.4</span><span class="inline-wrap">行锁</span></h3><div id="coNpqnh2fUqekQDxPe49qF" class="wolai-block wolai-text"><div><span class="inline-wrap">行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；  </span></div></div><div id="391FrrKis2GtwdTcLw9V33" class="wolai-block wolai-text"><div><span class="inline-wrap">特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高</span></div></div><div id="rrQ1QziHTWxZ3be6d3CjYs" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4sPfzqSERjWnH4F6rZEgJu" class="wolai-block"><span class="wolai-serial-number">9.2.5</span><span class="inline-wrap">记录锁(Record Lock)  </span></h3><div id="8e9XcrjQRTc63PQYUimWqo" class="wolai-block wolai-text"><div><span class="inline-wrap">记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</span></div></div><div id="2gDdiKFPMARb3LZiDg1UCK" class="wolai-block wolai-text"><div><span class="inline-wrap">精准条件命中，并且命中的条件字段是唯一索引加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。  </span></div></div><div id="tQNwsLoZTKaW2iC39jZuzz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7DocJwLRKqNJ8QoUouyXnX" class="wolai-block"><span class="wolai-serial-number">9.2.6</span><span class="inline-wrap">页锁</span></h3><div id="qMykjJAKT6zrrEUq8p1sHH" class="wolai-block wolai-text"><div><span class="inline-wrap">页级锁是<span class="jill"></span>MySQL<span class="jill"></span>中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。</span></div></div><div id="bn6gzAtLLMgYwre2RRrL3u" class="wolai-block wolai-text"><div><span class="inline-wrap">所以取了折衷的页级，一次锁定相邻的一组记录。</span></div></div><div id="bxKSsSXe1Mup7EGnnoAjyQ" class="wolai-block wolai-text"><div><span class="inline-wrap">特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</span></div></div><div id="m9JG5DfBad2pANyh2v38Lc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="xB1HHFwdT2TNGtA6THc4t7" class="wolai-block"><span class="wolai-serial-number">9.2.7</span><span class="inline-wrap">间隙锁(Gap Lock）</span></h3><div id="ho8gvzNmKRnfrQDcxPR345" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">是一种用于</span><span class="blue inline-wrap"><b>防止幻读</b></span><span class="inline-wrap">现象的锁机制。在数据库中，幻读是指一个事务在读取某个范围内的数据时，另一个事务插入了新的记录，导致第一个事务再次读取该范围时发现有新的记录出现。</span></div></div><h3 id="2D4Esj1KMZ9uCrAHLvWyeR" class="wolai-block"><span class="wolai-serial-number">9.2.8</span><span class="inline-wrap">间隙锁的特性：</span></h3><ol class="wolai-block"><li id="7MapDr3EieRE97Wd64cecL"><div class="marker"></div><span class="inline-wrap"><b>锁定范围</b></span><span class="inline-wrap">：间隙锁不仅锁定实际存在的记录，还锁定这些记录之间的“间隙”。这意味着即使两个事务试图插入相同的记录范围，它们也会因为间隙锁而发生冲突。</span></li><li id="6shmCzZjhh8yfTXfEozhEn"><div class="marker"></div><span class="inline-wrap"><b>防止插入</b></span><span class="inline-wrap">：间隙锁可以防止其他事务在锁定的范围内插入新的记录。这确保了在一个事务读取某个范围的数据后，其他事务不能在该范围内插入新的记录，从而避免了幻读现象。</span></li><li id="5xjA1QnaqN6McFVwX7uY8u"><div class="marker"></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：间隙锁通常用于可重复读（Repeatable Read）隔离级别，以防止幻读现象。在这种隔离级别下，事务在第一次读取数据时会对读取的范围加锁，包括间隙锁，以确保在整个事务期间数据的一致性。</span></li></ol><h3 id="aHDhRtexYi1FjNSNqybwuu" class="wolai-block"><span class="wolai-serial-number">9.2.9</span><span class="inline-wrap">示例：</span></h3><div id="3kfo53ixtoXZ6FQ2t7Mvdf" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个表 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">，其中包含以下记录：</span></div></div><code-block id="fNfmvMHM6ETwuuBfnLcK6V" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>id | name
---|------
1  | Alice
3  | Bob
5  | Charlie</pre></div></code-block><ul class="wolai-block"><li id="eSgB3Ujm4BKxKNxw5ALxaj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务<span class="jill"></span>A<span class="jill"></span>执行查询 </span><span class="inline-wrap"><code>SELECT * FROM employees WHERE id &gt; 2 AND id &lt; 6 FOR UPDATE;</code></span><span class="inline-wrap">，这将对范围 (2, 6) 加上间隙锁。</span></li><li id="kUn2fsqtSFNyZL7qdC9xTv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务<span class="jill"></span>B<span class="jill"></span>尝试执行插入操作 </span><span class="inline-wrap"><code>INSERT INTO employees (id, name) VALUES (4, &#39;David&#39;);</code></span><span class="inline-wrap">，由于间隙锁的存在，事务<span class="jill"></span>B<span class="jill"></span>将被阻塞，直到事务<span class="jill"></span>A<span class="jill"></span>释放锁。</span></li></ul><div id="pafM1iWynt97nuXq77m7KK" class="wolai-block wolai-text"><div><span class="inline-wrap">通过使用间隙锁，数据库系统能够有效地防止幻读现象，确保事务的隔离性和数据的一致性。</span></div></div><div id="39cP4bDxoCPoESY8R2WKii" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL<span class="jill"></span>并不直接提供显式的语法来手动加间隙锁。相反，间隙锁是通过<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎在执行某些查询时自动管理的。</span></div></div><div id="8LXrT2qx3g98J8t6ssUfZB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="a5cAj1LJWKpGQFqxJX3y5k" class="wolai-block"><span class="wolai-serial-number">9.2.10</span><span class="inline-wrap">临建锁(Next-Key Lock)</span></h3><div id="eCdW8WJRz6Ts13JMcABCxJ" class="wolai-block wolai-text"><div><span class="inline-wrap">临建锁（Next-Key Lock）是<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎中的一种锁机制，用于解决幻读问题并确保事务的隔离性。它结合了行级锁和间隙锁的特性，提供了更强的数据一致性保证。</span></div></div><h4 id="6jhpntfuj8FpKkRqDgZ8o1" class="wolai-block"><span class="wolai-serial-number">9.2.10.1</span><span class="inline-wrap">临建锁的特性：</span></h4><ol class="wolai-block"><li id="c45JKLfLwHyAwUs3vh9Rwb"><div class="marker"></div><span class="inline-wrap"><b>锁定范围</b></span><span class="inline-wrap">：临建锁不仅锁定实际存在的记录，还锁定这些记录之间的“间隙”。这意味着即使两个事务试图插入相同的记录范围，它们也会因为临建锁而发生冲突。</span></li><li id="6zefPzHwsG2eZFEhrFXPAp"><div class="marker"></div><span class="inline-wrap"><b>防止插入和删除</b></span><span class="inline-wrap">：临建锁可以防止其他事务在锁定的范围内插入新的记录或删除现有的记录。这确保了在一个事务读取某个范围的数据后，其他事务不能在该范围内插入新的记录或删除已有的记录，从而避免了幻读现象。</span></li><li id="aCh4sYq1pAAhQAy9n5iWu7"><div class="marker"></div><span class="inline-wrap"><b>兼容性</b></span><span class="inline-wrap">：临建锁与共享锁和排他锁是兼容的，即一个事务持有的共享锁或排他锁不会阻止其他事务获取相同范围的临建锁。然而，临建锁会阻止其他事务获取相同范围的共享锁或排他锁，除非它们也持有临建锁。</span></li><li id="4FwVsAcNP5Fg3YiMxbd96s"><div class="marker"></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：临建锁通常用于可重复读（Repeatable Read）隔离级别，以防止幻读现象。在这种隔离级别下，事务在第一次读取数据时会对读取的范围加锁，包括临建锁，以确保在整个事务期间数据的一致性。</span></li></ol><h4 id="9oNuoTPj1YkWH388ij79mD" class="wolai-block"><span class="wolai-serial-number">9.2.10.2</span><span class="inline-wrap">示例：</span></h4><div id="q72bQX6gzWpgiSAFGWn13h" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个表 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">，其中包含以下记录：</span></div></div><code-block id="9X75Vyjx2bErQDmWdY3tHz" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre>id <span class="token operator">|</span> name
<span class="token comment">---|------</span>
<span class="token number">1</span>  <span class="token operator">|</span> Alice
<span class="token number">3</span>  <span class="token operator">|</span> Bob
<span class="token number">5</span>  <span class="token operator">|</span> Charlie</pre></div></code-block><ul class="wolai-block"><li id="rq8UTW5nypSkqACds3K7uy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务<span class="jill"></span>A<span class="jill"></span>执行查询 </span><span class="inline-wrap"><code>SELECT * FROM employees WHERE id &gt; 2 AND id &lt; 6 FOR UPDATE;</code></span><span class="inline-wrap">，这将对范围 (2, 6) 加上临建锁。</span></li><li id="2rZBJVpn9pnvyHeAH9MVhx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务<span class="jill"></span>B<span class="jill"></span>尝试执行插入操作 </span><span class="inline-wrap"><code>INSERT INTO employees (id, name) VALUES (4, &#39;David&#39;);</code></span><span class="inline-wrap">，由于临建锁的存在，事务<span class="jill"></span>B<span class="jill"></span>将被阻塞，直到事务<span class="jill"></span>A<span class="jill"></span>释放锁。</span></li></ul><div id="5b7CmkpD87gn3zZHPU7RmV" class="wolai-block wolai-text"><div><span class="inline-wrap">通过使用临建锁，数据库系统能够有效地防止幻读现象，确保事务的隔离性和数据的一致性。</span></div></div><div id="tFNDe1kMQeHoMV7Nkdeuay" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="rx3EnKM3VUtjWtix7LrvVr" class="wolai-block"><span class="wolai-serial-number">9.2.11</span><span class="inline-wrap">临键锁和间隙锁的区别是什么？</span></h3><div id="oZoTijhA1j2QHrjpKjxNcS" class="wolai-block wolai-text"><div><span class="inline-wrap">临键锁（Next-Key Lock）和间隙锁（Gap Lock）都是<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎中用于防止幻读现象的锁机制，但它们在锁定范围和应用场景上有一些区别。以下是对两者的详细比较：</span></div></div><h4 id="22fSyYcrtGWJbkVvA4cBM9" class="wolai-block"><span class="wolai-serial-number">9.2.11.1</span><span class="inline-wrap">1. 锁定范围</span></h4><ul class="wolai-block"><li id="biwps9HmLTUM7VAknhSRWh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临键锁（Next-Key Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="32hKCxDSaJd5mUrLv77HPV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">临键锁不仅锁定实际存在的记录，还锁定这些记录之间的“间隙”。这意味着它不仅防止其他事务插入或删除锁定范围内的记录，还防止在这些间隙内插入新的记录。</span></li><li id="cb2zXeixp2gsFSghLq5YVi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">例如，对于范围查询 </span><span class="inline-wrap"><code>WHERE id &gt; 2 AND id &lt; 6</code></span><span class="inline-wrap">，临键锁会锁定范围 (2, 6) 以及这个范围内的所有间隙。</span></li></ul></li><li id="pdjcoJSnDoFtRRFLgojhRe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="X9KjVo94wbSdMaL6qhM68"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">间隙锁只锁定记录之间的“间隙”，而不锁定实际存在的记录。这意味着它仅防止其他事务在这些间隙内插入新的记录，而不会锁定实际的记录本身。</span></li><li id="ped9q3QcYCmzFV2nBkST4G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">例如，对于范围查询 </span><span class="inline-wrap"><code>WHERE id &gt; 2 AND id &lt; 6</code></span><span class="inline-wrap">，间隙锁只会锁定范围 (2, 6) 内的间隙，而不会锁定记录 3 和 5。</span></li></ul></li></ul><h4 id="oWHfJD4RJcnuU8RhoceKGX" class="wolai-block"><span class="wolai-serial-number">9.2.11.2</span><span class="inline-wrap">2. 兼容性</span></h4><ul class="wolai-block"><li id="dXsq8HPXKSqLacwohMRCH7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临键锁（Next-Key Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="r69a4MAcEcs6fMPt5wTfJT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">与共享锁和排他锁兼容，即一个事务持有的共享锁或排他锁不会阻止其他事务获取相同范围的临键锁。然而，临键锁会阻止其他事务获取相同范围的共享锁或排他锁，除非它们也持有临键锁。</span></li></ul></li><li id="Q9Fa8RKi2LJtYS3b5QzMU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="n2Xiena2A8jX1hskuGHAAW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">与共享锁和排他锁兼容，即一个事务持有的共享锁或排他锁不会阻止其他事务获取相同范围的间隙锁。然而，间隙锁会阻止其他事务获取相同范围的共享锁或排他锁，除非它们也持有间隙锁。</span></li></ul></li></ul><h4 id="cUnXuGHJjXzi6K2kwMgdd6" class="wolai-block"><span class="wolai-serial-number">9.2.11.3</span><span class="inline-wrap">3. 应用场景</span></h4><ul class="wolai-block"><li id="6bC4zBfABaYGPePAES6tBv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临键锁（Next-Key Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="7ia83Po4ebijyyLie3dASJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通常用于可重复读（Repeatable Read）隔离级别，以防止幻读现象。在这种隔离级别下，事务在第一次读取数据时会对读取的范围加锁，包括临键锁，以确保在整个事务期间数据的一致性。</span></li></ul></li><li id="u7UCGFLQAp7qBAGm2yq2qT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="8HkxgQuxj6iNLqLYDRUTbZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通常用于可重复读（Repeatable Read）隔离级别，以防止幻读现象。在这种隔离级别下，事务在第一次读取数据时会对读取的范围加锁，包括间隙锁，以确保在整个事务期间数据的一致性。</span></li></ul></li></ul><h4 id="qwGadZAEr4HraHbaULAbU6" class="wolai-block"><span class="wolai-serial-number">9.2.11.4</span><span class="inline-wrap">4. 实现方式</span></h4><ul class="wolai-block"><li id="5c3Ct493vcZQfWgTU6v5Z3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临键锁（Next-Key Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="7EctoyHD9Uzys3KH2a4N6i"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">临键锁实际上是由多个锁组成的，包括行级锁和间隙锁的组合。因此，它可以同时提供行级锁和间隙锁的功能。</span></li></ul></li><li id="72sHBj1J2nPApand8bBhsN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="srJcxqduP54qQ5YojeT11"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">间隙锁是独立的锁类型，专门用于锁定记录之间的间隙。</span></li></ul></li></ul><h4 id="2cbDeTDkNXB7jyHaXGH5zz" class="wolai-block"><span class="wolai-serial-number">9.2.11.5</span><span class="inline-wrap">总结</span></h4><div id="24Pegf1MwpW7QVFwvicf5x" class="wolai-block wolai-text"><div><span class="inline-wrap">虽然临键锁和间隙锁都用于防止幻读现象，确保事务的隔离性和数据的一致性，但它们的锁定范围和实现方式有所不同。临键锁不仅锁定实际存在的记录，还锁定这些记录之间的间隙，而间隙锁仅锁定记录之间的间隙。在实际应用中，这两种锁机制可以结合使用，以提供更强的数据一致性保证。</span></div></div><div id="7Cpk4cgyx2ixRpTCJHKaZZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="uqocGbd28ar8dhMym2f2yU" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qkHfQzFKD3QgyXtWfHQPdj" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">MySQL<span class="jill"></span>什么是死锁？怎么解决？</span></h1><h2 id="ds44q5wL5zN9m1qBDD9Bh2" class="wolai-block"><span class="wolai-serial-number">10.1</span><span class="inline-wrap">概念</span></h2><div id="vv9EzhfwoxNHxtRrtkwrpn" class="wolai-block wolai-text"><div><span class="inline-wrap">死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</span></div></div><div id="hGiYiFax3NTfKRqvjnB2VF" class="wolai-block"><figure class="wolai-center" style="width: 374px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><h2 id="r2SW77c8XqeHqLFStQfTLw" class="wolai-block"><span class="wolai-serial-number">10.2</span><span class="inline-wrap">发生死锁现象有四个必要条件</span></h2><ul class="wolai-block"><li id="r6VJ4EcwYk8smNZJJrXNDJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">互斥条件</span></li><li id="szKBLiPLoZjb1w9eMgzrJx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">请求和保持条件</span></li><li id="gZQgB9YHfPjvbV6ZGtJPn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">环路等待条件</span></li><li id="mPhEiCY5Mtji84TXKay2Hp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不剥夺条件  </span></li></ul><div id="bCFYhWXkCrmfkHDwmFvQLw" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ksNvucV8i3ArpN7AhQjvLf" class="wolai-block"><span class="wolai-serial-number">10.3</span><span class="inline-wrap">解决思路</span></h2><div id="bzMP5Dfs7kffHyqmLX5btT" class="wolai-block wolai-text"><div><span class="inline-wrap">解决死锁思路，一般就是切断环路，尽量避免并发形成环路。如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；</span></div></div><div id="7jQ2BmfmwU9kfLGq5iWtAp" class="wolai-block wolai-text"><div><span class="inline-wrap">在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</span></div></div><div id="uHHz92cUWesnFXUod8rEHH" class="wolai-block wolai-text"><div><span class="inline-wrap">对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</span></div></div><div id="snnAuLwE9sFdRxpU4Lhfg2" class="wolai-block wolai-text"><div><span class="inline-wrap">如果业务处理不好可以用分布式事务锁或者使用乐观锁；</span></div></div><div id="sC16Ehn2ynGNu8fT5ZkTpF" class="wolai-block wolai-text"><div><span class="inline-wrap">死锁与索引密不可分，解决索引问题，需要合理优化索引。</span></div></div><div id="abXkDGsgHM67Czm3c1wMKG" class="wolai-block wolai-text"><div></div></div><div id="tPAgiRqpmBQoV9NjVAXsjA" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="8fqxSPMcY1xgN4u9KE7Uc5" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">MySQL<span class="jill"></span>的约束有哪些？</span></h1><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="gsYFVpTkzaFQYk1K1PbXk9" class="wolai-block wolai-text"><div><span class="inline-wrap">约束类型</span></div></div><span class="inline-wrap"></span><br/><div id="vqi7wzWTVTA8yAZPaS1UtM" class="wolai-block wolai-text"><div><span class="inline-wrap">NOT NULL</span></div></div><span class="inline-wrap"></span><br/><div id="mhmfFK6qUBQwXDcFiRhuXw" class="wolai-block wolai-text"><div><span class="inline-wrap">UNIQUE</span></div></div><span class="inline-wrap"></span><br/><div id="6WE2e5eD8jyV3zK4GsCoLm" class="wolai-block wolai-text"><div><span class="inline-wrap">PRIMARY KEY</span></div></div><span class="inline-wrap"></span><br/><div id="v3sEn4ZRq8myoGgzS5MV8" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="xtRyuWpzPkUwDDeK9wtRvC" class="wolai-block wolai-text"><div><span class="inline-wrap">约束字段的内容一定不能为<span class="jill"></span>NULL</span></div></div><span class="inline-wrap"></span><br/><div id="bA9fPEEPRgwaD5VAV7xsYQ" class="wolai-block wolai-text"><div><span class="inline-wrap">约束字段唯一性，一个表允许有多个<span class="jill"></span>Unique<span class="jill"></span>约束</span></div></div><span class="inline-wrap"></span><br/><div id="bRtGsbwPTiaFHQZPDuUodj" class="wolai-block wolai-text"><div><span class="inline-wrap">约束字段唯一，不可重复，一个表只允许存在一个</span></div></div><span class="inline-wrap"></span><br/><div id="h2UqStCZS91hCn4iw6w8rJ" class="wolai-block wolai-text"><div><span class="inline-wrap">FOREIGN KEY</span></div></div><span class="inline-wrap"></span><br/><div id="svi24EKsmqFge5ipFwY7Lw" class="wolai-block wolai-text"><div><span class="inline-wrap">用于预防破坏表之间连接的动作，也能防止非法数据插入外键。
用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</span></div></div><span class="inline-wrap"></span><br/><div id="jYqwksz1J4dnBqFKuRKyjv" class="wolai-block wolai-text"><div><span class="inline-wrap">CHECK</span></div></div><span class="inline-wrap"></span><br/><div id="jrfj6Dp4Y58cPh3PW5JHX3" class="wolai-block wolai-text"><div><span class="inline-wrap">用于控制字段的值范围。保证字段值满足某一个条件</span></div></div><span class="inline-wrap"></span><br/><div id="hZSbAQbKL7d5p3nCi2asCZ" class="wolai-block wolai-text"><div><span class="inline-wrap">DEFAULT</span></div></div><span class="inline-wrap"></span><br/><div id="vD96Vob8ctHNtSvr3ZNayu" class="wolai-block wolai-text"><div><span class="inline-wrap">保存数据时，如果未指定该字段的值，则采用默认值</span></div></div><div id="nGFzvDkCFavSf8Dj1k5nK7" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="q1TcBq7ZPXvC5FGf8tbfcw" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">关心过业务系统里面的<span class="jill"></span>SQL<span class="jill"></span>耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span></h1><div id="oewoeaHnCc1qhzMAQhgSzS" class="wolai-block wolai-text"><div><span class="inline-wrap">在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。  </span></div></div><div id="vNRGmCgHS5HfeNxnUqdghP" class="wolai-block wolai-text"><div><span class="inline-wrap">慢查询的优化首先要搞明白慢的原因是什么？  </span></div></div><div id="3WibJGJd6LWRjR6ipzKrMg" class="wolai-block wolai-text"><div><span class="inline-wrap">1、是查询条件没有命中索引？</span></div></div><div id="5o6mR6TEHcWahfSyrRuFvQ" class="wolai-block wolai-text"><div><span class="inline-wrap">2、是<span class="jill"></span>load<span class="jill"></span>了不需要的数据列？</span></div></div><div id="sWHRgpugyUGhfyVAPrnAdZ" class="wolai-block wolai-text"><div><span class="inline-wrap">3、还是数据量太大？</span></div></div><div id="6YKVWpUBiqZEHTNPayXXQs" class="wolai-block wolai-text"><div><span class="inline-wrap">所以优化也是针对这三个方向来的：</span></div></div><div id="kmn8nY7nuDc2qXJND1jbZ" class="wolai-block wolai-text"><div><span class="inline-wrap">1、首先分析语句，看看是否<span class="jill"></span>load<span class="jill"></span>了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</span></div></div><div id="tTDZFiAhYo6aKL9TwcNMYk" class="wolai-block wolai-text"><div><span class="inline-wrap">2、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</span></div></div><div id="xn4vpHW4etkMsJfqhizpWz" class="wolai-block wolai-text"><div><span class="inline-wrap">3、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</span></div></div><div id="5vAAchbeJHTthhgwb2eXPU" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nucXGgk7mHoDcaLPMiFS7J" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">MySQL<span class="jill"></span>事务的基本特性和隔离级别</span></h1><div id="ihg39ZLHTCeKKL4WPYs4Lx" class="wolai-block wolai-text"><div><span class="inline-wrap">事务基本特性<span class="jill"></span>ACID<span class="jill"></span>分别是：</span></div></div><ul class="wolai-block"><li id="7ATq9HJ6i6eSTMZVmrSs89"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原子性：指的是一个事务中的操作要么全部成功，要么全部失败。  </span></li><li id="nrFXMVJ9t1M3zm4F9KcfrB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一致性：指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如<span class="jill"></span>A<span class="jill"></span>转账给<span class="jill"></span>B100<span class="jill"></span>块钱，假设<span class="jill"></span>A<span class="jill"></span>只有<span class="jill"></span>90<span class="jill"></span>块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证。</span></li><li id="k2jrMjgTABpKV4jR4RU2Br"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">隔离性:指的是一个事务的修改在最终提交前，对其他事务是不可见的。</span></li><li id="qiP5Dzc3cE1xHjWpm5FfKr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">持久性：指的是一旦事务提交，所做的修改就会永久保存到数据库中。</span></li></ul><div id="vbfLeMYcdxFqJsv5d5X9yj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="62HtQWXvPAQy9UDnE8sBmy" class="wolai-block wolai-text"><div><span class="inline-wrap">并发问题有三种情况：</span></div></div><ul class="wolai-block"><li id="3tz1guYPPXrMd6ag2jJz7q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>脏读(Drity Read)</b></span><span class="inline-wrap">：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个<span class="jill"></span>RollBack<span class="jill"></span>了操作，则后一个事务所读取的数据就会是不正确的。</span></li><li id="hsB2hB5cq59v1iJZg9u2mW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>不可重复读(Non-repeatable read)：</b></span><span class="inline-wrap">在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</span></li><li id="787DkwT2k9S9M6sVQvYL9h"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>幻读(Phantom Read)：</b></span><span class="inline-wrap">在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</span></li></ul><div id="o25arHgikJ7aMANfFCy5KS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="t6pb9b3pTUt1SPLSajsqht" class="wolai-block wolai-text"><div><span class="inline-wrap">隔离性有<span class="jill"></span>4<span class="jill"></span>个隔离级别，分别是：</span></div></div><ul class="wolai-block"><li id="ahxtqTwQqVtRaJCGHE6oX9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>read uncommit</b></span><span class="inline-wrap">读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</span></li></ul><div id="h9vrXcHFjuYQziVZKsoU2V" class="wolai-block wolai-text"><div><span class="inline-wrap">用户本来应该读取到<span class="jill"></span>id=1<span class="jill"></span>的用户<span class="jill"></span>age<span class="jill"></span>应该是<span class="jill"></span>10，结果读取到了其他事务还没有提交的事务，结果读取结果<span class="jill"></span>age=20，这就是脏读。</span></div></div><ul class="wolai-block"><li id="hrDCg1Xy52RbktrSktY3s7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>read commit</b></span><span class="inline-wrap">读已提交，两次读取结果不一致，叫做不可重复读。</span></li></ul><div id="4gq8Nfuhdm37JhX2EPVdyY" class="wolai-block wolai-text"><div><span class="inline-wrap">不可重复读解决了脏读的问题，他只会读取已经提交的事务。</span></div></div><div id="hShWxZqRzVtJpWSiH3cRJM" class="wolai-block wolai-text"><div><span class="inline-wrap">用户开启事务读取<span class="jill"></span>id=1<span class="jill"></span>用户，查询到<span class="jill"></span>age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。  </span></div></div><ul class="wolai-block"><li id="nuv2CdT5Va9ggjKKGq4Jog"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>repeatable read</b></span><span class="inline-wrap">可重复复读，这是<span class="jill"></span>mysql<span class="jill"></span>的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</span></li><li id="f5fah7kT2sNrGopw6h9kKm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>serializable</b></span><span class="inline-wrap">串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</span></li></ul><div id="SaNp4NFM2wREp8zri5sQj" class="wolai-block wolai-text"><div></div></div><div id="C7UcN5ysMjMMHTHbXzLgb" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6ohNARvh5QFsAXqWV8ghVj" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">MySQL<span class="jill"></span>中<span class="jill"></span>ACID<span class="jill"></span>靠什么保证的？</span></h1><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="vPRNwhmPm1wyhqSpDLXGdw" class="wolai-block wolai-text"><div><span class="inline-wrap">缩写</span></div></div><span class="inline-wrap"></span><br/><div id="gCa7ZUukacgYPX2DNguzRg" class="wolai-block wolai-text"><div><span class="inline-wrap">A</span></div></div><span class="inline-wrap"></span><br/><div id="jm7imueG54GkcZmDRpqFho" class="wolai-block wolai-text"><div><span class="inline-wrap">C</span></div></div><span class="inline-wrap"></span><br/><div id="rgeTBc7VeZ6AHT6YkBsoaY" class="wolai-block wolai-text"><div><span class="inline-wrap">I</span></div></div><span class="inline-wrap"></span><br/><div id="oVSrjtRUATR1d698KZaqd6" class="wolai-block wolai-text"><div><span class="inline-wrap">属性名</span></div></div><span class="inline-wrap"></span><br/><div id="r1HYXHcnM4HY4oiEayTFNv" class="wolai-block wolai-text"><div><span class="inline-wrap">原子性</span></div></div><span class="inline-wrap"></span><br/><div id="wrkioZ8mWkCmASrR4ko57Q" class="wolai-block wolai-text"><div><span class="inline-wrap">一致性</span></div></div><span class="inline-wrap"></span><br/><div id="8KsRaR9NSwYG5vQbxYBwHk" class="wolai-block wolai-text"><div><span class="inline-wrap">隔离性</span></div></div><span class="inline-wrap"></span><br/><div id="61Sg4iV58ztfKxgmRsdD33" class="wolai-block wolai-text"><div><span class="inline-wrap">保证机制</span></div></div><span class="inline-wrap"></span><br/><div id="eraey3wWHF6ZWytDDrjYQV" class="wolai-block wolai-text"><div><span class="inline-wrap">由<span class="jill"></span>undo log<span class="jill"></span>日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的<span class="jill"></span>SQL</span></div></div><span class="inline-wrap"></span><br/><div id="vKfW2oV1UzCcfeYE4iRgH2" class="wolai-block wolai-text"><div><span class="inline-wrap">由其他三大特性保证、程序代码要保证业务上的一致性</span></div></div><span class="inline-wrap"></span><br/><div id="rK7zGsKN2SCJLhBtD4zdSD" class="wolai-block wolai-text"><div><span class="inline-wrap">由<span class="jill"></span>MVCC<span class="jill"></span>来保证</span></div></div><span class="inline-wrap"></span><br/><div id="w1uQckBeV3AGTdPNguJmrz" class="wolai-block wolai-text"><div><span class="inline-wrap">D</span></div></div><span class="inline-wrap"></span><br/><div id="3nvw9V5mszN35z1ePefnMP" class="wolai-block wolai-text"><div><span class="inline-wrap">持久性</span></div></div><span class="inline-wrap"></span><br/><div id="irEvDhsJbDCVBdfcQHR7tC" class="wolai-block wolai-text"><div><span class="inline-wrap">由内存和<span class="jill"></span>redo log<span class="jill"></span>来保证，MySQL<span class="jill"></span>修改数据同时在内存和<span class="jill"></span>redo log<span class="jill"></span>记录这次操作。
宕机的时候可以从<span class="jill"></span>redo log<span class="jill"></span>恢复。
redolog<span class="jill"></span>的刷盘操作会在系统空闲时进行</span></div></div><div id="85CbwoNUPfcGMcWBT59cMu" class="wolai-block wolai-text"><div></div></div><div id="ntAQmkTnThFa8tdfQAuJPx" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3iwmZpp2n8edewHJKTp8v8" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">MySQL<span class="jill"></span>中的<span class="jill"></span>MVCC<span class="jill"></span>是什么？</span></h1><div id="s3kAn2t7nnYt4ky4znXjJD" class="wolai-block wolai-text"><div><span class="inline-wrap">多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务会看到自己特定版本的数据，版本链。</span></div></div><div id="7J2JgKUAAYD2a5Loni44Ke" class="wolai-block wolai-text"><div><span class="inline-wrap">MVCC<span class="jill"></span>只在<span class="jill"></span>READ COMMITTED<span class="jill"></span>和<span class="jill"></span>REPEATABLE READ<span class="jill"></span>两个隔离级别下工作。其他两个隔离级别和<span class="jill"></span>MVCC<span class="jill"></span>不兼容。</span></div></div><div id="i3Uppbq4zudDMmRnJ4fgc" class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>READ UNCOMMITTED<span class="jill"></span>总是读取最新的数据行，而不是符合当前事务版本的数据行。而<span class="jill"></span>SERIALIZABLE 则会对所有读取的行都加锁。</span></div></div><div id="mvNzN9pTtsJatZEM17UyXE" class="wolai-block wolai-text"><div><span class="inline-wrap">聚簇索引记录中有两个必要的隐藏列：</span></div></div><div id="biksrGrJ35taWp4Qpwhqtb" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务<span class="jill"></span>id。</span></div></div><div id="rzx29cC3jd1yiQanQyDMTk" class="wolai-block wolai-text"><div><span class="inline-wrap">roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入<span class="jill"></span>undo<span class="jill"></span>日志中。</span></div></div><div id="otkMst9HGCp4KYfyJZpNb6" class="wolai-block wolai-text"><div><span class="inline-wrap">这个<span class="jill"></span>roll_pointer<span class="jill"></span>就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。</span></div></div><div id="uYQCkxHpaguev4FntJNs8" class="wolai-block wolai-text"><div><span class="inline-wrap">（注意插入操作的<span class="jill"></span>undo<span class="jill"></span>日志没有这个属性，因为它没有老版本）</span></div></div><div id="e7oihB7Br8AoAxzG9ty5VU" class="wolai-block wolai-text"><div><span class="inline-wrap">已提交读和可重复读的区别就在于它们生成<span class="jill"></span>ReadView<span class="jill"></span>的策略不同。</span></div></div><div id="6uAAdSuSJhCZx3UMVUKkMw" class="wolai-block"><figure class="wolai-center" style="width: 385.3333333333333px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="3v5FwjFUQXv4DQrq22kRP8" class="wolai-block wolai-text"><div><span class="inline-wrap">开始事务时创建<span class="jill"></span>ReadView，ReadView<span class="jill"></span>维护当前活动的事务<span class="jill"></span>id，即未提交的事务<span class="jill"></span>id，排序生成一个数组。</span></div></div><div id="fQrCvdz3jLRBpPXXa9Q7dg" class="wolai-block wolai-text"><div><span class="inline-wrap">访问数据，获取数据中的事务<span class="jill"></span>id，对比<span class="jill"></span>ReadView：  </span></div></div><div id="7fco6WRBELhZKdAvfgtw43" class="wolai-block wolai-text"><div><span class="inline-wrap">如果在<span class="jill"></span>ReadView<span class="jill"></span>的左边（比<span class="jill"></span>ReadView<span class="jill"></span>都小），可以访问（在左边意味着该事务已经提交）  </span></div></div><div id="cKFv4bd8mMgcBTg119JT9C" class="wolai-block wolai-text"><div><span class="inline-wrap">如果在<span class="jill"></span>ReadView<span class="jill"></span>的右边（比<span class="jill"></span>ReadView<span class="jill"></span>都大）或者就在<span class="jill"></span>ReadView<span class="jill"></span>中，不可以访问，获取<span class="jill"></span>roll_pointer，取上一版本重新对比（在右边意味着，该事务在<span class="jill"></span>ReadView<span class="jill"></span>生成之后出现，在<span class="jill"></span>ReadView<span class="jill"></span>中意味着该事务还未提交）</span></div></div><div id="a9t4Foqs4Z7ENM41Bvr2mo" class="wolai-block wolai-text"><div><span class="inline-wrap">已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的<span class="jill"></span>ReadView,而可重复读隔离级别则在第一次读的时候生成一个<span class="jill"></span>ReadView，之后的读都复用之前的<span class="jill"></span>ReadView。  </span></div></div><div id="trpPC12xFLjHSeCxchjW8T" class="wolai-block wolai-text"><div><span class="inline-wrap">这就是<span class="jill"></span>Mysql<span class="jill"></span>的<span class="jill"></span>MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过<span class="jill"></span>ReadView<span class="jill"></span>生成策略的不同实现不同的隔离级别</span></div></div><div id="uAoZ5pYBdV2AjqiaEMJT34" class="wolai-block wolai-text"><div></div></div><div id="vwRyCmNQyhkALhS3yi9h1i" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hhQBMEKHaRsC6mDszrMmF" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">数据库表主键生成方式使用自增<span class="jill"></span>int<span class="jill"></span>类型还是<span class="jill"></span>UUID？</span></h1><div id="7dkVsDsLjayGS2c4s7bWRG" class="wolai-block wolai-text"><div><span class="inline-wrap">在数据库设计中，选择主键生成方式是一个需要仔细考虑的问题。自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型和 </span><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap">（通用唯一标识符）各有优缺点，具体选择取决于应用场景、性能需求和系统架构等因素。以下是对这两种主键生成方式的详细比较：</span></div></div><h2 id="g9pg8iiKn4c7LeGZoWbRuB" class="wolai-block"><span class="wolai-serial-number">16.1</span><span class="inline-wrap">自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型</span></h2><h3 id="oVAadiDe3REe5t6VVbjumf" class="wolai-block"><span class="wolai-serial-number">16.1.1</span><span class="inline-wrap">优点：</span></h3><ol class="wolai-block"><li id="vQNZp28qm6gZsR6tsqPwtb"><div class="marker"></div><span class="inline-wrap"><b>性能高</b></span><span class="inline-wrap">：自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的主键生成速度非常快，因为它只是简单地递增一个整数。这在插入操作频繁的场景下表现尤为出色。</span></li><li id="ijBkcXXEuEoHnDMNURSyfJ"><div class="marker"></div><span class="inline-wrap"><b>存储空间小</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型通常占用<span class="jill"></span>4<span class="jill"></span>个字节，而 </span><span class="inline-wrap"><code>UUID</code></span><span class="inline-wrap"> 通常占用<span class="jill"></span>16<span class="jill"></span>个字节，因此使用 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 可以节省存储空间。</span></li><li id="fSYTqGZp9PAxM7thqShaE5"><div class="marker"></div><span class="inline-wrap"><b>索引效率高</b></span><span class="inline-wrap">：由于 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 是固定长度且有序的，数据库引擎可以更高效地创建和维护索引。</span></li></ol><h3 id="c7DQnWCdEfAqn7jXHyMC7q" class="wolai-block"><span class="wolai-serial-number">16.1.2</span><span class="inline-wrap">缺点：</span></h3><ol class="wolai-block"><li id="4jRMdMureNE14vxZtrYc2p"><div class="marker"></div><span class="inline-wrap"><b>分布式系统中不友好</b></span><span class="inline-wrap">：在分布式系统中，如果多个节点同时生成自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的主键，可能会导致冲突。虽然可以通过一些策略（如设置不同的起始值和步长）来避免冲突，但实现起来较为复杂。</span></li><li id="82TsFmKeBbT47qM33dyQYM"><div class="marker"></div><span class="inline-wrap"><b>安全性问题</b></span><span class="inline-wrap">：自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的主键容易被猜测，可能会带来安全隐患。例如，攻击者可以通过遍历主键来获取数据。</span></li></ol><h2 id="uVyct19DKHv4MnBboV7jsN" class="wolai-block"><span class="wolai-serial-number">16.2</span><span class="inline-wrap">UUID</span></h2><h3 id="8kyhwM3Z6tMPAgVMQM6eBp" class="wolai-block"><span class="wolai-serial-number">16.2.1</span><span class="inline-wrap">优点：</span></h3><ol class="wolai-block"><li id="5hqWQgxVdn3Cyf1kPQ6UHC"><div class="marker"></div><span class="inline-wrap"><b>全局唯一性</b></span><span class="inline-wrap">：UUID 是基于时间和随机数生成的，几乎可以保证全球范围内的唯一性，非常适合分布式系统。</span></li><li id="6HDMiw1qQUXJom37xtuT3w"><div class="marker"></div><span class="inline-wrap"><b>安全性高</b></span><span class="inline-wrap">：由于 UUID 是随机生成的，不容易被猜测，从而提高了数据的安全性。</span></li><li id="wvW2ckjn5rAWWTi55r7Y3H"><div class="marker"></div><span class="inline-wrap"><b>无中心化管理</b></span><span class="inline-wrap">：不需要集中式的主键生成服务，每个节点都可以独立生成 UUID，减少了单点故障的风险。</span></li></ol><h3 id="2AyvKfdSJbSrjjK6S3D2mN" class="wolai-block"><span class="wolai-serial-number">16.2.2</span><span class="inline-wrap">缺点：</span></h3><ol class="wolai-block"><li id="g8jYStKWMXzY9C9oRfaPyM"><div class="marker"></div><span class="inline-wrap"><b>性能较低</b></span><span class="inline-wrap">：生成 UUID 的速度比自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 慢，特别是在高并发场景下，性能开销较大。</span></li><li id="cw9BCNg3R8jFUERcUXdfX5"><div class="marker"></div><span class="inline-wrap"><b>存储空间大</b></span><span class="inline-wrap">：UUID 通常占用<span class="jill"></span>16<span class="jill"></span>个字节，比 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的<span class="jill"></span>4<span class="jill"></span>个字节要大得多，增加了存储成本。</span></li><li id="khosSWV78CmNLZushxE2NT"><div class="marker"></div><span class="inline-wrap"><b>索引效率低</b></span><span class="inline-wrap">：由于 UUID 是无序的，数据库引擎在创建和维护索引时效率较低。</span></li></ol><h2 id="cx47H3FJyjnKTsC1LfduBC" class="wolai-block"><span class="wolai-serial-number">16.3</span><span class="inline-wrap">综合考虑</span></h2><ul class="wolai-block"><li id="pSCNbyTyKTgvrmjKcr7nuk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>单节点应用或非分布式环境</b></span><span class="inline-wrap">：如果系统是单节点应用或者不需要分布式支持，自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型通常是更好的选择，因为它性能高且存储空间小。</span></li><li id="cje7TALUcKq5Sacduabo7n"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：如果系统需要在多个节点之间进行数据同步或扩展，并且需要确保主键的唯一性和安全性，那么 UUID 是更好的选择。</span></li><li id="4oK585a3LMV4JHFbsqoRE4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>安全性要求高</b></span><span class="inline-wrap">：如果系统对数据安全性有较高要求，不希望主键被轻易猜测，那么 UUID 是更安全的选择。</span></li></ul><h2 id="iCfbTFNMZ89WRXT5rp3rvP" class="wolai-block"><span class="wolai-serial-number">16.4</span><span class="inline-wrap">实际案例</span></h2><ul class="wolai-block"><li id="tKLhN9wKJAzRru4noPT8Hk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>MySQL</b></span><span class="inline-wrap">：在 MySQL 中，可以使用 </span><span class="inline-wrap"><code>AUTO_INCREMENT</code></span><span class="inline-wrap"> 属性来实现自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的主键。</span></li><li id="pmPG9AYTizhp2RryaVYFgt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>PostgreSQL</b></span><span class="inline-wrap">：在 PostgreSQL 中，可以使用 </span><span class="inline-wrap"><code>SERIAL</code></span><span class="inline-wrap"> 类型来实现自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型的主键。</span></li><li id="6YydRPL6QjZNjGsS7jW39V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>UUID</b></span><span class="inline-wrap">：在大多数数据库中，都提供了生成 UUID 的函数。例如，在 PostgreSQL 中可以使用 </span><span class="inline-wrap"><code>uuid_generate_v4()</code></span><span class="inline-wrap"> 函数生成 UUID。</span></li></ul><div id="jatro4RxCVkrx8ahJS2GFN" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，选择主键生成方式需要根据具体的业务需求和系统架构来决定。对于大多数单节点应用来说，自增 </span><span class="inline-wrap"><code>int</code></span><span class="inline-wrap"> 类型是一个不错的选择；而对于需要分布式支持和高安全性的系统，UUID 则更为合适。</span></div></div><div id="nbeGU3AqhSUezZJWFiqGNK" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="81cpEj89dmsNz9qts68Adb" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap"><b>MySQL<span class="jill"></span>数据库</b></span><span class="inline-wrap">CPU<span class="jill"></span>飙升的话，要怎么处理呢？</span></h1><h2 id="KyNUrjr7Saxm6VDWue6kE" class="wolai-block"><span class="wolai-serial-number">17.1</span><span class="inline-wrap">排查过程</span></h2><div id="tj6ekcLzsqWo2NUjATScUC" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>top<span class="jill"></span>命令观察，确定是<span class="jill"></span>mysqld<span class="jill"></span>导致还是其他原因。  </span></div></div><div id="dzJw376q78AKct5g8p9T1y" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是<span class="jill"></span>mysqld<span class="jill"></span>导致的，show processlist，查看<span class="jill"></span>session<span class="jill"></span>情况，确定是不是有消耗资源的<span class="jill"></span>SQL<span class="jill"></span>在运行。  </span></div></div><div id="mP3bc11VwhGnfEJBpjc4Hi" class="wolai-block wolai-text"><div><span class="inline-wrap">找出消耗高的<span class="jill"></span>SQL，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</span></div></div><div id="ugfS6NJAkJqTHVJ5R8iktj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="x5vJmKFpqRMJSyGqphSwXh" class="wolai-block"><span class="wolai-serial-number">17.2</span><span class="inline-wrap">处理</span></h2><div id="i7PK1Jf6SaUQRwSLAa3xUL" class="wolai-block wolai-text"><div><span class="inline-wrap">kill<span class="jill"></span>掉这些线程，同时观察<span class="jill"></span>CPU<span class="jill"></span>使用率是否下降，进行相应的调整，比如说加索引、SQL<span class="jill"></span>调优、改内存参数，然后重新跑<span class="jill"></span>SQL。</span></div></div><div id="byU5UdEX1DRPxvWKyh3yeq" class="wolai-block wolai-text"><div><span class="inline-wrap">  </span><br/></div></div><h2 id="dbEabHPviJiqRRGwZWqU5K" class="wolai-block"><span class="wolai-serial-number">17.3</span><span class="inline-wrap">其他情况</span></h2><div id="cvs7jtqbekVmPeVSoBXtDs" class="wolai-block wolai-text"><div><span class="inline-wrap">也有可能是每个<span class="jill"></span>SQL<span class="jill"></span>消耗资源并不多，但是突然之间，有大量的<span class="jill"></span>session<span class="jill"></span>连进来导致<span class="jill"></span>CPU<span class="jill"></span>飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数或添加<span class="jill"></span>Redis<span class="jill"></span>缓存等。</span></div></div><div id="gmV1QhkemPHHAHspj73XeW" class="wolai-block wolai-text"><div></div></div><div id="h7YwXqSRwpYzQhYptC6a4Q" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="QBx6mssnTAqqW54DXA9rd" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">了解什么是表分区吗？表分区的好处有哪些？</span></h1><h2 id="8p5ewYsb453edTBPF4miVi" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">概念</span></h2><div id="k9pzuZcGa9jXgW56gxipQ6" class="wolai-block wolai-text"><div><span class="inline-wrap">表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的容易管理的部分。</span></div></div><div id="cbzHDfCPLdss8WSKirdMTz" class="wolai-block wolai-text"><div><span class="inline-wrap">从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</span></div></div><div id="hm3863bYrYZ2vSfLEYPVy3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="vPgkPcBKMnmUxEpQSt2p8F" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">好处</span></h2><h3 id="aJ6ij5vkt3PGPxQGVZhHQV" class="wolai-block"><span class="wolai-serial-number">18.2.1</span><span class="inline-wrap">存储更多数据</span></h3><div id="g4NjYBjpLVyjJDbYhVAT3g" class="wolai-block wolai-text"><div><span class="inline-wrap">分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据。</span></div></div><div id="nmxmZsmSdScZCMLTUvaLbj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="krHEcdwmxfpWn1VYRwFxzY" class="wolai-block"><span class="wolai-serial-number">18.2.2</span><span class="inline-wrap">优化查询</span></h3><div id="mpUPATyiknxLvcJGFVnki8" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>where<span class="jill"></span>语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及<span class="jill"></span>sum<span class="jill"></span>和<span class="jill"></span>count<span class="jill"></span>语句时，也可以在多个分区上并行处理，最后汇总结果。  </span></div></div><div id="bqz7BL9qBuE7n5GYrbCt94" class="wolai-block wolai-text"><div><span class="inline-wrap">分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。避免某些特殊的瓶颈，例如<span class="jill"></span>InnoDB<span class="jill"></span>的单个索引的互斥访问。</span></div></div><div id="ucsamUVhBCTjAgV5bMJ35C" class="wolai-block wolai-text"><div></div></div><div id="6nNTk5gQy3T4Eedp2uNoUb" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="719WgG39H7rYPXdKbnQp9V" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="bF9iFs3cg7KVQZ4L1TdkyV" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">说说<span class="jill"></span>MySQL<span class="jill"></span>主从同步原理</span></h1><h2 id="iExFHJWMg4dajPkxSkRYL9" class="wolai-block"><span class="wolai-serial-number">19.1</span><span class="inline-wrap">MySQL<span class="jill"></span>主从同步的过程</span></h2><div id="9PL7sXHhuTW7KsxKxWjgrn" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL<span class="jill"></span>的主从复制中主要有三个线程： master（binlog dump thread）、slave（I/O thread 、SQLthread），Master<span class="jill"></span>一条线程和<span class="jill"></span>Slave<span class="jill"></span>中的两条线程。  </span></div></div><div id="wd3W2cjJj57DfbjgPr4WwS" class="wolai-block wolai-text"><div><span class="inline-wrap">主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。</span></div></div><div id="fmQ19a18WxoXbpDKAuKuPL" class="wolai-block wolai-text"><div><span class="inline-wrap">binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</span></div></div><div id="jdVhyZeHKbPKZiqX2dnpeV" class="wolai-block wolai-text"><div><span class="inline-wrap">主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。</span></div></div><div id="q1zZYgUUJx9tuChj8djEdk" class="wolai-block wolai-text"><div><span class="inline-wrap">从节点 I/O<span class="jill"></span>线程接收 binlog 内容，并将其写入到 relay log 文件中。</span></div></div><div id="3mYzQdaaoYfCkheu68bGf1" class="wolai-block wolai-text"><div><span class="inline-wrap">从节点的<span class="jill"></span>SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</span></div></div><div id="omekPWSisb81ZVCRf9iMpc" class="wolai-block wolai-text"><div><span class="inline-wrap">注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。由于<span class="jill"></span>MySQL<span class="jill"></span>默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念：全同步复制和半同步复制。</span></div></div><div id="bP1YNQ9use3tfjnavgfLtD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="gAsMGeqKoV52AJxvCx5JSB" class="wolai-block"><span class="wolai-serial-number">19.2</span><span class="inline-wrap">全同步复制</span></h2><div id="scTNUgAbecgACxWGGXxFpN" class="wolai-block wolai-text"><div><span class="inline-wrap">主库写入<span class="jill"></span>binlog<span class="jill"></span>后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，所以该方式数据一致性好，性能差。  </span></div></div><div id="2vPkuaDs9HZrnGq1c7KGS7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ckQFi22dmuay9ELeV5yoLz" class="wolai-block"><span class="wolai-serial-number">19.3</span><span class="inline-wrap">半同步复制</span></h2><div id="9cyMULMAH1kE3z6ZnMtrfz" class="wolai-block wolai-text"><div><span class="inline-wrap">和全同步不同的是，半同步复制把从库写入日志成功后返回<span class="jill"></span>ACK<span class="jill"></span>确认给主库，主库收到至少一个从库的确认就认为写操作完成。</span></div></div><div id="hymx3Fi5s4ZKLKzW5GNR6p" class="wolai-block wolai-text"><div><span class="inline-wrap">所以该方式性能好，数据一致性差。</span></div></div><div id="txctDz5aAZ3Ky5Q6aQo8X4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="577zJkwa2rXix3dWmgbnfX" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qgxRecAY5TKfGf42UozSVm" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">简述<span class="jill"></span>MyISAM<span class="jill"></span>和<span class="jill"></span>InnoDB<span class="jill"></span>的区别</span></h1><h2 id="6NCdKqjr9DUygt7NiQo5TW" class="wolai-block"><span class="wolai-serial-number">20.1</span><span class="inline-wrap">MyISAM</span></h2><div id="aJaW45FSKcJ4cnML44dwx4" class="wolai-block wolai-text"><div><span class="inline-wrap">1、不支持事务；</span></div></div><div id="hdJEbLNurDwxTH3s9TaouB" class="wolai-block wolai-text"><div><span class="inline-wrap">2、支持表级锁，即每次操作是对整个表加锁；</span></div></div><div id="eerj4ndengLDxuXFsz77VW" class="wolai-block wolai-text"><div><span class="inline-wrap">3、存储表的总行数；</span></div></div><div id="tHXsqcjXwYpTyEYWM5xC9L" class="wolai-block wolai-text"><div><span class="inline-wrap">4、一个<span class="jill"></span>MYISAM<span class="jill"></span>表有三个文件：索引文件、表结构文件、数据文件；</span></div></div><div id="iif6PetMhWQrZmyKSSW1Mo" class="wolai-block wolai-text"><div><span class="inline-wrap">5、采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</span></div></div><div id="qnkqBo6N8aAd3YkvtchmZL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="n41WAAVi1dZuC9qTgvuubV" class="wolai-block"><span class="wolai-serial-number">20.2</span><span class="inline-wrap">InnoDB</span></h2><div id="9sLYGM4R1mfXvXBfpMfMhS" class="wolai-block wolai-text"><div><span class="inline-wrap">1、支持<span class="jill"></span>ACID<span class="jill"></span>的事务，支持事务的四种隔离级别；</span></div></div><div id="ffo3TSv6Q4ZifXRtYd76TW" class="wolai-block wolai-text"><div><span class="inline-wrap">2、支持行级锁及外键约束：因此可以支持写并发；</span></div></div><div id="pBa9Rtam7DjbKcG9RsuaB1" class="wolai-block wolai-text"><div><span class="inline-wrap">3、不存储总行数；</span></div></div><div id="2HCh7mMbcYBjTjQn2Yajez" class="wolai-block wolai-text"><div><span class="inline-wrap">4、一个<span class="jill"></span>InnoDB<span class="jill"></span>引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为<span class="jill"></span>2G），受操作系统文件大小的限制；</span></div></div><div id="fMLRsLo5ZEXbFgoU9h41XB" class="wolai-block wolai-text"><div><span class="inline-wrap">5、主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引树；索引最好使用自增主键，防止插入数据时，为维持<span class="jill"></span>B+<span class="jill"></span>树结构，文件的大调整。</span></div></div><div id="hXEWwVk7JKBNW31cQmDuaQ" class="wolai-block wolai-text"><div></div></div><div id="kcVcjYTk1sWJHMkspygJUh" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="opY8V4BU1Fth2sBxGKnvRe" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">简述<span class="jill"></span>MySQL<span class="jill"></span>中索引类型及对数据库的性能的影响</span></h1><div id="aFYJ8NZZ4sR7uJ9NP789vU" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>普通索引</b></span><span class="inline-wrap">：允许被索引的数据列包含重复的值。</span></div></div><div id="vX41QRZVAxanT3cx1xagKG" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>唯一索引</b></span><span class="inline-wrap">：可以保证数据记录的唯一性。</span></div></div><div id="9Sjjh2B2aeodD5QxQ62h4j" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>主键索引</b></span><span class="inline-wrap">：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</span></div></div><div id="2w4tMkoaw7TMEPyQ3E4CrB" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>联合索引</b></span><span class="inline-wrap">：索引可以覆盖多个数据列，如像<span class="jill"></span>INDEX(columnA, columnB)索引。</span></div></div><div id="eb7vTZ6ogxpid9GmHEkbgY" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>全文索引</b></span><span class="inline-wrap">：通过建立 倒排索引 ,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过<span class="jill"></span>ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引索引可以极大的提高数据的查询速度。</span></div></div><div id="mNKMbiL8NuRD4TUGqJJ4Vz" class="wolai-block wolai-text"><div><span class="inline-wrap">通过使用索引，可以在查询的过程中，使用优化器，提高系统的性能。但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</span></div></div><div id="b9Tvf8bY1RAZge1etQQCbp" class="wolai-block wolai-text"><div></div></div><div id="eDvrrEHZ35nr7MDUCp94kd" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pTaayPyxqNUbVmMkrmsnrC" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">MySQL<span class="jill"></span>执行计划怎么看</span></h1><div id="fB4RPhstrtSsmubJUFdHLz" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL<span class="jill"></span>中<span class="jill"></span>SQL<span class="jill"></span>语句的执行计划可以通过<span class="jill"></span>explain<span class="jill"></span>关键词查看，其中包括查询执行的步骤、索引使用的情况等信息。</span></div></div><code-block id="645zQF1xRjb4hXS5ER9XrN" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">where</span> X<span class="token operator">=</span>? <span class="token operator">and</span> Y<span class="token operator">=</span>?</pre></div></code-block><div id="x2MSxLfDYrMqh2JorTgma7" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 213.99998474121094px"><span class="inline-wrap">列名</span></th><th style="width: 100px"><span class="inline-wrap">重要</span></th><th style="width: 646px"><span class="inline-wrap">描述</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><code>id</code></span></td><td><span class="inline-wrap">○</span></td><td><span class="inline-wrap">用来告诉我们整个<span class="jill"></span>SQL<span class="jill"></span>语句在执行过程中，有哪些大的步骤和小的步骤。</span></td></tr><tr><td><span class="inline-wrap"><code>select_type</code></span></td><td><span class="inline-wrap">○</span></td><td><span class="inline-wrap">SELECT<span class="jill"></span>关键字对应的那个查询的类型</span></td></tr><tr><td><span class="inline-wrap"><code>table</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">每个具体步骤对应的表名。可能是实际的表，也可能是保存中间数据的临时表。</span></td></tr><tr><td><span class="inline-wrap"><code>partitions</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">匹配的分区信息</span></td></tr><tr><td><span class="inline-wrap"><code>type</code></span></td><td><span class="inline-wrap">●</span></td><td><span class="inline-wrap">针对单表的访问方法</span></td></tr><tr><td><span class="inline-wrap"><code>possible_keys</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">可能用到的索引</span></td></tr><tr><td><span class="inline-wrap"><code>key</code></span></td><td><span class="inline-wrap">●</span></td><td><span class="inline-wrap">实际上使用的索引</span></td></tr><tr><td><span class="inline-wrap"><code>key_len</code></span></td><td><span class="inline-wrap">●</span></td><td><span class="inline-wrap">实际使用到的索引长度</span></td></tr><tr><td><span class="inline-wrap"><code>ref</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></td></tr><tr><td><span class="inline-wrap"><code>rows</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">预估的需要读取的记录条数</span></td></tr><tr><td><span class="inline-wrap"><code>filtered</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">某个表经过搜索条件过滤后剩余记录条数的百分比</span></td></tr><tr><td><span class="inline-wrap"><code>Extra</code></span></td><td><span class="inline-wrap"></span><br/></td><td><span class="inline-wrap">一些额外的信息</span></td></tr></tbody></table></div><div id="2KQUQxTcmJvEc6SoAkisu8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="csxeA4RsMW9TSLovETJ5Hi" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">id<span class="jill"></span>字段</span></h2><div id="q8ircEZPZMaZBYAqSWWL1L" class="wolai-block wolai-text"><div><span class="inline-wrap">是一个有顺序的编号，是查询的顺序号，有几个<span class="jill"></span>select<span class="jill"></span>就显示几行。id<span class="jill"></span>的顺序是按<span class="jill"></span>select<span class="jill"></span>出现的顺序增长的。id<span class="jill"></span>列的值越大执行优先级越高越先执行，id<span class="jill"></span>列的值相同则从上往下执行，id<span class="jill"></span>列的值为<span class="jill"></span>NULL<span class="jill"></span>最后执行。</span></div></div><div id="rYJv48nbYRArumeBVw9ijw" class="wolai-block wolai-text"><div><span class="inline-wrap">id<span class="jill"></span>字段的值有可能会出现多个，每个值都有可能重复出现。其中每一个数值代表一个大步骤，同一个数值出现次数表示这个大步骤中小步骤执行的次数。</span></div></div><div id="hHwsLz3WqkahwJUav3Z56t" class="wolai-block wolai-text"><div><span class="inline-wrap">大步骤按照数值从大到小的顺序执行，小步骤按照从上到下的顺序执行</span></div></div><div id="eYex9EZfz1G4XACV1WVPsy" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有如下执行结果：</span></div></div><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="9mbaK4nVCwvAkmJWhczs24" class="wolai-block wolai-text"><div><span class="inline-wrap">id<span class="jill"></span>字段值</span></div></div><span class="inline-wrap"></span><br/><div id="hHqUpf12m2jbpsobXFAxg5" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="8sK1DabqkzN8ssqUDyEm4U" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="keDr3sFp1UwYCHy733Qi3X" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="5hdbBkXVnWeF1WQVP594a4" class="wolai-block wolai-text"><div><span class="inline-wrap">标号</span></div></div><span class="inline-wrap"></span><br/><div id="fZYLjATXV3nG5EWZgXdkYp" class="wolai-block wolai-text"><div><span class="inline-wrap">a</span></div></div><span class="inline-wrap"></span><br/><div id="c8CB786953u5kM9Tfc5Xo8" class="wolai-block wolai-text"><div><span class="inline-wrap">b</span></div></div><span class="inline-wrap"></span><br/><div id="PgvkQBs7n7jo28ziyb9fS" class="wolai-block wolai-text"><div><span class="inline-wrap">c</span></div></div><span class="inline-wrap"></span><br/><div id="mvQByrqYZ6tAS34yCoucnd" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="hh6HBYbfLGYW4kzjP6m7ew" class="wolai-block wolai-text"><div><span class="inline-wrap">d</span></div></div><span class="inline-wrap"></span><br/><div id="jCw9bh5vC3jGBEjRFzVpVY" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="rWVq1Y3Nm1P1X9FjxvTABZ" class="wolai-block wolai-text"><div><span class="inline-wrap">e</span></div></div><span class="inline-wrap"></span><br/><div id="3ffzzsHAqhFWtPNT2TGUB" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="re2yjxqNRJozcYX2DJK5Ex" class="wolai-block wolai-text"><div><span class="inline-wrap">f</span></div></div><span class="inline-wrap"></span><br/><div id="jhZkMeMb5q3QCNwkX8eTtg" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="2UfzLZvF8BxGpE4kjWAXYj" class="wolai-block wolai-text"><div><span class="inline-wrap">g</span></div></div><span class="inline-wrap"></span><br/><div id="bLtMZquKPXafHKu4zmj9aD" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="apcPTLyEwzKxWaTTq5VmUN" class="wolai-block wolai-text"><div><span class="inline-wrap">h</span></div></div><div id="h2CsieKn7mS3ACLpoAjouG" class="wolai-block wolai-text"><div><span class="inline-wrap">基于上表中的结果，最终的执行顺序是：f、g、h、d、e、a、b、c</span></div></div><div id="ahnFuE78zEqSpQUfxWdKWS" class="wolai-block wolai-text"><div><span class="inline-wrap">从调优的角度来说，大步骤和小步骤都是越少越好</span></div></div><div id="ephxcTB4wCgppQXD7cL68g" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="nFeyzFTyA6L5hMBCmCxjPG" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">selectType 字段</span></h2><div id="vCvfsRGvj2Y63kk8oPeq83" class="wolai-block wolai-text"><div><span class="inline-wrap">表示查询中每个<span class="jill"></span>select<span class="jill"></span>子句的类型</span></div></div><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="2bVrNd2aBcus7B1MDfns9e" class="wolai-block wolai-text"><div><span class="inline-wrap">取值</span></div></div><span class="inline-wrap"></span><br/><div id="6vw2i9quXY3shjkjXBg3Jz" class="wolai-block wolai-text"><div><span class="inline-wrap">SIMPLE</span></div></div><span class="inline-wrap"></span><br/><div id="vEq5snZhsJTL6SKt5gUQdZ" class="wolai-block wolai-text"><div><span class="inline-wrap">PRIMARY</span></div></div><span class="inline-wrap"></span><br/><div id="xy7g7xfAELJ5wWAttrpXtc" class="wolai-block wolai-text"><div><span class="inline-wrap">SUBQUERY</span></div></div><span class="inline-wrap"></span><br/><div id="sV1zKAgp8KFkUHzNnFgMMn" class="wolai-block wolai-text"><div><span class="inline-wrap">说明</span></div></div><span class="inline-wrap"></span><br/><div id="aa6vtXRbUaWk4w6WFpDz7W" class="wolai-block wolai-text"><div><span class="inline-wrap">表示此查询不包含 UNION 查询或子查询</span></div></div><span class="inline-wrap"></span><br/><div id="5tj8RW3rLyFAJHFxJr3cs3" class="wolai-block wolai-text"><div><span class="inline-wrap">表示此查询是最外层的查询（包含子查询）</span></div></div><span class="inline-wrap"></span><br/><div id="9rAL8Bu6CtN4G1YwaCqZMe" class="wolai-block wolai-text"><div><span class="inline-wrap">子查询中的第一个 SELECT</span></div></div><span class="inline-wrap"></span><br/><div id="hEELfu9dPAAVBRSaQtchNG" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION</span></div></div><span class="inline-wrap"></span><br/><div id="jpLQJEsLuqkPefwV4KKrhg" class="wolai-block wolai-text"><div><span class="inline-wrap">表示此查询是 UNION 的第二或随后的查询</span></div></div><span class="inline-wrap"></span><br/><div id="9qPRL4EJnvqGQrk59N6rTZ" class="wolai-block wolai-text"><div><span class="inline-wrap">DEPENDENT UNION</span></div></div><span class="inline-wrap"></span><br/><div id="49QAjqvFSaVPanC6mMCAPo" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION 中的第二个或后面的查询语句, 取决于外面的查询</span><span class="inline-wrap">UNION RESULT, UNION 的结果</span></div></div><span class="inline-wrap"></span><br/><div id="px5ofGAFy6qvZm3rdiB9MK" class="wolai-block wolai-text"><div><span class="inline-wrap">DEPENDENT SUBQUERY</span></div></div><span class="inline-wrap"></span><br/><div id="cD9fzi226jVksVPvvmtyMN" class="wolai-block wolai-text"><div><span class="inline-wrap">子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果</span></div></div><span class="inline-wrap"></span><br/><div id="84dd1MCQFRaawfomRd9PTh" class="wolai-block wolai-text"><div><span class="inline-wrap">DERIVED</span></div></div><span class="inline-wrap"></span><br/><div id="4ASHraqjByxwZJcQXifCGQ" class="wolai-block wolai-text"><div><span class="inline-wrap">衍生，表示导出表的<span class="jill"></span>SELECT（FROM<span class="jill"></span>子句的子查询）</span></div></div><div id="tbwyqQfX4RSZyibPiegJaK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dXcDcTecGXvszYEntcG5RL" class="wolai-block"><span class="wolai-serial-number">22.3</span><span class="inline-wrap">table<span class="jill"></span>字段</span></h2><div id="ppmp4fCrCVP8a4qsRsggZq" class="wolai-block wolai-text"><div><span class="inline-wrap">表示该语句查询的表</span></div></div><div id="6kABui2UQeJHku5oJhfFtg" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bZVZffxD71XgFtDmj8urSw" class="wolai-block"><span class="wolai-serial-number">22.4</span><span class="inline-wrap">type<span class="jill"></span>字段</span></h2><div id="2Z2WyasiwunYbEVdxLj8by" class="wolai-block wolai-text"><div><span class="inline-wrap">优化<span class="jill"></span>SQL<span class="jill"></span>的重要字段，也是我们判断<span class="jill"></span>SQL<span class="jill"></span>性能和优化程度重要指标</span></div></div><div id="sGHqZbKLu3X4TGQiJt4WqU" class="wolai-block wolai-text"><div><span class="inline-wrap">可以把它理解为对表访问方式，表示<span class="jill"></span>MySQL<span class="jill"></span>在表中找到所需行的方式，又称“访问类型”。具体取值参见下表（从上到下，性能越来越好）：</span></div></div><div id="pcXswVbTwh396EdQKcq1fT" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">取值</span></th><th style="width: 1144px"><span class="inline-wrap">含义</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">ALL</span></td><td><span class="inline-wrap">全表扫描，完全没有用到任何索引，效率最低的一种情况</span></td></tr><tr><td><span class="inline-wrap">index</span></td><td><span class="inline-wrap">对索引表（聚簇索引、非聚簇索引都算）进行整体遍历，虽然用到了索引但效率仍然较低</span></td></tr><tr><td><span class="orange inline-wrap"><u><b>range</b></u></span></td><td><span class="inline-wrap">在一定范围内查询索引表（例如：where age between 20 and 30，当然此时要求<span class="jill"></span>age<span class="jill"></span>字段上有索引）</span></td></tr><tr><td><span class="orange inline-wrap"><u><b>ref</b></u></span></td><td><span class="inline-wrap">通过普通的二级索引列与常量进行等值匹配时来查询某个表
例如：where age=20，当然此时要求<span class="jill"></span>age<span class="jill"></span>字段上有索引</span></td></tr><tr><td><span class="inline-wrap">eq_ref</span></td><td><span class="inline-wrap">在关联查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是</span><span class="inline-wrap"><code>eq_ref</code></span><span class="inline-wrap">
from emp left join dept on emp.dept_id=dept.id</span></td></tr><tr><td><span class="inline-wrap">const</span></td><td><span class="inline-wrap">根据主键或者唯一二级索引列与常数进行等值匹配
where emp_id=5</span></td></tr><tr><td><span class="inline-wrap">system</span></td><td><span class="inline-wrap">表仅有一行记录，这是<span class="jill"></span>const<span class="jill"></span>类型的特例，查询起来非常迅速</span></td></tr><tr><td><span class="inline-wrap">null</span></td><td><span class="inline-wrap">MySQL<span class="jill"></span>在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
select user();</span></td></tr></tbody></table></div><div id="poDxDawBdRHxr7BWUC6FMB" class="wolai-block wolai-text"><div><span class="inline-wrap">评价：</span></div></div><ul class="wolai-block"><li id="2hPjH6rXz6zKjRNs7FxCCy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ALL<span class="jill"></span>和<span class="jill"></span>index<span class="jill"></span>太差，尽量优化提升</span></li><li id="uTkMpa66dB5JSRTwzvJWUL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">从<span class="jill"></span>eq_ref<span class="jill"></span>开始的性能固然很好但是条件非常苛刻，不容易达成</span></li></ul><div id="whLt2CVutCiaaHUcJRZZkh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="e1GVsvimmG2AHJ5XwT3KFD" class="wolai-block wolai-text"><div><span class="inline-wrap">结论：平时尽量把<span class="jill"></span>SQL<span class="jill"></span>优化到<span class="jill"></span>range、ref</span></div></div><div id="3BQ9wSocw8RFtruduvM1Da" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="DJcesPEKFnDFKFdGUQrD5" class="wolai-block"><span class="wolai-serial-number">22.5</span><span class="inline-wrap">possible_keys<span class="jill"></span>字段</span></h2><div id="nA6FLp71WNR6C4uuXCVQio" class="wolai-block wolai-text"><div><span class="inline-wrap">它表示<span class="jill"></span>MySQL<span class="jill"></span>在执行该<span class="jill"></span>SQL<span class="jill"></span>语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。</span></div></div><div id="uLB74KSwmfwtteECaN7xcZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="32G8FiwxZfNfPdRURJBTuK" class="wolai-block"><span class="wolai-serial-number">22.6</span><span class="inline-wrap">key<span class="jill"></span>字段</span></h2><div id="jpnh59PULVUEjQdVAkpxP8" class="wolai-block wolai-text"><div><span class="inline-wrap">此字段是<span class="jill"></span>MySQL<span class="jill"></span>在当前查询时所真正使用到的索引。 他是<span class="jill"></span>possible_keys<span class="jill"></span>的子集</span></div></div><div id="wi92Nd4xWDHHjYHm7fQuec" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="msmGNyEtuiHxXVUWUMgQUE" class="wolai-block"><span class="wolai-serial-number">22.7</span><span class="inline-wrap">key_len<span class="jill"></span>字段</span></h2><div id="nWLG8hjrEcgardkwvdJonZ" class="wolai-block wolai-text"><div><span class="inline-wrap">表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化<span class="jill"></span>SQL<span class="jill"></span>时，评估索引的重要指标</span></div></div><div id="cQhTpbyx6ZRYv7UR1otnVp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="c4GmnQGeAEPUDv9TTgitga" class="wolai-block"><span class="wolai-serial-number">22.8</span><span class="inline-wrap">rows<span class="jill"></span>字段</span></h2><div id="2T6T8EGZZGrs8cxud5LaM5" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL<span class="jill"></span>查询优化器根据统计信息，估算该<span class="jill"></span>SQL<span class="jill"></span>返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大。</span></div></div><div id="tpwwxR1jKyHq616N2TCuja" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4dWdimZKCbiCCYarbD5H8n" class="wolai-block"><span class="wolai-serial-number">22.9</span><span class="inline-wrap">filtered<span class="jill"></span>字段</span></h2><div id="694uvA5sYhjrqL1r54XaDR" class="wolai-block wolai-text"><div><span class="inline-wrap">返回结果的行占需要读到的行(rows<span class="jill"></span>列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少</span></div></div><div id="2EwUF2P8nVhLQ2J2b8Xt8K" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eGqqhA8pWhUYHJNHyrvUoB" class="wolai-block"><span class="wolai-serial-number">22.10</span><span class="inline-wrap">extra<span class="jill"></span>字段</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="88JEeNcjyLoNdsD4icipXv" class="wolai-block wolai-text"><div><span class="inline-wrap">取值</span></div></div><span class="inline-wrap"></span><br/><div id="3479wt3NDLg76cDFzCZDBP" class="wolai-block wolai-text"><div><span class="inline-wrap">using filesort</span></div></div><span class="inline-wrap"></span><br/><div id="tPhyqBU1NKJpGSa2VajBt2" class="wolai-block wolai-text"><div><span class="inline-wrap">using index</span></div></div><span class="inline-wrap"></span><br/><div id="trz2CxDNa2CfX6PUMieda3" class="wolai-block wolai-text"><div><span class="inline-wrap">using temporary</span></div></div><span class="inline-wrap"></span><br/><div id="oTnNS1zEc44YzoSBZujjZE" class="wolai-block wolai-text"><div><span class="inline-wrap">说明</span></div></div><span class="inline-wrap"></span><br/><div id="3FPps5oLCRBxX8zJZwksHv" class="wolai-block wolai-text"><div><span class="inline-wrap">表示 MySQL<span class="jill"></span>对结果集进行外部排序，不能通过索引顺序达到排序效果。
通常看到<span class="jill"></span>using filesort<span class="jill"></span>都建议优化去掉，因为这样的查询<span class="jill"></span>CPU<span class="jill"></span>资源消耗大，延时大</span></div></div><span class="inline-wrap"></span><br/><div id="xzpHU46rqNWiNGFQZiuYib" class="wolai-block wolai-text"><div><span class="inline-wrap">覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错</span></div></div><span class="inline-wrap"></span><br/><div id="3KQvD389aaX8N66fCa4BT" class="wolai-block wolai-text"><div><span class="inline-wrap">查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化</span></div></div><span class="inline-wrap"></span><br/><div id="n6tpqKQAUnVhEsZoSm1ATT" class="wolai-block wolai-text"><div><span class="inline-wrap">using where</span></div></div><span class="inline-wrap"></span><br/><div id="hnfb9fM66PkQDJ4XiS9S9" class="wolai-block wolai-text"><div><span class="inline-wrap">SQL<span class="jill"></span>使用了<span class="jill"></span>where<span class="jill"></span>过滤，效率较高</span></div></div><div id="pmaMGSiYPejAba5XVbb34K" class="wolai-block wolai-text"><div></div></div><div id="w3CZqBuQeen8oD45yaHCzV" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jNdV2tD6NfX4oKPFzL1HUo" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">MySQL<span class="jill"></span>常见优化手段</span></h1><div id="39717cTNZpeSQ3pKqLzD5k" class="wolai-block wolai-text"><div><span class="inline-wrap">（1）尽量选择较小的列</span></div></div><div id="aYHrdxKV1j7nnZL5qtt7pR" class="wolai-block wolai-text"><div><span class="inline-wrap">（2）将<span class="jill"></span>where<span class="jill"></span>中用的比较频繁的字段建立索引</span></div></div><div id="qbBtq1DgcCqGk7e7Rk36v3" class="wolai-block wolai-text"><div><span class="inline-wrap">（3）select<span class="jill"></span>子句中避免使用“*”</span></div></div><div id="9PB6pXjSMffwdjeJWwSayn" class="wolai-block wolai-text"><div><span class="inline-wrap">（4）避免在索引列上使用计算、not in 和&lt;&gt;等操作</span></div></div><div id="3GcBdhAxEkmm6zqT9paYLN" class="wolai-block wolai-text"><div><span class="inline-wrap">（5）当只需要一行数据的时候使用<span class="jill"></span>limit 1</span></div></div><div id="6369vpCAHYmQ9SKzmhQJSk" class="wolai-block wolai-text"><div><span class="inline-wrap">（6）保证单表数据不超过<span class="jill"></span>200W，适时分割表。针对查询较慢的语句，可以使用<span class="jill"></span>explain 来分析该语句具体的执行情况</span></div></div><div id="9Dt25Zom5266rWMiczGZjS" class="wolai-block wolai-text"><div><span class="inline-wrap">（7）避免改变索引列的类型</span></div></div><div id="5K5BEpfZqunmW6yiyQUJar" class="wolai-block wolai-text"><div><span class="inline-wrap">（8）选择最有效的表名顺序，from<span class="jill"></span>字句中写在最后的表是基础表，将被最先处理，在<span class="jill"></span>from<span class="jill"></span>子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表</span></div></div><div id="iwh54ndq2mNdRPBn23dsZw" class="wolai-block wolai-text"><div><span class="inline-wrap">（9）避免在索引列上面进行计算</span></div></div><div id="iS9spLu2F8DkhLnpWjYfQU" class="wolai-block wolai-text"><div><span class="inline-wrap">（10）能用关联查询的不要用子查询</span></div></div><div id="stHHxqzRqRYc6sUYdZ5w9U" class="wolai-block wolai-text"><div><span class="inline-wrap">（11）尽量缩小子查询的结果</span></div></div><div id="boUu5V3uueU9x4umkzu4L" class="bg-vivid_tangerine wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="saTJW4o93uiSsURn94xy9W" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">你是如何进行<span class="jill"></span>SQL<span class="jill"></span>调优的？</span></h1><div id="rrDL6hSguE97L5AK4ydgXu" class="wolai-block wolai-text"><div><span class="inline-wrap">进行<span class="jill"></span>SQL<span class="jill"></span>调优时，通常可以采取以下步骤来优化查询性能和提高数据库操作效率：</span></div></div><ol class="wolai-block"><li id="tzn9B6AawNpYtRnqfNEBWF"><div class="marker"></div><span class="inline-wrap"><b>分析查询执行计划</b></span><span class="inline-wrap">： 使用数据库管理工具或命令，获取<span class="jill"></span>SQL<span class="jill"></span>查询的执行计划。执行计划将显示查询的执行路径，包括表的连接方式、索引的使用情况等。通过分析执行计划，可以确定查询中存在的性能瓶颈。</span></li><li id="vg4BnRZKoRxdwgUGvycEwn"><div class="marker"></div><span class="inline-wrap"><b>索引优化</b></span><span class="inline-wrap">： 确保表中的字段上存在适当的索引，以加快数据检索速度。然而，不宜过度索引，因为索引也会增加数据写入的开销。使用复合索引来覆盖多个查询条件，避免使用过多的单列索引。</span></li><li id="cPC8Y7RYi8t1ZQqMWXAUvw"><div class="marker"></div><span class="inline-wrap"><b>合理编写<span class="jill"></span>SQL<span class="jill"></span>语句</b></span><span class="inline-wrap">： 编写高效的<span class="jill"></span>SQL<span class="jill"></span>查询语句是调优的关键。避免使用&quot;SELECT *”，而是只选择需要的列；合理使用<span class="jill"></span>JOIN<span class="jill"></span>操作，避免多余的连接；使用子查询时，确保子查询返回的数据量有限。</span></li><li id="iaSUK6VSf7xgZXFftWSKoq"><div class="marker"></div><span class="inline-wrap"><b>缓存数据</b></span><span class="inline-wrap">： 对于频繁查询的数据，可以使用缓存技术，如<span class="jill"></span>Redis，将结果缓存起来，减少对数据库的频繁访问。</span></li><li id="8fm8stVvX3EGNEHL9bgWDH"><div class="marker"></div><span class="inline-wrap"><b>分区表和分表</b></span><span class="inline-wrap">： 如果数据表过大，可以考虑使用分区表或分表的方式，将数据分散存储，提高查询效率。</span></li><li id="d4vy6gYEqATetLZ6kYrDT4"><div class="marker"></div><span class="inline-wrap"><b>定期维护和统计</b></span><span class="inline-wrap">： 定期进行数据库的维护工作，如重新生成索引、更新统计信息等，以保持数据库的优化状态。</span></li><li id="pF6i8zRY7CPK2PtPdm2Mbh"><div class="marker"></div><span class="inline-wrap"><b>避免全表扫描</b></span><span class="inline-wrap">： 尽量避免全表扫描操作，可以通过适当的索引、条件过滤等方式来减少数据量，提高查询速度。</span></li><li id="9wN2p7vQapUgMmhMk7tBoz"><div class="marker"></div><span class="inline-wrap"><b>优化数据库参数配置</b></span><span class="inline-wrap">： 根据数据库类型，调整数据库的参数配置，如缓冲池大小、连接数等，以适应实际业务负载。</span></li><li id="tMyMj6zFKLMoPiKritzz1d"><div class="marker"></div><span class="inline-wrap"><b>使用合适的存储引擎</b></span><span class="inline-wrap">： 根据具体的应用需求，选择合适的数据库存储引擎，如<span class="jill"></span>InnoDB、MyISAM<span class="jill"></span>等。</span></li><li id="98XpdkceyxnEWMFpM2qjHG"><div class="marker"></div><span class="inline-wrap"><b>使用慢查询分析工具</b></span><span class="inline-wrap">： 数据库管理工具提供了慢查询分析功能，可以帮助你识别哪些查询语句执行较慢，从而有针对性地进行优化。</span></li></ol><div id="8XacGK5d24n4X5NczzBoqF" class="wolai-block wolai-text"><div><span class="inline-wrap">综合考虑上述方法，根据具体的业务需求和数据库特点，可以进行有效的<span class="jill"></span>SQL<span class="jill"></span>调优，提升数据库性能和查询效率。</span></div></div><div id="8gi6pkHrcVTFy1CHMeMMFj" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ptJQrWkEZLGxsMmLD78seg" class="wolai-block"><span class="wolai-serial-number">25</span><span class="inline-wrap">请描述<span class="jill"></span>MySQL<span class="jill"></span>中的<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎如何实现事务。</span></h1><div id="8huu3bswzCJk3G6FhHxzhm" class="wolai-block wolai-text"><div><span class="inline-wrap">InnoDB 存储引擎通过多种机制来实现事务，主要包括以下方面：</span></div></div><ol class="wolai-block"><li id="uZuFfsdUYzfVBQAazv7K1h"><div class="marker"></div><span class="inline-wrap"><b>日志机制</b></span><ul class="wolai-block"><li id="22sWYYo3aupBmyia56qzya"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Redo Log（重做日志）</b></span><span class="inline-wrap">：用于实现事务的持久性。它记录了对数据库数据页的所有修改操作，包括插入、更新、删除等。在事务提交时，必须先将该事务的所有重做日志写入到重做日志文件中，待事务的 commit 操作完成才算整个事务操作完成。重做日志文件是顺序写入的，且在每次将 redo log buffer 写入 redo log file 后，通常需要调用一次 fsync 操作以确保日志真正写入磁盘，不过可以通过参数 innodb_flush_log_at_trx_commit 来控制刷新策略。例如，默认值为 1 表示每次提交事务时都执行一次 fsync 操作；设置为 2 则仅写入文件系统缓存，不进行 fsync 操作，可提高性能但有一定风险；设置为 0 时，由 master thread 每秒进行一次重做日志文件的 fsync 操作。</span></li><li id="hpFWd6GVLd9dEtBGcjiPze"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Undo Log（回滚日志）</b></span><span class="inline-wrap">：记录了事务开始前的数据状态，主要用于回滚未提交的事务或提供多版本并发控制（MVCC）。当事务需要回滚时，InnoDB 会使用回滚日志将数据恢复到事务开始前的状态。同时，回滚日志也用于多版本并发控制，确保事务读取的是某个时间点的一致性视图。</span></li></ul></li><li id="3f2jFgwhcbFdS5mGgBEzKf"><div class="marker"></div><span class="inline-wrap"><b>锁机制</b></span><ul class="wolai-block"><li id="5s29C7kdXZ2f5snkBuSwFG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>行级锁</b></span><span class="inline-wrap">：InnoDB 支持行级锁，包括共享锁（S 锁）和排他锁（X 锁），以减少锁定粒度，提高并发性能。当多个事务试图修改同一行数据时，只有第一个事务可以获得排他锁，其他事务必须等待。这样可以在保证数据一致性的同时，允许多个事务并发地读取或修改不同的数据行。</span></li><li id="qKXdwZVo8KmGBcfQBCJyYG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>意向锁</b></span><span class="inline-wrap">：用于表级别的锁，表示即将对表中的某些行进行加锁，从而避免死锁。意向锁包括意向共享锁（IS 锁）和意向排他锁（IX 锁），它们并不直接锁住数据行，而是表明一个事务对某张表有某种锁的意向，为后续的行级锁做准备。</span></li></ul></li><li id="qHquVEYuMgJZ4bDfccaV2D"><div class="marker"></div><span class="inline-wrap"><b>多版本并发控制（MVCC）</b></span><ul class="wolai-block"><li id="q5qFGEpWtP3UnqSj2LVNuK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">MVCC 通过保存数据的历史版本，允许多个事务同时读取数据而不会相互干扰。每个事务都有一个唯一的事务 ID，InnoDB 通过比较事务 ID 来决定哪些版本的数据是可见的。在读已提交隔离级别下，一个事务只能看到其他事务已经提交的数据；在可重复读隔离级别下，事务可以看到其他事务已经提交的数据以及当前事务开始之前其他事务提交的数据；在串行化隔离级别下，事务会被强制按顺序执行，完全串行化。</span></li></ul></li><li id="uiX9iPW8FYnQEBXshdFbzT"><div class="marker"></div><span class="inline-wrap"><b>双写缓冲区（Doublewrite Buffer）</b></span><ul class="wolai-block"><li id="n2iWKG2qZvuHTrA56c1VAr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">为了防止部分写入导致的数据损坏，InnoDB 会先将数据写入双写缓冲区，然后再写入数据文件。这样可以在内存中先完成数据的修改和整理，然后再一次性地将完整的数据写入磁盘，提高数据写入的效率和可靠性。</span></li></ul></li></ol><div id="5riLfonxDtJf9ivaT1zgtC" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，InnoDB 存储引擎通过日志机制、锁机制、多版本并发控制和双写缓冲区等多种技术手段，实现了高效、可靠的事务处理。这些机制相互配合，共同确保了事务的 ACID 特性，使得 InnoDB 成为处理复杂事务的理想选择。</span></div></div></article><footer></footer></body></html>