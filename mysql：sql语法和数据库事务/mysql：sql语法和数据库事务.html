<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>MySQL：SQL语法和数据库事务 - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="MySQL：SQL语法和数据库事务" class="main-title"></div></div></header><article><h1 id="syst7Bx9jStJRuCrBxJUG4" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>数据库中，</span><span class="inline-wrap">对查询结果去重的关键词是什么？</span></h1><div id="8x13RN9KEoqYZsT5ix6CbQ" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>数据库中，可以使用<span class="jill"></span>DISTINCT<span class="jill"></span>关键字来进行去重操作。DISTINCT<span class="jill"></span>关键字用于查询语句的<span class="jill"></span>SELECT<span class="jill"></span>子句中，用于返回唯一的结果集，去除重复的行。</span></div></div><div id="sSDkjFiXcnusNkttK4x2AL" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，以下是使用 DISTINCT 关键字进行去重的示例：</span></div></div><code-block id="qZyvzZsvDsGVmCM9avBZNC" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre>  <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></pre></div></code-block><div id="7gkpMHw41zjq63SVwhni9L" class="wolai-block wolai-text"><div><span class="inline-wrap">上述示例中，column1<span class="jill"></span>和<span class="jill"></span>column2<span class="jill"></span>是要查询的列名，table_name<span class="jill"></span>是要查询的表名。查询结果将返回去重后的唯一行。</span></div></div><div id="tEMYU55gqiGYfF5Cxr5Ymh" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，DISTINCT<span class="jill"></span>关键字会对查询结果的所有列进行去重。如果只想对部分列进行去重，可以指定相应的列名。</span></div></div><div id="nfQuohJDJVxNPBjopEZeDu" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="p72CMRsoUvd8E2S66rGpXn" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">MySQL<span class="jill"></span>多表连接有哪些方式？怎么用的？这些连接都有什么区别？</span></h1><div id="uMPCf2FuGEt6e169ViMmGe" class="wolai-block wolai-text"><div><span class="inline-wrap">连接方式：左连接、右连接、内连接</span></div></div><div id="7f9u2bnrFXGmdUnMajcAAk" class="wolai-block wolai-text"><div><span class="inline-wrap">使用方法：  </span></div></div><ul class="wolai-block"><li id="5Ek43fU7fyuxBrCqeBL93L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">左连接：select * from A LEFT JOIN B on </span><span class="inline-wrap"><a href="http://A.id=B.id"><span>A.id=B.id</span></a></span><span class="inline-wrap"> ;  </span></li><li id="orDKya61kF5MvtM3LiEfeH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">右连接：select * from A RIGHT JOIN B on </span><span class="inline-wrap"><a href="http://A.id=B.id"><span>A.id=B.id</span></a></span><span class="inline-wrap"> ;  </span></li><li id="hosVx5mtvxR9SN1uwVjyaK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内连接：select * from A inner join B on a.xx=b.xx;（其中<span class="jill"></span>inner<span class="jill"></span>可以省略）  </span></li></ul><div id="mLyXfEXX6wXLW9dHpdzgpN" class="wolai-block wolai-text"><div><span class="inline-wrap">区别：</span></div></div><ul class="wolai-block"><li id="wCnoBYpy72V79GqAbTBSmV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">inner join<span class="jill"></span>内连接，在两张表进行连接查询时，无论左表还是右表都只选取满足连接条件的记录</span></li><li id="b97t7nhkM5rBG4prGG8rNb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">left join<span class="jill"></span>在两张表进行连接查询时，会返回左表所有的记录，不论是否满足连接条件，即使在右表中没有匹配的记录；右表只返回满足连接条件的记录。</span></li><li id="KbPiVZved4aPyDuPQA5SC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">right join<span class="jill"></span>在两张表进行连接查询时，会返回右表所有的记录，不论是否满足连接条件，即使在左表中没有匹配的记录；左表只返回满足连接条件的记录。</span></li></ul><div id="tPQHuZGr4gqheA8tAuJV4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3kLAJL34N5wLv4xadx58ZX" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">UNION<span class="jill"></span>和<span class="jill"></span>UNION ALL<span class="jill"></span>的区别？</span></h1><h2 id="axppwVfwzJghQG1YCYbQuX" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="cEWVmdSxwpKv5AEEKnb4XX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UNION：纵向合并数据<span class="jill"></span>+<span class="jill"></span>去重<span class="jill"></span>+<span class="jill"></span>排序</span></li><li id="gGNP9Xnd1z1DtYX8DR1iko"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UNION ALL：纵向合并数据（没有去重、排序等操作）</span></li></ul><div id="cp2x2WmQAZzs4Pr42QLabo" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>UION ALL<span class="jill"></span>操作简单，所以同等条件下性能会比<span class="jill"></span>UNION<span class="jill"></span>更好，但也要看业务需求来选择</span></div></div><div id="4BtBSnFKtjG9B7TanQHf6C" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="9b4P9WbgsEJTsjgjJ7ge6n" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">验证</span></h2><h3 id="g5Kaw81aVAjBgywBqWc76U" class="wolai-block"><span class="wolai-serial-number">3.2.1</span><span class="inline-wrap">数据合并效果</span></h3><div id="rcaeyzHomh1RSvEYvouM6t" class="wolai-block wolai-text"><div><span class="inline-wrap">a<span class="jill"></span>表数据：</span></div></div><div id="5yHurVdZUwJXXzKRD9owry" class="wolai-block"><figure class="wolai-center" style="width: 589.3333333333334px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="5AVS1X5pS5D7Uv6UZa82RF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="odYCJNuqqGmMyppAKNMsJs" class="wolai-block wolai-text"><div><span class="inline-wrap">b<span class="jill"></span>表数据：</span></div></div><div id="bdF6h61n2WAxnYneARBBkb" class="wolai-block"><figure class="wolai-center" style="width: 573.3333333333334px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="pfrjEpaKiYCUeovcemc66P" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="oMBNyZ3ovtiEE77jxrjzF3" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION ALL<span class="jill"></span>的查询结果：</span></div></div><div id="mtSuSq1MEiE5axV9G6cSi2" class="wolai-block"><figure class="wolai-center" style="width: 295.3333333333333px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="7jphcepLTqVeCH72JamoQG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="rkQt9hhBywekyBPo2xYDX3" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION<span class="jill"></span>的查询结果：</span></div></div><div id="hwug6hu3SRUKAUX2BoT5su" class="wolai-block"><figure class="wolai-center" style="width: 414px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><div id="fMz1tSLvypz25WzSsarvbT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="35HhzSaThbFbpCqGskDDBa" class="wolai-block"><span class="wolai-serial-number">3.2.2</span><span class="inline-wrap">explain<span class="jill"></span>分析</span></h3><div id="6aVXpAJduYLbi3pY2krRuw" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION ALL<span class="jill"></span>只有两步操作：</span></div></div><div id="gDSWZcmZsEz51MVT6HAfyq" class="wolai-block"><figure class="wolai-center" style="width: 632.6666666666666px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><div id="aaSGkh8ALjUJ9bY3sYjdkp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="vrD7PDs3AVzntRbapdVuR8" class="wolai-block wolai-text"><div><span class="inline-wrap">UNION<span class="jill"></span>有三步操作：</span></div></div><div id="s4hHNxMGs8aMyXG8z1PTr3" class="wolai-block"><figure class="wolai-center" style="width: 690.6666666666666px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><div id="qk7u8eA3RcfZ6kudfqYRW1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="wzZPC4sq8bgETi1ec8RLfY" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="7crubGjj1ATurYvpSC29es" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hFi3inPJZ383PV4HtCqvz4" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">请简述<span class="jill"></span>SQL<span class="jill"></span>中的基本查询语句（SELECT）的语法结构。</span></h1><div id="sZ68r1Zd5VTS8SDVgoNEXU" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句用于从数据库中检索数据。其基本语法结构如下：</span></div></div><code-block id="7xQQEMER5Qe6kCnH3KHtvf" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table_name
<span class="token keyword">WHERE</span> condition
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column_name
<span class="token keyword">HAVING</span> condition
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> column_name<span class="token punctuation">;</span></pre></div></code-block><div id="jiVNiDMvyGsa3BZpARKb29" class="wolai-block wolai-text"><div><span class="inline-wrap">具体说明如下：</span></div></div><ul class="wolai-block"><li id="fXpuj8rLu1XBN2EXXFUxCN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SELECT column1, column2, ...</code></span><span class="inline-wrap">: 指定要查询的列。可以使用*表示查询所有列。</span></li><li id="cvuHmcRZBP5M4n663zqvMR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>FROM table_name</code></span><span class="inline-wrap">: 指定要查询的数据表。</span></li><li id="iwwPxxGcDc8LQyoUrF5e5j"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>WHERE condition</code></span><span class="inline-wrap">: 可选部分，用于过滤记录。只有满足条件的记录才会被查询出来。</span></li><li id="mvzKAcwZHrfH7RHtfHjsyW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>GROUP BY column_name</code></span><span class="inline-wrap">: 可选部分，用于根据一个或多个列对结果进行分组。通常与聚合函数（如<span class="jill"></span>COUNT(), SUM(), AVG()等）一起使用。</span></li><li id="2Xi69pT2dXAUcwXTn3Jyrk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>HAVING condition</code></span><span class="inline-wrap">: 可选部分，用于对分组后的结果进行过滤。通常与</span><span class="inline-wrap"><code>GROUP BY</code></span><span class="inline-wrap">子句一起使用。</span></li><li id="jnkHYWVa1WFSqeBzCw5QZU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>ORDER BY column_name</code></span><span class="inline-wrap">: 可选部分，用于对查询结果进行排序。可以指定升序（ASC）或降序（DESC）。</span></li></ul><div id="2Au1YxYLWaHJmnC5q1GBsz" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，包含以下列：</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">。以下是一个具体的查询示例：</span></div></div><code-block id="ouheVFDqjCzXy5JyzoWdNV" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age
<span class="token keyword">FROM</span> employees
<span class="token keyword">WHERE</span> age <span class="token operator">></span> <span class="token number">30</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">5</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> age <span class="token keyword">DESC</span><span class="token punctuation">;</span></pre></div></code-block><div id="bVyzK5i7yT9pqX8U1tFqA9" class="wolai-block wolai-text"><div><span class="inline-wrap">这个查询的含义是：从</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中选择年龄大于<span class="jill"></span>30<span class="jill"></span>的员工，按部门进行分组，只保留每个部门中员工数多于<span class="jill"></span>5<span class="jill"></span>个的组，最后按年龄降序排列结果。</span></div></div><div id="dPeZFzoQjzVbiDVdyyfAp4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="icTCy9fSrUF4LnpBm8Enqp" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">如何通过<span class="jill"></span>SQL<span class="jill"></span>语句实现表的插入操作？</span></h1><div id="3uu1fGFnt3kjZgazSpgzsB" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，通过</span><span class="inline-wrap"><code>INSERT INTO</code></span><span class="inline-wrap">语句可以实现向表中插入数据。其基本语法结构如下：</span></div></div><code-block id="rwb58J8QwwbK3fXG7FYy2V" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table_name <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="hd1p7rwFnRD5R2QinC6S94" class="wolai-block wolai-text"><div><span class="inline-wrap">具体说明如下：</span></div></div><ul class="wolai-block"><li id="9DH8vvXSFuhspsDgrJ3QRW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>table_name</code></span><span class="inline-wrap">: 指定要插入数据的表名。</span></li><li id="gqZMHWEHuiDbs1syoFthpd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>(column1, column2, ...)</code></span><span class="inline-wrap">: 可选部分，指定要插入数据的列名。如果省略，则表示插入所有列的数据，且必须按表定义的顺序提供所有列的值。</span></li><li id="hCzKfFyRPvdUQfsNN487Pv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>VALUES (value1, value2, ...)</code></span><span class="inline-wrap">: 指定要插入的具体值。这些值的数量和顺序应与指定的列名或表的列定义相匹配。</span></li></ul><div id="gKY371r4u3EipYUKb5Ebu1" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，包含以下列：</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">。以下是一个具体的插入操作示例：</span></div></div><code-block id="o9jqTndxQrbZvmEBEzwkiY" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> department<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'HR'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="giiFi1Y9Kxt4RHPrBHTbbw" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：向</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中插入一条记录，其中</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">为<span class="jill"></span>1，</span><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">为&#39;Alice&#39;，</span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">为<span class="jill"></span>30，</span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">为&#39;HR&#39;。</span></div></div><div id="fUnPqYK6FvWbTZ1HmDjWCz" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要插入多条记录，可以这样写：</span></div></div><code-block id="tAyv466bid3FDx5WaDMFTe" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> department<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> 
    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">'Engineering'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Charlie'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token string">'Marketing'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'David'</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">'Finance'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="bbXcky3GNDHmenZMcV1ZUd" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：一次性向</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中插入三条记录。</span></div></div><div id="m11MbGT17EQ9AVGpSdLZEs" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，还可以使用子查询来插入数据。例如，从另一个表中选择数据并插入到目标表中：</span></div></div><code-block id="u5fzGPrwyqLnWSmo1SQBvi" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> department<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> department
<span class="token keyword">FROM</span> new_employees<span class="token punctuation">;</span></pre></div></code-block><div id="99PMcKRR9W9sbZVUxQLzf3" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：将</span><span class="inline-wrap"><code>new_employees</code></span><span class="inline-wrap">表中的所有记录插入到</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中。</span></div></div><div id="t6NAEKE3A1JjhysKQWc9JV" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="v2fEQnazyt4QpD63cJ1Ww8" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">如何使用<span class="jill"></span>SQL<span class="jill"></span>更新表中的数据？</span></h1><div id="m9xvsurmpEqzYcQRz5wStJ" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，通过</span><span class="inline-wrap"><code>UPDATE</code></span><span class="inline-wrap">语句可以实现对表中数据的更新。其基本语法结构如下：</span></div></div><code-block id="do1jAJcSbNnopBF6M5dEF" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> table_name
<span class="token keyword">SET</span> column1 <span class="token operator">=</span> value1<span class="token punctuation">,</span> column2 <span class="token operator">=</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></pre></div></code-block><div id="5CfE88ysWU8uEbG6aToXCL" class="wolai-block wolai-text"><div><span class="inline-wrap">具体说明如下：</span></div></div><ul class="wolai-block"><li id="23GSz8iuB2ChQYnb4HGTRE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>table_name</code></span><span class="inline-wrap">: 指定要更新数据的表名。</span></li><li id="28dcDro1rJBsQKYRCdag7H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SET column1 = value1, column2 = value2, ...</code></span><span class="inline-wrap">: 指定要更新的列及其新值。可以同时更新多个列，用逗号分隔。</span></li><li id="7J6ZouhuN4bJvjJfNa7beM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>WHERE condition</code></span><span class="inline-wrap">: 可选部分，用于过滤要更新的记录。如果省略，则表示更新表中的所有记录。使用</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">子句时需要特别小心，以避免意外更新大量数据。</span></li></ul><div id="55MyWoGwpPo9v4KZjdonGa" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，包含以下列：</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">。以下是一个具体的更新操作示例：</span></div></div><code-block id="c7hnqUTWwLZ5s1ZWxwTAWK" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> employees
<span class="token keyword">SET</span> age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">,</span> department <span class="token operator">=</span> <span class="token string">'Engineering'</span>
<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></div></code-block><div id="27KCUjJ3aagyg6o1yjbw73" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：将</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">为<span class="jill"></span>1<span class="jill"></span>的记录的</span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">更新为<span class="jill"></span>31，</span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">更新为&#39;Engineering&#39;。</span></div></div><div id="qjHoMY7KzkCKoRD33JSmEy" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要更新多条记录，可以使用类似的方法：</span></div></div><code-block id="9np9PFuCi2jaV2kPQHJt3V" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> employees
<span class="token keyword">SET</span> age <span class="token operator">=</span> age <span class="token operator">+</span> <span class="token number">1</span>
<span class="token keyword">WHERE</span> department <span class="token operator">=</span> <span class="token string">'Engineering'</span><span class="token punctuation">;</span></pre></div></code-block><div id="hrfBYL3PtQg4wm8RaGZXha" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：将</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中所有</span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">为&#39;Engineering&#39;的记录的</span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">增加<span class="jill"></span>1。</span></div></div><div id="ifhwknfeao9HVX8HTk5jpC" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，使用</span><span class="inline-wrap"><code>UPDATE</code></span><span class="inline-wrap">语句时要非常谨慎，特别是在没有</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">条件的情况下，因为这会更新表中的所有记录。建议在执行更新操作之前先备份数据或在事务中进行操作，以便在出现问题时能够回滚更改。</span></div></div><div id="6xhQYi433DnKW8QJdB5dxu" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="djhcjUWrxhCrtwxA64TdWi" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">请解释<span class="jill"></span>SQL<span class="jill"></span>中的删除操作及其基本语法。</span></h1><div id="9Tk95CRLXfZaqkCUuCmXBr" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，通过</span><span class="inline-wrap"><code>DELETE</code></span><span class="inline-wrap">语句可以实现对表中数据的删除。其基本语法结构如下：</span></div></div><code-block id="tzscGKZrvTzzEZTp3yewn3" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name
<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></pre></div></code-block><div id="v8o9sbuNyQ4nVMzgSQidJS" class="wolai-block wolai-text"><div><span class="inline-wrap">具体说明如下：</span></div></div><ul class="wolai-block"><li id="4yRRHihjLzZj2nPFVhZNMJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>table_name</code></span><span class="inline-wrap">: 指定要删除数据的表名。</span></li><li id="cg8dhLVsL83BvAPhNVjXk7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>WHERE condition</code></span><span class="inline-wrap">: 可选部分，用于过滤要删除的记录。如果省略，则表示删除表中的所有记录。使用</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">子句时需要特别小心，以避免意外删除大量数据。</span></li></ul><div id="gALNdNSSTxkAFA8ZuBzPdP" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，包含以下列：</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>age</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">。以下是一个具体的删除操作示例：</span></div></div><code-block id="7zZP6gjozU6fgVBWeKMNMx" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> employees
<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></div></code-block><div id="w7JpEhL9PBTCxJcwy7DRqx" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：从</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中删除</span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">为<span class="jill"></span>1<span class="jill"></span>的记录。</span></div></div><div id="3tTysNaJuFB9s22mmkdzYT" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要删除多条记录，可以使用类似的方法：</span></div></div><code-block id="7LS51tQUzjzDBSKMyBZhhp" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> employees
<span class="token keyword">WHERE</span> department <span class="token operator">=</span> <span class="token string">'Engineering'</span><span class="token punctuation">;</span></pre></div></code-block><div id="eKWuG9hxkXphaqdUw81oNW" class="wolai-block wolai-text"><div><span class="inline-wrap">这个语句的含义是：从</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中删除所有</span><span class="inline-wrap"><code>department</code></span><span class="inline-wrap">为&#39;Engineering&#39;的记录。</span></div></div><div id="2GnE1YsTGRjsM4V3BxR97q" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，使用</span><span class="inline-wrap"><code>DELETE</code></span><span class="inline-wrap">语句时要非常谨慎，特别是在没有</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">条件的情况下，因为这会删除表中的所有记录。建议在执行删除操作之前先备份数据或在事务中进行操作，以便在出现问题时能够回滚更改。</span></div></div><div id="kXsP8qUFdYSqGYRRYEQPxw" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3RDyJ7P3wLFo7JKF642Ksq" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">什么是联合查询（UNION），它与连接查询（JOIN）有何不同？</span></h1><div id="7kvuuYekTckKfwRjN5Crez" class="wolai-block wolai-text"><div><span class="inline-wrap">联合查询（UNION）和连接查询（JOIN）是<span class="jill"></span>SQL<span class="jill"></span>中用于合并多个结果集的两种不同方法。它们有不同的用途和行为，通俗来说，“UNION”是竖着连，“JOIN”是横着连。以下是对它们的详细解释：</span></div></div><h2 id="e65sPg2AUyxJLVLhwERRJQ" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">联合查询（UNION）</span></h2><div id="hJzASsEDH2poYcJvScCs53" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：</span></div></div><div id="5ytMdZrT8AZQdZo6KVFMAs" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">操作符用于将两个或多个</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句的结果集合并为一个结果集。每个</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句必须具有相同数量的列，并且相应列的数据类型必须兼容。</span></div></div><div id="66BgXV1roopqmhL2rz93NG" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>语法</b></span><span class="inline-wrap">：</span></div></div><code-block id="kVPV77MvnhFdRuMziZnSwV" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table1
<span class="token keyword">WHERE</span> condition
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table2
<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></pre></div></code-block><div id="7edyR2RppKRpncNjoWuk7d" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>特点</b></span><span class="inline-wrap">：</span></div></div><ul class="wolai-block"><li id="gDFxu9hoUWjPELfUBheYRp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">会自动去除重复的记录。如果需要保留所有重复记录，可以使用</span><span class="inline-wrap"><code>UNION ALL</code></span><span class="inline-wrap">。</span></li><li id="kyvXT9NxW8dLCxG1PJfd5U"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每个</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句中的列数和数据类型必须匹配。</span></li><li id="6dupuAGfc654AHqGMgYVtE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">默认情况下，结果集中的列名来自第一个</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句。</span></li></ul><div id="wWuVEr8NsBQaXspa2m29j7" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span></div></div><div id="faFXj1Q9cjMyjrBo6bhiRP" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有两个表</span><span class="inline-wrap"><code>employees_us</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>employees_uk</code></span><span class="inline-wrap">，结构相同。我们希望获取两个表中的所有员工姓名：</span></div></div><code-block id="uEZ6ujbcqr71wJCSRbdKoc" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> employees_us
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> employees_uk<span class="token punctuation">;</span></pre></div></code-block><div id="syu2vG9DCkVk3ASDjiW6Vr" class="wolai-block wolai-text"><div><span class="inline-wrap">这个查询会返回两个表中所有不重复的员工姓名。</span></div></div><h2 id="smtX6i19Lbcr3X3zj1meD" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">连接查询（JOIN）</span></h2><div id="a5yPEWQPvSwFicHeZiEkkp" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：</span></div></div><div id="9wN8qcUk2TJjsLezX2x7ow" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">操作符用于根据相关列将两个或多个表中的行组合起来。常见的连接类型包括内连接（INNER JOIN）、左连接（LEFT JOIN）、右连接（RIGHT JOIN）和全连接（FULL JOIN）。</span></div></div><div id="eyQ5f8qWKhazp3du7YVXuB" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>语法</b></span><span class="inline-wrap">：</span></div></div><code-block id="kbJK4NNJQwXBAUarf2hBxw" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token keyword">columns</span>
<span class="token keyword">FROM</span> table1
<span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></pre></div></code-block><div id="cp49jyGgnyh15gLUqV2LqU" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>特点</b></span><span class="inline-wrap">：</span></div></div><ul class="wolai-block"><li id="tHRwxsiNKQCubHFcT1SMZd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">不会自动去除重复记录。</span></li><li id="ph8sAbS5YjL1Q8Hr5WxLUZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以根据不同的条件进行复杂的多表关联。</span></li><li id="x1VWZUBkbDQykp3LycNUHd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以指定不同类型的连接来控制结果集的内容。</span></li></ul><div id="4cSJPExHENEPWqc6LaGRqQ" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span></div></div><div id="uNG1ibHRLouV8TdiqnHJx6" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有两个表</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">，我们想要获取每个员工及其所属部门的信息：</span></div></div><code-block id="pGUzqZW8czNRnqa4FkXNo4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> employees<span class="token punctuation">.</span>name<span class="token punctuation">,</span> departments<span class="token punctuation">.</span>department_name
<span class="token keyword">FROM</span> employees
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> departments <span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>id<span class="token punctuation">;</span></pre></div></code-block><div id="mjjn6QwesmCbLnhSZaL9ap" class="wolai-block wolai-text"><div><span class="inline-wrap">这个查询会返回每个员工及其所属部门的名称。</span></div></div><h2 id="jx97PHHH6wyFBQjWFezuQN" class="wolai-block"><span class="wolai-serial-number">8.3</span><span class="inline-wrap">主要区别</span></h2><ol class="wolai-block"><li id="8tJsMHKituXp4t3rs8mjjt"><div class="marker"></div><span class="inline-wrap"><b>目的</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="goEM3dDJwpDyvBWvSq7oY6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">用于合并多个结果集，通常用于从多个表中选择相似的数据。</span></li><li id="m4E1e2BwrBiJVzXCVFdWhj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">用于根据相关列将多个表中的行组合在一起，通常用于从多个表中提取相关的数据。</span></li></ul></li><li id="vFZdHZgNqohmPaG9tZVvcC"><div class="marker"></div><span class="inline-wrap"><b>去重</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="iKwi4juCNtRMMEERfmHb2k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">默认去除重复记录，使用</span><span class="inline-wrap"><code>UNION ALL</code></span><span class="inline-wrap">保留所有记录。</span></li><li id="dezcs8EnuYpgYzghF9T9Ki"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">不会自动去除重复记录。</span></li></ul></li><li id="8djTq4exrqGzdr5e1Yqfdz"><div class="marker"></div><span class="inline-wrap"><b>列数和数据类型</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="oTmkYCqTugFiBnm5SPJ7gH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">要求每个</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">语句中的列数和数据类型必须匹配。</span></li><li id="4ZJbGfnEqy5x7sawZ5X5He"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">允许根据需要选择不同的列，但需要确保连接条件合理。</span></li></ul></li><li id="kphZY763U8j8Uimhxv5sq2"><div class="marker"></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="vpF2m3u2rDJoisFVbrNfAp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">适用于简单的数据合并场景，如从多个表中选择相同的列。</span></li><li id="7cc58njtCtVRC6UZk5fMbr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>JOIN</code></span><span class="inline-wrap">适用于复杂的数据关联场景，如从多个表中提取相关联的数据。</span></li></ul></li></ol><div id="fAyq4fhvfbXsNAp7FKGSEn" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9DTeCMzRADcTtiFS9h1WhY" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">请描述<span class="jill"></span>SQL<span class="jill"></span>中的<span class="jill"></span>INNER JOIN<span class="jill"></span>和<span class="jill"></span>LEFT JOIN<span class="jill"></span>的区别，并举例说明。</span></h1><div id="ftmvbasmMXsmbz4JQBdZBq" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，INNER JOIN<span class="jill"></span>和<span class="jill"></span>LEFT JOIN<span class="jill"></span>是两种常用的连接方式，它们用于将多个表的数据组合在一起。以下是它们的区别及举例：</span></div></div><ol class="wolai-block"><li id="maZ4n29ZsABNSuMV7pjup4"><div class="marker"></div><span class="inline-wrap"><b>INNER JOIN</b></span><span class="inline-wrap">：INNER JOIN<span class="jill"></span>只返回两个表中匹配的行。如果左表中的行在右表中没有匹配项，那么这些行不会出现在结果集中。</span></li><li id="aNSqd6cF91WDr6CvMFSbmr"><div class="marker"></div><span class="inline-wrap"><b>LEFT JOIN</b></span><span class="inline-wrap">：LEFT JOIN<span class="jill"></span>返回左表中的所有行，无论它们在右表中是否有匹配。对于左表中没有匹配的行，右表中的相应列以<span class="jill"></span>NULL<span class="jill"></span>填充。</span></li><li id="raHdmJ67pj6TTVbe3M9moH"><div class="marker"></div><span class="inline-wrap"><b>示例</b></span><ul class="wolai-block"><li id="gTKUCP4SvrdGtVEVTfm1GM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>INNER JOIN 示例</b></span><span class="inline-wrap">：假设有两个表</span><span class="inline-wrap"><code>Customers</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>Orders</code></span><span class="inline-wrap">，通过</span><span class="inline-wrap"><code>CustomerID</code></span><span class="inline-wrap">列进行连接。</span><code-block id="2eJZv7FUAK4gJ3KKbRZc16" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID
<span class="token keyword">FROM</span> Customers
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span></pre></div></code-block><div id="cBo7HNsFGMjUC7zqqFjfgU" class="wolai-block wolai-text"><div><span class="inline-wrap">这个查询将返回</span><span class="inline-wrap"><code>Customers</code></span><span class="inline-wrap">表和</span><span class="inline-wrap"><code>Orders</code></span><span class="inline-wrap">表中匹配的数据行。</span></div></div></li><li id="pHB6kohCyUQYcEPm9yXzwC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>LEFT JOIN 示例</b></span><span class="inline-wrap">：同样使用</span><span class="inline-wrap"><code>Customers</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>Orders</code></span><span class="inline-wrap">表，通过</span><span class="inline-wrap"><code>CustomerID</code></span><span class="inline-wrap">列进行连接。</span><code-block id="gWubD4tQnVhBy15eamCGX4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>CustomerName<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>OrderID
<span class="token keyword">FROM</span> Customers
<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>CustomerID <span class="token operator">=</span> Orders<span class="token punctuation">.</span>CustomerID<span class="token punctuation">;</span></pre></div></code-block><div id="i8czqwFXCFPW3ZPgGVyuzo" class="wolai-block wolai-text"><div><span class="inline-wrap">这个查询将返回</span><span class="inline-wrap"><code>Customers</code></span><span class="inline-wrap">表中的所有数据行，以及与之对应匹配的</span><span class="inline-wrap"><code>Orders</code></span><span class="inline-wrap">表中的数据行。如果某个客户没有订单，则</span><span class="inline-wrap"><code>OrderID</code></span><span class="inline-wrap">列显示为<span class="jill"></span>NULL。</span></div></div></li></ul></li></ol><div id="kvWbbJm6VwYiuU7dALqaPp" class="wolai-block wolai-text"><div><span class="inline-wrap">总结来说，INNER JOIN<span class="jill"></span>只返回两个表中匹配的行，而<span class="jill"></span>LEFT JOIN<span class="jill"></span>返回左表中的所有行，即使右表中没有匹配的行。选择哪种连接方式取决于具体的数据需求和预期的查询结果。</span></div></div><div id="be2rojZMCdXaG9imQ57rR8" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="842iKaTp9mmyjZNh9pCZ93" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中使用子查询？请给出一个示例。</span></h1><div id="iyrw3dGdQyx7NHciuYpaTM" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，子查询（Subquery）是一个嵌套在其他查询中的查询。子查询可以出现在</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>FROM</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>HAVING</code></span><span class="inline-wrap">等子句中。以下是一些常见的使用场景和示例：</span></div></div><h2 id="tEzz7KZpvhzpbs3gJzC7os" class="wolai-block"><span class="wolai-serial-number">10.1</span><span class="inline-wrap">在 </span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap"> 子句中使用子查询</span></h2><div id="cmajw8K1ArtNVPoEjX2qBC" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设有两个表</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">，我们希望获取每个员工及其所属部门的名称。</span></div></div><code-block id="wdm6FeenRiE7Dyv7WofNEs" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> 
       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> d<span class="token punctuation">.</span>department_name 
        <span class="token keyword">FROM</span> departments d 
        <span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>id <span class="token operator">=</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> department_name
<span class="token keyword">FROM</span> employees e<span class="token punctuation">;</span></pre></div></code-block><div id="2eyvjULXEkbGWWLRDXpgjz" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，子查询用于从</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">表中获取与</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中的</span><span class="inline-wrap"><code>department_id</code></span><span class="inline-wrap">匹配的</span><span class="inline-wrap"><code>department_name</code></span><span class="inline-wrap">。</span></div></div><h2 id="fJWR91KP3yoTAQ3aiL3ks6" class="wolai-block"><span class="wolai-serial-number">10.2</span><span class="inline-wrap">在 </span><span class="inline-wrap"><code>FROM</code></span><span class="inline-wrap"> 子句中使用子查询</span></h2><div id="syGnQ2yE6ABRMj4JibBiqm" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有一个表</span><span class="inline-wrap"><code>orders</code></span><span class="inline-wrap">，我们希望获取每个客户的订单总数。</span></div></div><code-block id="tY4uqAGph7MsjbdDoBAi8z" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> customer_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> order_count
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> customer_id <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_date <span class="token operator">></span> <span class="token string">'2023-01-01'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> recent_orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> customer_id<span class="token punctuation">;</span></pre></div></code-block><div id="wG3nMbf95aE59f28TWKivc" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，子查询首先筛选出最近一年的订单，然后在外部查询中对这些订单进行分组和计数。</span></div></div><h2 id="3ZU98BDFvDsWzq6GrGYcyg" class="wolai-block"><span class="wolai-serial-number">10.3</span><span class="inline-wrap">在 </span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap"> 子句中使用子查询</span></h2><div id="67ZeXbtJ7wqpwiJg6VeM88" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有两个表</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">，我们希望获取所有属于某个特定部门的员工。</span></div></div><code-block id="tcs7SrXHr2cwfhVpsMJ4fk" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> name 
<span class="token keyword">FROM</span> employees 
<span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id 
                       <span class="token keyword">FROM</span> departments 
                       <span class="token keyword">WHERE</span> department_name <span class="token operator">=</span> <span class="token string">'Sales'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="cLSNJNAh9QJ4NujDLMvr1F" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，子查询用于获取名为&#39;Sales&#39;的部门的<span class="jill"></span>ID，然后外部查询根据这个<span class="jill"></span>ID<span class="jill"></span>筛选员工。</span></div></div><h2 id="31yDm819eNSefMsPAWRSjk" class="wolai-block"><span class="wolai-serial-number">10.4</span><span class="inline-wrap">在 </span><span class="inline-wrap"><code>HAVING</code></span><span class="inline-wrap"> 子句中使用子查询</span></h2><div id="9ojfXd1Ux8SNXrxgHkLRFn" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有一个表</span><span class="inline-wrap"><code>sales</code></span><span class="inline-wrap">，我们希望获取销售额超过平均销售额的销售记录。</span></div></div><code-block id="5UoiAJkNHmKQxzp6Jxhp9P" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span> total_sales
<span class="token keyword">FROM</span> sales
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> employee_id<span class="token punctuation">,</span> total_sales
<span class="token keyword">HAVING</span> total_sales <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>total_sales<span class="token punctuation">)</span> <span class="token keyword">FROM</span> sales<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="6oAKPNvopkwMctSMhR4JBP" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，子查询计算了所有销售记录的平均销售额，外部查询则筛选出销售额超过平均值的记录。</span></div></div><h2 id="mt7bQJQEK6n2xuEnMPu5Bq" class="wolai-block"><span class="wolai-serial-number">10.5</span><span class="inline-wrap">相关子查询（Correlated Subquery）</span></h2><div id="uwq5FKF38e1HVAQdr7nqKf" class="wolai-block wolai-text"><div><span class="inline-wrap">相关子查询是指子查询依赖于外部查询的某些列。</span></div></div><div id="72Z1pGuLSihmhAzqf2d7Cs" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有两个表</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">，我们希望获取每个员工及其所属部门的名称。</span></div></div><code-block id="c4Te4Fh9jge29XvWG2DXdS" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> 
       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> d<span class="token punctuation">.</span>department_name 
        <span class="token keyword">FROM</span> departments d 
        <span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>id <span class="token operator">=</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> department_name
<span class="token keyword">FROM</span> employees e<span class="token punctuation">;</span></pre></div></code-block><div id="toKbJYFC9nkKkWLw3fn8wS" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，子查询中的</span><span class="inline-wrap"><code>d.id = e.department_id</code></span><span class="inline-wrap">使得子查询依赖于外部查询的</span><span class="inline-wrap"><code>e.department_id</code></span><span class="inline-wrap">列，因此这是一个相关子查询。</span></div></div><div id="2hhpDcBh4sxWAocefu7Y6Q" class="wolai-block wolai-text"><div><span class="inline-wrap">通过这些示例，可以看到子查询在<span class="jill"></span>SQL<span class="jill"></span>中的强大功能和灵活性。它们可以帮助解决复杂的数据检索问题，使查询更加简洁和高效。</span></div></div><div id="939PqbBh1itB7u64zDcaH2" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wZkrCaTXNBMWitc61Aq3kN" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">请解释什么是索引（Index）以及在什么情况下使用索引。</span></h1><div id="dHvsVXt2DpNetmNM12LM1J" class="wolai-block wolai-text"><div><span class="inline-wrap">索引（Index）是一种特殊的数据结构，通过指针将数据位置与索引键关联起来，使得查询操作更加高效。可以将索引看作是书籍的目录，帮助快速找到所需的信息。合理地创建和使用索引，可以大幅度提升查询效率，但过多或不当的索引会影响数据修改的性能。</span></div></div><h2 id="bgMEZZ3HSEw5engRuUC7By" class="wolai-block"><span class="wolai-serial-number">11.1</span><span class="inline-wrap">索引的工作原理</span></h2><ol class="wolai-block"><li id="iifGNQHuwQpdDBa744hvf7"><div class="marker"></div><span class="inline-wrap"><b>B<span class="jill"></span>树索引</b></span><span class="inline-wrap">：B<span class="jill"></span>树是一种自平衡的树形数据结构，适合于数据库索引。它能保持数据有序，并允许高效的插入、删除和查找操作。B<span class="jill"></span>树的高度通常较低，使得查找操作非常迅速。</span></li><li id="wLcEmpDST9t2wcmQc5bE7f"><div class="marker"></div><span class="inline-wrap"><b>哈希索引</b></span><span class="inline-wrap">：哈希索引是一种使用哈希表实现的索引类型，主要用于快速查找等值查询。哈希索引使用哈希表结构来存储数据，能够提供快速的等值查询，时间复杂度为<span class="jill"></span>O(1)。但不支持范围查询，适用于简单的等值查询场景。</span></li><li id="n3PkGdh2VpNLSZpBYs2P8r"><div class="marker"></div><span class="inline-wrap"><b>全文索引</b></span><span class="inline-wrap">：全文索引专门用于文本搜索，适合处理大量文本数据的模糊搜索。它通过存储词项及其对应文档的位置，提高了搜索效率，适合处理复杂的文本查询需求。</span></li></ol><h2 id="MucnD69E9ogg2uRNhUvcQ" class="wolai-block"><span class="wolai-serial-number">11.2</span><span class="inline-wrap">索引的使用情况</span></h2><ol class="wolai-block"><li id="hoUVRDgRbQHZHoEVsGspgL"><div class="marker"></div><span class="inline-wrap"><b>频繁作为查询条件的字段</b></span><span class="inline-wrap">：如果某些列经常被用作查询条件，如</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">子句中的列，那么在这些列上创建索引可以显著提高查询速度。</span></li><li id="q2XTztCSjFpGQGMLPysP5L"><div class="marker"></div><span class="inline-wrap"><b>排序和分组操作</b></span><span class="inline-wrap">：在经常需要排序（</span><span class="inline-wrap"><code>ORDER BY</code></span><span class="inline-wrap">）或分组（</span><span class="inline-wrap"><code>GROUP BY</code></span><span class="inline-wrap">）的列上创建索引，可以加快这些操作的速度。</span></li><li id="3awNMRPTqcAeVN7DEnj5sE"><div class="marker"></div><span class="inline-wrap"><b>多表连接</b></span><span class="inline-wrap">：如果查询涉及多个表的连接操作，特别是在连接条件中的列上创建索引，可以提高连接操作的性能。</span></li><li id="7cEVrcFeZ4HNYjCx7BPKEP"><div class="marker"></div><span class="inline-wrap"><b>主键和唯一性约束</b></span><span class="inline-wrap">：主键索引确保每行数据的唯一性，而唯一索引则防止列中出现重复的值。这两者都可以提高查询效率。</span></li></ol><div id="8Ye6nHgBtv7ScZE9PJrQqt" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，通过合理使用索引，可以显著提高数据库查询的效率，从而优化整个系统的性能。</span></div></div><div id="3WUqEL6mGUrCyJrjxm7eJM" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="mLkjuJtx3f6ZPuEEL5uWSP" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中创建和删除数据库？</span></h1><div id="m8e1KxmtcKCmQkS2vM6Vod" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，创建和删除数据库是常见的管理任务。以下是如何在<span class="jill"></span>SQL<span class="jill"></span>中执行这些操作的详细步骤和示例：</span></div></div><h2 id="kNZNRhntC4cNEGytFxM8fU" class="wolai-block"><span class="wolai-serial-number">12.1</span><span class="inline-wrap">创建数据库</span></h2><div id="a626zcQ2TpFu7SCrWVuYr1" class="wolai-block wolai-text"><div><span class="inline-wrap">要创建一个新的数据库，可以使用</span><span class="inline-wrap"><code>CREATE DATABASE</code></span><span class="inline-wrap">语句。以下是一个基本的语法示例：</span></div></div><code-block id="wLD1ynFFrnWDp7Z5Dz9QV3" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> database_name<span class="token punctuation">;</span></pre></div></code-block><div id="nAP8djUejiA3qku62XNtTH" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：创建一个名为</span><span class="inline-wrap"><code>testdb</code></span><span class="inline-wrap">的数据库。</span></div></div><code-block id="eDxk3QUEJFr2hhcfQkFZgJ" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h2 id="8V4vjZ9oQxxmhAR18QSCd6" class="wolai-block"><span class="wolai-serial-number">12.2</span><span class="inline-wrap">删除数据库</span></h2><div id="sqpZ1ZNFtcZYBy7weHTpKj" class="wolai-block wolai-text"><div><span class="inline-wrap">要删除一个数据库，可以使用</span><span class="inline-wrap"><code>DROP DATABASE</code></span><span class="inline-wrap">语句。请注意，删除数据库是一个不可逆的操作，所有数据将永久丢失，因此应谨慎使用。</span></div></div><code-block id="sXuyAyRJsdCKuGC94mGQ3M" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> database_name<span class="token punctuation">;</span></pre></div></code-block><div id="rvoSJ1cXM9csvJ1mpByiEn" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：删除名为</span><span class="inline-wrap"><code>testdb</code></span><span class="inline-wrap">的数据库。</span></div></div><code-block id="fduv5hoFmc7qxrhigFtws3" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h2 id="94GL33efFQtHeCXFsaFRRE" class="wolai-block"><span class="wolai-serial-number">12.3</span><span class="inline-wrap">检查数据库是否存在</span></h2><div id="tBzhnq5FkBukPAyVc6w5EA" class="wolai-block wolai-text"><div><span class="inline-wrap">在删除数据库之前，通常需要确认数据库是否存在，以避免错误。不同的数据库管理系统（DBMS）有不同的方法来检查数据库的存在性。以下是一些常见的<span class="jill"></span>DBMS<span class="jill"></span>的示例：</span></div></div><h3 id="r2QZ5HFwNXraHE9QUcuv81" class="wolai-block"><span class="wolai-serial-number">12.3.1</span><span class="inline-wrap">MySQL</span></h3><div id="pPU8gQ32zxKs5DuNcxiM2i" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，可以使用</span><span class="inline-wrap"><code>IF EXISTS</code></span><span class="inline-wrap">子句来避免错误：</span></div></div><code-block id="nwxMo9woBXUPQkCgm2cd73" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h3 id="8wTZbiz9qQxyNV9XezDwq1" class="wolai-block"><span class="wolai-serial-number">12.3.2</span><span class="inline-wrap">PostgreSQL</span></h3><div id="jQPCBm6zUcFL33TbCnXoo3" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>PostgreSQL<span class="jill"></span>中，也可以使用</span><span class="inline-wrap"><code>IF EXISTS</code></span><span class="inline-wrap">子句：</span></div></div><code-block id="61xNEKPT565H72DdfW61z4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h3 id="sv7qNozjChaAbbFKLY2d4V" class="wolai-block"><span class="wolai-serial-number">12.3.3</span><span class="inline-wrap">SQL Server</span></h3><div id="5XZDKpaE7iwgtaC5ZYRGxq" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL Server<span class="jill"></span>中，可以使用</span><span class="inline-wrap"><code>IF DB_ID</code></span><span class="inline-wrap">函数来检查数据库是否存在：</span></div></div><code-block id="bVMTeySb8eCYFGiT2nuqKo" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">IF</span> DB_ID<span class="token punctuation">(</span><span class="token string">'testdb'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="b5VFdQ7yWbCcbpQHG3B1pM" class="wolai-block"><span class="wolai-serial-number">12.4</span><span class="inline-wrap">完整示例</span></h2><div id="sBVDE8bALnGPb2VHXVAWE6" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个完整的示例，展示如何创建和删除数据库，并确保在删除前检查其存在性：</span></div></div><h3 id="vGHtnuXiC2n8UnVGFH1MPT" class="wolai-block"><span class="wolai-serial-number">12.4.1</span><span class="inline-wrap">MySQL 示例</span></h3><code-block id="w6PAk9ooznSJhMfYEqvkQ8" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token comment">-- 创建数据库</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>

<span class="token comment">-- 检查并删除数据库</span>
<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h3 id="r4Q3x3XTry14Vqzv95vSRR" class="wolai-block"><span class="wolai-serial-number">12.4.2</span><span class="inline-wrap">PostgreSQL 示例</span></h3><code-block id="tpz1HMQ7dRhMZVeoX8sHnQ" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token comment">-- 创建数据库</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>

<span class="token comment">-- 检查并删除数据库</span>
<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> testdb<span class="token punctuation">;</span></pre></div></code-block><h3 id="kJpfwxA5rAPt9CHKYKH6sk" class="wolai-block"><span class="wolai-serial-number">12.4.3</span><span class="inline-wrap">SQL Server 示例</span></h3><code-block id="kpMpPXcwp174wrMiWFxHud" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token comment">-- 创建数据库</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>

<span class="token comment">-- 检查并删除数据库</span>
<span class="token keyword">IF</span> DB_ID<span class="token punctuation">(</span><span class="token string">'testdb'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span></pre></div></code-block><div id="gxkz8aiFqqD8EwD1a63Eaf" class="wolai-block wolai-text"><div><span class="inline-wrap">通过这些步骤和示例，你可以在<span class="jill"></span>SQL<span class="jill"></span>中有效地创建和删除数据库。请务必小心操作，特别是在删除数据库时，以免误删重要数据。</span></div></div><div id="9cjTUGA9YfPpo4BD1a7Y7n" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="f8ogBFZPL2kxKrsL8XB6At" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">请解释什么是视图（View），以及如何在<span class="jill"></span>SQL<span class="jill"></span>中创建和使用视图。</span></h1><div id="hkngD6YLvNarxTocrpBmQ8" class="wolai-block wolai-text"><div><span class="inline-wrap">视图（View）是一种虚拟表，它是基于<span class="jill"></span>SQL<span class="jill"></span>查询的结果集。视图并不存储数据本身，而是存储一个查询定义。当你查询视图时，数据库系统会动态地执行该查询并返回结果。视图可以简化复杂查询、提高代码可读性以及增强数据安全性。</span></div></div><h2 id="fEvaUJ41XQwKYZ4kdzBELu" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">创建视图</span></h2><div id="pVWYjEvY87sBt4T5NkjBAe" class="wolai-block wolai-text"><div><span class="inline-wrap">要创建一个视图，可以使用</span><span class="inline-wrap"><code>CREATE VIEW</code></span><span class="inline-wrap">语句。以下是基本的语法：</span></div></div><code-block id="5WUQ5n9BbGwcKg5VCi8E2U" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> view_name <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table_name
<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></pre></div></code-block><div id="hxSzP9KBmgn6zTjgiEiuC1" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，我们希望创建一个只包含员工姓名和部门名称的视图。</span></div></div><code-block id="u7RRfo3dVoWX9b7zbZLpXe" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> employee_view <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> d<span class="token punctuation">.</span>department_name
<span class="token keyword">FROM</span> employees e
<span class="token keyword">JOIN</span> departments d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>department_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span></pre></div></code-block><div id="caz9UXrVW9xAvjrFu1pg5S" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，</span><span class="inline-wrap"><code>employee_view</code></span><span class="inline-wrap">是一个视图，它包含了</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">表中的员工姓名和</span><span class="inline-wrap"><code>departments</code></span><span class="inline-wrap">表中的部门名称。</span></div></div><h2 id="4LCZc6Prh5y1v7x4U4DL2M" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">使用视图</span></h2><div id="cznbaJLXYAgfMPLKDgUrKt" class="wolai-block wolai-text"><div><span class="inline-wrap">一旦视图创建完成，你可以像查询普通表一样查询视图。例如：</span></div></div><code-block id="tv26P8ixD4Rcu8RkzDnKQr" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee_view<span class="token punctuation">;</span></pre></div></code-block><div id="h2kCYf8HRUNs2h9tFsxfsG" class="wolai-block wolai-text"><div><span class="inline-wrap">这将返回视图中的所有记录。</span></div></div><h2 id="sikMYPDqzJpCbigZ7UCrYV" class="wolai-block"><span class="wolai-serial-number">13.3</span><span class="inline-wrap">更新视图</span></h2><div id="d9dUSe6pwZJBJn4nVDkhp9" class="wolai-block wolai-text"><div><span class="inline-wrap">某些视图是可更新的，这意味着你可以通过视图来插入、更新或删除数据。然而，并不是所有视图都是可更新的。可更新视图通常需要满足以下条件：</span></div></div><ol class="wolai-block"><li id="x6MEpaDWMkbzmYBE7BgQRb"><div class="marker"></div><span class="inline-wrap"><b>简单视图</b></span><span class="inline-wrap">：视图必须基于单个表。</span></li><li id="iKaqresnWRCrEvvYwoarUb"><div class="marker"></div><span class="inline-wrap"><b>无聚合函数</b></span><span class="inline-wrap">：视图不能包含聚合函数（如</span><span class="inline-wrap"><code>SUM</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>AVG</code></span><span class="inline-wrap">等）。</span></li><li id="h16s8Uub9yV6DaRQ6TAgwo"><div class="marker"></div><span class="inline-wrap"><b>无子查询</b></span><span class="inline-wrap">：视图不能包含子查询。</span></li><li id="4UokzW3qpzxfubqSusVVeN"><div class="marker"></div><span class="inline-wrap"><b>无<span class="jill"></span>DISTINCT</b></span><span class="inline-wrap">：视图不能包含</span><span class="inline-wrap"><code>DISTINCT</code></span><span class="inline-wrap">关键字。</span></li><li id="dJFSdxge6ULq8ZArc7euXu"><div class="marker"></div><span class="inline-wrap"><b>无<span class="jill"></span>GROUP BY</b></span><span class="inline-wrap">：视图不能包含</span><span class="inline-wrap"><code>GROUP BY</code></span><span class="inline-wrap">子句。</span></li><li id="5WFJxSA3skrnBtcW5sALBk"><div class="marker"></div><span class="inline-wrap"><b>无<span class="jill"></span>HAVING</b></span><span class="inline-wrap">：视图不能包含</span><span class="inline-wrap"><code>HAVING</code></span><span class="inline-wrap">子句。</span></li><li id="4ME1RWQKqMphKrVhLeiN6T"><div class="marker"></div><span class="inline-wrap"><b>无<span class="jill"></span>UNION</b></span><span class="inline-wrap">：视图不能包含</span><span class="inline-wrap"><code>UNION</code></span><span class="inline-wrap">操作。</span></li><li id="nm9Zyp5hb3rDmAHxXDRJbw"><div class="marker"></div><span class="inline-wrap"><b>无连接</b></span><span class="inline-wrap">：视图不能包含多表连接。</span></li><li id="6QEGZjfioJ4k1RwZrai5Wp"><div class="marker"></div><span class="inline-wrap"><b>无计算列</b></span><span class="inline-wrap">：视图不能包含计算列。</span></li></ol><div id="v8vSxr9SBF9dU8Abssbt1" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，并且我们希望通过视图更新员工的薪水。</span></div></div><code-block id="iwX84fpuVsS1BLMccEjx7h" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> employee_salary_view <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> salary
<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span></pre></div></code-block><div id="9o1PJQLfae7y15Bz7TsNQV" class="wolai-block wolai-text"><div><span class="inline-wrap">现在，我们可以使用视图来更新员工的薪水：</span></div></div><code-block id="wGvmTbeVyHmb62gBUSVTK4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> employee_salary_view
<span class="token keyword">SET</span> salary <span class="token operator">=</span> salary <span class="token operator">*</span> <span class="token number">1.1</span>
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'John Doe'</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="o68bMD6XFWeZhwjA5kxhDP" class="wolai-block"><span class="wolai-serial-number">13.4</span><span class="inline-wrap">删除视图</span></h2><div id="vD14vXAM8cyZGpxJGchFnF" class="wolai-block wolai-text"><div><span class="inline-wrap">要删除一个视图，可以使用</span><span class="inline-wrap"><code>DROP VIEW</code></span><span class="inline-wrap">语句。以下是基本的语法：</span></div></div><code-block id="tWQg5nrBEQdwbmY6FDiffQ" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> view_name<span class="token punctuation">;</span></pre></div></code-block><div id="meLyB5XpuS1q5LRJW9BkSr" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：删除名为</span><span class="inline-wrap"><code>employee_view</code></span><span class="inline-wrap">的视图。</span></div></div><code-block id="aC9CuRf23SB91zhyg73SmH" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> employee_view<span class="token punctuation">;</span></pre></div></code-block><h2 id="aipWo1DK7utwzbGntv3XaE" class="wolai-block"><span class="wolai-serial-number">13.5</span><span class="inline-wrap">总结</span></h2><div id="w4XNfvgFx2TcUeDE3yKWYW" class="wolai-block wolai-text"><div><span class="inline-wrap">视图在<span class="jill"></span>SQL<span class="jill"></span>中是一个非常有用的工具，可以帮助简化复杂查询、提高代码可读性和增强数据安全性。通过创建和使用视图，你可以更方便地管理和访问数据库中的数据。</span></div></div><div id="tG7BeqduadkMoFc8bQ36rZ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vFVjgpxCAogp2cut7hj12t" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">SQL<span class="jill"></span>中的约束（Constraints）有哪些类型，它们的作用是什么？</span></h1><div id="9HviLVYiAnbAEj9J82KxAH" class="wolai-block wolai-text"><div><span class="inline-wrap">SQL<span class="jill"></span>中的约束（Constraints）是用于保证数据库中数据完整性、准确性和一致性的规则。常见的约束类型包括以下几种：</span></div></div><ol class="wolai-block"><li id="orsPpapdLp3LJkUqqVeAaK"><div class="marker"></div><span class="inline-wrap"><b>主键约束</b></span><span class="inline-wrap">：用于唯一标识表中的每一条记录，确保每行数据的唯一性和完整性。一个表中只能有一个主键，主键列的值不能为空，且必须是唯一的。</span></li><li id="pMBX96Jfqpp6nTqBx9FQBR"><div class="marker"></div><span class="inline-wrap"><b>外键约束</b></span><span class="inline-wrap">：用于建立表与表之间的关系，保证数据的参照完整性。外键列的值必须在被参照表的主键或唯一键中有对应的值，确保了相关表之间的数据一致性。</span></li><li id="tizYaVsSUsEyu7frrYjCC9"><div class="marker"></div><span class="inline-wrap"><b>唯一性约束</b></span><span class="inline-wrap">：确保在非主键列中不输入重复的值，允许空值，但每列只允许一个空值。主要用于防止在列中输入重复的值，保证数据的唯一性和识别性。</span></li><li id="gTz7ucM5rbL4tRkugHW3ji"><div class="marker"></div><span class="inline-wrap"><b>检查约束</b></span><span class="inline-wrap">：确保字段中的值满足特定的条件，只有满足条件的值才允许插入或更新到该字段。可以基于逻辑表达式定义业务规则，从而确保数据符合特定的要求或标准。</span></li><li id="qJkimMMKQvphWUtDaPQrsT"><div class="marker"></div><span class="inline-wrap"><b>非空约束</b></span><span class="inline-wrap">：设置某列不能为空，确保指定列必须有值，不能为<span class="jill"></span>NULL。是一种强制性的约束，要求列中的值必须被指定，不能为<span class="jill"></span>NULL。</span></li><li id="8mVL5sdmR4kCGJkTycJ5Qd"><div class="marker"></div><span class="inline-wrap"><b>默认值约束</b></span><span class="inline-wrap">：为没有提供输入值的字段或列提供默认值。当插入新产品时，如果没有指定库存数量，则会默认给<span class="jill"></span>0。</span></li></ol><div id="uX5RQX2nrDNoSVMx366ibD" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，合理地使用这些约束可以确保数据库中的数据质量和可靠性，同时提高查询性能和数据管理的效率。</span></div></div><div id="fzcYseQZuUrrFTGcmRSJQk" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="5eky8rNPVxZYc6xDihPmDB" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">请描述<span class="jill"></span>SQL<span class="jill"></span>中<span class="jill"></span>CASE<span class="jill"></span>语句的使用场景，并给出一个示例。</span></h1><div id="6N7ELtdh1wwJUEpv57rDxY" class="wolai-block wolai-text"><div><span class="inline-wrap">SQL<span class="jill"></span>中的<span class="jill"></span>CASE<span class="jill"></span>语句是一种条件表达式，用于在查询中根据不同的条件返回不同的结果。它类似于编程语言中的</span><span class="inline-wrap"><code>switch</code></span><span class="inline-wrap">或</span><span class="inline-wrap"><code>if-else</code></span><span class="inline-wrap">结构，可以在<span class="jill"></span>SELECT、UPDATE、DELETE<span class="jill"></span>等<span class="jill"></span>SQL<span class="jill"></span>语句中使用。</span></div></div><h2 id="aatEciuKwu4LyfjHMKBVJy" class="wolai-block"><span class="wolai-serial-number">15.1</span><span class="inline-wrap">使用场景</span></h2><ol class="wolai-block"><li id="kEQRt7yWL6s2N4L8KnZvs1"><div class="marker"></div><span class="inline-wrap"><b>数据转换</b></span><span class="inline-wrap">：将数据库中的代码值转换为更具可读性的文本描述。例如，将性别代码（&#39;M&#39;/&#39;F&#39;）转换为对应的文本描述（&#39;Male&#39;/&#39;Female&#39;）。</span></li><li id="eVXtcsUw2hxnhZx4ebvMMT"><div class="marker"></div><span class="inline-wrap"><b>条件计算</b></span><span class="inline-wrap">：根据不同条件对数据进行不同的计算或处理。例如，根据员工的绩效等级计算奖金。</span></li><li id="eag7dXgm64K1etEnvMUbrc"><div class="marker"></div><span class="inline-wrap"><b>分组统计</b></span><span class="inline-wrap">：在聚合查询中，根据不同条件对数据进行分类统计。例如，统计每个部门的员工数量，并根据员工是否满<span class="jill"></span>30<span class="jill"></span>岁进行分类。</span></li><li id="2HmXCs3Twx3sNUSQFPUz69"><div class="marker"></div><span class="inline-wrap"><b>动态排序</b></span><span class="inline-wrap">：根据不同的条件对查询结果进行动态排序。例如，根据用户输入的排序字段和顺序对查询结果进行排序。</span></li></ol><h2 id="wuVX3xMEpYmdmJvcH3gU3u" class="wolai-block"><span class="wolai-serial-number">15.2</span><span class="inline-wrap">示例</span></h2><div id="xgg1XzE4vtfEJQ6kYSg4Nu" class="wolai-block wolai-text"><div><span class="inline-wrap">假设我们有一个名为</span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap">的表，包含以下列：</span></div></div><ul class="wolai-block"><li id="7AuRNdE8jp3S4X5cPPM5r3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">: 员工<span class="jill"></span>ID</span></li><li id="ruzjoQeqonbyM1FMHzQ9fp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>name</code></span><span class="inline-wrap">: 员工姓名</span></li><li id="a2f5ruhnYm2p2Fxr3sJvEs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>gender</code></span><span class="inline-wrap">: 性别代码 (&#39;M&#39;表示男性, &#39;F&#39;表示女性)</span></li><li id="q4aNgKP5dRbM2JUTPmTEc5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>salary</code></span><span class="inline-wrap">: 工资</span></li><li id="6hUqBGqGRZqq12eyKbjrfU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>performance_rating</code></span><span class="inline-wrap">: 绩效评级 (1<span class="jill"></span>到<span class="jill"></span>5)</span></li></ul><div id="7P9f6NMprf9XJbrQJJ2FLL" class="wolai-block wolai-text"><div><span class="inline-wrap">我们希望创建一个查询，显示员工的姓名、性别（文本描述）、工资以及根据绩效评级计算的奖金。奖金规则如下：</span></div></div><ul class="wolai-block"><li id="eXFiGFqkzCZQjDz2Jmh4Nv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">绩效评级为<span class="jill"></span>1<span class="jill"></span>或<span class="jill"></span>2<span class="jill"></span>时，奖金为工资的<span class="jill"></span>10%</span></li><li id="pfbRDQfanGnc7Ez7hY7q38"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">绩效评级为<span class="jill"></span>3<span class="jill"></span>或<span class="jill"></span>4<span class="jill"></span>时，奖金为工资的<span class="jill"></span>20%</span></li><li id="qyYPgG2KjRXpGUeb7uF4qD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">绩效评级为<span class="jill"></span>5<span class="jill"></span>时，奖金为工资的<span class="jill"></span>30%</span></li></ul><div id="9qjS5ZcdT2h15ovjwkT9Nw" class="wolai-block wolai-text"><div><span class="inline-wrap">我们可以使用<span class="jill"></span>CASE<span class="jill"></span>语句来实现这个需求：</span></div></div><code-block id="3xX5UXugrwBzwtUquQAg3" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> 
    name<span class="token punctuation">,</span>
    <span class="token keyword">CASE</span> gender
        <span class="token keyword">WHEN</span> <span class="token string">'M'</span> <span class="token keyword">THEN</span> <span class="token string">'Male'</span>
        <span class="token keyword">WHEN</span> <span class="token string">'F'</span> <span class="token keyword">THEN</span> <span class="token string">'Female'</span>
        <span class="token keyword">ELSE</span> <span class="token string">'Unknown'</span>
    <span class="token keyword">END</span> <span class="token keyword">AS</span> gender_description<span class="token punctuation">,</span>
    salary<span class="token punctuation">,</span>
    <span class="token keyword">CASE</span> performance_rating
        <span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> salary <span class="token operator">*</span> <span class="token number">0.10</span>
        <span class="token keyword">WHEN</span> <span class="token number">2</span> <span class="token keyword">THEN</span> salary <span class="token operator">*</span> <span class="token number">0.10</span>
        <span class="token keyword">WHEN</span> <span class="token number">3</span> <span class="token keyword">THEN</span> salary <span class="token operator">*</span> <span class="token number">0.20</span>
        <span class="token keyword">WHEN</span> <span class="token number">4</span> <span class="token keyword">THEN</span> salary <span class="token operator">*</span> <span class="token number">0.20</span>
        <span class="token keyword">WHEN</span> <span class="token number">5</span> <span class="token keyword">THEN</span> salary <span class="token operator">*</span> <span class="token number">0.30</span>
        <span class="token keyword">ELSE</span> <span class="token number">0</span>
    <span class="token keyword">END</span> <span class="token keyword">AS</span> bonus
<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span></pre></div></code-block><div id="sVZmjhJ566neQwSkCPoXCr" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个查询中：</span></div></div><ul class="wolai-block"><li id="c9hBHFgvJAKxbQqc474Jxr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第一个<span class="jill"></span>CASE<span class="jill"></span>语句将</span><span class="inline-wrap"><code>gender</code></span><span class="inline-wrap">列中的代码值转换为文本描述。</span></li><li id="t96mKxWkPJUTvBhRFW1Lc1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第二个<span class="jill"></span>CASE<span class="jill"></span>语句根据</span><span class="inline-wrap"><code>performance_rating</code></span><span class="inline-wrap">列的值计算奖金。</span></li></ul><div id="fLx5H9xhmeCmg4BuUPL9dG" class="wolai-block wolai-text"><div><span class="inline-wrap">执行上述查询后，结果集将包含每个员工的姓名、性别描述、工资和计算出的奖金。</span></div></div><div id="26mCiibXsi22YNmK2NkyKf" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="d7CsQ4RtjfdJj25z59LZxZ" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">如何通过<span class="jill"></span>SQL<span class="jill"></span>语句实现数据的分组和聚合？</span></h1><div id="4QcCLSZpCkLVZvwt5inEbw" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，通过使用</span><span class="inline-wrap"><code>GROUP BY</code></span><span class="inline-wrap">子句和聚合函数（如</span><span class="inline-wrap"><code>COUNT</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>SUM</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>AVG</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>MAX</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>MIN</code></span><span class="inline-wrap">等），可以实现数据的分组和聚合。这些操作通常用于生成汇总报告或统计数据。</span></div></div><h2 id="qjU42SSHN9E7SwoEP1XhdT" class="wolai-block"><span class="wolai-serial-number">16.1</span><span class="inline-wrap">基本语法</span></h2><code-block id="aGprsQVHibTqJ7iwfHCJz6" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> aggregate_function<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> table_name
<span class="token keyword">WHERE</span> condition
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></pre></div></code-block><ul class="wolai-block"><li id="mFE82B4tVbPnFiS3g78Pro"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>column1, column2, ...</code></span><span class="inline-wrap">：要分组的列。</span></li><li id="q7z6VMBE1W1vgRRtHZd3RS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>aggregate_function(column)</code></span><span class="inline-wrap">：应用于每个组的聚合函数。</span></li><li id="gJs3rzQAmtezsqiZbUQsQC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>table_name</code></span><span class="inline-wrap">：数据来源表。</span></li><li id="cSQwP1MiiErbN7KdAS8LDg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>condition</code></span><span class="inline-wrap">：可选的条件过滤。</span></li><li id="pUKNivsFzHVomGtN2RVWnx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>GROUP BY column1, column2, ...</code></span><span class="inline-wrap">：指定分组依据的列。</span></li></ul><h2 id="wdewR4C7Lr7PRH64T7D2ow" class="wolai-block"><span class="wolai-serial-number">16.2</span><span class="inline-wrap">示例</span></h2><div id="9qiTxx6RSfyHieK2TytJJF" class="wolai-block wolai-text"><div><span class="inline-wrap">假设我们有一个名为</span><span class="inline-wrap"><code>sales</code></span><span class="inline-wrap">的表，包含以下列：</span></div></div><ul class="wolai-block"><li id="352vTThZhFMumqbpUo3LAj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>id</code></span><span class="inline-wrap">: 销售记录<span class="jill"></span>ID</span></li><li id="frQSVbAFRJuRmWVUCVSw6H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>product_id</code></span><span class="inline-wrap">: 产品<span class="jill"></span>ID</span></li><li id="qKpGn6Dm3W9XU2Ri8ALsLB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>quantity</code></span><span class="inline-wrap">: 销售数量</span></li><li id="iF3KSdvYn2sQph3T7QNsHz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>price</code></span><span class="inline-wrap">: 单价</span></li><li id="fEkhVfs3HJ8G5Hsk1mQdKB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>sale_date</code></span><span class="inline-wrap">: 销售日期</span></li></ul><div id="ofDHr8Vt78AbNDhDw8Fkiw" class="wolai-block wolai-text"><div><span class="inline-wrap">我们希望按产品<span class="jill"></span>ID<span class="jill"></span>分组，计算每种产品的总销售额和平均价格。可以使用以下<span class="jill"></span>SQL<span class="jill"></span>语句：</span></div></div><code-block id="mJAr6GmCocSYVufYLkTjVV" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> 
    product_id<span class="token punctuation">,</span>
    <span class="token function">SUM</span><span class="token punctuation">(</span>quantity <span class="token operator">*</span> price<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span>
    <span class="token function">AVG</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">AS</span> average_price
<span class="token keyword">FROM</span> sales
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_id<span class="token punctuation">;</span></pre></div></code-block><div id="jyh8nRtYz8z4f2znPe7CX4" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个查询中：</span></div></div><ul class="wolai-block"><li id="f9wNYrwXbX7y9tu3MMaZYH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>product_id</code></span><span class="inline-wrap">：我们要分组的列。</span></li><li id="5r5SiPKjmE2n6SR7a19h2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SUM(quantity * price) AS total_sales</code></span><span class="inline-wrap">：计算每种产品的总销售额。</span></li><li id="exMCDP2F1fXGc5EXcCUH7Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>AVG(price) AS average_price</code></span><span class="inline-wrap">：计算每种产品的平均价格。</span></li><li id="qZxabphQPeTUZUXuzHVgnw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>GROUP BY product_id</code></span><span class="inline-wrap">：按产品<span class="jill"></span>ID<span class="jill"></span>进行分组。</span></li></ul><h2 id="gPHGxwLhgEXMy4bSUhz3jE" class="wolai-block"><span class="wolai-serial-number">16.3</span><span class="inline-wrap">更复杂的示例</span></h2><div id="ewHoLK9bWmgz587bvLEivd" class="wolai-block wolai-text"><div><span class="inline-wrap">假设我们想要进一步按年份和月份分组，并计算每个月的总销售额和平均价格。我们可以使用</span><span class="inline-wrap"><code>YEAR()</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>MONTH()</code></span><span class="inline-wrap">函数从日期中提取年份和月份，然后进行分组：</span></div></div><code-block id="bm8D4QP62bRuaCDnFcYsuB" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> 
    <span class="token keyword">YEAR</span><span class="token punctuation">(</span>sale_date<span class="token punctuation">)</span> <span class="token keyword">AS</span> sale_year<span class="token punctuation">,</span>
    <span class="token keyword">MONTH</span><span class="token punctuation">(</span>sale_date<span class="token punctuation">)</span> <span class="token keyword">AS</span> sale_month<span class="token punctuation">,</span>
    product_id<span class="token punctuation">,</span>
    <span class="token function">SUM</span><span class="token punctuation">(</span>quantity <span class="token operator">*</span> price<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span>
    <span class="token function">AVG</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">AS</span> average_price
<span class="token keyword">FROM</span> sales
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>sale_date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>sale_date<span class="token punctuation">)</span><span class="token punctuation">,</span> product_id<span class="token punctuation">;</span></pre></div></code-block><div id="uN16PTwu1DfbVfoF6H8TaP" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个查询中：</span></div></div><ul class="wolai-block"><li id="7ZHTgUjsjGizB8nzFHknyX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>YEAR(sale_date) AS sale_year</code></span><span class="inline-wrap">：提取销售日期的年份。</span></li><li id="he3Sj79cWWFxVs8c2kFy24"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>MONTH(sale_date) AS sale_month</code></span><span class="inline-wrap">：提取销售日期的月份。</span></li><li id="5BtJff1o2AtV1yphp3TYCr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>SUM(quantity * price) AS total_sales</code></span><span class="inline-wrap">：计算每个月每种产品的总销售额。</span></li><li id="b6j47AW23HZtHzqDLwBrep"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>AVG(price) AS average_price</code></span><span class="inline-wrap">：计算每个月每种产品的平均价格。</span></li><li id="8PiuFB3cR9NZfgGseoQ1F2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>GROUP BY YEAR(sale_date), MONTH(sale_date), product_id</code></span><span class="inline-wrap">：按年份、月份和产品<span class="jill"></span>ID<span class="jill"></span>进行分组。</span></li></ul><h2 id="mwXUfDygTRiDQC9ffNh9Bg" class="wolai-block"><span class="wolai-serial-number">16.4</span><span class="inline-wrap">注意事项</span></h2><ol class="wolai-block"><li id="ew57MHwrZJvvvRqf4JnFpM"><div class="marker"></div><span class="inline-wrap"><b>选择列</b></span><span class="inline-wrap">：在</span><span class="inline-wrap"><code>SELECT</code></span><span class="inline-wrap">子句中，除了聚合函数外，其他列必须出现在</span><span class="inline-wrap"><code>GROUP BY</code></span><span class="inline-wrap">子句中，否则会导致错误。</span></li><li id="5soQDwF2cu29bp6uKMh6h"><div class="marker"></div><span class="inline-wrap"><b>HAVING<span class="jill"></span>子句</b></span><span class="inline-wrap">：如果需要对分组后的结果进行过滤，可以使用</span><span class="inline-wrap"><code>HAVING</code></span><span class="inline-wrap">子句。它类似于</span><span class="inline-wrap"><code>WHERE</code></span><span class="inline-wrap">子句，但作用于分组后的结果。例如，只显示总销售额大于<span class="jill"></span>1000<span class="jill"></span>的产品：</span><code-block id="xbtGwcFj7JYnNJd3Kwg7m3" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> 
    product_id<span class="token punctuation">,</span>
    <span class="token function">SUM</span><span class="token punctuation">(</span>quantity <span class="token operator">*</span> price<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span>
    <span class="token function">AVG</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">AS</span> average_price
<span class="token keyword">FROM</span> sales
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_id
<span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity <span class="token operator">*</span> price<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="x57umqkPjbHCzemksPUHrj"><div class="marker"></div><span class="inline-wrap"><b>ORDER BY<span class="jill"></span>子句</b></span><span class="inline-wrap">：可以使用</span><span class="inline-wrap"><code>ORDER BY</code></span><span class="inline-wrap">子句对结果进行排序。例如，按总销售额降序排列：</span><code-block id="qpRrS9R2osxcrsdy9VoKhg" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> 
    product_id<span class="token punctuation">,</span>
    <span class="token function">SUM</span><span class="token punctuation">(</span>quantity <span class="token operator">*</span> price<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales<span class="token punctuation">,</span>
    <span class="token function">AVG</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token keyword">AS</span> average_price
<span class="token keyword">FROM</span> sales
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_id
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> total_sales <span class="token keyword">DESC</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><div id="iEAS7D8QexPEPmfBmuP1bd" class="wolai-block wolai-text"><div><span class="inline-wrap">通过这些技巧，您可以灵活地使用<span class="jill"></span>SQL<span class="jill"></span>语句实现数据的分组和聚合，从而满足各种数据分析需求。</span></div></div><div id="sMs3exXoRZCX7vQG6o1aop" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="r9crixAWiyTccCotUoYgR5" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">请解释什么是规范化（Normalization），并简述其过程。</span></h1><div id="tna5aJUiSWzdz78t5pH3pz" class="wolai-block wolai-text"><div><span class="inline-wrap">规范化（Normalization）是指对数值进行特殊函数变换的方法，将原始的某个数值 x 通过某种函数转换，得到规范化后的数值 x_bar。它完成了不同维度数据的规范和统一，但并没有对如何规范作出具体规定。</span></div></div><div id="74aEQ8CbGMu992Ux5jG5KT" class="wolai-block wolai-text"><div><span class="inline-wrap">规范化的过程一般如下：</span></div></div><ol class="wolai-block"><li id="74mZGDQkRmJWF2v7gJen7q"><div class="marker"></div><span class="inline-wrap"><b>确定目标</b></span><span class="inline-wrap">：明确规范化的目的，例如是为了消除数据尺度对算法的影响、提高算法的效率和精度，还是为了使不同特征的数值范围和分布更加一致等。</span></li><li id="6eJMaSgAvU5R6F3MyYD6mM"><div class="marker"></div><span class="inline-wrap"><b>选择方法</b></span><span class="inline-wrap">：根据数据的特点和规范化的目标选择合适的规范化方法，常见的方法包括最小-最大规范化、Z-score 规范化、对数变换、小数定标规范化等。</span></li><li id="fQqNEGLURsSTyD8WeuW7aQ"><div class="marker"></div><span class="inline-wrap"><b>应用变换</b></span><span class="inline-wrap">：使用选定的规范化方法对原始数据进行处理，将每个数据点按照相应的公式进行转换，得到规范化后的数据。</span></li><li id="b8K35uuSzzvMXd25PoBt8M"><div class="marker"></div><span class="inline-wrap"><b>验证效果</b></span><span class="inline-wrap">：检查规范化后的数据是否达到了预期的效果，例如数据的分布是否符合要求、是否存在异常值等。如果需要，可以对规范化过程进行调整和优化。</span></li></ol><div id="8LTT8KWhHeEvgGRQdEtBT8" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，规范化是数据处理中的重要步骤，通过将不同尺度或量纲的数据转化为统一标准，有助于提高机器学习算法的效率和精度，更好地进行数据处理和分析。</span></div></div><div id="mx8ecACHq4XC6aaGS1iyqV" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="2fhNbtvXW9wJ2Lsz7EQftR" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中实现分页查询？</span></h1><div id="pJnDnoMYddfQy5Yy8jAfUH" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是不同数据库分页的不同语法：</span></div></div><ol class="wolai-block"><li id="wiwuZsS9JSvg1Qty7T435e"><div class="marker"></div><span class="inline-wrap"><b>MySQL</b></span><ul class="wolai-block"><li id="3UBnH2uQXcRAK2vcy1fiaU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本语法</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SELECT column1, column2,... FROM table_name ORDER BY column LIMIT offset, row_count;</code></span></li><li id="rGHjPjZBroSfZWFafDnWLp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：假设有一个 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 表，查询第 3 页的数据，每页 10 条记录，可使用 </span><span class="inline-wrap"><code>SELECT * FROM employees ORDER BY employee_id LIMIT 20, 10;</code></span><span class="inline-wrap">。其中 </span><span class="inline-wrap"><code>offset</code></span><span class="inline-wrap"> 表示从第几条记录开始，</span><span class="inline-wrap"><code>row_count</code></span><span class="inline-wrap"> 表示查询返回的记录数。</span></li></ul></li><li id="wajUhiVPzFmEHzxr9AKdcN"><div class="marker"></div><span class="inline-wrap"><b>PostgreSQL</b></span><ul class="wolai-block"><li id="8DpNJG7wiEpWyKh2HZUJts"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本语法</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SELECT column1, column2,... FROM table_name ORDER BY column LIMIT row_count OFFSET offset;</code></span></li><li id="rua668js3vEmdo4FYLTGWk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：同样对于 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 表，查询第 3 页的数据，每页 10 条记录，语句为 </span><span class="inline-wrap"><code>SELECT * FROM employees ORDER BY employee_id LIMIT 10 OFFSET 20;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="bXkqThHHyzr8JECKxyhiFZ"><div class="marker"></div><span class="inline-wrap"><b>Oracle</b></span><ul class="wolai-block"><li id="2muKaeVPQrZfy2QThHaH6a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>子查询 + ROWNUM 方式</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="bkiUrwTY2arKzDLQTywSaG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本语法</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SELECT * FROM ( SELECT a.*, ROWNUM rnum FROM ( SELECT column1, column2,... FROM table_name ORDER BY column ) a WHERE ROWNUM &lt;= :max_row_num ) WHERE rnum &gt; :min_row_num;</code></span></li><li id="vnTe1m3kFuYjRxpaRDLWT2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：查询 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 表的第 3 页数据，每页 10 条记录，可写成 </span><span class="inline-wrap"><code>SELECT * FROM ( SELECT a.*, ROWNUM rnum FROM ( SELECT * FROM employees ORDER BY employee_id ) a WHERE ROWNUM &lt;= 30 ) WHERE rnum &gt; 20;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="84byLEW75wyzimjzpKFt1V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>分析函数 ROW_NUMBER 方式</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="iu9thyGSaFp7VhpEvXw1HQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本语法</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SELECT column1, column2,... FROM ( SELECT column1, column2,..., ROW_NUMBER() OVER (ORDER BY column) AS rnum FROM table_name ) WHERE rnum BETWEEN :min_row_num AND :max_row_num;</code></span></li><li id="qFakSA2AcJTYxUoL4dcC9w"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：查询 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 表的第 3 页数据，每页 10 条记录，语句为 </span><span class="inline-wrap"><code>SELECT * FROM ( SELECT *, ROW_NUMBER() OVER (ORDER BY employee_id) AS rnum FROM employees ) WHERE rnum BETWEEN 21 AND 30;</code></span><span class="inline-wrap">。</span></li></ul></li></ul></li><li id="SNWMGzcbPfcYax2qUgxGd"><div class="marker"></div><span class="inline-wrap"><b>SQL Server</b></span><ul class="wolai-block"><li id="g8w1kfzR2U16q1dgNcxJ8z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本语法</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SELECT column1, column2,... FROM table_name ORDER BY column OFFSET row_count ROWS FETCH NEXT row_count ROWS ONLY;</code></span></li><li id="e3uYPwMtaz8rFzASeLfSea"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：对于 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 表，要查询第 3 页的数据，每页 10 条记录，可以使用 </span><span class="inline-wrap"><code>SELECT * FROM employees ORDER BY employee_id OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;</code></span><span class="inline-wrap">。</span></li></ul></li></ol><div id="eYdPb8oL7Ju7oCuLFFx187" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，不同的数据库管理系统在实现分页功能时采用了不同的语法和方法。开发者在进行分页操作时，需要根据所使用的数据库类型选择相应的语法和策略。</span></div></div><div id="ixh3x3DLmq1YzFBbweBvr" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="fR4KrKZKtuAi6e5N1iaaC3" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">请描述存储过程（Stored Procedure）的概念及其优缺点。</span></h1><div id="c9Xb4cxhxjq7Dk2A6oMPCH" class="wolai-block wolai-text"><div><span class="inline-wrap">存储过程是数据库管理系统中预先编译并存储的<span class="jill"></span>SQL<span class="jill"></span>语句集，它们可以接受参数、执行逻辑操作，并返回结果。以下是对存储过程概念及其优缺点的介绍：</span></div></div><h2 id="urS7rnQ7uaEypVoJMKZEBL" class="wolai-block"><span class="wolai-serial-number">19.1</span><span class="inline-wrap">存储过程的概念</span></h2><div id="3zQ8oPKRHYDnPKXtYj9FSK" class="wolai-block wolai-text"><div><span class="inline-wrap">存储过程（Stored Procedure）是一组为了完成特定功能的<span class="jill"></span>SQL<span class="jill"></span>语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程可以看作是数据库服务器上的一种程序或函数，它可以在数据库级别完成一系列操作而不需要每次都从客户端发送完整的<span class="jill"></span>SQL<span class="jill"></span>命令。</span></div></div><h2 id="ukwhdGUpLWosy8oQXDCbnc" class="wolai-block"><span class="wolai-serial-number">19.2</span><span class="inline-wrap">存储过程的优点</span></h2><ol class="wolai-block"><li id="wEhbdZxUT39v9vTeh6Lqto"><div class="marker"></div><span class="inline-wrap"><b>提高性能</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="tSCaSCU7ECiLBizhxhkXKD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存储过程在创建时被编译，并存储在数据库服务器上。这意味着在运行时，存储过程无需重新编译，可以直接执行，从而提高了查询性能。</span></li><li id="4Prc6UWTNbPVp2GKYwWnHi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存储过程减少了客户端与服务器之间的数据传输量，因为多条<span class="jill"></span>SQL<span class="jill"></span>语句可以在服务器端一次性执行。</span></li></ul></li><li id="qUfEwB4yNTBjNp1RN2NwKV"><div class="marker"></div><span class="inline-wrap"><b>增强代码重用性和可维护性</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="bWxg2Q91WoRK3BHYfyGCAm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存储过程将业务逻辑封装在数据库层中，使得同一业务逻辑可以被多个应用程序或客户端重复使用，减少了代码重复。</span></li><li id="wTQpRwhBrvgEK61TUMz57m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果需要修改业务逻辑，只需修改存储过程，而不需要修改每个应用程序的代码，提高了可维护性。</span></li></ul></li><li id="fMB1sg1QR6DVHV6bkLtXXd"><div class="marker"></div><span class="inline-wrap"><b>提高安全性</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="tXaNxooVJMQkEwJkZeqWY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过使用存储过程，开发人员可以限制直接访问数据库表的权限，而只允许通过存储过程访问数据。这可以有效防止<span class="jill"></span>SQL<span class="jill"></span>注入攻击，并确保数据访问的安全性。</span></li></ul></li><li id="fUxywaH1WuEkuY98WhjmK6"><div class="marker"></div><span class="inline-wrap"><b>简化复杂操作</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="eBXLdKuJGgqPPdJBAcs7LD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存储过程可以封装复杂的业务逻辑，包括条件判断、循环等，从而简化了应用程序代码。</span></li><li id="prjM43X7SZVz4vrewW8Bke"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">开发人员只需调用存储过程，而无需关心具体的实现细节。</span></li></ul></li></ol><h2 id="7JpA1i5Cq3Hk1rJmfAu2Cs" class="wolai-block"><span class="wolai-serial-number">19.3</span><span class="inline-wrap">存储过程的缺点</span></h2><ol class="wolai-block"><li id="iYTzSWpbYaxbJ3ppqvktXW"><div class="marker"></div><span class="inline-wrap"><b>学习和开发成本</b></span><span class="inline-wrap">：编写存储过程需要专业的数据库编程知识，学习和开发的成本相对较高。</span></li><li id="aM9CPYUZmSU81GhZBWNHn8"><div class="marker"></div><span class="inline-wrap"><b>依赖于特定数据库</b></span><span class="inline-wrap">：存储过程的语法和功能依赖于特定的数据库系统，不同数据库系统之间可能存在差异。</span></li><li id="5cc5fKBa8egVeUtDYq1yM4"><div class="marker"></div><span class="inline-wrap"><b>难以调试</b></span><span class="inline-wrap">：调试存储过程相对较复杂，不如调试应用程序直观，需要使用特定的工具和技术。</span></li><li id="tn1bjSYj3dwtHP3XgLxRqS"><div class="marker"></div><span class="inline-wrap"><b>数据库层次耦合</b></span><span class="inline-wrap">：存储过程将业务逻辑嵌入到数据库中，导致数据库与应用程序的耦合性增加。</span></li><li id="nRgtpqJPskkNTmF1Q6dwNm"><div class="marker"></div><span class="inline-wrap"><b>可移植性差</b></span><span class="inline-wrap">：存储过程的语法和功能在不同的数据库系统中可能存在差异，降低了应用程序的可移植性。</span></li></ol><div id="hboMCXdYJSARVLw4torLiF" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cctch5xe24MdwcrHXCpXb3" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中调用存储过程？</span></h1><div id="hRiuwXBQPzRrUu4JPjjCkZ" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中调用存储过程的方法取决于所使用的数据库管理系统（DBMS）。以下是一些常见数据库系统中调用存储过程的语法和示例：</span></div></div><h2 id="ufQJcBFXUWFB4RpT95VrP7" class="wolai-block"><span class="wolai-serial-number">20.1</span><span class="inline-wrap">MySQL</span></h2><h3 id="kg2SLx8BiZ8eb7vebQ7ybj" class="wolai-block"><span class="wolai-serial-number">20.1.1</span><span class="inline-wrap">基本语法</span></h3><code-block id="8TBMxz91W5qfnh3b99P5KN" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CALL</span> procedure_name<span class="token punctuation">(</span><span class="token punctuation">[</span>parameter<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h3 id="2FFKKf1EEZCWCjPmjdhufh" class="wolai-block"><span class="wolai-serial-number">20.1.2</span><span class="inline-wrap">示例</span></h3><div id="3KWGWP8phRvJDe3S5mcAUQ" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个名为 </span><span class="inline-wrap"><code>getEmployee</code></span><span class="inline-wrap"> 的存储过程，它接受一个参数 </span><span class="inline-wrap"><code>employee_id</code></span><span class="inline-wrap">：</span></div></div><code-block id="s3hm8A8Tj1d2nqseKVBpM5" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CALL</span> getEmployee<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="nG4h99xHHvC3PHNoXqq8KA" class="wolai-block"><span class="wolai-serial-number">20.2</span><span class="inline-wrap">PostgreSQL</span></h2><h3 id="8gjo5K9eEXjZnhSuPay3U6" class="wolai-block"><span class="wolai-serial-number">20.2.1</span><span class="inline-wrap">基本语法</span></h3><code-block id="kChgr4XuPY6EQDjpH5iDk6" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> procedure_name<span class="token punctuation">(</span><span class="token punctuation">[</span>parameter<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h3 id="f924hNr1o1eUZLSxwBYzh5" class="wolai-block"><span class="wolai-serial-number">20.2.2</span><span class="inline-wrap">示例</span></h3><div id="o37JV6GtZyHxMM7Cj8NJ5h" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个名为 </span><span class="inline-wrap"><code>getEmployee</code></span><span class="inline-wrap"> 的存储过程，它接受一个参数 </span><span class="inline-wrap"><code>employee_id</code></span><span class="inline-wrap">：</span></div></div><code-block id="hgsGHewTRhMJ8Goa4GVb8f" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> getEmployee<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="pGTGsShy6naZjAegak8D8q" class="wolai-block"><span class="wolai-serial-number">20.3</span><span class="inline-wrap">SQL Server (T-SQL)</span></h2><h3 id="rYTyKzkyoofUGMCPCnV21W" class="wolai-block"><span class="wolai-serial-number">20.3.1</span><span class="inline-wrap">基本语法</span></h3><code-block id="d29L3xR4guAyLP5cbqbLub" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">EXEC</span> procedure_name <span class="token punctuation">[</span> <span class="token variable">@parameter</span> <span class="token operator">=</span> <span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span></pre></div></code-block><h3 id="oMQwm254yinWYae5xqqsoM" class="wolai-block"><span class="wolai-serial-number">20.3.2</span><span class="inline-wrap">示例</span></h3><div id="fhgYkkZmi7BBfS8heSgB29" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个名为 </span><span class="inline-wrap"><code>getEmployee</code></span><span class="inline-wrap"> 的存储过程，它接受一个参数 </span><span class="inline-wrap"><code>@employee_id</code></span><span class="inline-wrap">：</span></div></div><code-block id="6kQG5mGe4x5LX6k8hQoZAr" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">EXEC</span> getEmployee <span class="token variable">@employee_id</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="hospVe2vWey6d3ap2qGQq4" class="wolai-block"><span class="wolai-serial-number">20.4</span><span class="inline-wrap">Oracle</span></h2><h3 id="9gem6AMEXiu8GYyCjkiBHC" class="wolai-block"><span class="wolai-serial-number">20.4.1</span><span class="inline-wrap">基本语法</span></h3><code-block id="6YrSaA1dWKik8hHuP7DRLY" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span>
    procedure_name<span class="token punctuation">(</span><span class="token punctuation">[</span>parameter<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
<span class="token operator">/</span></pre></div></code-block><h3 id="eJg8vtgvDCADpr8SrPwUtB" class="wolai-block"><span class="wolai-serial-number">20.4.2</span><span class="inline-wrap">示例</span></h3><div id="qmNoLbZr3hWNk4uMUjQCDX" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个名为 </span><span class="inline-wrap"><code>getEmployee</code></span><span class="inline-wrap"> 的存储过程，它接受一个参数 </span><span class="inline-wrap"><code>employee_id</code></span><span class="inline-wrap">：</span></div></div><code-block id="8C1N1mkaM8wV4whx2jQsoW" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span>
    getEmployee<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
<span class="token operator">/</span></pre></div></code-block><h2 id="5hkAwVbBkrcLeMps2vwVAf" class="wolai-block"><span class="wolai-serial-number">20.5</span><span class="inline-wrap">SQLite</span></h2><div id="6UdKeuy2KyBvLYmEkrp5A4" class="wolai-block wolai-text"><div><span class="inline-wrap">SQLite 不支持存储过程，但可以通过编写用户定义函数（UDF）来实现类似的功能。以下是一个使用 Python 创建 UDF 的示例：</span></div></div><h3 id="w2vM6Mbe1kiXfSVUSGusPH" class="wolai-block"><span class="wolai-serial-number">20.5.1</span><span class="inline-wrap">示例</span></h3><div id="b8YQ7EaKrvFcsqTLKXDTdW" class="wolai-block wolai-text"><div><span class="inline-wrap">首先，需要创建一个 Python 脚本来定义 UDF：</span></div></div><code-block id="aZebXyrEdLLE1bCwUAsoXM" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> sqlite3

<span class="token keyword">def</span> <span class="token function">get_employee</span><span class="token punctuation">(</span>employee_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 这里可以添加实际的业务逻辑，例如查询数据库等</span>
    <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"Employee ID: </span><span class="token interpolation"><span class="token punctuation">{</span>employee_id<span class="token punctuation">}</span></span><span class="token string">"</span></span>

conn <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'example.db'</span><span class="token punctuation">)</span>
conn<span class="token punctuation">.</span>create_function<span class="token punctuation">(</span><span class="token string">"getEmployee"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> get_employee<span class="token punctuation">)</span>
cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT getEmployee(123)"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></div></code-block><div id="jPHZ34w6XQ7LsuXPNfQdqN" class="wolai-block wolai-text"><div><span class="inline-wrap">然后，可以在 SQLite 中使用这个 UDF：</span></div></div><code-block id="iXyGGTQiagwHM7k7Wgib67" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> getEmployee<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="mgdcRZvoko3szXHTe2YwiX" class="wolai-block"><span class="wolai-serial-number">20.6</span><span class="inline-wrap">总结</span></h2><div id="vSM21Y6yF49qnupzXCS8je" class="wolai-block wolai-text"><div><span class="inline-wrap">调用存储过程的具体方法因数据库系统而异。一般来说，你需要了解目标数据库系统的语法规则，并确保存储过程已经正确创建和编译。通过调用存储过程，你可以封装复杂的业务逻辑，提高代码的可重用性和安全性。</span></div></div><div id="89Fjg7ncxDmuQFiMNbx9QE" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="or3XjTijTHwqSkFS24TksN" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">请解释触发器（Trigger）的概念及其使用场景。</span></h1><div id="tokZEm8uJ84KR38HzjysH" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是关于触发器的概念及使用场景的介绍：</span></div></div><h2 id="xa9DUqmFEKNKZ8w1qKiTgx" class="wolai-block"><span class="wolai-serial-number">21.1</span><span class="inline-wrap">概念</span></h2><div id="j6xiBNugtzVApAkvVckND8" class="wolai-block wolai-text"><div><span class="inline-wrap">触发器（Trigger）是数据库中一种特殊的存储过程，它会在特定的数据库操作（如插入、更新、删除等）发生时自动执行。触发器通常与表紧密关联，当表中的数据发生变化时，触发器就会被激活并执行预先定义好的操作。这种机制使得触发器成为实现数据完整性约束、自动化业务逻辑处理和复杂数据操作的重要工具。</span></div></div><h2 id="kMQRSdmvkN9WocDwv1P1mY" class="wolai-block"><span class="wolai-serial-number">21.2</span><span class="inline-wrap">使用场景</span></h2><ul class="wolai-block"><li id="jvwLjjszXjKht7zfBzdSAu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据验证</b></span><span class="inline-wrap">：通过触发器可以在插入或更新数据之前对数据进行验证，确保满足特定的条件或规则，如检查数据的合法性、完整性等。</span></li><li id="2Wvzj9smCukRjq43mcGMPj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>自动化任务</b></span><span class="inline-wrap">：触发器可以用于自动执行一系列复杂的任务，如记录日志、生成报表、发送邮件等。</span></li><li id="s8Pe996ZcVnSewUzf3YFw4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据同步</b></span><span class="inline-wrap">：当一个表的数据发生变化时，触发器可以触发与之相关的操作，以确保其他相关表中的数据保持同步。</span></li><li id="xhraH6FZVtwTpitSh16MUu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据审计</b></span><span class="inline-wrap">：在触发器中记录相关操作的详细信息，包括操作时间、操作人和修改前后的数据，方便后续的数据分析和追踪。</span></li><li id="ic6owHU8P2i2tJUWYLqFJb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>强制引用完整性</b></span><span class="inline-wrap">：通过触发器可以实现比<span class="jill"></span>CHECK<span class="jill"></span>约束更复杂的数据完整性约束，如跨表的级联修改等。</span></li></ul><div id="biY8Hws71PnY54Fay4Cncy" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，触发器作为一种强大的数据库工具，在多种场景下都能发挥重要作用，帮助开发人员实现更加高效、安全和智能的数据管理。</span></div></div><div id="jaK6qHLSQiZBjFh6KLvpaN" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nuvB3CNj2eK45tCoQAEvT8" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中实现数据的备份和恢复？</span></h1><div id="hLvHyPrYnS6YYxhaR1APZc" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，实现数据的备份和恢复通常依赖于数据库管理系统（DBMS）提供的工具和命令。以下是一些常见数据库系统中进行数据备份和恢复的方法：</span></div></div><h2 id="6CN2etar3c5cVptpcuw9Dh" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">MySQL</span></h2><h3 id="fsK6tCLcMLUJgnxMgxwqAC" class="wolai-block"><span class="wolai-serial-number">22.1.1</span><span class="inline-wrap">备份</span></h3><div id="jpZhuWpJeDnLnXdkTWRyRQ" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>mysqldump</code></span><span class="inline-wrap"> 工具可以备份<span class="jill"></span>MySQL<span class="jill"></span>数据库：</span></div></div><code-block id="pN15xnEpeRwmwWjr2qt5DH" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>mysqldump <span class="token parameter variable">-u</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span> -p<span class="token punctuation">[</span>password<span class="token punctuation">]</span> <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token punctuation">[</span>backup_file.sql<span class="token punctuation">]</span></pre></div></code-block><div id="p2rscCRHXXN74HAXbndm48" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="pBSraeEHuvFcXFk8JcQEwA" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>mysqldump <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> mydatabase <span class="token operator">></span> backup.sql</pre></div></code-block><h3 id="e7gUorUeQgPtYDza2fMd2H" class="wolai-block"><span class="wolai-serial-number">22.1.2</span><span class="inline-wrap">恢复</span></h3><div id="8sUTdu7LBEaujT4TJ6nbTk" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>mysql</code></span><span class="inline-wrap"> 命令行工具可以恢复<span class="jill"></span>MySQL<span class="jill"></span>数据库：</span></div></div><code-block id="5qsqZbBb1bmkBjfUFgKVZE" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>mysql <span class="token parameter variable">-u</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span> -p<span class="token punctuation">[</span>password<span class="token punctuation">]</span> <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span>backup_file.sql<span class="token punctuation">]</span></pre></div></code-block><div id="krurSAUUBaMRJjxUWxCmot" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="oRtVkJAoJGxm3qbUGYBoGG" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> mydatabase <span class="token operator">&lt;</span> backup.sql</pre></div></code-block><h2 id="pM9dznsvCCTpys328aNvFo" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">PostgreSQL</span></h2><h3 id="imkN6x28P4Qj463RA29S53" class="wolai-block"><span class="wolai-serial-number">22.2.1</span><span class="inline-wrap">备份</span></h3><div id="rxZGh8oMfC1X7PyRk7kiio" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>pg_dump</code></span><span class="inline-wrap"> 工具可以备份<span class="jill"></span>PostgreSQL<span class="jill"></span>数据库：</span></div></div><code-block id="fAsZyr5qGMJj4VdS9sQuVV" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>pg_dump <span class="token parameter variable">-U</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span> <span class="token parameter variable">-F</span> c <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token punctuation">[</span>backup_file.dump<span class="token punctuation">]</span></pre></div></code-block><div id="dAhADcktsCb3Y6BZR96ay4" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="o6KQBYFXgKTgS2GKGoucMh" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>pg_dump <span class="token parameter variable">-U</span> postgres <span class="token parameter variable">-F</span> c mydatabase <span class="token operator">></span> backup.dump</pre></div></code-block><h3 id="vEzqhR2WAYr5msUmn3nMgn" class="wolai-block"><span class="wolai-serial-number">22.2.2</span><span class="inline-wrap">恢复</span></h3><div id="g3USxxvxDZ8QzLEX6cfTYT" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>pg_restore</code></span><span class="inline-wrap"> 工具可以恢复<span class="jill"></span>PostgreSQL<span class="jill"></span>数据库：</span></div></div><code-block id="ujQFbTbfAJ7fxd9J7XsuiR" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>pg_restore <span class="token parameter variable">-U</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span> <span class="token parameter variable">-d</span> <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>backup_file.dump<span class="token punctuation">]</span></pre></div></code-block><div id="pJSQzwuYiuaLx7ST8GS7fG" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="j3xoeQMjSmxscncYKrxZ7U" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>pg_restore <span class="token parameter variable">-U</span> postgres <span class="token parameter variable">-d</span> mydatabase backup.dump</pre></div></code-block><h2 id="r8KCw5g8vDjJVsadkVGd7F" class="wolai-block"><span class="wolai-serial-number">22.3</span><span class="inline-wrap">SQL Server (T-SQL)</span></h2><h3 id="rj3SzjgjQKHyYFu34Bq1bX" class="wolai-block"><span class="wolai-serial-number">22.3.1</span><span class="inline-wrap">备份</span></h3><div id="mc3yxyM8EoidrQFfEFR25q" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 T-SQL 的 </span><span class="inline-wrap"><code>BACKUP DATABASE</code></span><span class="inline-wrap"> 语句可以备份<span class="jill"></span>SQL Server<span class="jill"></span>数据库：</span></div></div><code-block id="ia1tB1Gc3GE86CHUcMHmeg" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BACKUP</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token keyword">TO</span> <span class="token keyword">DISK</span> <span class="token operator">=</span> <span class="token string">'[backup_file.bak]'</span></pre></div></code-block><div id="gh9tNX8muT5QXhjWLjiSan" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="cdfzwqmDszBwLECfMC9rxN" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BACKUP</span> <span class="token keyword">DATABASE</span> mydatabase <span class="token keyword">TO</span> <span class="token keyword">DISK</span> <span class="token operator">=</span> <span class="token string">'C:\backup\mydatabase.bak'</span></pre></div></code-block><h3 id="tD2KWmeSypBvixayW45axB" class="wolai-block"><span class="wolai-serial-number">22.3.2</span><span class="inline-wrap">恢复</span></h3><div id="8bcAMgLBRX5TLwh3cyq7m7" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 T-SQL 的 </span><span class="inline-wrap"><code>RESTORE DATABASE</code></span><span class="inline-wrap"> 语句可以恢复<span class="jill"></span>SQL Server<span class="jill"></span>数据库：</span></div></div><code-block id="6vzjbdtPqkdf8GGw8a5c2d" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">RESTORE</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">[</span>database_name<span class="token punctuation">]</span> <span class="token keyword">FROM</span> <span class="token keyword">DISK</span> <span class="token operator">=</span> <span class="token string">'[backup_file.bak]'</span></pre></div></code-block><div id="oWXYXRs9LfoBwYJd3rcL83" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="nWnwBHv9s9HPdKje856eXE" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">RESTORE</span> <span class="token keyword">DATABASE</span> mydatabase <span class="token keyword">FROM</span> <span class="token keyword">DISK</span> <span class="token operator">=</span> <span class="token string">'C:\backup\mydatabase.bak'</span></pre></div></code-block><h2 id="8BpjqdeMmjrAD9vEtNrNyv" class="wolai-block"><span class="wolai-serial-number">22.4</span><span class="inline-wrap">Oracle</span></h2><h3 id="hDGPt27NGeHr86ttQB72QK" class="wolai-block"><span class="wolai-serial-number">22.4.1</span><span class="inline-wrap">备份</span></h3><div id="ukxy2CuAcukBQmsYJAJLuX" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>expdp</code></span><span class="inline-wrap"> 工具可以备份<span class="jill"></span>Oracle<span class="jill"></span>数据库：</span></div></div><code-block id="whXsegGD3CZHv1pYkZLoBX" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>expdp <span class="token punctuation">[</span>username<span class="token punctuation">]</span>/<span class="token punctuation">[</span>password<span class="token punctuation">]</span>@<span class="token punctuation">[</span>service_name<span class="token punctuation">]</span> <span class="token assign-left variable">schemas</span><span class="token operator">=</span><span class="token punctuation">[</span>schema_name<span class="token punctuation">]</span> <span class="token assign-left variable">directory</span><span class="token operator">=</span><span class="token punctuation">[</span>directory_name<span class="token punctuation">]</span> <span class="token assign-left variable">dumpfile</span><span class="token operator">=</span><span class="token punctuation">[</span>dump_file.dmp<span class="token punctuation">]</span> <span class="token assign-left variable">logfile</span><span class="token operator">=</span><span class="token punctuation">[</span>log_file.log<span class="token punctuation">]</span></pre></div></code-block><div id="mcStZUgZkGJfM8bfa7J8sS" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="qkEmjctWtTMjm1zsJMfa5D" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>expdp system/password@orcl <span class="token assign-left variable">schemas</span><span class="token operator">=</span>hr <span class="token assign-left variable">directory</span><span class="token operator">=</span>DATA_PUMP_DIR <span class="token assign-left variable">dumpfile</span><span class="token operator">=</span>hr.dmp <span class="token assign-left variable">logfile</span><span class="token operator">=</span>hr.log</pre></div></code-block><h3 id="a5PbeonWmxdMpKorCT8jc1" class="wolai-block"><span class="wolai-serial-number">22.4.2</span><span class="inline-wrap">恢复</span></h3><div id="uqeYGQG46uXpT1xUSfK5Rn" class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>impdp</code></span><span class="inline-wrap"> 工具可以恢复<span class="jill"></span>Oracle<span class="jill"></span>数据库：</span></div></div><code-block id="a5MM4D14ED5Y8rJq5oWmxR" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>impdp <span class="token punctuation">[</span>username<span class="token punctuation">]</span>/<span class="token punctuation">[</span>password<span class="token punctuation">]</span>@<span class="token punctuation">[</span>service_name<span class="token punctuation">]</span> <span class="token assign-left variable">schemas</span><span class="token operator">=</span><span class="token punctuation">[</span>schema_name<span class="token punctuation">]</span> <span class="token assign-left variable">directory</span><span class="token operator">=</span><span class="token punctuation">[</span>directory_name<span class="token punctuation">]</span> <span class="token assign-left variable">dumpfile</span><span class="token operator">=</span><span class="token punctuation">[</span>dump_file.dmp<span class="token punctuation">]</span> <span class="token assign-left variable">logfile</span><span class="token operator">=</span><span class="token punctuation">[</span>log_file.log<span class="token punctuation">]</span></pre></div></code-block><div id="wiHY1vuuehsnB1EoNqzsVn" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="oLHk8iXQRBQ1bGTnSZWmJr" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>impdp system/password@orcl <span class="token assign-left variable">schemas</span><span class="token operator">=</span>hr <span class="token assign-left variable">directory</span><span class="token operator">=</span>DATA_PUMP_DIR <span class="token assign-left variable">dumpfile</span><span class="token operator">=</span>hr.dmp <span class="token assign-left variable">logfile</span><span class="token operator">=</span>hr.log</pre></div></code-block><h2 id="hRFW8rhsV3dA5zKUURzr1Z" class="wolai-block"><span class="wolai-serial-number">22.5</span><span class="inline-wrap">SQLite</span></h2><div id="9oEaPUDYhMvfdSDhKtMRaL" class="wolai-block wolai-text"><div><span class="inline-wrap">SQLite 是一个轻量级的嵌入式数据库，通常用于小型应用。备份和恢复操作相对简单，可以通过复制数据库文件来实现。</span></div></div><h3 id="2y18ho6Se6bqfuF3gmNtqL" class="wolai-block"><span class="wolai-serial-number">22.5.1</span><span class="inline-wrap">备份</span></h3><div id="gLxJoVzxHxUPyxbVa7gEEw" class="wolai-block wolai-text"><div><span class="inline-wrap">直接复制数据库文件即可：</span></div></div><code-block id="u72LptpE7Esu4AXqp6gRa7" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">cp</span> <span class="token punctuation">[</span>database_file.db<span class="token punctuation">]</span> <span class="token punctuation">[</span>backup_file.db<span class="token punctuation">]</span></pre></div></code-block><div id="dN2yaAj6RdJxA1JxBiYaE2" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="6sq7vHhvJuzWdakkx7DEDq" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">cp</span> mydatabase.db backup.db</pre></div></code-block><h3 id="kJUWCocMJgdRpLpA9rDyNR" class="wolai-block"><span class="wolai-serial-number">22.5.2</span><span class="inline-wrap">恢复</span></h3><div id="9M5K8d2NB4WctWnhr1YF1o" class="wolai-block wolai-text"><div><span class="inline-wrap">直接替换数据库文件即可：</span></div></div><code-block id="3YaRPQF5yh2LRc1UMhTdKP" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">cp</span> <span class="token punctuation">[</span>backup_file.db<span class="token punctuation">]</span> <span class="token punctuation">[</span>database_file.db<span class="token punctuation">]</span></pre></div></code-block><div id="7fTwwpc2zTF2sFR7W4TEdD" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="iNh7u1cb9xh61pTvFEMjm8" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">cp</span> backup.db mydatabase.db</pre></div></code-block><h2 id="mXRLW9GPECADy1mmHJsTKx" class="wolai-block"><span class="wolai-serial-number">22.6</span><span class="inline-wrap">总结</span></h2><div id="cBQEu98bX6rt34tgEofjZQ" class="wolai-block wolai-text"><div><span class="inline-wrap">不同的数据库系统有不同的备份和恢复方法，但基本思路都是通过特定的工具或命令将数据库导出到文件中，并在需要时从文件中导入数据。这些操作对于保障数据安全、实现灾难恢复以及迁移数据等场景都非常重要。</span></div></div><div id="9sYWtX1jNYoQ9WpVzvi519" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vQWJaSPGsJjoHYfRyZnfik" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">什么是数据库事务（Transaction）？</span></h1><div id="wxJiwr4ATSwSbfZrouYefi" class="wolai-block wolai-text"><div><span class="inline-wrap">数据库事务是一系列数据库操作的集合，这些操作要么全部执行，要么全部不执行，以确保数据库从一个一致的状态转换到另一个一致的状态。它具有以下四个特性：</span></div></div><ol class="wolai-block"><li id="xuzVRXsg6LrwxfmtSTymG1"><div class="marker"></div><span class="inline-wrap"><b>原子性（Atomicity）</b></span><span class="inline-wrap">：事务内的操作要么全部完成，要么全部不完成，不可能结束在中间某个环节。事务执行的过程中出错，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</span></li><li id="bmJ15hpk52qzY2o7spc88c"><div class="marker"></div><span class="inline-wrap"><b>一致性（Consistency）</b></span><span class="inline-wrap">：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的任何数据都必须满足所有设置的约束，包括数据约束、业务约束等。</span></li><li id="4hgatWaoRuY342LJCwkknv"><div class="marker"></div><span class="inline-wrap"><b>隔离性（Isolation）</b></span><span class="inline-wrap">：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读已提交、可重复读和串行化。</span></li><li id="x3GLHfb5AUUqLtJa9tmifs"><div class="marker"></div><span class="inline-wrap"><b>持久性（Durability）</b></span><span class="inline-wrap">：一旦事务完成，无论系统发生什么故障，其修改的结果都能够保持。大多数数据库系统都提供了事务管理功能，如回滚、提交等。在开发过程中，应充分利用这些功能来确保数据的一致性和完整性。</span></li></ol><div id="nQe8LS9D2YSncn6eTDPYJm" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，数据库事务通过保证一组操作的原子性、一致性、隔离性和持久性，为数据库操作提供了可靠性和一致性的保障。</span></div></div><div id="6AWpvevec6qPZcWUuRgZhV" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="eozyXAj4s5ZQPATK9KMSRp" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">简述<span class="jill"></span>ACID<span class="jill"></span>特性及其含义。</span></h1><div id="rwPLvkx6tFg3QQSsCeTBbr" class="wolai-block wolai-text"><div><span class="inline-wrap">ACID 特性是数据库事务处理系统的四个关键属性的缩写，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），它们共同确保了数据库操作的可靠性和一致性。以下是对 ACID 特性及其含义的简述：</span></div></div><ol class="wolai-block"><li id="bxAnDiZ5UqVmobAPjpnzYv"><div class="marker"></div><span class="inline-wrap"><b>原子性（Atomicity）</b></span><span class="inline-wrap">：指事务中的所有操作要么全部执行成功，要么全部不执行。如果在执行过程中发生错误，会回滚到事务开始前的状态，就像这个事务从未执行过一样。这确保了在发生系统故障或其他问题时，数据库不会处于不一致的状态。</span></li><li id="bYXZ4LUi4JwFAJi9WSt91s"><div class="marker"></div><span class="inline-wrap"><b>一致性（Consistency）</b></span><span class="inline-wrap">：保证事务执行的结果必须使数据库从一个一致的状态转换到另一个一致的状态。这意味着事务执行前后，数据库都必须满足所有的约束条件和规则，以确保数据的完整性和正确性。</span></li><li id="p17fgQLjPQPYshA3hdaDEi"><div class="marker"></div><span class="inline-wrap"><b>隔离性（Isolation）</b></span><span class="inline-wrap">：多个并发事务同时执行时，每个事务都应与其他事务隔离开来，互不干扰。不同的隔离级别定义了事务间相互隔离的程度，以防止并发操作导致的数据不一致问题。</span></li><li id="mqxpTGvXq7pfu4UALT2fCA"><div class="marker"></div><span class="inline-wrap"><b>持久性（Durability）</b></span><span class="inline-wrap">：一旦事务提交成功，其结果将永久保存在数据库中，即使系统发生故障也不会丢失。这通过将数据写入磁盘或使用备份和恢复机制等方式来保证。</span></li></ol><div id="r5PyJyLVEefyjkw7Ma5cYJ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jHczidE1G7r6ngB8f4mEts" class="wolai-block"><span class="wolai-serial-number">25</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中开始一个事务？</span></h1><div id="amNCFWf1SrdNpsngp9gr2S" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，开始一个事务通常使用 </span><span class="inline-wrap"><code>BEGIN TRANSACTION</code></span><span class="inline-wrap"> 语句。不同的数据库管理系统（DBMS）可能有不同的语法和命令来处理事务，但大多数都支持标准的 SQL 事务控制命令。以下是一些常见 DBMS 中如何开始一个事务的示例：</span></div></div><h2 id="iVpNpYjMPmk71itvMQ2Ktd" class="wolai-block"><span class="wolai-serial-number">25.1</span><span class="inline-wrap">MySQL</span></h2><code-block id="8nnsmg5j79nR1DzYEQYpL4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token comment">-- 或者</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="b98hYKLpkxWaeGwyhvnKR1" class="wolai-block"><span class="wolai-serial-number">25.2</span><span class="inline-wrap">PostgreSQL</span></h2><code-block id="sT5N2LzDwJPkqVZkUFVuLP" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="mLQk1gqWoSt3tZsaxBELfi" class="wolai-block"><span class="wolai-serial-number">25.3</span><span class="inline-wrap">SQL Server (T-SQL)</span></h2><code-block id="wQe3t8281Jcx3L4K3ujWSL" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="gMmaD955TamrzWUvDwgcDb" class="wolai-block"><span class="wolai-serial-number">25.4</span><span class="inline-wrap">Oracle</span></h2><code-block id="qq4XKmFcP8dkEcUqdAqDJo" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="fontZ3ute8roQPwGPLsnhw" class="wolai-block"><span class="wolai-serial-number">25.5</span><span class="inline-wrap">SQLite</span></h2><code-block id="5Kej6BxgRBSAkmqoXvqYPb" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></div></code-block><div id="wJVAbw3gHNejtDWrCfoefD" class="wolai-block wolai-text"><div><span class="inline-wrap">一旦事务开始，你可以执行一系列的 SQL 操作，如插入、更新或删除数据。如果所有操作都成功，你可以使用 </span><span class="inline-wrap"><code>COMMIT</code></span><span class="inline-wrap"> 语句提交事务，使更改永久生效：</span></div></div><code-block id="qwwH67gUf913Q47mKurdVu" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><div id="pSuRrgde9EP8UZ91HAAbmz" class="wolai-block wolai-text"><div><span class="inline-wrap">如果在事务过程中遇到错误或需要撤销所有更改，可以使用 </span><span class="inline-wrap"><code>ROLLBACK</code></span><span class="inline-wrap"> 语句回滚事务：</span></div></div><code-block id="u4GEzPX7H4YjTnEmxNF5iH" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><div id="6gPrB7Ldzc2sCDGwQhvLiB" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，通过使用 </span><span class="inline-wrap"><code>BEGIN TRANSACTION</code></span><span class="inline-wrap"> 或其等效命令，可以有效地管理数据库中的事务，确保数据的一致性和完整性。</span></div></div><div id="p2zqLXVmBFBaBoGNGNE9Q1" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cqn2E47nD3MCHRLdnUomSV" class="wolai-block"><span class="wolai-serial-number">26</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中提交（Commit）一个事务？</span></h1><div id="sHFTDFgi7URywfT4CvbGLN" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，提交（Commit）一个事务意味着将事务中的所有操作永久保存到数据库中。不同的数据库管理系统（DBMS）可能有不同的语法和命令来处理事务，但大多数都支持标准的 SQL 事务控制命令。以下是一些常见 DBMS 中如何提交一个事务的示例：</span></div></div><h2 id="7KYsp2f1HeawQxHRUnnmPd" class="wolai-block"><span class="wolai-serial-number">26.1</span><span class="inline-wrap">MySQL</span></h2><code-block id="rJ97u3JqrVCRGSX4M1Ak3N" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="dYsqZR7amtaCZoXHZ5eSbA" class="wolai-block"><span class="wolai-serial-number">26.2</span><span class="inline-wrap">PostgreSQL</span></h2><code-block id="ivkG1p99x4brP8ZCq7nHet" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="b94KZQaBi2Jz6Gyxkey8uM" class="wolai-block"><span class="wolai-serial-number">26.3</span><span class="inline-wrap">SQL Server (T-SQL)</span></h2><code-block id="oFTAPYQ2KmLhXCwDjtP6Vu" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="xoKgjPU32A2ySbpNHkVjGd" class="wolai-block"><span class="wolai-serial-number">26.4</span><span class="inline-wrap">Oracle</span></h2><code-block id="9UJ9dpE8AMZ4k2EZEMakAv" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="w1DccVSWgMDJ8GzrgnNTa7" class="wolai-block"><span class="wolai-serial-number">26.5</span><span class="inline-wrap">SQLite</span></h2><code-block id="hyM9j2v8sdGu9vfXdMn2MV" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><div id="YHUCb3URYMJ8VudL6HRaw" class="wolai-block wolai-text"><div><span class="inline-wrap">一旦执行了 </span><span class="inline-wrap"><code>COMMIT</code></span><span class="inline-wrap"> 语句，事务中的所有更改将被永久保存到数据库中。如果在事务过程中遇到错误或需要撤销所有更改，可以使用 </span><span class="inline-wrap"><code>ROLLBACK</code></span><span class="inline-wrap"> 语句回滚事务：</span></div></div><code-block id="8xRP6g9Zw4cD426PVgqiSN" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><div id="ekMN1XFNfDCuUzzxTuGaTD" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，通过使用 </span><span class="inline-wrap"><code>COMMIT</code></span><span class="inline-wrap"> 语句，可以有效地管理数据库中的事务，确保数据的一致性和完整性。</span></div></div><div id="9pNMS5kezY1j7QTk3o2ES8" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wuwJCo4QzgGDNq6u2gqKtn" class="wolai-block"><span class="wolai-serial-number">27</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中回滚（Rollback）一个事务？</span></h1><div id="aU9yD6GAJ2WYmRNijm1KcR" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，回滚（Rollback）一个事务意味着撤销事务中的所有操作，使数据库恢复到事务开始前的状态。不同的数据库管理系统（DBMS）可能有不同的语法和命令来处理事务，但大多数都支持标准的 SQL 事务控制命令。以下是一些常见 DBMS 中如何回滚一个事务的示例：</span></div></div><h2 id="kVv3K6UBCiKc3yT8KwwC57" class="wolai-block"><span class="wolai-serial-number">27.1</span><span class="inline-wrap">MySQL</span></h2><code-block id="eAaTV8admD4vuFDs4P42Si" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="aWErREV3fhGZhLqdtdtbtY" class="wolai-block"><span class="wolai-serial-number">27.2</span><span class="inline-wrap">PostgreSQL</span></h2><code-block id="gCfo49GjCnWy8nUiLAyZ6F" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="audMa9vmJmmc5LbAwuHMR" class="wolai-block"><span class="wolai-serial-number">27.3</span><span class="inline-wrap">SQL Server (T-SQL)</span></h2><code-block id="rHxfLAA8XcCbYSPcLr5YnM" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="9hmTHRytZetBrcxLgaUGqn" class="wolai-block"><span class="wolai-serial-number">27.4</span><span class="inline-wrap">Oracle</span></h2><code-block id="rdQcTZ7dJv25cjW1eqUFRL" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="c9UUBhqt8YPuHf3STM8aLv" class="wolai-block"><span class="wolai-serial-number">27.5</span><span class="inline-wrap">SQLite</span></h2><code-block id="c1uX4fQnq9nrpLrgsQ1xxt" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block><div id="bC4sgsNpqm3Uee43sfhF2U" class="wolai-block wolai-text"><div><span class="inline-wrap">一旦执行了 </span><span class="inline-wrap"><code>ROLLBACK</code></span><span class="inline-wrap"> 语句，事务中的所有更改将被撤销，数据库将恢复到事务开始前的状态。这在处理错误或需要取消一系列操作时非常有用。</span></div></div><div id="wgZ9TgERF4nD1bdd284g6W" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，通过使用 </span><span class="inline-wrap"><code>ROLLBACK</code></span><span class="inline-wrap"> 语句，可以有效地管理数据库中的事务，确保数据的一致性和完整性。</span></div></div><div id="3f9CxD2z5iJWTXaLCjuzX6" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="juVuybL92Q5wCkc5fNsQ79" class="wolai-block"><span class="wolai-serial-number">28</span><span class="inline-wrap">请解释什么是脏读、不可重复读和幻读。</span></h1><div id="kPatwRwTuE2qvMRVYBwcQy" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是对脏读、不可重复读和幻读的详细解释：</span></div></div><ol class="wolai-block"><li id="gxTjHn8CHdVmwVrSBNw2fE"><div class="marker"></div><span class="inline-wrap"><b>脏读</b></span><ul class="wolai-block"><li id="ixoYmTfLZFetqTyCn9PB5c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：一个事务读取了另一个事务未提交的数据。</span></li><li id="cRpreULWFHnvs7zTBuU3yJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：事务<span class="jill"></span>T1<span class="jill"></span>修改了一条记录，但尚未提交。事务<span class="jill"></span>T2<span class="jill"></span>读取了这条记录。如果<span class="jill"></span>T1<span class="jill"></span>回滚了事务，那么<span class="jill"></span>T2<span class="jill"></span>读取到的数据就是无效的，这就是脏读。</span></li></ul></li><li id="cXiJnB2eaSeuQSE7BsdnUb"><div class="marker"></div><span class="inline-wrap"><b>不可重复读</b></span><ul class="wolai-block"><li id="ffwwWFnPrjVzJrG4B5z5Pu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：在一个事务内多次读取同一数据时，由于其他事务的修改，导致读取结果不一致。</span></li><li id="eXDih28UyagDwHXi6DqXoE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：事务<span class="jill"></span>T1<span class="jill"></span>读取了一条记录，然后事务<span class="jill"></span>T2<span class="jill"></span>修改了这条记录并提交。当<span class="jill"></span>T1<span class="jill"></span>再次读取这条记录时，结果与第一次读取的结果不同，这就是不可重复读。</span></li></ul></li><li id="73mHKcPAfFCkYC7oK83PTV"><div class="marker"></div><span class="inline-wrap"><b>幻读</b></span><ul class="wolai-block"><li id="q5JFn8RpNZFWJdbVs4bzEo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：在一个事务内多次执行同一查询时，由于其他事务的插入或删除操作，导致查询结果集的行数发生变化。</span></li><li id="pczNCMx4qVVQ6eCvjvGqeJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：事务<span class="jill"></span>T1<span class="jill"></span>查询某个范围内的记录，得到一些结果。然后事务<span class="jill"></span>T2<span class="jill"></span>在这个范围内插入了一条新记录并提交。当<span class="jill"></span>T1<span class="jill"></span>再次执行相同的查询时，结果集中多了一条记录，这就是幻读。</span></li></ul></li></ol><div id="rvA3PrKzxDZmZVEmjXVFHQ" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，脏读、不可重复读和幻读是数据库中常见的数据不一致性问题。了解这些概念对于设计和维护数据库系统至关重要，可以帮助开发人员采取适当的措施来避免这些问题的发生，确保数据的一致性和完整性。</span></div></div><div id="9izbYrrzMVSnvgviaf4LcP" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="gmBdBmJtMq7Kj6i8X5XqAw" class="wolai-block"><span class="wolai-serial-number">29</span><span class="inline-wrap">如何在<span class="jill"></span>SQL<span class="jill"></span>中设置事务的隔离级别？有哪些隔离级别？</span></h1><div id="ooViqmM4nNeRZ5T8kJqUbm" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>SQL<span class="jill"></span>中，设置事务的隔离级别通常使用</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL</code></span><span class="inline-wrap">语句。以下是一些常见的隔离级别及其含义：</span></div></div><ol class="wolai-block"><li id="74AyBJ5mdSJ6vPS8nNEYHT"><div class="marker"></div><span class="inline-wrap"><b>READ UNCOMMITTED</b></span><ul class="wolai-block"><li id="6qJKsRJjH7siMKpPfsmQ1m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>含义</b></span><span class="inline-wrap">：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读。</span></li><li id="f29NPoS35qchhHA6m4Uzwd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="kXmx91YLQKjF2TSf1PhqE8"><div class="marker"></div><span class="inline-wrap"><b>READ COMMITTED</b></span><ul class="wolai-block"><li id="vXSW7AqjJUorEVGJKyYEn1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>含义</b></span><span class="inline-wrap">：只能读取已经提交的事务数据，可以避免脏读，但可能会存在不可重复读和幻读的问题。</span></li><li id="9BoxFqUNMwMYEZmhK4UkuM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="2iuDbDBWhDa9i9eTQ9bzx4"><div class="marker"></div><span class="inline-wrap"><b>REPEATABLE READ</b></span><ul class="wolai-block"><li id="i1RL36E2AwpbnT9Dcssbx1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>含义</b></span><span class="inline-wrap">：在同一个事务中多次读取同一数据时，结果保持一致，能避免脏读和不可重复读，但可能出现幻读。</span></li><li id="n2QUMxk6bnTV1qhTAtPkRe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="i5xsRC9PMRU57wd2LCYNkB"><div class="marker"></div><span class="inline-wrap"><b>SERIALIZABLE</b></span><ul class="wolai-block"><li id="uxtn8bFL7mzNbMNyyR1SQ3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>含义</b></span><span class="inline-wrap">：最高的隔离级别，完全服从<span class="jill"></span>ACID<span class="jill"></span>原理，通过强制事务串行执行来避免脏读、不可重复读和幻读，但会导致大量的超时和锁争用问题。</span></li><li id="9kCkU6Fg1KxtZrKGnzvi7V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></span><span class="inline-wrap">。</span></li></ul></li></ol><div id="pjdWEzBycr1BS9iFfSxY9S" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，不同的数据库系统可能支持的隔离级别略有差异，具体使用时需根据所使用的数据库系统来确定。</span></div></div><div id="cTjk61VySt9QsBEhPGVFWt" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="uwx8cebbZiwrdwxcpxtcZR" class="wolai-block"><span class="wolai-serial-number">30</span><span class="inline-wrap">请描述在<span class="jill"></span>MySQL<span class="jill"></span>中如何实现可重复读隔离级别。</span></h1><h2 id="733GqsB4JpSZtPP1szJjA" class="wolai-block"><span class="wolai-serial-number">30.1</span><span class="inline-wrap">概念</span></h2><div id="6DnJwS1iD4rM2SBuexT75g" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，实现可重复读隔离级别可以通过以下步骤：</span></div></div><ol class="wolai-block"><li id="9QsodfVp6JkQ8xRnPiqL7s"><div class="marker"></div><span class="inline-wrap"><b>设置事务的隔离级别</b></span><span class="inline-wrap">：使用</span><span class="inline-wrap"><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></span><span class="inline-wrap">语句来设置当前会话的事务隔离级别为可重复读。这将确保在同一个事务中多次读取同一数据时，结果保持一致，从而避免脏读和不可重复读的问题。</span></li><li id="fn2a6WPeKgs65jvBTMaUFm"><div class="marker"></div><span class="inline-wrap"><b>开始事务</b></span><span class="inline-wrap">：使用</span><span class="inline-wrap"><code>START TRANSACTION;</code></span><span class="inline-wrap">或</span><span class="inline-wrap"><code>BEGIN;</code></span><span class="inline-wrap">语句来显式地开始一个事务。</span></li><li id="dh71K9RyKVVrqYf833JN9a"><div class="marker"></div><span class="inline-wrap"><b>执行查询和更新操作</b></span><span class="inline-wrap">：在事务中执行所需的查询和更新操作。由于隔离级别设置为可重复读，这些操作将遵循相应的隔离规则。</span></li><li id="tKKCNf41puhUap4ts2DoTD"><div class="marker"></div><span class="inline-wrap"><b>提交或回滚事务</b></span><span class="inline-wrap">：根据需要，使用</span><span class="inline-wrap"><code>COMMIT;</code></span><span class="inline-wrap">语句提交事务，使所有更改永久生效，或者使用</span><span class="inline-wrap"><code>ROLLBACK;</code></span><span class="inline-wrap">语句回滚事务，撤销所有更改。</span></li></ol><h2 id="faNXvhLnuXUsDW6saTVeML" class="wolai-block"><span class="wolai-serial-number">30.2</span><span class="inline-wrap">示例代码</span></h2><div id="7y5NeR53khVo5Sw8UnjaRD" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个简单的示例，展示了如何在<span class="jill"></span>MySQL<span class="jill"></span>中实现可重复读隔离级别：</span></div></div><code-block id="tr3iW1VWJewAUX6xxKKQjB" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token comment">-- 设置事务的隔离级别为可重复读</span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span>

<span class="token comment">-- 开始事务</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>

<span class="token comment">-- 执行查询操作</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 执行更新操作</span>
<span class="token keyword">UPDATE</span> employees <span class="token keyword">SET</span> salary <span class="token operator">=</span> salary <span class="token operator">*</span> <span class="token number">1.1</span> <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 再次执行相同的查询操作，结果应该与第一次相同</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 提交事务</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block><div id="jvCKp9DrFqztAvBpiDxZzK" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个示例中，第一个查询和第二个查询返回的结果集应该是相同的，即使在两次查询之间进行了更新操作。这是因为可重复读隔离级别确保了在同一个事务中多次读取同一数据时，结果保持一致。</span></div></div><div id="dyz3J3wwpwpGXZdWq9iVqM" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，通过设置适当的事务隔离级别并显式地管理事务，可以在<span class="jill"></span>MySQL<span class="jill"></span>中实现可重复读隔离级别，从而确保数据的一致性和完整性。</span></div></div><div id="tTT5wH2GE2hFpFtP1cusGc" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nFra6SyQPaMdN7br78n1wf" class="wolai-block"><span class="wolai-serial-number">31</span><span class="inline-wrap">什么是悲观锁和乐观锁？它们有什么区别？</span></h1><div id="4JBudnu7D4CmzJa5xtcuK2" class="wolai-block wolai-text"><div><span class="inline-wrap">乐观锁和悲观锁是两种常见的并发控制策略，它们在多线程或多进程环境下用于保护数据一致性，防止出现脏读、不可重复读和幻读等现象。以下是对它们的详细介绍：</span></div></div><h2 id="3jMPwtxWhteFWiwRxNeqgX" class="wolai-block"><span class="wolai-serial-number">31.1</span><span class="inline-wrap">定义</span></h2><ul class="wolai-block"><li id="efp1yzQDA542kLkmrGR4yf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>乐观锁</b></span><span class="inline-wrap">：假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</span></li><li id="2JbasCNsDoJp2pthBzqSFE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>悲观锁</b></span><span class="inline-wrap">：假设会冲突，所以在操作前就锁定数据，确保同一时间只有一个线程能进行写操作。</span></li></ul><h2 id="2QjyKCi1ZZhivgzRhx7Q1A" class="wolai-block"><span class="wolai-serial-number">31.2</span><span class="inline-wrap">实现方式</span></h2><ul class="wolai-block"><li id="6CsxDaJJgyvFUttLvoUcqZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>乐观锁</b></span><span class="inline-wrap">：通常是通过版本号（version）或时间戳（timestamp）等机制来实现。在数据表中增加一个数字类型的 “version” 字段，当读取数据时，将<span class="jill"></span>version<span class="jill"></span>字段的值一同读出，数据每更新一次，对此<span class="jill"></span>version<span class="jill"></span>值加一。当提交更新时，判断数据库表对应记录的当前版本信息与第一次取出来的<span class="jill"></span>version<span class="jill"></span>值进行比对，如果相等则予以更新，否则认为是过期数据。</span></li><li id="3GDg8SZVA467gktJQRLx2h"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>悲观锁</b></span><span class="inline-wrap">：通常依靠数据库提供的锁机制（如行锁、读锁和写锁等），在修改数据之前先获取锁，以确保其他事务不能访问该资源，直到自己的事务完成并释放锁。</span></li></ul><h2 id="qU5Wr9jNnTQoEDq9HqMzNm" class="wolai-block"><span class="wolai-serial-number">31.3</span><span class="inline-wrap">优缺点对比</span></h2><span class="inline-wrap"></span><br/><div id="a9jQcttR2mHZgiaEQgnjgK" class="wolai-block wolai-text"><div><span class="inline-wrap">优缺点对比</span></div></div><span class="inline-wrap"></span><br/><div id="8puGNPFWwC4Tf3FR4tXRD3" class="wolai-block wolai-text"><div><span class="inline-wrap">悲观锁</span></div></div><span class="inline-wrap"></span><br/><div id="jUiEYsA6H3ypC48JpUiBxB" class="wolai-block wolai-text"><div><span class="inline-wrap">乐观锁</span></div></div><span class="inline-wrap"></span><br/><div id="3AHhWtshsNpV9mHggf6av8" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>优点</b></span></div></div><span class="inline-wrap"></span><br/><div id="orwQYRGUHVSWfYYNiK48vG" class="wolai-block wolai-text"><div><span class="inline-wrap">数据一致性高，能确保事务在任一时刻只被一个事务访问和修改，避免数据的不一致性和脏读。</span></div></div><span class="inline-wrap"></span><br/><div id="bkycRX8ULMiVZdMR34pEcv" class="wolai-block wolai-text"><div><span class="inline-wrap">高并发高吞吐，不会阻塞其他事务的读取操作，只在提交时检查数据是否被修改，可以提供更好的并发性能。</span></div></div><span class="inline-wrap"></span><br/><div id="f5j1ghR2udJa5znYs6DpPU" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>缺点</b></span></div></div><span class="inline-wrap"></span><br/><div id="vZ7mRRfMUzEFUWnYi9V3X7" class="wolai-block wolai-text"><div><span class="inline-wrap">性能开销大，操作数据前需要获取锁，如果有大量的并发操作，可能会导致性能问题，因为其他事务需要等待锁释放。</span></div></div><span class="inline-wrap"></span><br/><div id="fENTbAniPYn9RTWMznqWZ1" class="wolai-block wolai-text"><div><span class="inline-wrap">冲突处理复杂，在提交时需要检查数据是否被其他事务修改，如果发现冲突，需要回滚事务或重新尝试操作，这增加了冲突处理的复杂性。</span></div></div><h2 id="sjtfEyakM5bLRUx4UNNRp3" class="wolai-block"><span class="wolai-serial-number">31.4</span><span class="inline-wrap">适用场景</span></h2><ul class="wolai-block"><li id="9hZq9ACsnNp17ZN57FdE5T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>乐观锁</b></span><span class="inline-wrap">：适用于读多写少、冲突较少的场景，如商品查询、排行榜查询等。在这些场景中，读取操作远多于写入操作，且数据冲突的可能性较小，使用乐观锁可以提高系统的吞吐量和并发性能。</span></li><li id="7nN9Qhmh1EJr2QBBJ6sJoS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>悲观锁</b></span><span class="inline-wrap">：适用于写操作较多、数据竞争激烈的场景，如数据库事务、金融、医疗等行业中对数据一致性要求极高的场景。在这些场景中，写操作频繁且对数据的准确性和一致性要求非常高，使用悲观锁可以确保数据在任一时刻只被一个事务访问和修改，从而满足数据一致性的要求。</span></li></ul><div id="uPeFdDwoQWBp9FtWTxkHdT" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pCU6AXth7V8GUAoKq4vbfX" class="wolai-block"><span class="wolai-serial-number">32</span><span class="inline-wrap">请解释什么是死锁（Deadlock），并描述如何检测和解决死锁。</span></h1><div id="2Gn6SgfoqZNutnCnsSjCbB" class="wolai-block wolai-text"><div><span class="inline-wrap">死锁（Deadlock）是指两个或多个线程因争夺资源而发生互相等待的现象，若无外力作用，这些线程都将无法向前推进。</span></div></div><div id="aWCBvKmatdSA9Qu21G3EAM" class="wolai-block wolai-text"><div><span class="inline-wrap">检测死锁的方法主要有以下几种：</span></div></div><ol class="wolai-block"><li id="73AyzaRhM67SC4yCNzHD9r"><div class="marker"></div><span class="inline-wrap"><b>资源分配图法</b></span><span class="inline-wrap">：通过绘制资源分配图，查看是否存在环路。若存在环路，则说明发生了死锁。在资源分配图中，节点表示进程或资源，有向边表示资源的申请或分配关系。</span></li><li id="jtngXzoaEshNbn42R8HYtv"><div class="marker"></div><span class="inline-wrap"><b>银行家算法</b></span><span class="inline-wrap">：这是一种避免死锁的算法，也可用于检测死锁。该算法通过判断系统是否处于安全状态来检测死锁。如果系统处于不安全状态，则可能发生死锁。</span></li><li id="qQCnTWrSWvif5RmpJB2RWL"><div class="marker"></div><span class="inline-wrap"><b>查找所有路径法</b></span><span class="inline-wrap">：在资源分配图中，找出所有可能的路径，检查每条路径上资源的分配情况。如果存在一条路径，使得每个进程都能获得所需的资源，则说明系统没有死锁；否则，系统可能存在死锁。</span></li></ol><div id="4ZBGdA9T7333tePsfED8ye" class="wolai-block wolai-text"><div><span class="inline-wrap">解决死锁的方法通常有以下几种：</span></div></div><ol class="wolai-block"><li id="f5JzHAn3FpE6d7a29xzhPB"><div class="marker"></div><span class="inline-wrap"><b>预防死锁</b></span><span class="inline-wrap">：通过破坏死锁产生的四个必要条件中的一个或多个来预防死锁的发生。例如，可以采用资源预先分配策略，让进程一次性申请它所需的全部资源，这样就避免了占有资源又申请资源的情况；或者采用资源有序分配策略，将资源按序号递增的顺序分配给进程。</span></li><li id="vy9o6DR93TkaNHJqz2y8A3"><div class="marker"></div><span class="inline-wrap"><b>避免死锁</b></span><span class="inline-wrap">：对进程的每个资源申请命令动态地进行检查，根据检查结果决定是否进行资源分配。如果分配后系统可能进入不安全状态，则拒绝分配，从而避免死锁的发生。</span></li><li id="qi8FHUPoyCuGPEHRJxh8Hw"><div class="marker"></div><span class="inline-wrap"><b>检测和解除死锁</b></span><span class="inline-wrap">：允许系统进入死锁状态，然后通过检测算法发现死锁，并通过一些方法解除死锁。例如，可以撤销一些死锁进程，剥夺它们的资源并分配给其他进程；或者使用资源剥夺法，挂起某些死锁进程，抢占它们的资源并分配给其他死锁进程。</span></li></ol><div id="n1gbjms9s49Q8feaoLLa2E" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，死锁问题虽然复杂，但通过合理的检测与解决方法，可以有效避免或解决这一问题，保障系统稳定运行。</span></div></div><div id="mMYkoibYab7xeYCb41dxbt" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="p3aNknpVg6rjB6Tdp4HtRw" class="wolai-block"><span class="wolai-serial-number">33</span><span class="inline-wrap">如何在数据库中实现并发控制？</span></h1><div id="detvHMQTPcUwp1vtbTUZLE" class="wolai-block wolai-text"><div><span class="inline-wrap">在数据库中实现并发控制主要有以下几种方法：</span></div></div><ol class="wolai-block"><li id="oc1Aj4SEyrg585ysrZcb3V"><div class="marker"></div><span class="inline-wrap"><b>锁机制</b></span><ul class="wolai-block"><li id="jovevG9Br34ATMnfP9j2po"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁和排他锁</b></span><span class="inline-wrap">：共享锁允许多个事务同时读取数据，但不能修改；排他锁则完全独占数据项，其他任何事务都无法访问该数据项。例如，在一个新闻网站中，当多个用户同时查看一篇新闻文章时，可以对这篇文章加共享锁，允许大家阅读，但如果有人要编辑该文章，就需要先获取排他锁。</span></li><li id="dDE9SQS7wHrCrYhVPRzzpN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>两阶段锁协议</b></span><span class="inline-wrap">：分为锁定阶段和解锁阶段。在锁定阶段，事务可以请求并获得锁，但不能释放任何锁；在解锁阶段，事务可以释放锁，但不能再请求任何锁。通过这种方式，保证了事务的原子性和隔离性。</span></li></ul></li><li id="vEppvjiUJeRmNsgc9sJfsg"><div class="marker"></div><span class="inline-wrap"><b>时间戳排序</b></span><ul class="wolai-block"><li id="iuFeX1t76A5jo9ifKod7at"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本时间戳排序</b></span><span class="inline-wrap">：每个事务在开始时分配一个唯一的时间戳，系统根据时间戳的顺序来执行事务。如果一个事务的时间戳早于另一个事务的时间戳，那么它必须先执行。这种方法可以避免某些类型的冲突，但可能会导致一些事务等待时间过长。</span></li><li id="w8KqfCr57sETyrRX67NdyN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>多版本时间戳排序</b></span><span class="inline-wrap">：每次写操作会创建一个新的数据版本，读操作则根据时间戳选择合适的版本读取。这样可以提高并发度，减少事务冲突，但也增加了存储开销。</span></li></ul></li><li id="8WAZa6QSmMmtmn9TK1UiaA"><div class="marker"></div><span class="inline-wrap"><b>乐观并发控制</b></span><ul class="wolai-block"><li id="airUKXJf8N1GywUF8hk5DT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设事务冲突较少，因此允许事务在没有锁的情况下执行，只有在提交时才进行冲突检测。如果检测到冲突，事务需要回滚并重新执行。</span></li></ul></li><li id="aQDeTWMdhwAeC2nJGc5388"><div class="marker"></div><span class="inline-wrap"><b>悲观并发控制</b></span><ul class="wolai-block"><li id="7mTV1y2Zhg5XefB7X3nnQv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设事务之间经常发生冲突，因此在事务读写数据之前会先锁定资源。这种方式虽然能有效地避免冲突，但也会带来额外的开销和性能损耗，特别是在高并发环境下。</span></li></ul></li></ol><div id="4GGCero8ibVWnkYLPFhsXZ" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，这些方法各有优缺点，具体选择哪种方法取决于应用场景、系统需求以及性能要求等因素。</span></div></div><div id="xscgLYr3mVbtL2zL7oaZeX" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3djYBeMgFbaTfnnXCXzKoW" class="wolai-block"><span class="wolai-serial-number">34</span><span class="inline-wrap">请解释两阶段锁定协议（Two-Phase Locking）。</span></h1><div id="9cNZBDfK2D4zQ3uEDpUs1z" class="wolai-block wolai-text"><div><span class="inline-wrap">两阶段锁定协议（Two-Phase Locking，简称 2PL）是一种用于并发控制的协议，旨在确保多个事务在同时访问数据库时能够保持数据的一致性和隔离性。以下是对其的详细解释：</span></div></div><ol class="wolai-block"><li id="4ovzJepJEdCNZP1Ar4n56c"><div class="marker"></div><span class="inline-wrap"><b>基本概念</b></span><ul class="wolai-block"><li id="7aRhJRmNKRtjK3u8Bsjc6m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>两个阶段</b></span><ul class="wolai-block"><li id="2wrkNRkcqL8fyFRnJPHZhM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>增长阶段</b></span><span class="inline-wrap">：也称为扩展阶段或加锁阶段。在此阶段，事务可以获取任何锁，但不能释放任何锁。事务可以不断申请并获得新的锁，以访问需要操作的数据项。例如，一个事务在读取数据 A 时会先获取 A 的共享锁，然后再读取数据 B 时获取 B 的共享锁，在这个过程中可以持续获取其他数据项的锁。</span></li><li id="evB2trPL3gPXjjhKu7MnuL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缩减阶段</b></span><span class="inline-wrap">：也称为收缩阶段或解锁阶段。在该阶段，事务可以释放任意数量的锁，但不能获取新的锁。当事务完成对某些数据的读写操作后，就可以释放相应的锁。比如，事务在对数据 A 的操作完成后，就可以释放 A 的锁。</span></li></ul></li></ul></li><li id="6wpjthMa7nw654j6KVatur"><div class="marker"></div><span class="inline-wrap"><b>工作原理</b></span><ul class="wolai-block"><li id="ovYWS6inf7fQzsCi5Mt2bq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>加锁阶段</b></span><ul class="wolai-block"><li id="tPwq29bpCrcWsoNxF6Tda7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当事务需要对数据进行读或写操作时，首先必须获得相应的锁。如果是读操作，则申请共享锁；如果是写操作，则申请排他锁。</span></li><li id="7giCZTBvszjBR2nrd7LRgG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果所需的锁已经被其他事务占用，那么该事务必须等待，直到锁被释放。只有当锁可用时，事务才能获取锁并执行相应的操作。</span></li><li id="wgEa9gQUenjgLWwDau8e8H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在获取锁之后，事务将锁状态设置为 “保持” 状态，表示已经成功获得了锁。</span></li></ul></li><li id="wFaYLjqXHBFE57ypTgA3WM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>解锁阶段</b></span><ul class="wolai-block"><li id="pJGqbHhn7iUUMaCroerCjS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务执行完操作后，释放它所持有的锁。此时锁状态从 “保持” 状态变为 “减少” 状态。</span></li><li id="j34xwfBXGQPkHDBjE6ZBCn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一旦事务进入解锁阶段，就不能再获取新的锁。如果事务在释放锁之前还需要获取其他的锁，那么它会因为违反协议而被阻塞或回滚。</span></li><li id="47sBCoadtFMfuPfN74pAY6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当事务已经释放了所有锁，并且没有其他锁请求时，锁状态变为 “自由” 状态，表示该事务已经完成了所有的操作。</span></li></ul></li></ul></li><li id="nwqgZNaoxtgtRML2KhY7Fr"><div class="marker"></div><span class="inline-wrap"><b>重要原则</b></span><ul class="wolai-block"><li id="tUwF6PdEK8wxuWUkEzLphH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>严格两段锁原则</b></span><span class="inline-wrap">：事务在执行期间可以获取锁，但在提交或回滚之前不能释放锁。这意味着事务必须在所有操作都完成后才能释放锁，以确保其他事务不会读取或修改它正在使用的数据。</span></li><li id="w5xVMbs4d1sVbSWjVwSZtZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>现在等待原则</b></span><span class="inline-wrap">：如果一个事务请求一个被其他事务占用的锁，它必须等待直到锁被释放。这样可以防止死锁的发生，避免多个事务之间相互等待对方释放锁而陷入僵局。</span></li></ul></li><li id="cMQqbkVS9bp1PXignSmMQA"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="5Sa9DxUcZsQN9zHxmuPK84"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>保证数据一致性</b></span><span class="inline-wrap">：通过严格的锁定机制，确保每个事务看到的数据都是一致的状态，避免了脏读、不可重复读和幻读等并发问题。</span></li><li id="dnTz65LKA7ZYeE28bqDjcD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提供事务隔离性</b></span><span class="inline-wrap">：使得不同事务之间的操作互不干扰，保证了数据库的并发控制和数据的准确性。</span></li><li id="iokMqDJ2mvLsZB3z8G5BzR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>预防死锁</b></span><span class="inline-wrap">：其严格的加锁和解锁规则有助于减少死锁的发生概率，提高系统的可靠性和稳定性。</span></li></ul></li><li id="b34KAgfzLqPLUAgQjUF1JD"><div class="marker"></div><span class="inline-wrap"><b>缺点</b></span><ul class="wolai-block"><li id="7ZgsWT5oVNWXrkvt32BPWw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>降低并发性</b></span><span class="inline-wrap">：由于事务在持有锁期间会阻止其他事务对同一数据项的访问，可能会导致一些事务长时间等待，从而降低了系统的并发性能。</span></li><li id="g6z6c819gSQkZjKhYz7eoE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>可能出现死锁</b></span><span class="inline-wrap">：尽管有预防措施，但在某些复杂的并发场景下，仍然可能发生死锁的情况，需要额外的机制来检测和解决死锁。</span></li></ul></li><li id="5NTxixSnNHkqETWc9baaGr"><div class="marker"></div><span class="inline-wrap"><b>应用场景</b></span><ul class="wolai-block"><li id="oMU8PBjhsanFL6bHzFca85"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">适用于对数据一致性和隔离性要求较高的场景，如银行转账、订单处理等关键业务系统，确保在这些系统中数据的准确和安全。</span></li><li id="qVQpVMHYgohX1re2d8BvDt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在一些对并发性能要求不是特别高，但对数据完整性要求严格的企业级应用中也有广泛的应用，如库存管理系统、财务管理系统等。</span></li></ul></li></ol><div id="kowKHDLLXYonsbt9EB47vH" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，两阶段锁定协议（Two-Phase Locking）是一种重要的并发控制机制，通过其独特的加锁与解锁策略，有效保障了数据库操作的一致性与隔离性。然而，它也面临着降低并发性和潜在死锁的挑战。因此，在实际应用中，需要根据具体场景权衡利弊，合理选择是否采用此协议，并可能需要结合其他技术来优化系统性能和可靠性。</span></div></div><div id="aZJ6WTqaHsG8aU981KSZSF" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="sQcqaREhQ75Yz5hMYXTeRF" class="wolai-block"><span class="wolai-serial-number">35</span><span class="inline-wrap">请解释什么是表锁（Table Lock）以及其在<span class="jill"></span>MySQL<span class="jill"></span>中的实现。</span></h1><div id="b8tUd5p6Kp26NVCpSeNWj1" class="wolai-block wolai-text"><div><span class="inline-wrap">表锁（Table Lock）是对整个数据库表进行锁定，以控制对该表的并发访问和修改。以下是关于表锁以及其在 MySQL 中的实现的详细解释：</span></div></div><h2 id="juvg227WHAPwDDz5jchKxg" class="wolai-block"><span class="wolai-serial-number">35.1</span><span class="inline-wrap">表锁的定义与特点</span></h2><ul class="wolai-block"><li id="rWr4JBVoWstrfjW3TaNqHz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：表锁是一种数据库锁机制，用于在对数据库表进行操作时，防止其他事务同时对同一表进行可能产生冲突的操作。</span></li><li id="4GR5vrQp5THcC7nhmw3Bpx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>特点</b></span><span class="inline-wrap">：开销小、加锁快、锁定粒度大、发生锁冲突的概率高、并发度最低。</span></li></ul><h2 id="uFXSL444us6JRUAUrsooLL" class="wolai-block"><span class="wolai-serial-number">35.2</span><span class="inline-wrap">表锁的类型</span></h2><ul class="wolai-block"><li id="2dgC7RHNGadUVuAUnkCL2k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表共享读锁（Table Read Lock）</b></span><span class="inline-wrap">：允许其他事务进行读取操作，但阻止其他事务对该表进行写操作。</span></li><li id="7Y9CNZbdTFGCUvSnwcJwzj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表独占写锁（Table Write Lock）</b></span><span class="inline-wrap">：阻止其他事务对该表进行读取和写入操作，只有持有写锁的连接可以对表进行读写操作。</span></li></ul><h2 id="mtzfHnXVnDbhEQJG6Cb7Kp" class="wolai-block"><span class="wolai-serial-number">35.3</span><span class="inline-wrap">MySQL 中实现表锁的方法</span></h2><ul class="wolai-block"><li id="rgmmhtD7R8LzxKQ5pwSkwU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用 </b></span><span class="inline-wrap"><b><code>LOCK TABLES</code></b></span><span class="inline-wrap"><b> 语句</b></span><span class="inline-wrap">：可以通过该语句手动添加表锁，语法为 </span><span class="inline-wrap"><code>LOCK TABLES table_name READ;</code></span><span class="inline-wrap"> 或 </span><span class="inline-wrap"><code>LOCK TABLES table_name WRITE;</code></span><span class="inline-wrap">。要解除读锁或写锁，可以执行 </span><span class="inline-wrap"><code>UNLOCK TABLES;</code></span><span class="inline-wrap">。</span></li><li id="ecvpwCR95uiNi5ktownwu9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>自动加锁</b></span><span class="inline-wrap">：在对表进行增删改查操作时，MySQL 会自动对表加 MDL 读锁；当要对表做结构变更操作时，MySQL 会自动对表加 MDL 写锁。</span></li></ul><h2 id="24y4iovsyxYAB2UyX4YkNs" class="wolai-block"><span class="wolai-serial-number">35.4</span><span class="inline-wrap">示例</span></h2><div id="2iHfh3EAgw1EhX1HjnHLDf" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个使用 </span><span class="inline-wrap"><code>LOCK TABLES</code></span><span class="inline-wrap"> 语句对表加锁和解锁的示例：</span></div></div><ol class="wolai-block"><li id="44MqR7KzBMuNN9ZzV7T7Pp"><div class="marker"></div><span class="inline-wrap">创建测试表并插入数据：</span><code-block id="7zxsgkg7n81fn9z9SCJvks" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mylock <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mylock <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="gKyiB5akNoKkAbRwxAvb8"><div class="marker"></div><span class="inline-wrap">开启两个会话窗口，在 A 会话中对 mylock 表加读锁，在 B 会话中尝试对 mylock 表进行写操作：</span><ul class="wolai-block"><li id="hm9jiqDZLkTCj49LT9vgAq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A 会话：</span><code-block id="2XbR3Rs1dNgw65dewFpexA" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> mylock <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mylock<span class="token punctuation">;</span></pre></div></code-block></li><li id="25WCAYNoshtBCS2scPXEdu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B 会话：</span><code-block id="5v8XxeZU4diAwq8hsheZA4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> mylock <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">'z'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block></li></ul></li><li id="x6tGk56AycB69GFjKJCYNR"><div class="marker"></div><span class="inline-wrap">查看表上的锁情况：</span><code-block id="o9EvYa2bjhxQWkCE9wixP" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SHOW</span> PROCESSLIST<span class="token punctuation">;</span></pre></div></code-block></li><li id="e2T2953xiVR1wn2hCLMrdh"><div class="marker"></div><span class="inline-wrap">释放 A 会话中的读锁：</span><code-block id="dVYNjkFsmsGrQjBi4UDQZB" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><div id="vNXjTpZWB5cjkXBKtGEB9e" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jfbua4uuVXvaR7EVknZejP" class="wolai-block"><span class="wolai-serial-number">36</span><span class="inline-wrap">请描述<span class="jill"></span>MySQL<span class="jill"></span>中的意向锁（Intention Lock）。</span></h1><div id="vu8YqQEZYfeJo8f33CaVaM" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MySQL 中，意向锁是一种表级锁，用于协调不同粒度的锁（行级锁和表级锁）之间的冲突，优化并发事务的锁管理。以下是对 MySQL 中的意向锁的描述：</span></div></div><ol class="wolai-block"><li id="bj7e9bSbKtnLv3eBopEocC"><div class="marker"></div><span class="inline-wrap"><b>类型</b></span><ul class="wolai-block"><li id="5ipEcxzcHtYfLJpodoPbSa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>意向共享锁（Intention Shared Lock，IS）</b></span><span class="inline-wrap">：表示事务计划在某些行上加共享锁。当一个事务持有某个表的意向共享锁时，它表示该连接希望在这个表上加上共享锁。</span></li><li id="tqSFf8UA3nquQnSnGncF46"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>意向排他锁（Intention Exclusive Lock，IX）</b></span><span class="inline-wrap">：表示事务计划在某些行上加排他锁。当一个连接持有某个表的意向排他锁时，它表示该连接希望在这个表上加上独占锁。</span></li></ul></li><li id="tPjVvetRJBuxSQG5AJSC8M"><div class="marker"></div><span class="inline-wrap"><b>工作原理</b></span><ul class="wolai-block"><li id="cAESisSNBcUm4YpnW2V7L4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当一个事务请求获取一个行级锁或表级锁时，MySQL 会自动获取相应的表的意向锁。这样，其他事务请求获取表锁时，就可以先基于这个意向锁来发现是否有人加过锁，并根据该锁的类型来判断自己是否可以获取锁。通过这种方式，当一个事务请求表级锁时，InnoDB 可以快速确定是否有任何行级锁冲突，而无需检查表中每一行的锁状态。</span></li></ul></li><li id="fwGq4ir4K2f6iBoXkcA5NR"><div class="marker"></div><span class="inline-wrap"><b>加锁流程</b></span><ul class="wolai-block"><li id="p1434hWj6VwUFZUuJZXgBX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>请求意向锁</b></span><span class="inline-wrap">：事务发出加意向锁的请求。</span></li><li id="4YjxGGft6F18yRoAtm3zdm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>检查兼容性</b></span><span class="inline-wrap">：MySQL 检查意向锁是否与当前表上的其他意向锁或表级锁兼容。如果兼容，则加锁成功。</span></li><li id="3ToxUM5rbwU8ccNHDDJokH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>后续加锁操作</b></span><span class="inline-wrap">：事务在行级别上加共享锁或排他锁时，只需检查意向锁而无需检查整个表。</span></li><li id="xxhHL13ikaA6eR7yEJEUWi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>释放锁</b></span><span class="inline-wrap">：事务提交或回滚后，释放意向锁。</span></li></ul></li><li id="g2yXcKmxLtAV9R3dkDF4R7"><div class="marker"></div><span class="inline-wrap"><b>锁兼容矩阵</b></span><ul class="wolai-block"><li id="4pWKvjxAC76pEierKVoLRS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IS 和 IS 是兼容的，可以同时存在。</span></li><li id="6vsqmPZjjgXve8WrzVhhu6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IS 和 IX 是兼容的，可以同时存在。</span></li><li id="wTJoYrSh77Cx3MHias4X2c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IX 和 IX 是兼容的，可以同时存在。</span></li><li id="cMKpZUhJKND7i9gYHbrdC3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S 和 IS 是兼容的，可以同时存在。</span></li><li id="hg2wuFsaggWCrGg7V26bWB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">S 和 IX 以及 X 锁都是不兼容的。</span></li></ul></li><li id="m74ppdiPHHjsDpr1qwGPhZ"><div class="marker"></div><span class="inline-wrap"><b>使用场景</b></span><ul class="wolai-block"><li id="8kodfMw4rg2TL6JzDgK7r7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高并发读写场景</b></span><span class="inline-wrap">：在高并发读写操作中，意向锁减少了锁冲突检测的开销，提高了系统的并发性能。</span></li><li id="5HHc9xAWY8dSSpQhRYPB85"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>行级锁与表级锁混合使用</b></span><span class="inline-wrap">：当事务需要在行级别加锁但可能会有其他事务请求表级锁时，意向锁有助于快速检测冲突。</span></li></ul></li></ol><div id="vbW1wra9yXuK4dUFZYTPif" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，MySQL<span class="jill"></span>中的意向锁通过提供表级的锁定信息，避免了系统去逐行检查是否可以加表锁，极大提高了加表锁的效率，从而提升了数据库的整体性能和并发控制能力。</span></div></div><div id="sVrMGLKSC2WKCoMRwAeizP" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kjPMedtorrcNwV3AHracw3" class="wolai-block"><span class="wolai-serial-number">37</span><span class="inline-wrap">请解释什么是行锁（Row Lock），以及它在<span class="jill"></span>MySQL<span class="jill"></span>中的实现。</span></h1><div id="36JMkFYJZrWbMG2VbxRRY2" class="wolai-block wolai-text"><div><span class="inline-wrap">行锁（Row Lock）是 MySQL 中用于控制对单行数据的并发访问的机制，以下是关于它的具体介绍：</span></div></div><ol class="wolai-block"><li id="kepdCNYo7ut8TBc2mWPF1U"><div class="marker"></div><span class="inline-wrap"><b>定义</b></span><ul class="wolai-block"><li id="gfsvFDF4742hicbuBJcnY1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当多个事务同时访问同一行数据时，行锁可以防止其他事务对该行的读写操作，从而保证数据的一致性和完整性。</span></li></ul></li><li id="npnQtB2RrxqgY7RQdULs2z"><div class="marker"></div><span class="inline-wrap"><b>类型</b></span><ul class="wolai-block"><li id="tiQUpD6FEJpokKTC1W6xjf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁（S 锁）</b></span><span class="inline-wrap">：允许多个事务同时读取同一行数据，但不允许修改。主要用于查询操作，确保在事务期间读取的数据不会被其他事务修改。</span></li><li id="mPpH16tcqeW6gMQwGJ3wQz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>排他锁（X 锁）</b></span><span class="inline-wrap">：只允许一个事务对行进行修改，其他事务既不能读也不能写该行。主要用于更新、插入和删除操作。</span></li></ul></li><li id="uhpoLBvXc28ND6WaoC8VT5"><div class="marker"></div><span class="inline-wrap"><b>实现方式</b></span><ul class="wolai-block"><li id="i13g7QWFEshxQJahzdu4UT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于索引的行锁</b></span><span class="inline-wrap">：InnoDB 存储引擎通过索引来管理行锁，当使用索引字段进行查询时，会对命中的索引项加锁，而不是全表扫描。</span></li><li id="67crDmVKo9MPRGfXWAYqUd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>记录锁（Record Lock）</b></span><span class="inline-wrap">：封锁特定的行记录，阻止其他事务对该行的插入、更新和删除操作。</span></li><li id="bEmXPgwUNP7usvPNBTRJXu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁（Gap Lock）</b></span><span class="inline-wrap">：锁定索引记录之间的空隙，或者第一条索引记录之前、最后一条索引记录之后的空隙，防止幻读现象。</span></li><li id="5bsn43zhcvpUtYcM6fu81M"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临键锁（Next-Key Lock）</b></span><span class="inline-wrap">：结合了记录锁和间隙锁，锁住一段左开右闭区间的数据，避免幻读。</span></li></ul></li><li id="bibC7bhrGeCMBK52PvPgev"><div class="marker"></div><span class="inline-wrap"><b>加锁与释放时机</b></span><ul class="wolai-block"><li id="pR6jYQf2onhGRmApzCMEy8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">行锁通常在事务开始时申请，在事务结束时释放。</span></li></ul></li><li id="hMbDk4XanKpMe3MjrzptQX"><div class="marker"></div><span class="inline-wrap"><b>死锁问题</b></span><ul class="wolai-block"><li id="tVhF755C9wuttqMyrgdT5v"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">多个事务相互持有对方所需的行锁，导致无法继续执行的情况。可以通过调整事务顺序、缩小锁的粒度、设置合理的超时时间等方法来避免或解决死锁问题。</span></li></ul></li></ol><div id="mVhtKwZvK2Z2C5kVFwnKba" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，MySQL<span class="jill"></span>中的行锁是数据库并发控制的重要机制之一，它通过多种类型的锁和不同的实现方式，保证了在多用户环境下数据的一致性和完整性，同时也提高了系统的并发性能。</span></div></div><div id="3Bt1AYMZJcNkhfEoi8SYed" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="5Zsogkw2ts2hi6SeAHmJGN" class="wolai-block"><span class="wolai-serial-number">38</span><span class="inline-wrap">如何在<span class="jill"></span>MySQL<span class="jill"></span>中查看当前的锁信息？</span></h1><div id="emsCxG3rFgGGhw5eTzLZ7C" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MySQL 中，可以通过多种方式查看当前的锁信息。以下是一些常用的方法：</span></div></div><h2 id="bk8ySHikRVvb7LnCrEPLUQ" class="wolai-block"><span class="wolai-serial-number">38.1</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>SHOW PROCESSLIST</code></span><span class="inline-wrap"> 命令</span></h2><div id="7yHGtrt6vcoiyi6rQ3xx1n" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SHOW PROCESSLIST</code></span><span class="inline-wrap"> 命令可以显示当前正在运行的线程及其状态。通过该命令，你可以查看哪些线程正在等待锁以及它们的状态。</span></div></div><code-block id="a8SUaCaXNAQi6gQz9nHDby" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SHOW</span> PROCESSLIST<span class="token punctuation">;</span></pre></div></code-block><div id="8Ptjv6yuVeNBiFVJ2z99R4" class="wolai-block wolai-text"><div><span class="inline-wrap">输出示例：</span></div></div><span class="inline-wrap"></span><br/><div id="dWSgpobtkbHMkTy9y1gXov" class="wolai-block wolai-text"><div><span class="inline-wrap">Id</span></div></div><span class="inline-wrap"></span><br/><div id="fSskVoXV16ZNgEh2smJd3u" class="wolai-block wolai-text"><div><span class="inline-wrap">User</span></div></div><span class="inline-wrap"></span><br/><div id="dBV5Sq1undsJ6i9PCvuXph" class="wolai-block wolai-text"><div><span class="inline-wrap">Host</span></div></div><span class="inline-wrap"></span><br/><div id="bSoR1QWXceyZQKnW7iGxSX" class="wolai-block wolai-text"><div><span class="inline-wrap">db</span></div></div><span class="inline-wrap"></span><br/><div id="nSnTrShHsm1e1rvCnWQ34g" class="wolai-block wolai-text"><div><span class="inline-wrap">Command</span></div></div><span class="inline-wrap"></span><br/><div id="7ovXrmLjvjSdV59Ekrpz7G" class="wolai-block wolai-text"><div><span class="inline-wrap">Time</span></div></div><span class="inline-wrap"></span><br/><div id="2cyMnqjsjqSfL7wwXm8uuv" class="wolai-block wolai-text"><div><span class="inline-wrap">State</span></div></div><span class="inline-wrap"></span><br/><div id="wcLsU9HzsAGv71K4XyLdNV" class="wolai-block wolai-text"><div><span class="inline-wrap">Info</span></div></div><span class="inline-wrap"></span><br/><div id="5Uozvs5j5JKTeaC6u48Dox" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="jCZjQzkARQGHyy1X5E51ZL" class="wolai-block wolai-text"><div><span class="inline-wrap">root</span></div></div><span class="inline-wrap"></span><br/><div id="q2RxUSWoJsXn9WNeJpaiyC" class="wolai-block wolai-text"><div><span class="inline-wrap">localhost</span></div></div><span class="inline-wrap"></span><br/><div id="oBrdcWF2Ep3f3mcVUo2vB7" class="wolai-block wolai-text"><div><span class="inline-wrap">test</span></div></div><span class="inline-wrap"></span><br/><div id="vdcnGkxKuAQYBze56hthUj" class="wolai-block wolai-text"><div><span class="inline-wrap">Query</span></div></div><span class="inline-wrap"></span><br/><div id="i7ufsuDLfSGauzXeTHNyxY" class="wolai-block wolai-text"><div><span class="inline-wrap">0</span></div></div><span class="inline-wrap"></span><br/><div id="s4MUBi6px9tRmC2siXP8Yy" class="wolai-block wolai-text"><div><span class="inline-wrap">NULL</span></div></div><span class="inline-wrap"></span><br/><div id="re7ZFFWUtbR7rCj3LJqSR4" class="wolai-block wolai-text"><div><span class="inline-wrap">SHOW PROCESSLIST</span></div></div><span class="inline-wrap"></span><br/><div id="kDaHABCZRpFnNEahMmnqV7" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="6ncfCtiqPwZYUFf7jYAxzd" class="wolai-block wolai-text"><div><span class="inline-wrap">root</span></div></div><span class="inline-wrap"></span><br/><div id="ntxA8YfZF4FPCugFGJiuzx" class="wolai-block wolai-text"><div><span class="inline-wrap">localhost</span></div></div><span class="inline-wrap"></span><br/><div id="tW8HCB7jZ84KSbnmv148vX" class="wolai-block wolai-text"><div><span class="inline-wrap">test</span></div></div><span class="inline-wrap"></span><br/><div id="pZgikpgKSkx1r1qKLoHrc1" class="wolai-block wolai-text"><div><span class="inline-wrap">Sleep</span></div></div><span class="inline-wrap"></span><br/><div id="98pLHPxpd8ff98xQqVph5w" class="wolai-block wolai-text"><div><span class="inline-wrap">10</span></div></div><span class="inline-wrap"></span><br/><div id="cxaJXVQGzDzxcrBHfMRYzQ" class="wolai-block wolai-text"><div><span class="inline-wrap">NULL</span></div></div><span class="inline-wrap"></span><br/><div id="ocH9afmzZuAKHrhSP68gQ7" class="wolai-block wolai-text"><div><span class="inline-wrap">NULL</span></div></div><span class="inline-wrap"></span><br/><div id="cqAfXEkFGpy1J3yB9dKaZY" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="aDGjz9iPqaQ8xSDWHtdPzs" class="wolai-block wolai-text"><div><span class="inline-wrap">root</span></div></div><span class="inline-wrap"></span><br/><div id="psjBSF7TcGVGnYKNpLHnQo" class="wolai-block wolai-text"><div><span class="inline-wrap">localhost</span></div></div><span class="inline-wrap"></span><br/><div id="hfKd3dgFBt32KqMiNQjzKQ" class="wolai-block wolai-text"><div><span class="inline-wrap">test</span></div></div><span class="inline-wrap"></span><br/><div id="u8FycFnReLeJMyFyx69TDP" class="wolai-block wolai-text"><div><span class="inline-wrap">Query</span></div></div><span class="inline-wrap"></span><br/><div id="xqjqk2xayeqbbqv9zf5CUP" class="wolai-block wolai-text"><div><span class="inline-wrap">5</span></div></div><span class="inline-wrap"></span><br/><div id="szcDA2yEUXqvJPDD3hTKJ3" class="wolai-block wolai-text"><div><span class="inline-wrap">Locked</span></div></div><span class="inline-wrap"></span><br/><div id="vHV57NuDPhYNtVi2FiDpUE" class="wolai-block wolai-text"><div><span class="inline-wrap">UPDATE mytable SET name=&#39;z&#39; WHERE id=1</span></div></div><div id="a7z2K1MdBAUTpsHyXBidYM" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个例子中，可以看到 ID 为 3 的线程处于 &quot;Locked&quot; 状态，表示它正在等待一个锁。</span></div></div><h2 id="5Yo78t8GTCJmonJBPEgbL3" class="wolai-block"><span class="wolai-serial-number">38.2</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_LOCKS</code></span><span class="inline-wrap"> 表</span></h2><div id="hvSkEhQwBR42A7tCcqnyVj" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_LOCKS</code></span><span class="inline-wrap"> 表提供了有关 InnoDB 存储引擎中的锁的信息。</span></div></div><code-block id="9tDBjzj3hfKzEAoQRNHTfU" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCKS<span class="token punctuation">;</span></pre></div></code-block><div id="9NdeNfE7ajUoHypRe38WKR" class="wolai-block wolai-text"><div><span class="inline-wrap">输出示例：</span></div></div><span class="inline-wrap"></span><br/><div id="woutnqp8UwXkkgGrqrEYrm" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_id</span></div></div><span class="inline-wrap"></span><br/><div id="ttmELWxgoCjrfpWMiSGHkH" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_trx_id</span></div></div><span class="inline-wrap"></span><br/><div id="pCrWTkVDRypQg37sSyf8nP" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_mode</span></div></div><span class="inline-wrap"></span><br/><div id="f9sYbyQtCtz6pdiL6UnP6M" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_type</span></div></div><span class="inline-wrap"></span><br/><div id="7RWnaAArWoJFScskxwsNG" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_table</span></div></div><span class="inline-wrap"></span><br/><div id="bmTrm3eYxQ9CVmiDyWshvm" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_index</span></div></div><span class="inline-wrap"></span><br/><div id="dpDKUSbfbHwvDwWopaqmKn" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_space</span></div></div><span class="inline-wrap"></span><br/><div id="qRHfCfoPSFZNtDrTKkG6Ky" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_page</span></div></div><span class="inline-wrap"></span><br/><div id="6RWDiHjzCfAHU2qYMEKcji" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_rec</span></div></div><span class="inline-wrap"></span><br/><div id="qcYA5LJFG7KeYtY4djMVP5" class="wolai-block wolai-text"><div><span class="inline-wrap">lock_data</span></div></div><span class="inline-wrap"></span><br/><div id="p37LKjYaMiDNkMW4rQWozR" class="wolai-block wolai-text"><div><span class="inline-wrap">12345:67890</span></div></div><span class="inline-wrap"></span><br/><div id="84xHtNAd9Vb28nkca2fmbz" class="wolai-block wolai-text"><div><span class="inline-wrap">12345</span></div></div><span class="inline-wrap"></span><br/><div id="wznsavSUmGRiZ6Es5mhRGB" class="wolai-block wolai-text"><div><span class="inline-wrap">X</span></div></div><span class="inline-wrap"></span><br/><div id="2N9QNUyQD4FkiNFNNzAQyC" class="wolai-block wolai-text"><div><span class="inline-wrap">RECORD</span></div></div><span class="inline-wrap"></span><br/><div id="LwVWiBbxEVrG4nLSX1phM" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>test</code></span><span class="inline-wrap">.</span><span class="inline-wrap"><code>mytable</code></span></div></div><span class="inline-wrap"></span><br/><div id="j8NFk4Hzw63Y8GnVLM4PpU" class="wolai-block wolai-text"><div><span class="inline-wrap">PRIMARY</span></div></div><span class="inline-wrap"></span><br/><div id="sKgxPkRbkG5vjvLdJwWpCs" class="wolai-block wolai-text"><div><span class="inline-wrap">67890</span></div></div><span class="inline-wrap"></span><br/><div id="a4zSoDNxYojbtpieGjzSWW" class="wolai-block wolai-text"><div><span class="inline-wrap">4</span></div></div><span class="inline-wrap"></span><br/><div id="rVnDZ19aBt1kNCrp6Wsqxf" class="wolai-block wolai-text"><div><span class="inline-wrap">5</span></div></div><span class="inline-wrap"></span><br/><div id="k5mAYKwKig53cULisyAYQk" class="wolai-block wolai-text"><div><span class="inline-wrap">12345</span></div></div><h2 id="3nnPTHmeEBQh8gYwuVyc81" class="wolai-block"><span class="wolai-serial-number">38.3</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code></span><span class="inline-wrap"> 表</span></h2><div id="41dYPZqZVSFJeJqLUeqz5w" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code></span><span class="inline-wrap"> 表提供了有关哪些事务正在等待锁的信息。</span></div></div><code-block id="sDwLmTK41JF4MkMQ39RJcY" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_LOCK_WAITS<span class="token punctuation">;</span></pre></div></code-block><div id="wEXb3Pf2ZKnFJNrKSDA7uB" class="wolai-block wolai-text"><div><span class="inline-wrap">输出示例：</span></div></div><span class="inline-wrap"></span><br/><div id="99ThyHjotg2mQg6sVCMFa1" class="wolai-block wolai-text"><div><span class="inline-wrap">requesting_trx_id</span></div></div><span class="inline-wrap"></span><br/><div id="8isrQc61tPkoGkQR9S49io" class="wolai-block wolai-text"><div><span class="inline-wrap">requested_lock_id</span></div></div><span class="inline-wrap"></span><br/><div id="pUVkoHvjQXuDdDzpyAEm61" class="wolai-block wolai-text"><div><span class="inline-wrap">blocking_trx_id</span></div></div><span class="inline-wrap"></span><br/><div id="uea7tnepe7H6SfkGbFNNuo" class="wolai-block wolai-text"><div><span class="inline-wrap">blocking_lock_id</span></div></div><span class="inline-wrap"></span><br/><div id="daYQ4nhT3qQFC66U94d6rd" class="wolai-block wolai-text"><div><span class="inline-wrap">12345</span></div></div><span class="inline-wrap"></span><br/><div id="rwTLjAnRnpgLmMYLekXZgU" class="wolai-block wolai-text"><div><span class="inline-wrap">12345:67890</span></div></div><span class="inline-wrap"></span><br/><div id="4k5qxVSXhHMswviH5xQs5e" class="wolai-block wolai-text"><div><span class="inline-wrap">67891</span></div></div><span class="inline-wrap"></span><br/><div id="nH7kgc68CQLYhSasiT1nok" class="wolai-block wolai-text"><div><span class="inline-wrap">67891:67890</span></div></div><h2 id="4cydBkwAH6AqYWfvQiKe21" class="wolai-block"><span class="wolai-serial-number">38.4</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_TRX</code></span><span class="inline-wrap"> 表</span></h2><div id="4bBkF2SLxwpmndsVxovDYX" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>INFORMATION_SCHEMA.INNODB_TRX</code></span><span class="inline-wrap"> 表提供了有关当前正在进行的 InnoDB 事务的信息。</span></div></div><code-block id="dpvEubbZSZ5okCgswQ1T6E" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span></pre></div></code-block><div id="fea8LqddcbwLtcoqWUkTDB" class="wolai-block wolai-text"><div><span class="inline-wrap">输出示例：</span></div></div><span class="inline-wrap"></span><br/><div id="jNbVq83QGJ6UxEp1h9NcHo" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_id</span></div></div><span class="inline-wrap"></span><br/><div id="7Jgqoa9dgrsRzf7b49hsJA" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_state</span></div></div><span class="inline-wrap"></span><br/><div id="3dVnZB2EzsQaNcwYo5XrAD" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_started</span></div></div><span class="inline-wrap"></span><br/><div id="sUaMrgmkFEJCk21uLpwTFo" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_requested_lock_id</span></div></div><span class="inline-wrap"></span><br/><div id="vFboyQApKiwQqat47Kkd8y" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_wait_started</span></div></div><span class="inline-wrap"></span><br/><div id="hPDBG1baLafDNaehBUa7GW" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_weight</span></div></div><span class="inline-wrap"></span><br/><div id="2Cik1TCYwUujfNJ1bT2AZv" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_mysql_thread_id</span></div></div><span class="inline-wrap"></span><br/><div id="8qizLYdHvyqwRtYsftvmhH" class="wolai-block wolai-text"><div><span class="inline-wrap">trx_query</span></div></div><span class="inline-wrap"></span><br/><div id="giNxpm8mu73kPBLu7ZqPQR" class="wolai-block wolai-text"><div><span class="inline-wrap">12345</span></div></div><span class="inline-wrap"></span><br/><div id="27YrjE7yobvv3uCByrRmUW" class="wolai-block wolai-text"><div><span class="inline-wrap">RUNNING</span></div></div><span class="inline-wrap"></span><br/><div id="pduu6FNCS8rVenqMA1tBjS" class="wolai-block wolai-text"><div><span class="inline-wrap">2023-10-01 12:34:56</span></div></div><span class="inline-wrap"></span><br/><div id="enPwG2uFjJeKpEoY7GKx8L" class="wolai-block wolai-text"><div><span class="inline-wrap">12345:67890</span></div></div><span class="inline-wrap"></span><br/><div id="89bnDFd6dKWzyMFRHgR1BC" class="wolai-block wolai-text"><div><span class="inline-wrap">NULL</span></div></div><span class="inline-wrap"></span><br/><div id="8uJjgjnpGHNbnqihJ3aon7" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="uC1M5QZKEvLC2XQPzPyny" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="2dCBgAFLpF3Tv5jyMrLpQM" class="wolai-block wolai-text"><div><span class="inline-wrap">UPDATE mytable 
SET name=&#39;z&#39; WHERE id=1</span></div></div><h2 id="pUKWELBbdc6tU6CaFLSgQu" class="wolai-block"><span class="wolai-serial-number">38.5</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>SHOW ENGINE INNODB STATUS</code></span><span class="inline-wrap"> 命令</span></h2><div id="jAgYrPeWST2u3BcdxkAAVo" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SHOW ENGINE INNODB STATUS</code></span><span class="inline-wrap"> 命令提供了关于 InnoDB 存储引擎的详细状态信息，包括锁信息。</span></div></div><code-block id="di5Kma1DLirdz5iTtngwV7" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span></pre></div></code-block><div id="hrNorfJMQV9qee8qA21tVF" class="wolai-block wolai-text"><div><span class="inline-wrap">输出示例（部分）：</span></div></div><code-block id="wVJ7FELRw8rSVfKQ6om39v" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>------------
TRANSACTIONS
------------
Trx id counter 12345
Purge done for trx's n:o &lt; 12345 undo n:o &lt; 0 state: running but idle
History list length 10
...</pre></div></code-block><div id="tTxv6YcqfZtcX8YniukcZR" class="wolai-block wolai-text"><div><span class="inline-wrap">这些命令和表可以帮助你监控和诊断数据库中的锁问题，从而更好地管理并发事务和优化性能。</span></div></div><div id="uSiwi8FCAnYva46v2cqfKq" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bzeExjZKTGRyjhsi5NXVBV" class="wolai-block"><span class="wolai-serial-number">39</span><span class="inline-wrap">请描述<span class="jill"></span>MySQL<span class="jill"></span>中的锁粒度及其对性能的影响。</span></h1><div id="vaFaGxKNcFHU3b2gD5qCAN" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是对<span class="jill"></span>MySQL<span class="jill"></span>中锁粒度及其对性能影响的描述：</span></div></div><h2 id="tDhRVBAbz41rLfQ5EmbcuD" class="wolai-block"><span class="wolai-serial-number">39.1</span><span class="inline-wrap">锁粒度</span></h2><ul class="wolai-block"><li id="i3NwNvUMdjDET9B2K8r1vH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：是<span class="jill"></span>MySQL<span class="jill"></span>中锁定粒度最大的一种锁，由<span class="jill"></span>MySQL Server<span class="jill"></span>控制，会对整个表进行加锁。当对一张表执行<span class="jill"></span>DDL<span class="jill"></span>语句（如<span class="jill"></span>ALTER TABLE、CREATE TABLE<span class="jill"></span>等）时，会自动加上表级锁；也可以手动指定加表级锁。一般分为读锁和写锁，读锁允许其他会话读取当前被加锁的表，但不能写入；写锁则不允许其他会话对该表进行读写操作。</span></li><li id="6QUA3UqWGDHzWsBg9oxrr6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>行级锁</b></span><span class="inline-wrap">：由存储引擎实现，不同的存储引擎支持的锁机制不同，如<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎支持行级锁。只有通过索引条件检索数据，InnoDB<span class="jill"></span>才会使用行级锁，否则将使用表级锁。行级锁的优点是锁粒度小，发生锁冲突的概率低，并发度高，但开销大、加锁慢，并且可能会产生死锁。</span></li><li id="7gmH6pnbQjMjoPgtr5vuwp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>页面锁</b></span><span class="inline-wrap">：介于表级锁和行级锁之间，会锁定表中的一页数据。当一个事务对某一页数据进行写操作时，其他事务可以对该表中的其他页数据进行读写操作。</span></li></ul><h2 id="e8aKoPNwj2bxXWTiJ1kDhG" class="wolai-block"><span class="wolai-serial-number">39.2</span><span class="inline-wrap">对性能的影响</span></h2><ul class="wolai-block"><li id="mxBhruScpQBQWBdkprbQFd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：开销小、加锁快，不会产生死锁，能提升系统的并发处理能力。但是，它的锁定粒度大，发生锁冲突的概率也最高，会大大降低数据库的并发度。</span></li><li id="eDA7iznoZDJrk1zZuzzvcy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>行级锁</b></span><span class="inline-wrap">：虽然开销大、加锁慢，并且可能会出现死锁的情况，但它的锁定粒度小，发生锁冲突的概率最低，能够支持更高的并发度，在高并发的应用场景下，整体性能比表级锁更优。</span></li><li id="ksPd1sLiwUuzSwsUEXLcMA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>页面锁</b></span><span class="inline-wrap">：并发能力和开销都比较适中，但实现相对复杂。</span></li></ul><div id="6NFGC7vX9piicmc6jNgWNe" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6XbHAbfctzVWAavPBabmPM" class="wolai-block"><span class="wolai-serial-number">40</span><span class="inline-wrap">请解释<span class="jill"></span>MySQL<span class="jill"></span>中的间隙锁（Gap Lock）及其作用。</span></h1><div id="v5r8CK2n23i8SbQNYRSEmQ" class="wolai-block wolai-text"><div><span class="inline-wrap">间隙锁（Gap Lock）是 MySQL 中一种用于并发控制的行锁机制，以下是关于它的解释及作用：</span></div></div><h2 id="aSERPuyeSf55WHXmu6t3LV" class="wolai-block"><span class="wolai-serial-number">40.1</span><span class="inline-wrap">间隙锁的解释</span></h2><div id="6LNsbvd4s7CfyYe8x7gyNA" class="wolai-block wolai-text"><div><span class="inline-wrap">间隙锁是 MySQL 在可重复读（REPEATABLE-READ）隔离级别下对索引记录之间的间隙进行加锁的一种机制。它锁定的是索引范围之间的间隙，这些间隙可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</span></div></div><h2 id="7EMwEKbXkQELHxDr2otMSb" class="wolai-block"><span class="wolai-serial-number">40.2</span><span class="inline-wrap">触发条件</span></h2><ol class="wolai-block"><li id="gFi3arKN2xn81qMqLG9vfs"><div class="marker"></div><span class="inline-wrap"><b>事务隔离级别</b></span><span class="inline-wrap">：只有在可重复读（REPEATABLE-READ）隔离级别下才会产生间隙锁；在其他隔离级别下，如读提交（READ COMMITTED），MySQL 可能会使用临时的意向锁来避免并发问题，而不是生成真正的间隙锁。</span></li><li id="gMW6esSy3CVqK8PdVF5RZR"><div class="marker"></div><span class="inline-wrap"><b>查询条件</b></span><span class="inline-wrap">：当一个事务使用普通索引进行范围查询时，MySQL 会在满足条件的索引范围之间的间隙上生成间隙锁；如果查询的条件列上有索引，并且查询未命中任何记录，也会在与该条件相邻的间隙上加上间隙锁。</span></li></ol><h2 id="vHVuvJ79T7qxaR3FsnH3jr" class="wolai-block"><span class="wolai-serial-number">40.3</span><span class="inline-wrap">间隙锁的作用</span></h2><ol class="wolai-block"><li id="5QwDdgiAtmEpFpkEqLUBiF"><div class="marker"></div><span class="inline-wrap"><b>防止幻读</b></span><span class="inline-wrap">：间隙锁的主要作用是防止幻读现象的发生。在可重复读隔离级别下，通过加锁索引记录之间的间隙，阻止其他事务在这个范围内插入新的数据，从而保证当前事务多次读取结果的一致性。</span></li><li id="RF4dRrSNTWSH6Vnq9azmh"><div class="marker"></div><span class="inline-wrap"><b>保持数据一致性</b></span><span class="inline-wrap">：在高并发环境下，间隙锁可以确保数据的完整性和一致性，避免因并发操作导致的数据不一致问题。</span></li><li id="6TxSB59izkQQUtEgcmLnZK"><div class="marker"></div><span class="inline-wrap"><b>防止数据误删/改</b></span><span class="inline-wrap">：间隙锁还可以防止其他事务在当前事务正在处理的范围内删除或修改数据，从而保护数据的完整性。</span></li></ol><div id="4rT1EXBdW5Uo2SmAVbbxao" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，间隙锁是 MySQL 在可重复读隔离级别下提供的一种重要的并发控制机制，它通过加锁索引记录之间的间隙来防止幻读、保持数据一致性以及防止数据误删/改，对于保证数据库系统的稳定性和可靠性具有重要意义。</span></div></div><div id="8Vz7LCQ7e6juqvvjuyGPBn" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="5r18uzyvgyQnqzUpsGN874" class="wolai-block"><span class="wolai-serial-number">41</span><span class="inline-wrap">请描述<span class="jill"></span>Next-Key Lock<span class="jill"></span>是什么及其在<span class="jill"></span>MySQL<span class="jill"></span>中的使用场景。</span></h1><div id="743uWtKdj8uDy9HbVxRnbj" class="wolai-block wolai-text"><div><span class="inline-wrap">Next-Key Lock 是 MySQL InnoDB 存储引擎的一种锁机制，主要用于防止幻读现象的发生。以下是关于 Next-Key Lock 的详细描述及其在 MySQL 中的使用场景：</span></div></div><h2 id="naDyAizxLwK2fCmdWuxio2" class="wolai-block"><span class="wolai-serial-number">41.1</span><span class="inline-wrap">定义与作用</span></h2><ul class="wolai-block"><li id="mgAUyubcBZygnEWgiPR7rV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：Next-Key Lock 是一种结合了行锁（Record Lock）和间隙锁（Gap Lock）的锁机制。它通过锁定特定的索引记录及其前后的间隙，确保在一个事务期间，其他事务无法插入位于该间隙的记录。</span></li><li id="oe74qy9rNep1HQJgzRNJHD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>作用</b></span><span class="inline-wrap">：主要用于解决幻读问题，即在同一事务中，两次执行相同的查询，结果集中出现了不同的行，通常是因为其他事务在查询间隔内插入了新记录。</span></li></ul><h2 id="idKZ6PjEqjq25ypNUHQeKG" class="wolai-block"><span class="wolai-serial-number">41.2</span><span class="inline-wrap">加锁规则</span></h2><ul class="wolai-block"><li id="9TvB6EJx7cJ4njPHCAh8B1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>原则<span class="jill"></span>1</b></span><span class="inline-wrap">：加锁的基本单位是 next-key lock，它是前开后闭区间。</span></li><li id="tYP3BbXonn1iNJyqmoURn7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>原则<span class="jill"></span>2</b></span><span class="inline-wrap">：查找过程中访问到的对象才会加锁。</span></li></ul><h2 id="cqJ3Mjz4mKdDVYwG6LQ2TL" class="wolai-block"><span class="wolai-serial-number">41.3</span><span class="inline-wrap">优化策略</span></h2><ul class="wolai-block"><li id="qPqwpq8VJUFSDzJCoJuY92"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>唯一索引等值查询退化为行锁</b></span><span class="inline-wrap">：当对唯一索引进行精确等值查询时，Next-Key Lock 会退化为行锁，只锁定索引记录本身，而不锁定间隙。</span></li><li id="ghzZgRpBC4cEMGNmH7PaKJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>间隙锁优化</b></span><span class="inline-wrap">：在某些情况下，InnoDB 会跳过对间隙的加锁，以提高性能，尤其是在不容易产生冲突的情况下。</span></li></ul><h2 id="sXzQnnbuCBnUwv3MRtr7vh" class="wolai-block"><span class="wolai-serial-number">41.4</span><span class="inline-wrap">使用场景</span></h2><ul class="wolai-block"><li id="626EZskzYxkSo3mqGxz7Dt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>银行系统中的余额查询</b></span><span class="inline-wrap">：用户查询账户余额时可能会执行范围查询（例如，查询特定时间段的交易记录）。通过 Next-Key Locking，系统可以防止其他事务在这个时间段内插入新的交易记录，确保用户每次查询得到的一致结果。</span></li><li id="m9ekLGFRHQbnN6zeBZfNV6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>电商系统中的订单查询</b></span><span class="inline-wrap">：在电商平台中，用户查询某一时间段的订单时，可能需要保证查询过程中订单数据的一致性。通过 Next-Key Locking，避免其他用户在订单查询期间插入新的订单，确保订单数据的一致性。</span></li></ul><div id="f7NFJS7aGPFSnDaTULTGi7" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bXZusH21KREADymnumrc8w" class="wolai-block"><span class="wolai-serial-number">42</span><span class="inline-wrap">如何在<span class="jill"></span>MySQL<span class="jill"></span>中设置锁等待超时时间？</span></h1><div id="uWT1KCm5RVBZov6gqLrczZ" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MySQL 中，可以通过设置锁等待超时时间来控制事务在等待获取锁时的最长等待时间。如果超过这个时间，事务将自动回滚并抛出错误。以下是设置锁等待超时时间的几种方法：</span></div></div><h2 id="3nUbBctRi1iJc5Es8Hskfu" class="wolai-block"><span class="wolai-serial-number">42.1</span><span class="inline-wrap">1. 使用 SQL 语句设置锁等待超时时间</span></h2><ul class="wolai-block"><li id="9AwbdsAtN8rvXcNAwPgUB2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局设置</b></span><span class="inline-wrap">：通过 </span><span class="inline-wrap"><code>SET GLOBAL</code></span><span class="inline-wrap"> 命令可以设置全局的锁等待超时时间，这将影响所有新的连接。例如，将锁等待超时时间设置为 50 秒：</span><code-block id="mTKHneY8kENj4hNTb3qBha" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_lock_wait_timeout <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="3ttecx2MK1inKZr5SmCwSn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>会话设置</b></span><span class="inline-wrap">：通过 </span><span class="inline-wrap"><code>SET SESSION</code></span><span class="inline-wrap"> 命令可以设置当前会话的锁等待超时时间，这只会影响当前连接。例如，将当前会话的锁等待超时时间设置为 30 秒：</span><code-block id="2JGiPgmSv42N8BD1QrrzFJ" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> innodb_lock_wait_timeout <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h2 id="qRG3KC7KTXzJVXHFGkFdNT" class="wolai-block"><span class="wolai-serial-number">42.2</span><span class="inline-wrap">2. 修改配置文件</span></h2><div id="nvKAyZKErNgZG13iyR9Qa8" class="wolai-block wolai-text"><div><span class="inline-wrap">可以在 MySQL 的配置文件（如 my.cnf 或 my.ini）中设置锁等待超时时间，这样在数据库重启后配置仍然有效。在 [mysqld] 部分添加或修改如下配置：</span></div></div><code-block id="ukuea6igUdEWxhyjpDyjAJ" class="wolai-block"><div class="wolai-pre"><div data-lang="Ini" class="marker"></div><pre><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">innodb_lock_wait_timeout</span> <span class="token punctuation">=</span> <span class="token value attr-value">50</span></pre></div></code-block><h2 id="vjJhQdEdj4SUYT9CtcxD5a" class="wolai-block"><span class="wolai-serial-number">42.3</span><span class="inline-wrap">3. 使用系统变量</span></h2><div id="ksxXh223A5wrJVbbZ4zmJR" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 提供了一些系统变量来控制锁等待的行为，除了 </span><span class="inline-wrap"><code>innodb_lock_wait_timeout</code></span><span class="inline-wrap"> 之外，还有以下相关变量：</span></div></div><ul class="wolai-block"><li id="2aNK1FbKuoRsKEB9Ta1NBx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>innodb_rollback_on_timeout</b></span><span class="inline-wrap">：当锁等待超时时是否回滚事务。默认值为 </span><span class="inline-wrap"><code>OFF</code></span><span class="inline-wrap">，表示不回滚；设置为 </span><span class="inline-wrap"><code>ON</code></span><span class="inline-wrap"> 则表示回滚。</span><code-block id="uLeRnN8zVYZRFHPxq53wt4" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_rollback_on_timeout <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h2 id="2fkUy2h8vN5okcTxncE94E" class="wolai-block"><span class="wolai-serial-number">42.4</span><span class="inline-wrap">4. 查看当前锁等待超时时间</span></h2><div id="jTATEfHoRHrZPuS3upJCBw" class="wolai-block wolai-text"><div><span class="inline-wrap">可以使用以下 SQL 语句查看当前的锁等待超时时间设置：</span></div></div><code-block id="bBkmpBJN3AEQ22h2aaJ6ex" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'innodb_lock_wait_timeout'</span><span class="token punctuation">;</span></pre></div></code-block><h2 id="a4SDUA5ueXt5msXvww5xcH" class="wolai-block"><span class="wolai-serial-number">42.5</span><span class="inline-wrap">示例</span></h2><div id="aQhPhnRdU3qc5nPwh9QZNF" class="wolai-block wolai-text"><div><span class="inline-wrap">假设你希望将锁等待超时时间设置为 60 秒，并且希望在锁等待超时时回滚事务，你可以执行以下步骤：</span></div></div><ol class="wolai-block"><li id="am1XhHUU7AA4eFraYZPLVx"><div class="marker"></div><span class="inline-wrap">设置全局锁等待超时时间为 60 秒：</span><code-block id="ujmMgR84ZEYxWSPvngH2Zo" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_lock_wait_timeout <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="5G4dCTuoLY9DiCLrFCZN3n"><div class="marker"></div><span class="inline-wrap">设置在锁等待超时时回滚事务：</span><code-block id="3pMsbXzrfJMhoDg6HJXhzp" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> innodb_rollback_on_timeout <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="gyBR74rS6zgpTZ516fK4oU"><div class="marker"></div><span class="inline-wrap">验证设置是否生效：</span><code-block id="qW64WQUpKi5RAk1fR2JYhc" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'innodb_lock_wait_timeout'</span><span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'innodb_rollback_on_timeout'</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><div id="ckcGtz1E2S7Ah3K5ULfdib" class="wolai-block wolai-text"><div><span class="inline-wrap">通过以上方法，你可以灵活地控制 MySQL 中的锁等待超时时间，从而优化数据库的性能和并发处理能力。</span></div></div><div id="dW1WfpK32e2Tb312YfdDFV" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hKWDXzLNY94g7B8CD2LJRi" class="wolai-block"><span class="wolai-serial-number">43</span><span class="inline-wrap">请解释什么是自适应哈希索引（Adaptive Hash Index）及其作用。</span></h1><div id="jsk8zk9C9aLw8Uh7p42LMJ" class="wolai-block wolai-text"><div><span class="inline-wrap">自适应哈希索引（Adaptive Hash Index，AHI）是 MySQL 中 InnoDB 存储引擎提供的一种高级索引优化技术。以下是对其的解释及作用：</span></div></div><h2 id="8Q4fusM1URQZY2h76rhJb9" class="wolai-block"><span class="wolai-serial-number">43.1</span><span class="inline-wrap">解释</span></h2><div id="qyR6uzkFqwjMaR3NYCWZv" class="wolai-block wolai-text"><div><span class="inline-wrap">自适应哈希索引是一种自动创建和管理的内存中的哈希表结构。它不同于传统的 B-tree 索引，其特点是能够根据查询模式和数据访问频率动态地调整自身结构。当 InnoDB 存储引擎监测到某些索引键值被频繁地以等值查询的方式访问时，会自动在内存中为这些键值建立哈希索引，从而加速后续的等值查询。</span></div></div><h2 id="nhTBA9CccbgYES5RSWDFsg" class="wolai-block"><span class="wolai-serial-number">43.2</span><span class="inline-wrap">作用</span></h2><ol class="wolai-block"><li id="rBwy8Qe7L7kjRxYfHvR5tB"><div class="marker"></div><span class="inline-wrap"><b>提高查询性能</b></span><span class="inline-wrap">：对于经常进行等值查询的场景，自适应哈希索引可以显著减少查找时间。由于哈希索引基于哈希函数将索引键值映射到哈希表中，能够在 O(1) 时间复杂度内完成查找操作，因此比传统的 B-tree 索引更快。</span></li><li id="gPBrMd5bww3pdZndaVx6NK"><div class="marker"></div><span class="inline-wrap"><b>降低资源消耗</b></span><span class="inline-wrap">：通过减少对二级索引树的频繁访问，自适应哈希索引可以降低系统资源的消耗。在高并发环境下，这种优化效果尤为明显，能够提高数据库的整体性能和响应速度。</span></li><li id="bHi8gMb3vfxDbHKY6PDjKE"><div class="marker"></div><span class="inline-wrap"><b>自动适应变化</b></span><span class="inline-wrap">：自适应哈希索引能够根据数据的实时变化和查询模式的变化动态地调整自身的结构和内容。这意味着数据库管理员无需手动干预索引的维护和管理，提高了数据库的自动化程度和易用性。</span></li></ol><div id="91YUBTp22XwJfF4pXkrfFz" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，自适应哈希索引是 MySQL 中 InnoDB 存储引擎提供的一种高效、灵活的索引优化技术，能够显著提升特定类型查询的性能并降低系统资源消耗。</span></div></div><div id="sWLfFgSnWJCDhD2iV3NhZ6" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="8A2QxvRM6zeBeke8goemcN" class="wolai-block"><span class="wolai-serial-number">44</span><span class="inline-wrap">请描述<span class="jill"></span>MySQL<span class="jill"></span>中的全局锁和局部锁的区别。</span></h1><div id="6wR6GxpvHuqbmsv6qUgHxw" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是对 MySQL 中全局锁和局部锁（表级锁）区别的详细描述：</span></div></div><h2 id="uVsyEVxWZgQBSNhzo8rg69" class="wolai-block"><span class="wolai-serial-number">44.1</span><span class="inline-wrap">加锁范围</span></h2><ul class="wolai-block"><li id="r2QcMLxwxiBuCoDEDotULR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局锁</b></span><span class="inline-wrap">：锁定整个数据库实例，使所有表都处于只读状态。</span></li><li id="myMB4936mQCC17V8zzRP5e"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：每次操作锁住整张表，只影响特定的表，其他表可以正常访问。</span></li></ul><h2 id="epY7drdywUHH5AbpKzhqhY" class="wolai-block"><span class="wolai-serial-number">44.2</span><span class="inline-wrap">并发度</span></h2><ul class="wolai-block"><li id="963jfAn7jT72YA1aiBozgo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局锁</b></span><span class="inline-wrap">：由于锁定了整个数据库，所有其他线程的读写操作都会被阻塞，并发度最低，在备份等特定场景下使用。</span></li><li id="4LK7eo3isj9aqbggGZZDiC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：只锁住一张表，其他表仍可正常访问，相比全局锁，对系统整体并发性能的影响较小，但被锁表的并发访问会受到限制。</span></li></ul><h2 id="34nw45vSF78ZGgRcV5kNEu" class="wolai-block"><span class="wolai-serial-number">44.3</span><span class="inline-wrap">应用场景</span></h2><ul class="wolai-block"><li id="kfUitBWSSDLd98UpvJDsbK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局锁</b></span><span class="inline-wrap">：主要用于全库逻辑备份、主从切换等需要保证数据一致性的操作。如使用 </span><span class="inline-wrap"><code>mysqldump</code></span><span class="inline-wrap"> 进行备份时，加上 </span><span class="inline-wrap"><code>--single-transaction</code></span><span class="inline-wrap"> 参数可保证备份的一致性，但对于不支持事务的存储引擎，仍需使用全局锁。</span></li><li id="3PvyoxHHSDnCKLDgBcHQib"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：常用于 MyISAM 引擎的表操作，或在需要对某个表进行保护，防止其他并发操作时使用。例如在对大表进行一些简单操作和维护时，可先加表锁再进行操作，以避免其他线程对该表的干扰。</span></li></ul><h2 id="j4ZdubAdvNkiuW8diWpsKq" class="wolai-block"><span class="wolai-serial-number">44.4</span><span class="inline-wrap">锁的粒度</span></h2><ul class="wolai-block"><li id="iPLxCWtvnFy3csgb6mzpbF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局锁</b></span><span class="inline-wrap">：锁的粒度最大，是整个数据库实例级别的锁。</span></li><li id="7Vn9Nfm5Jo9DtjeTq7xnPW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：锁的粒度介于全局锁和行锁之间，是针对单张表的锁。</span></li></ul><h2 id="eoYMf3Hadc5nTJEJSGxVYv" class="wolai-block"><span class="wolai-serial-number">44.5</span><span class="inline-wrap">对业务的影响</span></h2><ul class="wolai-block"><li id="dipwmRExNSvGphtdDBa1ap"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>全局锁</b></span><span class="inline-wrap">：备份期间如果主库上执行全局锁，会导致业务基本停顿；如果从库执行，会导致主从延迟，影响数据的实时性。</span></li><li id="bs9jgRYK6TMhBP2ZbXtDN2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>表级锁</b></span><span class="inline-wrap">：只影响被锁表的操作，对其他表的业务影响相对较小，但如果该表是业务核心表，也可能会导致部分业务功能受限。</span></li></ul><div id="tAt738Cc7q7nW174ZDP8th" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="gBYLvqW9BfymmFhb16rB4c" class="wolai-block"><span class="wolai-serial-number">45</span><span class="inline-wrap">如何在<span class="jill"></span>MySQL<span class="jill"></span>中手动管理锁（加锁和解锁）？</span></h1><div id="wXGtyqX7SipMy1yARevhrd" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MySQL 中，手动管理锁（加锁和解锁）通常涉及使用表级锁或行级锁。以下是一些常见的方法：</span></div></div><h2 id="oSEKB24e7eQkTeTCdwX21S" class="wolai-block"><span class="wolai-serial-number">45.1</span><span class="inline-wrap">1. 使用表级锁</span></h2><h3 id="4WFEVcP8WLQK4tAUkSmb35" class="wolai-block"><span class="wolai-serial-number">45.1.1</span><span class="inline-wrap">加锁</span></h3><ul class="wolai-block"><li id="u5JDrqdry3gfaGKUUvEMp8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>读锁</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>LOCK TABLES</code></span><span class="inline-wrap"> 命令可以对表进行读锁定，防止其他会话对表进行写操作。例如：</span><code-block id="vVNTen6VZQ95r3pjANpims" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> table_name <span class="token keyword">READ</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="ksbXLyfmwR4TPfDhNAoQKn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>写锁</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>LOCK TABLES</code></span><span class="inline-wrap"> 命令可以对表进行写锁定，防止其他会话对表进行读写操作。例如：</span><code-block id="q9EXzEeQUrYugE9yC2inCG" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> table_name <span class="token keyword">WRITE</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h3 id="duyEirN58ta4FmgyP39J9n" class="wolai-block"><span class="wolai-serial-number">45.1.2</span><span class="inline-wrap">解锁</span></h3><ul class="wolai-block"><li id="2PpnJ4bJYMZNgVVU77Yi47"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>解锁所有表</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>UNLOCK TABLES</code></span><span class="inline-wrap"> 命令可以解锁当前会话锁定的所有表。例如：</span><code-block id="tS9eavDeB3RuYQrxrb2u2M" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h2 id="vrgvgvQ3YM34xyMK64R6Q1" class="wolai-block"><span class="wolai-serial-number">45.2</span><span class="inline-wrap">2. 使用行级锁</span></h2><h3 id="jqkPqm4YrxMkuLo7LQjJBR" class="wolai-block"><span class="wolai-serial-number">45.2.1</span><span class="inline-wrap">加锁</span></h3><ul class="wolai-block"><li id="rWGkC8BkBG4qfgoHAaP5jB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁（读锁）</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>SELECT ... FOR SHARE</code></span><span class="inline-wrap"> 语句可以为查询结果集中的行添加共享锁，允许其他事务读取这些行，但不允许修改。例如：</span><code-block id="6xv2bBJ8BEsiASQen3w4nC" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> condition <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="5nn8yXiMCUVePVDwEDKcXG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>排他锁（写锁）</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>SELECT ... FOR UPDATE</code></span><span class="inline-wrap"> 语句可以为查询结果集中的行添加排他锁，阻止其他事务对这些行进行任何操作。例如：</span><code-block id="x4kB2Xuc7uzwM6uznGCjva" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> condition <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h3 id="9ixjVPD1eUMqsVRwAGz6gM" class="wolai-block"><span class="wolai-serial-number">45.2.2</span><span class="inline-wrap">解锁</span></h3><ul class="wolai-block"><li id="4ii5KCpbCfLpqNWyyQAg4A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提交事务</b></span><span class="inline-wrap">：通过提交事务来释放所有行级锁。例如：</span><code-block id="dNENqDDsGstuMF8iXM8nMs" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="wxfU63VrXNE17KYsTRts6f"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>回滚事务</b></span><span class="inline-wrap">：通过回滚事务来释放所有行级锁。例如：</span><code-block id="vXXzUbqdg4CXcve37juQLX" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block></li></ul><h2 id="i8fpKHBqaYMVDPqaNJJZWe" class="wolai-block"><span class="wolai-serial-number">45.3</span><span class="inline-wrap">示例</span></h2><div id="eHYbX6yVzH9LhFWrbU7Wmj" class="wolai-block wolai-text"><div><span class="inline-wrap">假设有一个名为 </span><span class="inline-wrap"><code>employees</code></span><span class="inline-wrap"> 的表，我们希望手动管理该表上的锁。</span></div></div><h3 id="xA77zuQ1oChkWnni3izf96" class="wolai-block"><span class="wolai-serial-number">45.3.1</span><span class="inline-wrap">使用表级锁</span></h3><ol class="wolai-block"><li id="iUAJbx2rd4SR8mCDRoTzy4"><div class="marker"></div><span class="inline-wrap"><b>加读锁</b></span><span class="inline-wrap">：</span><code-block id="uEC2k3bA6MjwZiZT3VFw7d" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> employees <span class="token keyword">READ</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="3MqUMYaDpqR18kmTgrdTJX"><div class="marker"></div><span class="inline-wrap"><b>执行查询</b></span><span class="inline-wrap">：</span><code-block id="qntK5ZNDHbLDwsK8Zs6j1U" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span></pre></div></code-block></li><li id="juAc8qvusmX7Xy5YFPeSTx"><div class="marker"></div><span class="inline-wrap"><b>解锁</b></span><span class="inline-wrap">：</span><code-block id="ftGZ7Qh3yLqqxNaqr5ZUPm" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><h3 id="oyfnPXy5ZhuCQrTtFwb24J" class="wolai-block"><span class="wolai-serial-number">45.3.2</span><span class="inline-wrap">使用行级锁</span></h3><ol class="wolai-block"><li id="dVc8AjXmn24PtYeuf7PAvM"><div class="marker"></div><span class="inline-wrap"><b>启动事务并加排他锁</b></span><span class="inline-wrap">：</span><code-block id="aaywTxbGFXnTKGpRUAbwZq" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> employee_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="kYJFZTwQDtEycGZwjjg7yU"><div class="marker"></div><span class="inline-wrap"><b>更新数据</b></span><span class="inline-wrap">：</span><code-block id="bLw4Uro7EeeRykgSAxpiLG" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> employees <span class="token keyword">SET</span> salary <span class="token operator">=</span> salary <span class="token operator">+</span> <span class="token number">1000</span> <span class="token keyword">WHERE</span> employee_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="6tHe8ZkBFmYepM4skotaLw"><div class="marker"></div><span class="inline-wrap"><b>提交事务</b></span><span class="inline-wrap">：</span><code-block id="5zzSnrRNy6jzaDpPFcBtMF" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><div id="bwVAcceZQRdFr1MZ9Fmyec" class="wolai-block wolai-text"><div><span class="inline-wrap">通过以上方法，你可以在 MySQL 中手动管理锁，以确保数据的一致性和并发控制。需要注意的是，手动管理锁需要谨慎操作，以避免死锁和性能问题。</span></div></div><div id="qTa7YrTWaE2JG7JCdwDZW4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vzaXCXwXnQoRy2TjhPNJnP" class="wolai-block"><span class="wolai-serial-number">46</span><span class="inline-wrap">请解释自旋锁（Spinlock）及其在<span class="jill"></span>MySQL<span class="jill"></span>中的应用。</span></h1><div id="8ypHJGH94FiB1NXBJBzsMq" class="wolai-block wolai-text"><div><span class="inline-wrap">自旋锁（Spinlock）是一种典型的对临界资源进行互斥访问的手段，其名称来源于它的工作方式。以下是关于自旋锁及其在 MySQL 中的应用的介绍：</span></div></div><h2 id="vzR52jkdrmyjEGSpwZVi7n" class="wolai-block"><span class="wolai-serial-number">46.1</span><span class="inline-wrap">自旋锁的定义与工作原理</span></h2><ul class="wolai-block"><li id="vaHT8KMGTubmQVWwkvKKff"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：自旋锁是一种同步原语，用于在多线程环境中保护共享资源的访问。当一个线程尝试获取自旋锁时，如果锁已经被其他线程占用，该线程将循环等待，不断检查锁的状态，直到成功获取锁为止。</span></li><li id="24NHmN2ZNYZkAEJToRXtbS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>工作原理</b></span><span class="inline-wrap">：自旋锁的实现通常依赖于原子操作，如 compare-and-swap (CAS) 指令。当一个线程尝试获取锁时，它会使用 CAS 指令检查锁的状态，并在锁未被占用时将其设置为占用状态。如果锁已被占用，线程将继续循环等待，直到锁变为可用。</span></li></ul><h2 id="ozekgk1i7464ins4qdHySu" class="wolai-block"><span class="wolai-serial-number">46.2</span><span class="inline-wrap">自旋锁的特点</span></h2><ul class="wolai-block"><li id="2GpBdefbkN3NMfFjzB5zHz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>无阻塞</b></span><span class="inline-wrap">：自旋锁不会使线程进入阻塞状态，而是让线程在获取锁时自旋等待。这意味着线程在等待锁的过程中仍然占用 CPU 资源。</span></li><li id="hhHedPfxS9Ev2UERDZm9d8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>轻量级</b></span><span class="inline-wrap">：自旋锁的实现相对简单，通常只涉及原子操作，因此在短时间的临界区中开销较小。</span></li><li id="tootmMJKZ2uwTG4nbb4V8u"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>适合短时间锁定</b></span><span class="inline-wrap">：由于自旋锁在等待锁时会持续占用 CPU，因此它最适合用于保护短时间的临界区。如果临界区执行时间较长，使用自旋锁可能会导致性能下降。</span></li></ul><h2 id="e77JedcezwvjAr1wMasWcX" class="wolai-block"><span class="wolai-serial-number">46.3</span><span class="inline-wrap">自旋锁在 MySQL 中的应用</span></h2><ul class="wolai-block"><li id="pFuepHhxzgBiFPYbpcnsoC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>InnoDB 存储引擎</b></span><span class="inline-wrap">：在 MySQL 的 InnoDB 存储引擎中，自旋锁被广泛用于控制对其内部数据结构的访问。InnoDB 存储引擎具有复杂的并发控制机制，自旋锁在其中扮演了重要角色，用于保护关键数据结构如表缓存、查询缓存等，以实现高性能和并发。</span></li><li id="9NedBErgkWpPc4MqAVSoQS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>性能优化</b></span><span class="inline-wrap">：通过合理使用自旋锁，MySQL 可以在某些情况下避免线程上下文切换的开销，提高系统的并发性能。然而，需要注意的是，如果自旋锁的持有时间过长或竞争过于激烈，可能会导致 CPU 资源的浪费和系统性能的下降。</span></li></ul><h2 id="gu1Pp1TJtR89EFDqX2CW1W" class="wolai-block"><span class="wolai-serial-number">46.4</span><span class="inline-wrap">示例代码</span></h2><div id="6aAa932MEFpyS1LPXmkiJp" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个使用自旋锁实现线程安全转账功能的示例代码（假设使用 MySQL 数据库）：</span></div></div><code-block id="m9rPL8bQ3WxsyhmkUeb3Z1" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token comment">-- 创建存储锁信息的表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> account_lock <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    lock_status <span class="token keyword">INT</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 初始化锁状态为未加锁</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> account_lock <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 转账存储过程</span>
<span class="token keyword">DELIMITER</span> <span class="token comment">//</span>

<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> TransferFunds<span class="token punctuation">(</span><span class="token operator">IN</span> from_account <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token operator">IN</span> to_account <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token operator">IN</span> amount <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DECLARE</span> done <span class="token keyword">BOOLEAN</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">FALSE</span><span class="token punctuation">;</span>
    <span class="token keyword">DECLARE</span> lock_status <span class="token keyword">INT</span><span class="token punctuation">;</span>
    
    <span class="token comment">-- 自旋等待获取锁</span>
    <span class="token keyword">WHILE</span> <span class="token operator">NOT</span> done <span class="token keyword">DO</span>
        <span class="token keyword">SELECT</span> lock_status <span class="token keyword">INTO</span> <span class="token variable">@lock_status</span> <span class="token keyword">FROM</span> account_lock <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
        <span class="token keyword">IF</span> <span class="token variable">@lock_status</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span>
            <span class="token comment">-- 尝试获取锁</span>
            <span class="token keyword">UPDATE</span> account_lock <span class="token keyword">SET</span> lock_status <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">SELECT</span> lock_status <span class="token keyword">INTO</span> <span class="token variable">@lock_status</span> <span class="token keyword">FROM</span> account_lock <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">IF</span> <span class="token variable">@lock_status</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">THEN</span>
                <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">;</span>
            <span class="token keyword">ELSE</span>
                <span class="token comment">-- 如果获取锁失败，则等待一段时间后重试</span>
                WAIT<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
    
    <span class="token comment">-- 执行转账操作</span>
    <span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
    <span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> amount <span class="token keyword">WHERE</span> id <span class="token operator">=</span> from_account<span class="token punctuation">;</span>
    <span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> amount <span class="token keyword">WHERE</span> id <span class="token operator">=</span> to_account<span class="token punctuation">;</span>
    <span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
    
    <span class="token comment">-- 释放锁</span>
    <span class="token keyword">UPDATE</span> account_lock <span class="token keyword">SET</span> lock_status <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token comment">//</span>

<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></pre></div></code-block><div id="9EPAaT4HmXgJXXkj8Dmmoo" class="wolai-block wolai-text"><div><span class="inline-wrap">这个示例代码展示了如何使用自旋锁来实现一个简单的转账功能。在实际应用中，需要根据具体的需求和场景来选择合适的同步机制和锁策略。</span></div></div><div id="sYNAAp6jXHuhi45fG9d8W2" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="2XZhvzyHHiw57DLNgu5n3s" class="wolai-block"><span class="wolai-serial-number">47</span><span class="inline-wrap">请描述如何使用<span class="jill"></span>SQL<span class="jill"></span>语句显式锁定表或行。</span></h1><div id="tyVbshHXo7jPzZHXDZmmUY" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是几种常见的使用 SQL 语句显式锁定表或行的方法：</span></div></div><h2 id="zi97SPfezP8a767JNDst6" class="wolai-block"><span class="wolai-serial-number">47.1</span><span class="inline-wrap">MySQL</span></h2><ul class="wolai-block"><li id="s2rzqaxDm98zTubcBPmwPT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定表</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="kLe7ZSUhhSq1AfhKzNhGNf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁</b></span><span class="inline-wrap">：允许多个事务读取表，但不允许写操作。语法为 </span><span class="inline-wrap"><code>LOCK TABLES table_name READ</code></span><span class="inline-wrap">。</span></li><li id="ajUxAxSAQSmM2ZGvaiaByj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>排他锁</b></span><span class="inline-wrap">：完全锁定表，禁止其他事务进行任何读写操作。语法为 </span><span class="inline-wrap"><code>LOCK TABLES table_name WRITE</code></span><span class="inline-wrap">。</span></li></ul></li><li id="wiUn7AdmukkVBSTh2sTuaU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定行</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="dXbejA3zgD2DciSwVVyJaF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... FOR UPDATE</code></b></span><span class="inline-wrap">：在查询时锁定所选行，防止其他事务对其进行修改。例如：</span><span class="inline-wrap"><code>SELECT * FROM employees WHERE id = 1 FOR UPDATE</code></span><span class="inline-wrap">。</span></li><li id="s1YywbiT9puq3CBsCUpPzs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... LOCK IN SHARE MODE</code></b></span><span class="inline-wrap">：允许其他事务读取锁定的行，但不允许修改。例如：</span><span class="inline-wrap"><code>SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE</code></span><span class="inline-wrap">。</span></li></ul></li></ul><h2 id="mRjoNdp533gLAhuxBjN9Ki" class="wolai-block"><span class="wolai-serial-number">47.2</span><span class="inline-wrap">PostgreSQL</span></h2><ul class="wolai-block"><li id="2i8kv6izBCwdL1yvBbA9pa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定表</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="j6HUSKWKqi9FGh5qqzmPET"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁</b></span><span class="inline-wrap">：允许多个事务读取表，但不允许写操作。语法为 </span><span class="inline-wrap"><code>BEGIN; LOCK TABLE employees IN SHARE MODE; -- Perform operations on the locked table COMMIT;</code></span><span class="inline-wrap">。</span></li><li id="ay2CA6GYpg19eGVMpCv4FQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>排他锁</b></span><span class="inline-wrap">：完全锁定表，禁止其他事务进行任何读写操作。语法为 </span><span class="inline-wrap"><code>BEGIN; LOCK TABLE employees IN EXCLUSIVE MODE; -- Perform operations on the locked table COMMIT;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="wjdLnwwoTrqoUYxM8ZqZaf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定行</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="purwvU8uBTV6yAEGGWHqih"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... FOR UPDATE</code></b></span><span class="inline-wrap">：在查询时锁定所选行，防止其他事务对其进行修改。例如：</span><span class="inline-wrap"><code>BEGIN; SELECT * FROM employees WHERE id = 1 FOR UPDATE; -- Perform operations on the locked row COMMIT;</code></span><span class="inline-wrap">。</span></li><li id="asT29d6jfUyzRtdwytcffJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... FOR NO KEY UPDATE</code></b></span><span class="inline-wrap">：与 </span><span class="inline-wrap"><code>FOR UPDATE</code></span><span class="inline-wrap"> 类似，但仅锁定满足条件的行，而不锁定索引列。例如：</span><span class="inline-wrap"><code>BEGIN; SELECT * FROM employees WHERE department = &#39;Sales&#39; FOR NO KEY UPDATE; -- Perform operations on the locked rows COMMIT;</code></span><span class="inline-wrap">。</span></li></ul></li></ul><h2 id="kXkfmm8Hv1GM8gXJAtr7m3" class="wolai-block"><span class="wolai-serial-number">47.3</span><span class="inline-wrap">SQL Server</span></h2><ul class="wolai-block"><li id="kW1b6zfC8LrfWr2WKHBhAo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定表</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="vu9rvCUpdATCVDwcwh14Fx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>共享锁</b></span><span class="inline-wrap">：允许多个事务读取表，但不允许写操作。语法为 </span><span class="inline-wrap"><code>BEGIN TRANSACTION; SELECT * FROM employees WITH (HOLDLOCK); -- Perform operations on the locked table COMMIT;</code></span><span class="inline-wrap">。</span></li><li id="2DxTWrZT9QAhJspvboJ7cb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>排他锁</b></span><span class="inline-wrap">：完全锁定表，禁止其他事务进行任何读写操作。语法为 </span><span class="inline-wrap"><code>BEGIN TRANSACTION; SELECT * FROM employees WITH (TABLOCKX); -- Perform operations on the locked table COMMIT;</code></span><span class="inline-wrap">。</span></li></ul></li><li id="fQKNsAoEvAZBUmpBgrGn1o"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>锁定行</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="dyvUZxdbGSj7khDJUSVVGX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... WITH (UPDLOCK)</code></b></span><span class="inline-wrap">：在查询时锁定所选行，防止其他事务对其进行修改。例如：</span><span class="inline-wrap"><code>BEGIN TRANSACTION; SELECT * FROM employees WHERE id = 1 WITH (UPDLOCK); -- Perform operations on the locked row COMMIT;</code></span><span class="inline-wrap">。</span></li><li id="ebZaqTatqU6uCuXyCSMLSj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基于 </b></span><span class="inline-wrap"><b><code>SELECT ... WITH (ROWLOCK, UPDLOCK)</code></b></span><span class="inline-wrap">：与 </span><span class="inline-wrap"><code>UPDLOCK</code></span><span class="inline-wrap"> 类似，但明确指定行级锁和更新锁。例如：</span><span class="inline-wrap"><code>BEGIN TRANSACTION; SELECT * FROM employees WHERE id = 1 WITH (ROWLOCK, UPDLOCK); -- Perform operations on the locked row COMMIT;</code></span><span class="inline-wrap">。</span></li></ul></li></ul><div id="baSEu92pxaii8wLPUXu4Ve" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="t4C1tByBigqc5Rg4UDFj9M" class="wolai-block"><span class="wolai-serial-number">48</span><span class="inline-wrap">请描述如何使用<span class="jill"></span>SELECT ... FOR UPDATE<span class="jill"></span>语句进行行锁。</span></h1><div id="qj3mfFPt7ByNhvurRtWQXT" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，可以使用 </span><span class="inline-wrap"><code>SELECT ... FOR UPDATE</code></span><span class="inline-wrap"> 语句进行行锁。以下是具体步骤：</span></div></div><ol class="wolai-block"><li id="cgAQudCLKzzMh4yoysLiwm"><div class="marker"></div><span class="inline-wrap"><b>开启事务</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>START TRANSACTION</code></span><span class="inline-wrap"> 或 </span><span class="inline-wrap"><code>BEGIN</code></span><span class="inline-wrap"> 语句开启一个事务。例如：</span><code-block id="kP2tsdgNCBPiwGtBxQvJyv" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="nFys5ZSiXAaCtdpUJeF9JT"><div class="marker"></div><span class="inline-wrap"><b>执行查询并加锁</b></span><span class="inline-wrap">：在查询语句中使用 </span><span class="inline-wrap"><code>FOR UPDATE</code></span><span class="inline-wrap"> 关键字来获取行锁。例如，要锁定 </span><span class="inline-wrap"><code>users</code></span><span class="inline-wrap"> 表中 </span><span class="inline-wrap"><code>id</code></span><span class="inline-wrap"> 为 1 的行，可以这样写：</span><code-block id="aWnu3J35xxVNkqPKR8gBfC" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="rpKLrX61p68r7bh6XinSwj"><div class="marker"></div><span class="inline-wrap"><b>对查询结果进行操作</b></span><span class="inline-wrap">：在获取行锁后，可以对查询结果进行修改或其他操作，如更新、删除等。例如：</span><code-block id="mYBe9sVuSyCYa8t1BGxTFd" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">UPDATE</span> users <span class="token keyword">SET</span> name <span class="token operator">=</span> <span class="token string">'new_name'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="aE9FqMM3jcTiyh4CkpX72F"><div class="marker"></div><span class="inline-wrap"><b>提交事务</b></span><span class="inline-wrap">：使用 </span><span class="inline-wrap"><code>COMMIT</code></span><span class="inline-wrap"> 语句提交事务，释放行锁。例如：</span><code-block id="t5fH5Ju8KRx3SLJpAUGJ8W" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></pre></div></code-block></li></ol><div id="8AhVTXfck9BrPBq3tFFnZY" class="wolai-block wolai-text"><div><span class="inline-wrap">如果需要回滚事务，可以使用 </span><span class="inline-wrap"><code>ROLLBACK</code></span><span class="inline-wrap"> 语句。例如：</span></div><code-block id="ne2ve4J2h5VVMpeStJeaGD" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></pre></div></code-block></div><div id="rEEcozmzLxj8sbnMte93jE" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，行锁是在事务中执行的，并且在事务结束时才会释放。因此，要确保事务的结束，否则行锁将一直被占用，可能导致其他事务无法访问或修改被锁定的行。</span></div></div><div id="d9J2kKy1PSN8TXzEud7ymx" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="22fyjFAe2CscNjjX7RXFvv" class="wolai-block"><span class="wolai-serial-number">49</span><span class="inline-wrap">请解释什么是一致性非锁定读（Consistent Non-Locking Reads）。</span></h1><div id="5SdZo3Qac6WKDFHbRW5ub3" class="wolai-block wolai-text"><div><span class="inline-wrap">一致性非锁定读（Consistent Non-Locking Reads）是<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎的一种读取数据的方式，以下是具体介绍：</span></div></div><ol class="wolai-block"><li id="whMHGtT2dw6YR4YJdnWpiW"><div class="marker"></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：当<span class="jill"></span>InnoDB<span class="jill"></span>执行<span class="jill"></span>SELECT<span class="jill"></span>操作时，如果读取的行正在执行<span class="jill"></span>DELETE<span class="jill"></span>或<span class="jill"></span>UPDATE<span class="jill"></span>操作，此时读取操作不会等待行上锁的释放，而是读取该行的快照数据。这种读取方式被称为一致性非锁定读。</span></li><li id="vYeSCUqQ6MPugWan2msnBt"><div class="marker"></div><span class="inline-wrap"><b>实现原理</b></span><span class="inline-wrap">：通过多版本并发控制（MVCC）机制来实现。InnoDB<span class="jill"></span>为每一行数据维护多个版本，每个事务在读取数据时，会根据一定的规则选择其中一个合适的版本进行读取。这样可以避免不同事务之间的读写冲突，提高数据库的并发性能。</span></li><li id="v7rocBH5E7a9gWCefi2JwZ"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="pfjuiXL5fAApmTkwdaQ1EE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提高并发性</b></span><span class="inline-wrap">：允许多个事务同时对同一行数据进行读取操作，而不会因为写操作导致的行锁而阻塞，大大提高了数据库的并发处理能力。</span></li><li id="pVdxBZQnjH5yGb9wfeQxfA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>降低锁争用</b></span><span class="inline-wrap">：减少了读操作对写操作的干扰，避免了因等待锁释放而产生的延迟，提高了系统的整体性能。</span></li></ul></li><li id="avEtpwU58p5LmACed1UMxo"><div class="marker"></div><span class="inline-wrap"><b>适用场景</b></span><span class="inline-wrap">：适用于以读操作为主的场景，如数据查询、报表生成等，能够有效提高系统的响应速度和吞吐量。</span></li><li id="f9ZSfPZjnBHuMY7Zi5a8Kc"><div class="marker"></div><span class="inline-wrap"><b>注意事项</b></span><ul class="wolai-block"><li id="mfh1fao1fbcozWgAWrNyhd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>数据一致性</b></span><span class="inline-wrap">：虽然一致性非锁定读可以提高并发性，但在某些情况下可能会导致数据的不一致性。例如，在一个事务中读取到的数据可能是另一个事务尚未提交的修改结果。因此，在使用一致性非锁定读时，需要根据具体的业务需求和数据一致性要求来选择合适的隔离级别。</span></li><li id="jEeLPcDGfvxD7Si8uVVb8y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>索引的使用</b></span><span class="inline-wrap">：为了提高一致性非锁定读的性能，需要合理地设计和使用索引。索引可以帮助<span class="jill"></span>InnoDB<span class="jill"></span>更快地定位到需要读取的行数据，减少不必要的全表扫描，从而提高读取效率。</span></li></ul></li></ol><div id="fNVFwt3FTrh4AYfqDKy7Hg" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，一致性非锁定读是<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎提供的一种高效的数据读取方式，能够在保证一定数据一致性的前提下，提高数据库的并发性能和系统的整体吞吐量。在实际应用中，需要根据具体的业务场景和需求来合理地使用一致性非锁定读，并结合索引等技术来优化其性能。</span></div></div><div id="7mMVksxhCuQutSd6aadDeL" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qtnv1dcxk3cTPyQnzhVZuP" class="wolai-block"><span class="wolai-serial-number">50</span><span class="inline-wrap">如何在<span class="jill"></span>MySQL<span class="jill"></span>中优化锁争用以提高并发性能？</span></h1><div id="s3dS6asDYaMGH6jCFcbRVE" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，可以通过以下多种方法优化锁争用以提高并发性能：</span></div></div><ol class="wolai-block"><li id="91SFA2kLrNfVhyxQth5fuq"><div class="marker"></div><span class="inline-wrap"><b>选择合适存储引擎</b></span><span class="inline-wrap">：InnoDB<span class="jill"></span>是<span class="jill"></span>MySQL<span class="jill"></span>默认的存储引擎，支持行级锁和外键约束，在高并发环境下表现较好。而<span class="jill"></span>MyISAM<span class="jill"></span>仅支持表级锁，适合读多写少的场景，对于频繁写操作的表，应优先选择<span class="jill"></span>InnoDB<span class="jill"></span>存储引擎。</span></li><li id="nev6Gakyj4aZfg9GqhJ1ih"><div class="marker"></div><span class="inline-wrap"><b>优化事务处理</b></span><ul class="wolai-block"><li id="n8QDCy61AdYept7ZvFeCgz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缩短事务执行时间</b></span><span class="inline-wrap">：尽量缩短事务的执行时间，减少事务持锁的时间，避免长时间持有锁资源导致其他事务无法访问相应数据。</span></li><li id="4o5xX3Ki786NGCcvL8osRK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>避免大事务</b></span><span class="inline-wrap">：将复杂的操作分解为多个小事务，降低锁冲突的概率。</span></li></ul></li><li id="r38e8bGDAgeDWGSp1UJ3uB"><div class="marker"></div><span class="inline-wrap"><b>合理设计索引</b></span><ul class="wolai-block"><li id="jSBxrMqfdsyTKN2uYyMXWS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>创建合适索引</b></span><span class="inline-wrap">：对经常用于查询条件的列建立索引，尤其是<span class="jill"></span>WHERE<span class="jill"></span>子句中的条件字段和<span class="jill"></span>JOIN<span class="jill"></span>操作中的连接字段，可减少全表扫描，提高查询效率，进而减少锁争用。例如，如果经常根据</span><span class="inline-wrap"><code>user_id</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>status</code></span><span class="inline-wrap">两个字段进行查询，可创建组合索引</span><span class="inline-wrap"><code>CREATE INDEX idx_user_status ON users (user_id, status);</code></span><span class="inline-wrap">。</span></li><li id="5YabRtXT7ZMWQtQEKcGogK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优化索引结构</b></span><span class="inline-wrap">：避免冗余索引，定期重建索引，因为随着数据更新，索引可能会碎片化，影响查询效率。同时，使用覆盖索引，让索引包含查询所需的所有列，避免回表查询，从而减少锁争用。</span></li></ul></li><li id="8QssiFjPKTxQnG9vxNsB7C"><div class="marker"></div><span class="inline-wrap"><b>调整隔离级别</b></span><span class="inline-wrap">：MySQL<span class="jill"></span>支持多种事务隔离级别，不同的隔离级别对并发性能和一致性有不同的影响。在高并发环境中，可通过降低隔离级别来减少锁争用和死锁情况。一般来说，READ COMMITTED<span class="jill"></span>或<span class="jill"></span>REPEATABLE READ<span class="jill"></span>隔离级别较为常用，而<span class="jill"></span>SERIALIZABLE<span class="jill"></span>隔离级别虽然提供了最高的数据一致性，但会严重影响并发性能。</span></li><li id="p9waDsVFHe1wPvTCGzg2vb"><div class="marker"></div><span class="inline-wrap"><b>控制锁的范围与时间</b></span><ul class="wolai-block"><li id="sEYBXfpw1yMTyUv5GMkNjn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缩小加锁范围</b></span><span class="inline-wrap">：在事务中，尽量只对需要操作的数据行加锁，而不是对整个表或大范围的数据加锁，以减少锁冲突。</span></li><li id="tTw8x43YK7jKQkoEA7bwmS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>减少锁等待时间</b></span><span class="inline-wrap">：通过监控和分析锁等待情况，及时发现并解决锁等待过长的问题。可以根据实际情况调整锁等待超时参数，如</span><span class="inline-wrap"><code>innodb_lock_wait_timeout</code></span><span class="inline-wrap">等。</span></li></ul></li><li id="b4kdy6BdoL21CmEmaxRwem"><div class="marker"></div><span class="inline-wrap"><b>避免锁升级</b></span><span class="inline-wrap">：确保查询语句能够命中索引，减少锁定数据的行数，以避免<span class="jill"></span>MySQL<span class="jill"></span>将行级锁升级为表级锁，从而导致并发性能下降。</span></li><li id="wEfsXpAfXoUYe9tJxQAeeM"><div class="marker"></div><span class="inline-wrap"><b>采用读写分离</b></span><span class="inline-wrap">：在高并发环境下，可使用主从复制和读写分离架构，主数据库负责处理写操作，从数据库负责处理读操作，这样读操作不会影响写操作的锁竞争，从而提升整体性能。</span></li><li id="xirH8BaH3i4JoF6iDL8SGn"><div class="marker"></div><span class="inline-wrap"><b>使用分区表或分片技术</b></span><span class="inline-wrap">：对于大表，可使用表分区或数据库分片技术，将数据划分为多个分区或分片，分散并发查询和更新的压力，减少单个表的锁争用。</span></li><li id="iQYNAJdLZoY8WnKdeVEUy9"><div class="marker"></div><span class="inline-wrap"><b>监控和分析锁的使用情况</b></span><span class="inline-wrap">：定期使用<span class="jill"></span>MySQL<span class="jill"></span>提供的工具，如</span><span class="inline-wrap"><code>SHOW ENGINE INNODB STATUS</code></span><span class="inline-wrap">、INFORMATION_SCHEMA<span class="jill"></span>中的锁表等，监控和分析锁争用情况，及时发现潜在的问题并进行针对性的优化。</span></li></ol><div id="dbJCt1H3VLUvXXcCBFjN89" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，通过以上多种优化策略的综合运用，可以有效减少<span class="jill"></span>MySQL<span class="jill"></span>中的锁争用情况，提高系统的并发性能和响应速度。</span></div></div></article><footer></footer></body></html>