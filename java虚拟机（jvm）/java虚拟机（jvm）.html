<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>Java虚拟机（JVM） - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="Java虚拟机（JVM）" class="main-title"></div></div></header><article><h1 id="fUj8PKuB3sT8Q84Cw9tpAu" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">请介绍一下<span class="jill"></span>JVM<span class="jill"></span>的主要组成部分及其作用</span></h1><div id="8B7nNMWwj1iMJEtRpy4Uea" class="wolai-block"><figure class="wolai-center" style="width: 605.3333333333334px; flex-direction: column"><img src="media/img002.png" style="width: 100%"/></figure></div><h2 id="mBEMkaLF7TZrCipu1v4mD1" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="otmQAffSQQkdpWj5wtradr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类加载器（Class Loader）：将*.class<span class="jill"></span>字节码文件加载到内存中</span></li><li id="8RkVoszbv4fkTt2hgQ2A97"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">执行引擎（Execution Engine）：也叫解释器，负责解释命令，就是将字节码指令解释/编译为当前所在平台上的本地机器指令</span></li><li id="qxRjE7uJ8m5aBQNQ9bnzMY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地接口（Native Interface）：本地接口的作用是融合不同的语言为<span class="jill"></span>Java<span class="jill"></span>所用</span></li><li id="jCCf6GuxVGHQzyYXuT5amX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">栈（Stack）：过去叫<span class="jill"></span>Java<span class="jill"></span>栈内存，现在叫虚拟机栈，Java<span class="jill"></span>程序中方法执行时使用的内存空间，用于存储局部变量表、操作栈、动态链接(即引</span></li></ul><div id="5GynUSReTMvt1wCiz6Leaa" class="wolai-block wolai-text"><div><span class="inline-wrap">用，比如方法区的成员变量)、方法出口等信息</span></div></div><ul class="wolai-block"><li id="jqa1jJ4jxexSD7EkU2KCix"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">堆（Heap）：存放实例对象</span></li><li id="5RCca56u36ZmXZEKTBeHK1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区（Method Area）：它用于存储已被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码缓存等</span></li><li id="9UoURXEzRmxXPDxdqzg9nA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序计数器（PC Register）：每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码</span></li></ul><h2 id="qgyZkMQNVFGYcUwHGZDyJx" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">理解</span></h2><h3 id="sgdEaQDKp1kdnqs9NFgsai" class="wolai-block"><span class="wolai-serial-number">1.2.1</span><span class="inline-wrap">栈空间</span></h3><div id="xwwo1hN9nXyGN8Pabrh7Hg" class="wolai-block wolai-text"><div><span class="inline-wrap">栈空间随着线程的创建而创建，随着线程结束而释放，只要线程一结束，该栈就结束；</span></div></div><div id="d1b63xstZySJKuv2stopYo" class="wolai-block wolai-text"><div><span class="inline-wrap">对于栈来说不存在垃圾回收的问题（垃圾回收只针对于堆和方法区）。</span></div></div><div id="tzDJH6RC4jaJYhK71BmY7w" class="wolai-block wolai-text"><div><span class="inline-wrap">栈中的数据以栈帧的形式存在，是一个数据集，是一个有关方法和运行期数据的集合，</span></div></div><div id="kMkgmVXvaheQRYoqwD3XfM" class="wolai-block wolai-text"><div><span class="inline-wrap">当方法<span class="jill"></span>A<span class="jill"></span>被调用时就产生了一个栈帧<span class="jill"></span>F1，并被压入到栈中，A<span class="jill"></span>方法又调用了<span class="jill"></span>B<span class="jill"></span>方法，</span></div></div><div id="ufwsSvGPRBCiGPHyrkcQ6n" class="wolai-block wolai-text"><div><span class="inline-wrap">于是产生栈帧<span class="jill"></span>F2<span class="jill"></span>也被压入栈，执行完毕后，先弹出<span class="jill"></span>F2<span class="jill"></span>栈帧，再弹出<span class="jill"></span>F1<span class="jill"></span>栈帧，遵循“先进后出”原则。</span></div></div><h3 id="eveJ94JgnP1f9eYa4c7CZD" class="wolai-block"><span class="wolai-serial-number">1.2.2</span><span class="inline-wrap">堆空间</span></h3><div id="sEr8uLsZ8oezFXD3zJ66zD" class="wolai-block wolai-text"><div><span class="inline-wrap">堆空间存放的是实例对象。一个<span class="jill"></span>JVM<span class="jill"></span>实例只存在一个堆内存，堆内存的大小是可以调节的。</span></div></div><div id="3x1wnce8pGah75furHWZRV" class="wolai-block wolai-text"><div><span class="inline-wrap">堆内存分三部分：</span></div></div><ul class="wolai-block"><li id="rocn945on5nKoyV3QB3aWB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">永久区（即存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收掉的，只有关闭<span class="jill"></span>JVM<span class="jill"></span>释放此区域所占用的内存）</span></li><li id="xdegvhs2MTYj6cb2RyFYtV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生区</span></li><li id="jB22YGytVFGVSmFhMedvx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代</span></li></ul><h3 id="xpZxWywwUdhy5KShoNLcHE" class="wolai-block"><span class="wolai-serial-number">1.2.3</span><span class="inline-wrap">方法区</span></h3><div id="knpFz63UEi3Gp6GsBgbbfP" class="wolai-block wolai-text"><div><span class="inline-wrap">方法区只是<span class="jill"></span>JVM<span class="jill"></span>规范中定义的一个概念，它用于存储已被虚拟机加载的类的信息（类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码缓存等。</span></div></div><h3 id="aMLzwJSToZGG2JNhNpLJp9" class="wolai-block"><span class="wolai-serial-number">1.2.4</span><span class="inline-wrap">程序计数器</span></h3><div id="6KTs5ueYDpfkNgNfSoenRe" class="wolai-block wolai-text"><div><span class="inline-wrap">每个线程都有一个程序计数器，它就是一个指针，指向方法区中的方法字节码（用来存储下一条将要执行的字节码指令的地址），用这种方式记录代码执行到了什么位置，线程得到<span class="jill"></span>CPU<span class="jill"></span>时间片后由执行引擎读取下一条指令执行</span></div></div><div id="tS1es7KzFiv9QzwRWkPQuM" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="2DAWXsAfUZmWakcQ94HCyy" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">说一下<span class="jill"></span>JVM<span class="jill"></span>运行时数据区？</span></h1><h2 id="xmAVa84jk6EKhZPLxLozvy" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">背记</span></h2><div id="HwC5NyvWopEPbaTt1KiEi" class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>运行时数据区分为<span class="jill"></span>5<span class="jill"></span>个部分：</span></div></div><ul class="wolai-block"><li id="6yMfTZQYzNfixgvR65MKuS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序计数器（Program Counter Register）</span></li><li id="3NcauwErMMWjcB1RAbZYQV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java 虚拟机栈（Java Virtual Machine Stacks）</span></li><li id="qeGbYXv2WF5kZCr5LScz8U"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地方法栈（Native Method Stack）</span></li><li id="awQQbegPngPEHv4KVfhEkd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java 堆（Java Heap）</span></li><li id="xts5dEGXBzAW2fNt5hsydS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区（Methed Area）</span></li></ul><div id="ajoNwiw2W75x45bx4kpUFY" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sFjyYt8bBHkFfRx7bDrjKj" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">理解</span></h2><div id="hoR774YDyAg3ySvdRcprP2" class="wolai-block wolai-text"><div><span class="inline-wrap">不同虚拟机的运行时数据区可能略微有所不同，但都会遵从<span class="jill"></span>Java<span class="jill"></span>虚拟机规范，Java<span class="jill"></span>虚拟机规范规定的区域分为以下<span class="jill"></span>5<span class="jill"></span>个部分：</span></div></div><ul class="wolai-block"><li id="spC6VHMJMLL62bzen2XD9A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</span></li><li id="qgamaj1C944U5DyUTU4HvE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息</span></li><li id="dWtCg9dmSKeyBFnQZ4CzkQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地方法栈：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务<span class="jill"></span>Java<span class="jill"></span>方法的，而本地方法栈是为虚拟机调用<span class="jill"></span>Native<span class="jill"></span>方法服务的</span></li><li id="3qb1P58jtSMkSpu68eodpg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java 堆：Java<span class="jill"></span>虚拟机中内存最大的一块，是被所有线程共享的，存放对象实例</span></li><li id="6s3hQuJg5Jie9CVD3xJJdK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</span></li></ul><div id="mLCZH6L5Qckf5XwKJnTugx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="nX4kUeHwMttBS2EQfCTk3Y" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hadLtRakMM5xuYhz6oWSNW" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">什么是类加载器？</span></h1><div id="ff9i1oTDUh3EBWwEdBNwbA" class="wolai-block"><figure class="wolai-center" style="width: 546.6666666666666px; flex-direction: column"><img src="media/img003.png" style="width: 100%"/></figure></div><h2 id="opgYFUWHfskLSPHy1ER1Ju" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背记</span></h2><div id="eUeocUUSy1HXScYLFZ99Bo" class="wolai-block wolai-text"><div><span class="inline-wrap">类加载器是负责将<span class="jill"></span>Java<span class="jill"></span>字节码文件（*.class）加载到<span class="jill"></span>Java<span class="jill"></span>虚拟机（JVM）中的组件，根据指定全限定名称将*.class<span class="jill"></span>文件加载到<span class="jill"></span>JVM<span class="jill"></span>内存，然后再转化为<span class="jill"></span>Class<span class="jill"></span>对象</span></div></div><ul class="wolai-block"><li id="h7VgcXjG38mVC9yRx5iZW4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8</span><ul class="wolai-block"><li id="8TFhbYXfwyYWq2LrCHeD61"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">启动类加载器</span></li><li id="nAbpzfCDspbwKWUMVaZ6PR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">扩展类加载器</span></li><li id="neoojppjSuxNnJsJpMnYVA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用类加载器</span></li><li id="8SDNfbDNTkBJ4i8AxjGZ5W"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户自定义类加载器</span></li></ul></li><li id="7AGvqFKt49gZjRdT86GCbD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK9</span><ul class="wolai-block"><li id="mGu4Me5sgkvfDJK9b6yYQD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">启动类加载器</span></li><li id="3YVCoaQcSqu5gFiKpYZYGB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">平台类加载器</span></li><li id="bHU3fQDifhnS7BH34mLQo4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用类加载器</span></li><li id="sBvWbrYwMdc3XS97w1CeSS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户自定义类加载器</span></li></ul></li></ul><div id="xp5hTuPUYNK9YfsNH7sBfu" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7D1qWDQx42xWWKsk3vJXVJ" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">理解</span></h2><div id="avN11xE5LLWhsu3UDHng4y" class="wolai-block wolai-text"><div><span class="inline-wrap">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在<span class="jill"></span>JVM<span class="jill"></span>中的唯一性</span></div></div><div id="sc6XgxryAYXBGpkUxLKzcC" class="wolai-block wolai-text"><div><span class="inline-wrap">每一个类加载器，都有一个独立的类名称空间</span></div></div><div id="drRejKaoeBQUQbuQNfJjcp" class="wolai-block wolai-text"><div><span class="inline-wrap">类加载器就是根据指定全限定名称将*.class<span class="jill"></span>文件加载到<span class="jill"></span>JVM 内存，然后再转化为<span class="jill"></span>Class<span class="jill"></span>对象</span></div></div><div id="mU17w4Nyyytwi5y6BXqAmJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3TDTkqbJTBxT6KVB8qdiDZ" class="wolai-block"><span class="wolai-serial-number">3.3</span><span class="inline-wrap">JDK1.8<span class="jill"></span>的类加载器</span></h2><h3 id="gajNy2GDgpLi2X36EsZtP2" class="wolai-block"><span class="wolai-serial-number">3.3.1</span><span class="inline-wrap">启动类加载器（Bootstrap）C++</span></h3><div id="8ask48xzaDcQpUtAAMBNzD" class="wolai-block wolai-text"><div><span class="inline-wrap">负责加载<span class="jill"></span>$JAVA_HOME<span class="jill"></span>中<span class="jill"></span>jre/lib/下的某些<span class="jill"></span>jre<span class="jill"></span>包中的类【比如<span class="jill"></span>rt.jar】，该类加载器由<span class="jill"></span>C++<span class="jill"></span>实现，不是<span class="jill"></span>ClassLoader<span class="jill"></span>子类</span></div></div><h3 id="cmyuaJD8vwnpnp5TosLeVt" class="wolai-block"><span class="wolai-serial-number">3.3.2</span><span class="inline-wrap">扩展类加载器（Extension）Java</span></h3><div id="kKkoVxuwqvXQMzSFyVnRAb" class="wolai-block wolai-text"><div><span class="inline-wrap">负责加载<span class="jill"></span>Java<span class="jill"></span>平台中扩展功能的一些<span class="jill"></span>jar<span class="jill"></span>包，包括<span class="jill"></span>$JAVA_HOME<span class="jill"></span>中<span class="jill"></span>jre/lib/ext/ *.jar<span class="jill"></span>或-Djava.ext.dirs<span class="jill"></span>指定目录下的<span class="jill"></span>jar<span class="jill"></span>包</span></div></div><h3 id="8XU6Fq4iuNHNtoJ4Mu5p7H" class="wolai-block"><span class="wolai-serial-number">3.3.3</span><span class="inline-wrap">应用程序类加载器（AppClassLoader）</span></h3><div id="cU7pMT7U4bB78eoYo2JEr" class="wolai-block wolai-text"><div><span class="inline-wrap">也叫系统类加载器，负责加载<span class="jill"></span>classpath<span class="jill"></span>中指定的<span class="jill"></span>jar<span class="jill"></span>包及目录中<span class="jill"></span>class<span class="jill"></span>或-Djava.class.path<span class="jill"></span>目录下的<span class="jill"></span>jar<span class="jill"></span>包或者.class<span class="jill"></span>文件</span></div></div><h3 id="o9j16kVnv7c8L77bqkreoe" class="wolai-block"><span class="wolai-serial-number">3.3.4</span><span class="inline-wrap">用户自定义加载器</span></h3><div id="4bFjyudc8e5hi5YwuVjtiv" class="wolai-block wolai-text"><div><span class="inline-wrap">java.lang.ClassLoader<span class="jill"></span>的子类，用户可以定制类的加载方式</span></div></div><span class="inline-wrap"></span><br/><div id="tLX2VEk8L71k2vrfmQQ5uS" class="wolai-block wolai-text"><div><span class="inline-wrap">中文名称</span></div></div><span class="inline-wrap"></span><br/><div id="s8QRm9RdJQfoK4vioUHzTk" class="wolai-block wolai-text"><div><span class="inline-wrap">英文名称</span></div></div><span class="inline-wrap"></span><br/><div id="mqiwYygeWH75J3QeTzCyzJ" class="wolai-block wolai-text"><div><span class="inline-wrap">说明</span></div></div><span class="inline-wrap"></span><br/><div id="cTA8vsoAhEbCUguW6HJUqD" class="wolai-block wolai-text"><div><span class="inline-wrap">加载范围</span></div></div><span class="inline-wrap"></span><br/><div id="3ceiGKiTxwep9rea4FYJXV" class="wolai-block wolai-text"><div><span class="inline-wrap">启动类加载器</span></div></div><div id="8Gf37QhmPgfJqQ21NAKV1F" class="wolai-block wolai-text"><div></div></div><span class="inline-wrap"></span><br/><div id="iRTjgkptCUE6UhL8sCBgU1" class="wolai-block wolai-text"><div><span class="inline-wrap">Bootstrap</span></div></div><span class="inline-wrap"></span><br/><div id="7Shd3WB5JUA9sSAhWN2Zam" class="wolai-block wolai-text"><div><span class="inline-wrap">C++ 语言编写，不是 ClassLoader 子类，
Java 中为 null</span></div></div><span class="inline-wrap"></span><br/><div id="fYiXfHoA1ouyaTHx2kRzxi" class="wolai-block wolai-text"><div><span class="inline-wrap">$JAVA_HOME/jre/lib/rt.jar</span></div></div><span class="inline-wrap"></span><br/><div id="qKcgkewZ4XbCspP5XJUyrJ" class="wolai-block wolai-text"><div><span class="inline-wrap">扩展类加载器</span></div></div><span class="inline-wrap"></span><br/><div id="fBw9Mnb1r7QvqVHXk5XMQ9" class="wolai-block wolai-text"><div><span class="inline-wrap">Extension</span></div></div><span class="inline-wrap"></span><br/><div id="k9ojki5Hh35ygDCnyTEfaJ" class="wolai-block wolai-text"><div><span class="inline-wrap">sun.misc.Launcher.ExtClassLoader</span></div></div><span class="inline-wrap"></span><br/><div id="f5t3oGtFjtPwfJmDQXm5wp" class="wolai-block wolai-text"><div><span class="inline-wrap">$JAVA_HOME/jre/lib/*.jar -Djava.ext.dirs 参数指定目录下的 jar 包 $JAVA_HOME/jre/lib/ext/classes 目录下的 class</span></div></div><span class="inline-wrap"></span><br/><div id="quzhxirkDBX6b1Gd4NjhRv" class="wolai-block wolai-text"><div><span class="inline-wrap">应用类加载器</span></div></div><span class="inline-wrap"></span><br/><div id="2W3Fs4HmpLHeFFpKeH5W9a" class="wolai-block wolai-text"><div><span class="inline-wrap">AppClassLoader</span></div></div><span class="inline-wrap"></span><br/><div id="mvvpXgmvwgKfSfkbqWdLH" class="wolai-block wolai-text"><div><span class="inline-wrap">sun.misc.Launcher.AppClassLoader</span></div></div><span class="inline-wrap"></span><br/><div id="viZoVvMekVqSCpVKSVy2d2" class="wolai-block wolai-text"><div><span class="inline-wrap">classpath<span class="jill"></span>中指定的 jar 包及目录中的 class 以及我们导入的第三方框架的<span class="jill"></span>jar<span class="jill"></span>包</span></div></div><span class="inline-wrap"></span><br/><div id="4VaoNTZzCi9oyZi4AhxvoQ" class="wolai-block wolai-text"><div><span class="inline-wrap">自定义类加载器</span></div></div><span class="inline-wrap"></span><br/><div id="2TEgT7DYhXz42P71AJhfL9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><span class="inline-wrap"></span><br/><div id="msFDZeGHmCb5JVy35pvHor" class="wolai-block wolai-text"><div><span class="inline-wrap">程序员自己开发一个类继承 java.lang.ClassLoader， 
定制类加载方式</span></div></div><span class="inline-wrap"></span><br/><div id="9dZyX2bMz1Aew55eaHkqae" class="wolai-block wolai-text"><div><span class="inline-wrap">自定义</span></div></div><div id="uDM99PDX7E6VwcDCwhXSfk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kFCwU3e3xzuBnEh2s2MEtv" class="wolai-block wolai-text"><div><span class="inline-wrap">注意：各种类加载器之间存在着逻辑上的父子关系，但不是真正意义上的父子关系，因为它们从类型上并没有彼此继承，仅仅只是通过<span class="jill"></span>parent<span class="jill"></span>属性引用父加载器的对象</span></div></div><div id="aEz1DmPzhybvqKpC8MTuoj" class="wolai-block"><figure class="wolai-center" style="width: 278.6666666666667px; flex-direction: column"><img src="media/img004.png" style="width: 100%"/></figure></div><div id="jw5rKyseDmET759F429DET" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="xtpRR8chSPErVeQJTekPvq" class="wolai-block"><span class="wolai-serial-number">3.4</span><span class="inline-wrap">JDK9<span class="jill"></span>的类加载器</span></h2><div id="urHAjdJHRS4wsSuyAFg4sB" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK 9 引入了模块化系统，类加载器体系中也引入了一个新的成员：PlatformClassLoader</span></div></div><div id="qMBbFYNnQwcW2YqE8iV5fK" class="wolai-block wolai-text"><div><span class="inline-wrap">对应关系是：</span></div></div><ul class="wolai-block"><li id="u58rZPz5Dx6KY2zvmGT8Cb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用类加载器的父加载器是：PlatformClassLoader</span></li><li id="DdNZk8Ln5DdG9tLhmcyXW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">PlatformClassLoader<span class="jill"></span>的父加载器是：启动类加载器</span></li></ul><div id="xqoDhUxUXUcgMGcc7QXPo4" class="wolai-block wolai-text"><div><span class="inline-wrap">PlatformClassLoader<span class="jill"></span>和扩展类加载器区别：</span></div></div><blockquote id="3G67osMizttabotmkckZWC" class="wolai-block"><span class="inline-wrap">JDK 9 中的 PlatformClassLoader 和之前 JDK 版本中的 ExtClassLoader 具有相似的功能，但在一些细节上有所不同。</span></blockquote><ol class="wolai-block"><li id="3cUxQgTHiX3ow7Zg1vokXR"><div class="marker"></div><span class="inline-wrap">命名和位置：ExtClassLoader 是 JDK 8 及之前版本中定义的扩展类加载器，而 PlatformClassLoader 是从 JDK 9 开始引入的。它们的命名和位置略有不同，但都属于应用程序类加载器的子类。</span></li><li id="n6SsYRVAL69rXnYyKGGX2R"><div class="marker"></div><span class="inline-wrap">类加载范围：ExtClassLoader 主要用于加载 Java 扩展库（Java Extension），即位于 JRE 的 &quot;lib/ext&quot; 目录下的 JAR 文件。而 PlatformClassLoader 主要用于加载模块化平台的类，包括 Java SE 平台的核心类和模块。</span></li><li id="8BcxLttDbXHdH5nR8MW8eS"><div class="marker"></div><span class="inline-wrap">模块化支持：PlatformClassLoader 是在 JDK 9 引入的模块化系统中新增的类加载器，它与 Java 平台模块系统（JPMS）紧密集成。PlatformClassLoader 被设计为按模块进行类加载，可以加载模块路径上的模块，并且具有更灵活的类路径处理能力。</span></li></ol><div id="kXFfm6sMrPHWTXmy3NJ3w1" class="wolai-block wolai-text"><div><span class="inline-wrap">总体来说，PlatformClassLoader 是 JDK 9 后引入的类加载器，专门用于加载模块化平台的类，与 JPMS 集成。而 ExtClassLoader 则是 JDK 8 及之前版本的扩展类加载器，主要用于加载 Java 扩展库。它们在功能和使用场景上有所不同，但都属于应用程序类加载器的子类。</span></div></div><div id="o1BANxHzXvWGfogdqsCqyc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hbwdJEDKnARSmyNCFKpfMV" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ikobQS3sf2PoQuxSXh2o3y" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">请谈谈你对双亲委派机制的理解</span></h1><h2 id="d1DH3Qk2jTUSogM2pb2b9U" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">背记</span></h2><div id="JGnFiqQ1WxKyxo7DgsZVv" class="wolai-block wolai-text"><div><span class="inline-wrap">简单来说，双亲委派机制就是：找字节码文件先看是否曾经加载过，已经加载过就返回，否则就让爸爸找，爸爸找不到再让儿子找</span></div></div><div id="ofNM2G2hcmniHZ5j3u96gk" class="wolai-block wolai-text"><div><span class="inline-wrap">为啥这么搞呢？这是为了避免字节码文件被重复加载，确保类的唯一性和安全性，防止内存中出现多份相同的字节码，可以保证内存中只存在一份字节码</span></div></div><div id="9ACXtjXfHTYUHF8P5TXTm6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="psC2owGEvWsEZrmjrZMsRZ" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">理解</span></h2><div id="9bP9h3Ec1rCBF4svdS48tf" class="wolai-block wolai-text"><div><span class="inline-wrap">双亲委派机制是<span class="jill"></span>Java<span class="jill"></span>虚拟机加载一个类时为该类确定类加载器的一种机制</span></div></div><div id="w727VoKjwYbD8BSiJd88TJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fSpTnjhT7rdkPCRkB8QTS9" class="wolai-block"><span class="wolai-serial-number">4.2.1</span><span class="inline-wrap">总体说明</span></h3><ul class="wolai-block"><li id="kpkVnVDJiyjvLrHmMNKr89"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一个类加载器收到了加载某个类的请求</span></li><li id="q5YZGkP18R3eyeJSF79eP2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">先看是否曾经加载过如果曾经加载过就直接返回，因为方法区里面已经有了</span></li><li id="rRogDQBvvxsCnRWsRiCkBQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果没有加载过，该类加载器并不会去加载该类，而是把这个请求委派给父类加载器</span></li><li id="sRxWLEGhqnnwK8KD2Ahdza"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶端的启动类加载器</span></li><li id="9FMzGLR7zYzyBPkMDHo5xM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">只有当父类加载器在其搜索范围内无法找到所需的类，并将该结果反馈给子类加载器，子类加载器会尝试去自己加载</span></li></ul><div id="YeSp6YStZU9HgsCgDebWE" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2vgzTYaVckof4JQXjzqJJf" class="wolai-block"><span class="wolai-serial-number">4.2.2</span><span class="inline-wrap">举例说明</span></h3><div id="n71UnMnExNLVycLctGuD3w" class="wolai-block wolai-text"><div><span class="inline-wrap">例如有一个类 com.atguigu.demo.Foo 需要加载：</span></div></div><ul class="wolai-block"><li id="aQkJPyBuGHqEw6EbaDc6yx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用类加载器：判断之前是否加载过这个类，如果加载过则返回，如果没有加载过，则会向上委托给扩展类加载器；</span></li><li id="89Tmuo2Foy1DEo6SYneXwr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">扩展类加载器：判断之前是否加载过这个类，如果加载过则返回，如果没有加载过，则继续向上委托给引导类加载器；</span></li><li id="awJShKZRUVV5HF1FhxeHAc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">引导类加载器：判断之前是否加载过这个类，如果加载过则返回，如果没有加载过，则到 jre/lib 目录下去查询是否有这个类，如果找不到则把任务返还给扩展类加载器；</span></li><li id="om2jj5PZnKTcEyW4zHtBvf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">扩展类加载器：到 jre/lib/ext 目录下去查询是否有这个类，如果有这个类则加载，如果没有这个类就向下回传给应用类加载器；</span></li><li id="h7K2dvoKZunEdxxNYa6EtN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用类加载器：到项目的类路径下（classPath）下去查询是否有这个类，如果有这个类则加载，如果没有这个类就会抛出经典的 ClassNotFoundException。</span></li></ul><div id="4CPECXxvShHrH94RSbRwUn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6C9PKaZjpf7HKZmZMdhCWK" class="wolai-block"><figure class="wolai-center" style="width: 1092px; flex-direction: column"><img src="media/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6(4).png" style="width: 100%"/></figure></div><div id="o4PPaQ1x35Jgkt8MvPcBDv" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dHmqu837GK7urcUmvmUdmA" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">请描述一下类加载的执行过程</span></h1><h2 id="j4KsRZy8J6HdqHaR5SSB8d" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">背记</span></h2><div id="2z2bkhEAUAWi1Sa57CyEA8" class="wolai-block wolai-text"><div><span class="inline-wrap">类加载过程主要包括以下五个步骤：</span></div></div><ul class="wolai-block"><li id="uuf5CsmvRbzZok79cNPPFE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>加载</b></span><span class="inline-wrap">：根据查找路径找到相应的<span class="jill"></span>class<span class="jill"></span>文件然后导入</span></li><li id="r8nD6t9EdX6cac72Cvb6np"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>验证</b></span><span class="inline-wrap">：检查加载的 class 文件的正确性</span></li><li id="m1MQQPGPHvTfiCW2eVcfY3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>准备</b></span><span class="inline-wrap">：给类中的静态变量分配内存空间</span></li><li id="bQAtz7GL86MmfaSDNCbw4E"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>解析</b></span><span class="inline-wrap">：虚拟机将常量池中的符号引用替换成直接引用的过程</span></li><li id="k8DKG6aRQ7cp9mxd5fnbL6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>初始化</b></span><span class="inline-wrap">：对静态变量和静态代码块执行初始化工作</span></li></ul><div id="4wYz6V1vvWNP1MBqC86ri8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qVXHzipJUDCJTW8dtVbUbD" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">理解</span></h2><div id="chP3a2nkePu7Fx9MfRdEAn" class="wolai-block wolai-text"><div><span class="inline-wrap">以下对上述五个步骤做一个详细说明：</span></div></div><ul class="wolai-block"><li id="a1V7qLmvbo2Ds6tA7r2L1F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="indigo inline-wrap"><b>加载</b></span><span class="inline-wrap">：首先，类加载器会从指定的路径或<span class="jill"></span>URL<span class="jill"></span>中读取类的字节码文件（.class<span class="jill"></span>文件），并将其加载到内存中。这个过程涉及到文件<span class="jill"></span>I/O<span class="jill"></span>操作和字节码解析。</span></li><li id="6ViGHFa5hkaUuuhzH4eEQb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>验证</b></span><span class="inline-wrap">：在加载过程中，类加载器会对字节码进行验证，确保其符合<span class="jill"></span>Java<span class="jill"></span>虚拟机规范的要求。这包括检查字节码的格式、语义和安全性等方面。</span></li><li id="7VjEi3mdULmVzzfYx98VFp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>准备</b></span><span class="inline-wrap">：在这个阶段，类加载器会为类的静态变量分配内存空间，并设置默认值。这些静态变量包括基本数据类型（如<span class="jill"></span>int、float<span class="jill"></span>等）和引用类型（如对象引用）。</span></li><li id="oASvyzb8fJ3GKhnoE35uTX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>解析</b></span><span class="inline-wrap">：在这个阶段，类加载器会将符号引用转换为直接引用。符号引用是指以字符串形式表示的类、字段和方法的引用，而直接引用则是指向内存中实际对象的指针。解析过程涉及到常量池的解析和动态链接。</span></li><li id="kEvuQgpeNJiRuSTRgQebY1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>初始化</b></span><span class="inline-wrap">：在这个阶段，类加载器会执行类的静态代码块和静态变量的初始化操作。这是类加载的最后一步，也是类被完全加载的标志。</span></li></ul><div id="nWFRrhSUiYBFyDAzdxU49d" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="caAGkqTNitG3KfXwqgVRXC" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">Java<span class="jill"></span>中都有哪些引用类型？</span></h1><h2 id="iXsaLXmhPvNDJ9Ns5a44qf" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="fMbvWew8wMPu6bKK7EFmSa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="indigo inline-wrap"><b>强引用</b></span><span class="inline-wrap">：只要引用指针还在，那么发生<span class="jill"></span>GC<span class="jill"></span>的时候就不会被回收</span></li><li id="7mH6HotTnFF2uzjcbeE23a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>软引用</b></span><span class="inline-wrap">：有用但不是必须的对象，在发生内存空间不够会被回收</span></li><li id="iX4pCQBNjVe1r8UcKKNzmg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>弱引用</b></span><span class="inline-wrap">：有用但不是必须的对象，只要遇到<span class="jill"></span>GC<span class="jill"></span>就会被回收，哪怕弱引用指针还在</span></li><li id="wk2PgN53Hrcwm4zLdzpShk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap"><b>虚引用</b></span><span class="inline-wrap">（幽灵引用/幻影引用）：无法通过虚引用获得对象，用<span class="jill"></span>PhantomReference<span class="jill"></span>实现虚引用，虚引用的用途是在<span class="jill"></span>GC<span class="jill"></span>时返回一个通知——临死之前收到一个通知</span></li></ul><div id="5qumSk9XhpeNfXPz6TE8c9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="vHcbqzAyhqdwWtJgjdaB5w" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">强引用</span></h2><div id="hAPJsTowZB3RtHo8rLoUW6" class="wolai-block wolai-text"><div><span class="inline-wrap">日常开发时指向对象的引用方式，是最常见的引用类型，当一个对象具有强引用时，垃圾回收器永远不会回收它。</span></div></div><div id="rEbVxc8rbJi4SMTciyWFgC" class="wolai-block wolai-text"><div><span class="inline-wrap">即便系统内存不足，JVM<span class="jill"></span>也不会回收被强引用指向的对象</span></div></div><code-block id="j9xQhPYfFG3ZcEGPQ7LTbV" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="orXwt6HrxRQTHjvDjzYccb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fKRAEBZPJAtNkGUxdgqZki" class="wolai-block"><span class="wolai-serial-number">6.3</span><span class="inline-wrap">软引用</span></h2><div id="ptp1hTEQUKZchMpfy5Z2w3" class="wolai-block wolai-text"><div><span class="inline-wrap">软引用（Soft Reference）是<span class="jill"></span>Java<span class="jill"></span>中的一种引用类型，用于实现内存敏感的缓存。与弱引用不同，软引用在内存不足时才会被垃圾回收器回收。</span></div></div><div id="fRZunXKSKeHcamFqHrUM8P" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是关于软引用的一些关键点：</span></div></div><ul class="wolai-block"><li id="rP8hRkqPQnCYQerQ6vmteW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>引用强度</b></span><span class="inline-wrap">：软引用比弱引用稍强一些，但在所有引用类型中仍然属于较弱的一类。</span></li><li id="kS2tTr5TSjhDgu3KgxrQ2G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>垃圾回收</b></span><span class="inline-wrap">：当<span class="jill"></span>JVM<span class="jill"></span>进行垃圾回收时，如果发现一个对象只被软引用所引用，并且内存不足时，才会回收这个对象。如果内存足够，则不会回收。</span></li><li id="jcbrBuyqYNHUsrDSz5wdBL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：通常用于实现缓存机制，例如缓存数据可以使用软引用来存储，当内存不足时，这些缓存数据会被自动回收，从而避免内存溢出。</span></li><li id="pyjPKedp1DK7gB3EPQ78U"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用方式</b></span><span class="inline-wrap">：通过 </span><span class="inline-wrap"><code>java.lang.ref.SoftReference</code></span><span class="inline-wrap"> 类来创建软引用。</span></li></ul><div id="ijs9tBzozVJRywwpmUuaZR" class="wolai-block wolai-text"><div><span class="inline-wrap">示例代码：</span></div></div><code-block id="cK1ZhVynKmbs2Re1xEKqth" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span></span><span class="token class-name">SoftReference</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoftReferenceExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个对象</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 创建软引用</span>
        <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 清除强引用</span>
        obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 打印软引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"软引用对象: "</span> <span class="token operator">+</span> softRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 强制垃圾回收</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 再次打印软引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"垃圾回收后软引用对象: "</span> <span class="token operator">+</span> softRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 模拟内存不足的情况</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 分配10MB的内存</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"内存不足"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 再次打印软引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"内存不足后软引用对象: "</span> <span class="token operator">+</span> softRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="bwWcoCtSqcYKAsrPxRptz" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个示例中，</span><span class="inline-wrap"><code>softRef</code></span><span class="inline-wrap"> 是一个软引用，指向 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 对象。当 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 被设置为 </span><span class="inline-wrap"><code>null</code></span><span class="inline-wrap"> 后，只有软引用指向该对象。调用 </span><span class="inline-wrap"><code>System.gc()</code></span><span class="inline-wrap"> 会请求垃圾回收器运行，但由于内存可能仍然足够，对象可能不会被立即回收。再次打印软引用的内容时，可能会仍然输出对象的引用。最后，通过分配大量内存模拟内存不足的情况，此时软引用的对象会被回收。</span></div></div><div id="P4rukw7HwZKEEhm8Lp1LK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qkGmtT1t6MPpZ7R2BCyiJf" class="wolai-block"><span class="wolai-serial-number">6.4</span><span class="inline-wrap">弱引用</span></h2><div id="rVxU1Y1hh9R5GJ65Ko1Rm5" class="wolai-block wolai-text"><div><span class="inline-wrap">弱引用（Weak Reference）是<span class="jill"></span>Java<span class="jill"></span>中的一种引用类型，用于实现内存敏感的高速缓存。它允许垃圾回收器在任何时间回收被弱引用关联的对象，即使该对象仍然可以通过弱引用来访问。以下是关于弱引用的一些关键点：</span></div></div><ul class="wolai-block"><li id="w7oji5GmUKczAmUPoFt1Mc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>引用强度</b></span><span class="inline-wrap">：弱引用是四种引用类型（强引用、软引用、弱引用、虚引用）中最弱的一种。</span></li><li id="eAux6FaRduApWnDCqShwGh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>垃圾回收</b></span><span class="inline-wrap">：当<span class="jill"></span>JVM<span class="jill"></span>进行垃圾回收时，如果发现一个对象只被弱引用所引用，那么无论当前内存是否足够，都会回收这个对象。</span></li><li id="dM7oGYNrWxHYrqTANjG6HC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：通常用于实现缓存机制，例如缓存数据可以使用弱引用来存储，当内存不足时，这些缓存数据会被自动回收，从而避免内存溢出。</span></li><li id="7tJ2cFoKQJ3CcBKn9v4dVu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用方式</b></span><span class="inline-wrap">：通过 </span><span class="inline-wrap"><code>java.lang.ref.WeakReference</code></span><span class="inline-wrap"> 类来创建弱引用。</span></li></ul><div id="4yZMb1UDdApFUq2mudvmJS" class="wolai-block wolai-text"><div><span class="inline-wrap">示例代码：</span></div></div><code-block id="i85wn2KWxfHRhNeqNmRfCz" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span></span><span class="token class-name">WeakReference</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakReferenceExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个对象</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 创建弱引用</span>
        <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 清除强引用</span>
        obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 打印弱引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"弱引用对象: "</span> <span class="token operator">+</span> weakRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 强制垃圾回收</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 再次打印弱引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"垃圾回收后弱引用对象: "</span> <span class="token operator">+</span> weakRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="4KnUxwFCbidJpqnksquD1H" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个示例中，</span><span class="inline-wrap"><code>weakRef</code></span><span class="inline-wrap"> 是一个弱引用，指向 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 对象。当 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 被设置为 </span><span class="inline-wrap"><code>null</code></span><span class="inline-wrap"> 后，只有弱引用指向该对象。调用 </span><span class="inline-wrap"><code>System.gc()</code></span><span class="inline-wrap"> 会请求垃圾回收器运行，回收该对象。再次打印弱引用的内容时，可能会输出 </span><span class="inline-wrap"><code>null</code></span><span class="inline-wrap">，表示对象已被回收。</span></div></div><div id="4ZHB2RK6vA4VGphfPZkh9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7EUijHtoEWTQMzYpt5DQ7F" class="wolai-block"><span class="wolai-serial-number">6.5</span><span class="inline-wrap">虚引用</span></h2><div id="dmsBYcLY8eMy8aHhqJrmgd" class="wolai-block wolai-text"><div><span class="inline-wrap">虚引用（Phantom Reference）是<span class="jill"></span>Java<span class="jill"></span>中的一种引用类型，是最弱的一种引用关系。虚引用并不会决定对象的生命周期，它的作用在于跟踪对象被垃圾回收的状态。</span></div></div><div id="8SanhFuRpEHgGvHgc6yGT6" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是关于虚引用的一些关键点：</span></div></div><ul class="wolai-block"><li id="q5fxsZSn8SHpxXmWBf4Lvi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>引用强度</b></span><span class="inline-wrap">：虚引用是最弱的一种引用类型，甚至比弱引用和软引用还要弱。</span></li><li id="x3T1quviV3Ybf6cuhjEgrw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>垃圾回收</b></span><span class="inline-wrap">：当一个对象仅持有虚引用时，它可以在任何时候被垃圾回收器回收。虚引用不能防止对象被回收，也不能通过虚引用来获取对象。</span></li><li id="aRpMfaqLsuq8YFFNHLYdc3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：虚引用主要用于在对象被垃圾回收时得到一个系统通知，常用于资源清理或执行其他清理操作。</span></li><li id="tX25r2mMtqSL5hznNpiKKQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用方式</b></span><span class="inline-wrap">：通过 </span><span class="inline-wrap"><code>java.lang.ref.PhantomReference</code></span><span class="inline-wrap"> 类来创建虚引用，并且通常需要与 </span><span class="inline-wrap"><code>ReferenceQueue</code></span><span class="inline-wrap"> 一起使用。</span></li></ul><div id="kaBmTk1dzeWnWbGRcNYomt" class="wolai-block wolai-text"><div><span class="inline-wrap">示例代码：</span></div></div><code-block id="82upbtnWciNS4RWp1tY9ts" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span></span><span class="token class-name">PhantomReference</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span></span><span class="token class-name">ReferenceQueue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个对象</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 创建引用队列</span>
        <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 创建虚引用</span>
        <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 清除强引用</span>
        obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 打印虚引用的内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"虚引用对象: "</span> <span class="token operator">+</span> phantomRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 null</span>
        
        <span class="token comment">// 强制垃圾回收</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 等待垃圾回收器将虚引用加入引用队列</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> ref <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象被垃圾回收，虚引用已加入引用队列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="8XugUUEWUpvFCdd1HR7Q5U" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个示例中，</span><span class="inline-wrap"><code>phantomRef</code></span><span class="inline-wrap"> 是一个虚引用，指向 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 对象。当 </span><span class="inline-wrap"><code>obj</code></span><span class="inline-wrap"> 被设置为 </span><span class="inline-wrap"><code>null</code></span><span class="inline-wrap"> 后，只有虚引用指向该对象。调用 </span><span class="inline-wrap"><code>System.gc()</code></span><span class="inline-wrap"> 会请求垃圾回收器运行，对象被回收后，虚引用会被添加到引用队列 </span><span class="inline-wrap"><code>queue</code></span><span class="inline-wrap"> 中。通过 </span><span class="inline-wrap"><code>queue.remove()</code></span><span class="inline-wrap"> 方法可以从队列中取出虚引用，从而知道对象已经被垃圾回收。</span></div></div><div id="kDTxvDSa3CsP95MpdPuGVX" class="wolai-block wolai-text"><div><span class="inline-wrap">关键点总结：</span></div></div><ul class="wolai-block"><li id="9MMqvhvY8Dyjbe43W9aix6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>最弱引用</b></span><span class="inline-wrap">：虚引用是最弱的一种引用类型，不能防止对象被回收。</span></li><li id="8m4ccxYzXDoEyKsFQL4kRj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>通知机制</b></span><span class="inline-wrap">：虚引用主要用于在对象被垃圾回收时得到一个系统通知。</span></li><li id="ujQsXD32NDsfr3B1WAKhyJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>配合引用队列</b></span><span class="inline-wrap">：通常需要与 </span><span class="inline-wrap"><code>ReferenceQueue</code></span><span class="inline-wrap"> 一起使用，以便在对象被回收时进行相应的处理。</span></li></ul><div id="oR5dVyK74ZFNaWCcHTZqKV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="9q9ifgrRnocUPxr8aBRSQt" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="n6rbEuU3KAePikiARkgNnD" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">怎么判断对象是否可以被回收？</span></h1><h2 id="qufazGTcP8ayduAdzNeyaW" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">核心思想</span></h2><div id="pFBeEaFhWGpbpPdsprg7b6" class="wolai-block wolai-text"><div><span class="inline-wrap">天上飞的风筝能够被人控制，是因为人手里拉着一根线拴在风筝身上。线断了，风筝就飞了。</span></div></div><div id="jihHiZznGScXF2gpWpCbuW" class="wolai-block wolai-text"><div><span class="inline-wrap">堆内存里的对象是否可以被回收，关键是要看指向对象的指针。</span></div></div><div id="odgWAgL7v9i7jhwb6mwR44" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是风筝上可能还有线出来连着下一个风筝，下一个风筝又连着下一个风筝……</span></div></div><div id="wUujWGDGaUTeLYyxbNbo61" class="wolai-block wolai-text"><div><span class="inline-wrap">所以指向对象的指针可能不是直接的，也可能是间接的，但只要还有线连着就不是垃圾</span></div></div><div id="nZskGN8casWFdRJUeGiHWL" class="wolai-block wolai-text"><div><span class="inline-wrap">专业的表述是：检查对象是否存在从堆外指向堆内的指针，不管这个路径是直接还是间接的</span></div></div><div id="2ijaLMvMk5Ccn7HKoRUFtU" class="wolai-block"><figure class="wolai-center" style="width: 885px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="qmxQ9wD3BkkF1oBTqDQR12" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2mCsYu49VLjK9E3HebjxBE" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">基于不同引用类型分析</span></h2><ul class="wolai-block"><li id="xz37tiXbQumarqNiodtMfJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">强引用：只要引用对象的强引用指针还在，那么就不能回收</span></li><li id="rZNiQ9HyH5UiQwyhy3m4rP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">软引用：当一个对象仅持有软引用时，如果<span class="jill"></span>GC<span class="jill"></span>是由于堆内存空间不足而触发的，那么即使软引用指针还在也会回收对象</span></li><li id="iFnzt3VL34K2m2FHXQnJQJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">弱引用：当一个对象仅持有弱引用时，不管<span class="jill"></span>GC<span class="jill"></span>是由于什么原因触发，这个对象都会被回收</span></li><li id="g1UTfoch4nGSkL7XSYRMQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚引用：当一个对象仅持有虚引用时，它可以在任何时候被垃圾回收器回收。虚引用不能防止对象被回收，也不能通过虚引用来获取对象</span></li><li id="iRs9ejb5Vgbayos2LRXpX2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">无引用：当一个对象没有任何类型的指针指向它，那么它在<span class="jill"></span>GC<span class="jill"></span>中一定会被回收</span></li></ul><div id="hNHPaNfpkGgLkLnVhVPemg" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="sU68wJNv6KZCzSvzLe1zdb" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="uBDBWuuNkk1zhHY6LCpEZL" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">为什么不能使用引用计数法查找垃圾对象？</span></h1><h2 id="jXXQxyrsKcc2fQyKNv8TxG" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">引用计数法的概念</span></h2><div id="8qH5pVmfjXmtGsgDc5PdSQ" class="wolai-block wolai-text"><div><span class="inline-wrap">在对象头中维护一个计数器，初始值为<span class="jill"></span>0。</span></div></div><div id="wUatEKE82MKATgqyPnbsTW" class="wolai-block wolai-text"><div><span class="inline-wrap">每增加一个指向对象的引用则使计数器<span class="jill"></span>+1</span></div></div><div id="xtLnqZLuCNazs3zmFU4Gy7" class="wolai-block wolai-text"><div><span class="inline-wrap">每减少一个指向对象的引用则使计数器-1</span></div></div><div id="4eTAH5ydfGQZJdpxkqNSqp" class="wolai-block wolai-text"><div><span class="inline-wrap">当计数器恢复为<span class="jill"></span>0<span class="jill"></span>时，该对象判定为垃圾对象，可以被垃圾回收</span></div></div><h2 id="7ckMY941dtFqjra1qSf8Bm" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">引用计数法的缺陷</span></h2><div id="qVSe5gsL5yJRtQFz5xY2gZ" class="wolai-block wolai-text"><div><span class="inline-wrap">对象之间的循环引用会导致原本应该被回收的对象无法回收</span></div></div><div id="rLTNkcTg7sCv4q5GrRbY3e" class="wolai-block"><figure class="wolai-center" style="width: 380px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><ul class="wolai-block"><li id="7VstESbM8yNxK9cjsVjdnM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象<span class="jill"></span>A<span class="jill"></span>引用计数器值：1</span></li><li id="rwJKEMqxJC8AMsU2pbHBjN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象<span class="jill"></span>B<span class="jill"></span>引用计数器值：1</span></li></ul><div id="8zRKaMFRtaTCuC4Vnm9vUC" class="wolai-block wolai-text"><div><span class="inline-wrap">此时其实已经没有任何有效指针指向它们了，但是这两个垃圾对象彼此之间互相引用，导致引用计数器无法减少到零，进而导致垃圾对象无法回收、长期占用内存，甚至可能导致<span class="jill"></span>OOM</span></div></div><div id="dJ3WW94scnUDSS3k2R5Qw" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6MheEqRFBbjPtEwKy3X1dQ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="u4tFaMteXS5ramTXGmJKoD" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">开发中是否可以避免出现对象的循环引用？</span></h1><h2 id="nx2ii7YTJuj3cbWVXvQVCu" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">结论</span></h2><div id="w1N4Sa8HZL4sT7AATELktT" class="wolai-block wolai-text"><div><span class="inline-wrap">无法避免，对象彼此之间的引用关系是错综复杂的，两个对象即使看似表面上没有互相引用，但是有可能绕很大一圈后发现它们是互相引用的。</span></div></div><div id="orgnEupENpdSgETpUnsQuA" class="wolai-block wolai-text"><div><span class="inline-wrap">如果禁止对象之间循环引用，那么很多业务功能将无法实现</span></div></div><h2 id="ugkFXTHKfB9S6RaTXWmiAe" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">举例</span></h2><h3 id="gPpLdb4wRtDCcU4R3MNo9u" class="wolai-block"><span class="wolai-serial-number">9.2.1</span><span class="inline-wrap">实体类之间的关联关系</span></h3><code-block id="xcRdUXdPsNcFdt8y6ZvokE" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Customer</span> customer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 订单实体</pre></div></code-block><code-block id="65t5je2UGvrByUgkyaYSq" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">></span></span> orderList<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 客户实体</pre></div></code-block><div id="cpksjnXLNEGJRipF6Sod5S" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="aUm3wS9HMfzs2ZEnmS4dhh" class="wolai-block"><span class="wolai-serial-number">9.2.2</span><span class="inline-wrap">框架源码</span></h3><div id="uZqSLtowRk9Lr2DGAgCPhF" class="wolai-block wolai-text"><div><span class="inline-wrap">SpringMVC<span class="jill"></span>源码显示：</span></div></div><ul class="wolai-block"><li id="ue7uxpjnPuaHZibaqisvxr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IOC<span class="jill"></span>容器初始化完成之后，IOC<span class="jill"></span>容器对象会存入<span class="jill"></span>ServletContext<span class="jill"></span>域</span></li><li id="fWcbMRwu5CZu4CT46GrYsX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">为了获取<span class="jill"></span>ServletContext<span class="jill"></span>对象方便，ServletContext<span class="jill"></span>对象会被存入<span class="jill"></span>IOC<span class="jill"></span>容器</span></li></ul><div id="71CiDL4eT9WSF83hQSh3mT" class="wolai-block"><figure class="wolai-center" style="width: 532px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><h3 id="ujnfFeumiTXGz6kZcos8Jp" class="wolai-block"><span class="wolai-serial-number">9.2.3</span><span class="inline-wrap">结论</span></h3><div id="dXFDuTHyaJzZr5uyF8axUu" class="wolai-block wolai-text"><div><span class="inline-wrap">引用计数法存在重大缺陷，不具备实用性；事实上也确实没有任何一款<span class="jill"></span>GC<span class="jill"></span>产品实际使用引用计数法</span></div></div><div id="3aoLUK5zxWV1KEqto7QLCb" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="is6o3mrjBM2cHxyugQzDBW" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">哪些对象可以作为<span class="jill"></span>GC-Roots？</span></h1><h2 id="gVqJSTNaheQmehtATsyn8P" class="wolai-block"><span class="wolai-serial-number">10.1</span><span class="inline-wrap">背记</span></h2><div id="hme9oXxMXCCjDTRjVQFRfb" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>语言中，可以作为<span class="jill"></span>GC Roots<span class="jill"></span>的对象包括下面几种：</span></div></div><ul class="wolai-block"><li id="d1kWeKqCYKRSET2UWVguU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">虚拟机栈（栈帧中的本地变量表）中的引用对象</span></li><li id="a2byGeCzXUq76U99FMtE13"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区中的类静态属性引用的对象</span></li><li id="3YjFovw5NH7KVkbJ6T3NKo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法区中的常量引用的对象</span></li><li id="qLHhBhcqpxjwrb4EVna2YE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">本地方法栈中<span class="jill"></span>JNI（Native<span class="jill"></span>方法）的引用对象</span></li></ul><div id="scTBogxaChGujbi9nrK8hj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cK4ynHYMuvus7VJQu9PMca" class="wolai-block"><span class="wolai-serial-number">10.2</span><span class="inline-wrap">理解</span></h2><h3 id="7LZNyN89jy3XgGeuKxu4VM" class="wolai-block"><span class="wolai-serial-number">10.2.1</span><span class="inline-wrap">虚拟机栈中的对象</span></h3><div id="cDNsQeASR9mkQyetGLZMDP" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个方法被调用时，该方法的局部变量会被压入到虚拟机栈中，这些局部变量就是<span class="jill"></span>GC Roots。例如：</span></div></div><code-block id="r1aiTbe8r7cqKuj4h89DLR" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj是GC Roots</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="7qb5z6cpKuJ1PuEPZFZyjC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="eSU35hp64EpXjV5QPWEGkJ" class="wolai-block"><span class="wolai-serial-number">10.2.2</span><span class="inline-wrap">方法区中的静态属性引用的对象</span></h3><div id="eJdJ4s4SQ45RWgWyFsUttx" class="wolai-block wolai-text"><div><span class="inline-wrap">类加载到方法区后，类的静态变量会引用该类中定义的静态属性，这些静态属性也是<span class="jill"></span>GC Roots。例如：</span></div></div><code-block id="5KNeXFKaUgan8878P7xwQF" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj是GC Roots</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="dBTvTi3tL99zUwP9jjQs6n" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7hdZRQSHJhSxpKFFGg6MEJ" class="wolai-block"><span class="wolai-serial-number">10.2.3</span><span class="inline-wrap">方法区中的常量引用的对象</span></h3><div id="c9499hCcZgAoVE39X79X3D" class="wolai-block wolai-text"><div><span class="inline-wrap">常量池是类元数据的一部分，其中存储了类中使用的常量值。</span></div></div><div id="s8B9YVbweTWW88vwm2UCrB" class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个常量引用了一个对象，那么这个对象也是<span class="jill"></span>GC Roots。例如：</span></div></div><code-block id="ux84UgaYDdapC4T3HP4sH3" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj是GC Roots</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="cfVbbDAbRtAVScojoXSSRc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="akJPpJKELPHALtd3MnzEnw" class="wolai-block"><span class="wolai-serial-number">10.2.4</span><span class="inline-wrap">本地方法栈中的<span class="jill"></span>JNI<span class="jill"></span>引用的对象</span></h3><div id="eDtcZQxqy77zWNr3btW22G" class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>Java<span class="jill"></span>代码与本地代码（如<span class="jill"></span>C<span class="jill"></span>或<span class="jill"></span>C++）交互时，本地方法栈中的<span class="jill"></span>JNI<span class="jill"></span>可能会引用<span class="jill"></span>Java<span class="jill"></span>对象，这些对象也被视为<span class="jill"></span>GC Roots。例如：</span></div></div><code-block id="2Q2UvPLAWoPmwppPtkT9tE" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">nativeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// nativeMethod是本地方法</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="sk1bAUPCi6Y3s8f2YPDnud" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="v6atveaq7rf57DBYZdgKRT" class="wolai-block"><span class="wolai-serial-number">10.3</span><span class="inline-wrap">小技巧</span></h2><div id="8ipMbM3A4hm6Y73SYEQzQK" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>Root 采用栈方式存放指针，所以如果一个指针，它保存了堆里面的对象，但是自己又不存放在堆里面，那他就可以作为一个<span class="jill"></span>Root</span></div></div><div id="iq7QtteUVg2tLH8bz9LA5Z" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="pqdJHiGvxvGGTZdTMeA3AM" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="acBe7f8ppU2xRPS2nWHCNN" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">说一下<span class="jill"></span>JVM<span class="jill"></span>有哪些垃圾回收算法？</span></h1><h2 id="rGsh8vsyuxzK1VpAzSVoaj" class="wolai-block"><span class="wolai-serial-number">11.1</span><span class="inline-wrap">背记</span></h2><div id="rKug8sicPui3EVfCJf782m" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>虚拟机（JVM）中的垃圾回收算法是用于自动管理内存，回收不再使用的对象所占用的内存空间。</span></div></div><div id="u8NwfVq8c5Z3zpEKN2Vf9M" class="wolai-block wolai-text"><div><span class="inline-wrap">主要的垃圾回收算法包括以下几种：</span></div></div><ul class="wolai-block"><li id="8XsGC4g5TahSHkKN1e7wg5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">标记复制算法</span></li><li id="aBF1DTpn9egygY9JcjdLLz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">标记清除算法</span></li><li id="m8UBjbzvZf7kummNhT3HcK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">标记整理算法</span></li><li id="jh2dTaZGoySVBm3AAiF68n"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分代算法</span></li></ul><div id="uW4rxi2wvgEVKkqNHMexda" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aGnKBNeKkqiZ2tiC3ApsNt" class="wolai-block"><span class="wolai-serial-number">11.2</span><span class="inline-wrap">理解</span></h2><h3 id="iBYn5L7EbBupPWkfpAerHu" class="wolai-block"><span class="wolai-serial-number">11.2.1</span><span class="inline-wrap">标记复制算法</span></h3><div id="sG7Cfc8ojKxVBYCPWRVBxR" class="wolai-block wolai-text"><div><span class="inline-wrap">该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，会将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</span></div></div><h4 id="5YtDw7jSq4EoQyibVM21JM" class="wolai-block"><span class="wolai-serial-number">11.2.1.1</span><span class="inline-wrap">执行<span class="jill"></span>GC<span class="jill"></span>前</span></h4><div id="mYYbDPzK48EDzknnwev4TE" class="wolai-block"><figure class="wolai-center" style="width: 718px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><h4 id="nkG4J6W8isdvP1aBJSiCh8" class="wolai-block"><span class="wolai-serial-number">11.2.1.2</span><span class="inline-wrap">执行标记</span></h4><div id="pw8Ke8QCoq17ajHBJV83BR" class="wolai-block"><figure class="wolai-center" style="width: 720px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><div id="ocUJ1ygVrSmhZauLiYpbV8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="wNrJ5EBneGLxWjvjCCUVvk" class="wolai-block"><span class="wolai-serial-number">11.2.1.3</span><span class="inline-wrap">执行复制</span></h4><div id="vFZG59qK7HFyjxZMEcQWKa" class="wolai-block"><figure class="wolai-center" style="width: 726px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><div id="humnDRjzKrNkUekT3JJCT6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="pprYEq5irqESZD3Jc2evkh" class="wolai-block"><span class="wolai-serial-number">11.2.1.4</span><span class="inline-wrap">交换指针</span></h4><div id="a1YMFC3DHmaM1NGk6ahB2G" class="wolai-block"><figure class="wolai-center" style="width: 722px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div><div id="a7MacxsNTKEYqSHpymYVi2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vQFXXjbMDXJa94Wq2rz9sQ" class="wolai-block"><span class="wolai-serial-number">11.2.2</span><span class="inline-wrap">标记清除算法</span></h3><ul class="wolai-block"><li id="x9mAgAcVa7N8C7FammgioF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用<span class="jill"></span>GC Roots<span class="jill"></span>可达性分析算法把不可达的对象标记出来</span></li><li id="cpvrcm8TQs1TYKp4XDhVwX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回收被标记的对象</span></li></ul><div id="95v3qQBQgRvZb513NktdMm" class="wolai-block"><figure class="wolai-center" style="width: 820px; flex-direction: column"><img src="media/image_7.png" style="width: 100%"/></figure></div><div id="tZ44APEkFWiYtLstuXYYFN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="r35Sj2Mi9Uz9Y9XyVezNGH" class="wolai-block"><span class="wolai-serial-number">11.2.3</span><span class="inline-wrap">标记整理算法</span></h3><div id="tLGzNyVfGb7428C5ZrLGWv" class="wolai-block wolai-text"><div><span class="inline-wrap">也叫标记压缩算法，它的做法是：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</span></div></div><div id="ukVhPkqwhyTdAk2uRV9i7v" class="wolai-block"><figure class="wolai-center" style="width: 770px; flex-direction: column"><img src="media/image_8.png" style="width: 100%"/></figure></div><div id="rv9SQUyHghcr6T4z3cm3b4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="oL18hrVz9skRonmDjPpeZq" class="wolai-block"><span class="wolai-serial-number">11.2.4</span><span class="inline-wrap">分代算法</span></h3><div id="6zHoi1CdfSJa4RmvkpTPSx" class="wolai-block wolai-text"><div><span class="inline-wrap">根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</span></div></div><div id="vECVhz4gi9gaABN5Y9FPXA" class="wolai-block wolai-text"><div><span class="inline-wrap">分代回收算法实际上是把复制算法和标记整理法的结合，并不是真正一个新的算法，一般分为：老年代（Old Generation）和新生代（Young Generation）</span></div></div><div id="ms54BRd3N5ih8164thbnG9" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代就是很少垃圾需要进行回收的，新生代就是有很多的内存空间需要回收，所以不同代就采用不同的回收算法，以此来达到高效的回收算法。</span></div></div><div id="pGtLMSgZ4qGJ1tDKZx9d7R" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fHqTNkZex3Hv7mMSo7999c" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9rnwDiaf9it8oxs9poXSXY" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">JVM<span class="jill"></span>有哪些垃圾回收器？</span></h1><h2 id="sdEtuVDdTtWCwzkpjmaDKz" class="wolai-block"><span class="wolai-serial-number">12.1</span><span class="inline-wrap">背记</span></h2><div id="bAoSGxW6PiwutpL6aJKiUC" class="wolai-block wolai-text"><div><span class="inline-wrap">垃圾回收器总共分成三大类：</span></div></div><ul class="wolai-block"><li id="nMEL22uftewnRBUJBCNhcE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">串行：Serial、Serial Old</span></li><li id="qeKrTFESHgwurHG1ZnJg2q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并行：ParNew、Parallel、Parallel Old</span></li><li id="i61dMBmg2ssMCTKwH5Gdee"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发：CMS、G1</span></li></ul><div id="aBfkxD9Hjs49wakpVku5FB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dZcLrHQkdAZ1WcBrQiavT6" class="wolai-block"><span class="wolai-serial-number">12.2</span><span class="inline-wrap">理解</span></h2><h3 id="j1roXpptyJRZVumwqSyacJ" class="wolai-block"><span class="wolai-serial-number">12.2.1</span><span class="inline-wrap">Serial<span class="jill"></span>收集器</span></h3><div id="egMCwPnHfsP2jaURx23SdZ" class="wolai-block wolai-text"><div><span class="inline-wrap">它是最基本的垃圾回收器，使用单线程进行垃圾回收，会暂停所有用户线程，适用于客户端应用或者小型服务器应用</span></div></div><div id="mAp92HfY2B46uLaXHCkJpb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kwpwKHjJEeYFYpbuCmvjQ9" class="wolai-block"><span class="wolai-serial-number">12.2.2</span><span class="inline-wrap">Parallel<span class="jill"></span>收集器</span></h3><div id="oEjGcHX8hqGDCqrYj1UXqW" class="wolai-block wolai-text"><div><span class="inline-wrap">包括<span class="jill"></span>Parallel Scavenge<span class="jill"></span>和<span class="jill"></span>Parallel Old，它们使用多线程进行垃圾回收，可以充分利用多核处理器的优势，提高回收效率，适用于对吞吐量要求较高的应用</span></div></div><div id="8tx2meTprg7qkiradnhJFR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="nxRN8euRXBKxE3XQ7L4dao" class="wolai-block"><span class="wolai-serial-number">12.2.3</span><span class="inline-wrap">CMS（Concurrent Mark Sweep）收集器</span></h3><div id="78yxhGrfpXP1jyMPHdT1Jk" class="wolai-block wolai-text"><div><span class="inline-wrap">它是一种以获取最短回收停顿时间为目标的收集器，主要使用并发收集算法，减少垃圾回收时的停顿时间，适用于对响应时间要求严格的应用，如<span class="jill"></span>B/S<span class="jill"></span>服务端</span></div></div><div id="v6M7aiTerJEq5a48JG7K2k" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fETov2EowGNhtPH9eUkU4o" class="wolai-block"><span class="wolai-serial-number">12.2.4</span><span class="inline-wrap">G1（Garbage-First）收集器</span></h3><div id="kVbfR3zXWkxLqRKKMbsLfD" class="wolai-block wolai-text"><div><span class="inline-wrap">它面向服务端应用，将堆划分为多个大小相等的<span class="jill"></span>Region，并根据预测的停顿时间来选择要清理的<span class="jill"></span>Region，以达到控制垃圾回收造成的停顿，适用于大内存、多核处理器的服务器环境。</span></div></div><div id="e5ApwKSjdS5G6WNvGsHYqs" class="wolai-block wolai-text"><div></div></div><div id="tgzsFA635BQEPNkAuSZqPu" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="fWu26YT2m3zfhcNZ6ao97g" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">详细介绍一下<span class="jill"></span>CMS<span class="jill"></span>垃圾回收器？</span></h1><h2 id="qyWA8op3jWhwYV4wVX23JH" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">背记</span></h2><div id="9mzRTWtYzi9QHm2m1FezEi" class="wolai-block wolai-text"><div><span class="inline-wrap">CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，属于并发收集器，它实现了让垃圾收集线程与用户线程几乎同时工作。</span></div></div><div id="b2bnuyhuzHtQFYw7BW8UDv" class="wolai-block wolai-text"><div><span class="inline-wrap">整个过程由四个步骤：</span></div></div><ul class="wolai-block"><li id="398TVe4y3f531YtJdW2pku"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记（CMS initial mark）</span></li><li id="TaR9go4NSe7D85JWJ1UzD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记（CMS concurrent mark）</span></li><li id="9FXyV7mP8Wr9SPDdAC5Zos"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重新标记（CMS remark）</span></li><li id="hobxkogD3XYbUPj3mHupw1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发清理（CMS concurrent sweep）</span></li></ul><div id="akoAhUozM6E7EENbAe4Eqo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bF8HnaiU7QFLo2vTrKwGhS" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">理解</span></h2><div id="g8QXhK3BGykqadipChx971" class="wolai-block wolai-text"><div><span class="inline-wrap">CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</span></div></div><div id="m4yMQksynp1qLCmzeRZXJW" class="wolai-block wolai-text"><div><span class="inline-wrap">它非常适合在注重用户体验的应用上使用，它是<span class="jill"></span>HotSpot<span class="jill"></span>虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程几乎同时工作。</span></div></div><div id="oKputiUbJcfskVmY4k8X33" class="wolai-block wolai-text"><div><span class="inline-wrap">从名字中的<span class="jill"></span>Mark Sweep<span class="jill"></span>这两个词可以看出，CMS<span class="jill"></span>收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。</span></div></div><div id="anmYzga4i3xKge99LcgRWP" class="wolai-block wolai-text"><div><span class="inline-wrap">整个过程分为四个步骤：</span></div></div><ul class="wolai-block"><li id="rBbVMVQVy25CyL2cHCwcXF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始标记（CMS initial mark）</span></li><li id="eeGpGx77VtM3E4oxPtMfDm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发标记（CMS concurrent mark）</span></li><li id="e3FPRjopBYChzGS3NYC5Gw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重新标记（CMS remark）</span></li><li id="mtta3oYCr5pdeZ9zC1sFJC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">并发清理（CMS concurrent sweep）</span></li></ul><div id="uEzqu8gu9L3bbhJ52BXoUv" class="wolai-block wolai-text"><div><span class="inline-wrap">其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。</span></div></div><div id="rEbPnPzhfJH4SoUqoi2Tzu" class="wolai-block wolai-text"><div><span class="inline-wrap">初始标记仅仅只是枚举全部的<span class="jill"></span>GC Roots<span class="jill"></span>对象，速度很快，并发标记阶段就是进行<span class="jill"></span>GC Roots Tracing<span class="jill"></span>的过程【采用三色标记算法】</span></div></div><div id="49Upq4rFsfUQfxVj2sMDCb" class="wolai-block wolai-text"><div><span class="inline-wrap">这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。</span></div></div><div id="kzc7jPCgUBcjjiokGkN5g6" class="wolai-block wolai-text"><div><span class="inline-wrap">因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</span></div></div><div id="fRg6ikwt3AiQ5Emfkoizq4" class="wolai-block wolai-text"><div><span class="inline-wrap">而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</span></div></div><div id="9PJRwfUEDMjRTGsWMtu2qQ" class="wolai-block wolai-text"><div><span class="inline-wrap">并发清理这个阶段、清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象，因此这个阶段可以与用户线程同时发生。</span></div></div><div id="h7ohJwErwAi2do9EJ51Vkd" class="wolai-block wolai-text"><div><span class="inline-wrap">初始标记：迄今为止在进行根节点枚举这一步骤都是需要暂停用户线程的，必须要保证在一个能够保证一致性的快照中得以进行。</span></div></div><div id="cD2iABfWA6DbSW4qnkWX5m" class="wolai-block wolai-text"><div><span class="inline-wrap">这里的一致性指的是，不会出现在分析过程中，根节点集合的对象的引用关系还在不断地变化。</span></div></div><div id="wZe5G8ToQQVHQTwPsvnvkG" class="wolai-block wolai-text"><div><span class="inline-wrap">因为如果这点不能满足，那么分析结果就不能保证。</span></div></div><div id="symyGviBYgL5zbpdnMd8Kk" class="wolai-block wolai-text"><div><span class="inline-wrap">那么对于目前的<span class="jill"></span>Java<span class="jill"></span>应用来说，光是方法区的大小就有数百上千兆，里面的类或者常量更是恒河数沙，若是检查这里为起源的引用就需要消耗很多的时间，所以虚拟机自当是有办法直接得到哪些地方存在着对象的引用。</span></div></div><div id="76D5v1L5RVUrigeQtmJsz7" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>HotSpot<span class="jill"></span>虚拟机中，是使用的一组称为<span class="jill"></span>OopMap<span class="jill"></span>的数据结构来达存放这些引用。</span></div></div><div id="pRdrDVPfoXX9aBpKR7QmoB" class="wolai-block wolai-text"><div><span class="inline-wrap">一旦类加载完成的时候，虚拟机就会把对象的偏移量数据计算出来。</span></div></div><div id="71mGzvUYKZBYzEjsr9uEo4" class="wolai-block wolai-text"><div><span class="inline-wrap">并且在<span class="jill"></span>JIT<span class="jill"></span>即时编译中也会在特定的位置记录下栈里的寄存器中存放哪些位置是引用。</span></div></div><div id="7npXV2ZARU89p1p5iNdKCQ" class="wolai-block wolai-text"><div><span class="inline-wrap">这样收集器在扫描的时候就可以得知这些信息了。并不需要真正的一个不漏的从方法区等<span class="jill"></span>GCROOT<span class="jill"></span>开始查找。</span></div></div><div id="rAWNqXPHnW7bk7sY5jk4qf" class="wolai-block"><figure class="wolai-center" style="width: 1053px; flex-direction: column"><img src="media/image_9.png" style="width: 100%"/></figure></div><div id="t9GjuYyKsfHqqyBQi4QZYh" class="wolai-block wolai-text"><div><span class="inline-wrap">从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。</span></div></div><div id="icM3be6JE97j6Uxq4UD3xS" class="wolai-block wolai-text"><div><span class="inline-wrap">但是它有下面几个明显的缺点：</span></div></div><ul class="wolai-block"><li id="cmjQct4HoA4Z7kgLz7Wnyb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对<span class="jill"></span>CPU<span class="jill"></span>资源敏感（会和服务抢资源，降低吞吐量）；当然，这是所有并发收集器的缺点</span></li><li id="ragCe497cKfuTvCiXxsk53"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">无法处理浮动垃圾（在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾在本次收集中无法干掉他们，只能等到下一次<span class="jill"></span>GC<span class="jill"></span>再清理了，这一部分垃圾成为浮动垃圾）；</span></li><li id="fppG8kZwBt9seD4Nq4Ra7w"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">它使用的回收算法-“标记-清除”算法会导致收集结束时有大量空间碎片产生</span></li></ul><div id="rfPafFTdDFdAD4os5ZJBDq" class="wolai-block wolai-text"><div><span class="inline-wrap">同样由于垃圾收集阶段用户程序还需要持续运行，那就还需要预留足够的空间给用户线程使用，因此<span class="jill"></span>CMS<span class="jill"></span>垃圾回收器不能像其他的收集器那样等待老年代几乎完全被填满再进行垃圾收集。</span></div></div><div id="9JdwrzbYRtwkhtoPs9e1VH" class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>CMS<span class="jill"></span>运行期间预留的内存无法满足程序分配新对象的空间，就会出现并发失败。</span></div></div><div id="3QEfWxBPzDGcpsjkzv8EYq" class="wolai-block wolai-text"><div><span class="inline-wrap">这时候虚拟机就启动默认的备预案，冻结用户线程，临时启用重新对老年代的垃圾收集。</span></div></div><div id="8WFzNJs7JBpWzmqbaFeZCT" class="wolai-block wolai-text"><div><span class="inline-wrap">这样就导致停顿时间很长了，性能反而降低。</span></div></div><div id="vjdUrTv4s3ZNCSaGWd99F" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="wvG6qsZ97fhEphkyCVH3j8" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="mQoCeSLVjGX8wqKCC9PW13" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span></h1><h2 id="W1RKEdMY26dCKFfrqysmu" class="wolai-block"><span class="wolai-serial-number">14.1</span><span class="inline-wrap">背记</span></h2><h3 id="9TozTgVy44qdF1D4SgmCxv" class="wolai-block"><span class="wolai-serial-number">14.1.1</span><span class="inline-wrap">名称列表</span></h3><ul class="wolai-block"><li id="eUcZrjYFSiVx82XavvLppH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代回收器：Serial、ParNew、Parallel Scavenge</span></li><li id="fJcKJB5d1fbMjYrpdSBgin"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代回收器：Serial Old、Parallel Old、CMS<span class="jill"></span>整堆回收器</span></li></ul><div id="7vWE5p9Jh5JsiRuT6sTjWy" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7nT7CKJxacbVN1HLQcMJwg" class="wolai-block"><span class="wolai-serial-number">14.1.2</span><span class="inline-wrap">区别</span></h3><h4 id="pnYqL8eCEZy6jbMuwGAGHg" class="wolai-block"><span class="wolai-serial-number">14.1.2.1</span><span class="inline-wrap">应用场景</span></h4><ul class="wolai-block"><li id="rYukhtMzSMREPJFDSwrasp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代通常采用复制算法，因为大部分新生成的对象会很快变得不可达，所以复制算法可以高效地处理这些朝生夕死的对象。</span></li><li id="RoiWpzR1V7FHBNKxhXE9L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代则使用标记-清除或标记-整理算法，这些算法适用于处理长期存活的对象，可以减少内存碎片并提高内存利用率。</span></li></ul><div id="hkdCp9rpUHsTGFWLt8egVL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="toKu8U2x4vaeaD8bLqWXPH" class="wolai-block"><span class="wolai-serial-number">14.1.2.2</span><span class="inline-wrap">内存分配和管理策略</span></h4><ul class="wolai-block"><li id="aY2WUEeJcLLiXXAQQjXZk7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代与老年代的比例默认为<span class="jill"></span>1:2，新生代又可细分为<span class="jill"></span>Eden、From Survivor、To Survivor<span class="jill"></span>三个区。</span></li><li id="fWxW7BtpHqbfejnyvJXf3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代中的对象通常占用较大的内存空间，因此需要能够有效地管理这些对象的内存分配和回收。</span></li></ul><div id="idedVNAeQXaRKbG5AK382e" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="3xMYofviFyZKEP8tSqVaYP" class="wolai-block"><span class="wolai-serial-number">14.1.2.3</span><span class="inline-wrap">设计目标</span></h4><ul class="wolai-block"><li id="d6Ep5RtUmiCPeZeNVGYHUP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代垃圾回收器的设计目标是优化垃圾回收的性能，因为大多数新创建的对象会很快变得不可达。</span></li><li id="amXa7QeeBpPaHYFtMf2k5h"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代垃圾回收器的设计目标是处理长时间存活的对象，这些对象通常占用较大的内存空间。</span></li></ul><div id="2YywKYPCYYjSmg7hRsZqhd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="esdLxgUURar7s3rF8mGsSc" class="wolai-block"><span class="wolai-serial-number">14.2</span><span class="inline-wrap">理解</span></h2><div id="x49N9zEccqeb3TAzbvtN1j" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代垃圾回收器与老年代垃圾回收器在多个维度上存在显著差异，这些差异体现在它们的设计目标、适用的回收算法、垃圾回收器的选择以及内存管理策略等方面。</span></div></div><div id="8LRErdMKuaaMDYHDLBRXXR" class="wolai-block wolai-text"><div><span class="inline-wrap">具体分析如下：</span></div></div><h3 id="tTw2d9TzThGaXynbhUc7xS" class="wolai-block"><span class="wolai-serial-number">14.2.1</span><span class="inline-wrap">设计目标</span></h3><ul class="wolai-block"><li id="5w3jAFUhNuq7MprYid2DsR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代垃圾回收器的设计目标是优化垃圾回收的性能，因为大多数新创建的对象会很快变得不可达，所以新生代的回收器需要快速处理这些短生命周期的对象。</span></li><li id="r9k4Z1C9X93r1rhYgwKpsf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代垃圾回收器的设计目标是处理长时间存活的对象，这些对象通常占用较大的内存空间，因此老年代的回收器需要能够有效地管理这些对象的内存分配和回收。</span></li></ul><div id="tsSjheUPwK3WLxxErHAL2K" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vv3xApe8gm4j2Ryjutd6N3" class="wolai-block"><span class="wolai-serial-number">14.2.2</span><span class="inline-wrap">适用的回收算法</span></h3><ul class="wolai-block"><li id="2nv3TrWZQBpTfH3YF48JKV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代通常使用复制（Copy）算法，这种算法适用于快速回收大量短期对象，但可能会导致内存利用率降低。</span></li><li id="gw52JTW5Jn1cnxCH3vHtKS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代通常使用标记-清除（Mark-Sweep）或标记-整理（Mark-Compact）算法，这些算法适用于处理长期存活的对象，可以减少内存碎片并提高内存利用率。</span></li></ul><div id="rhta1bwmHUnnS4qPM6EGzy" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2Mfpdc2QVoYV8oBn6sWegQ" class="wolai-block"><span class="wolai-serial-number">14.2.3</span><span class="inline-wrap">垃圾回收器的选择：</span></h3><ul class="wolai-block"><li id="9U8XmT7u2LXXFrPAvtRWVq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代可以使用的垃圾回收器包括<span class="jill"></span>Serial、ParNew<span class="jill"></span>和<span class="jill"></span>Parallel Scavenge，这些回收器专注于快速清理新生代中的短期对象。</span></li><li id="sbo7D2mVkhGE7h7QXTToJo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代可以使用的垃圾回收器包括<span class="jill"></span>Serial Old、CMS<span class="jill"></span>和<span class="jill"></span>Parallel Old，这些回收器专注于长期存活对象的内存管理。</span></li></ul><div id="9iPNi9oVZPY8pZS8ykeVUx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="eWD7mJxrtapn69JAkAXrSg" class="wolai-block"><span class="wolai-serial-number">14.2.4</span><span class="inline-wrap">内存管理策略</span></h3><ul class="wolai-block"><li id="tRYR9Xeai5c2DWhM4uX8Rc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在执行<span class="jill"></span>Minor GC<span class="jill"></span>之前，JVM<span class="jill"></span>会检查老年代的可用内存空间，确保有足够的空间容纳新生代中存活下来的对象，以避免内存溢出。</span></li><li id="uvjC7N9paeoD6EpLy2doh4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代和老年代的内存比例会根据应用程序的需求进行调整，以平衡垃圾回收的效率和内存的使用效率。</span></li></ul><div id="iguWo9nonhqjUF6xg32tE" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，新生代垃圾回收器和老年代垃圾回收器在设计目标、适用的回收算法等方面各有特点，这些差异使得它们能够高效地管理<span class="jill"></span>Java<span class="jill"></span>虚拟机中的内存，适应不同类型对象的生命周期。了解这些差异有助于优化<span class="jill"></span>JVM<span class="jill"></span>的内存管理和垃圾回收过程，从而提高应用程序的性能。</span></div></div><div id="dv9LQU1jqdBjZ3zW15NboB" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vX9v9wbMFPddqCyHp92EZt" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">简述分代垃圾回收器是怎么工作的？</span></h1><h2 id="4hnwEGFLKUBSf2SZB34Gu2" class="wolai-block"><span class="wolai-serial-number">15.1</span><span class="inline-wrap">背记</span></h2><div id="kgffH4jC6hUntcFkHNWDw" class="wolai-block wolai-text"><div><span class="inline-wrap">分代回收器有两个分区：老年代和新生代，新生代默认的空间占比总空间的 1/3，老年代的默认占比是 2/3。</span></div></div><div id="231x6zJFKWpc2KZqbsTfmG" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</span></div></div><ul class="wolai-block"><li id="j7fRq9FCTsVp98pAS89ZvS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">把 Eden + From Survivor 存活的对象放入 To Survivor 区；</span></li><li id="spKjUHfWRfbAfwc6hcv9Gi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">清空 Eden 和 From Survivor 分区；</span></li><li id="28okEJ68fYpiCvMrXoFpWn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor</span></li><li id="c3hS9JPmnwSeNa1dA7XZyH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是<span class="jill"></span>15）时，升级为老年代。</span></li><li id="24NccvjFhBmLFA6KKU6ij5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">大对象也会直接进入老年代。</span></li></ul><div id="h6W9GNG3dYvd1xqZYk4e9b" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="srw66TCGXP2nVvntZE5rgc" class="wolai-block"><span class="wolai-serial-number">15.2</span><span class="inline-wrap">理解</span></h2><div id="bVUY9zrPqJa9Q8D77AaD7A" class="wolai-block wolai-text"><div><span class="inline-wrap">分代垃圾回收器是基于一种名为“分代假设”的观察，即大部分对象都是很快死去的。基于这个假设，JVM<span class="jill"></span>将内存分为两个主要区域：新生代和老年代。</span></div></div><ol class="wolai-block"><li id="ixZsVnrZ32xBeUDWTfz7uP"><div class="marker"></div><span class="inline-wrap">新生代：用于存放刚创建的对象。它的回收过程通常称为<span class="jill"></span>Minor GC<span class="jill"></span>或<span class="jill"></span>Young GC，采用复制算法来处理新生成对象的快速回收。</span></li><li id="586D5qRQtCABDrZJ9vEbc4"><div class="marker"></div><span class="inline-wrap">老年代：用于存放长时间存活的对象。当对象经过一定次数的垃圾回收后依然存活，它们将从新生代晋升到老年代。老年代的回收过程通常称为<span class="jill"></span>Major GC<span class="jill"></span>或<span class="jill"></span>Old GC，采用标记-清除或标记-整理算法来处理长期存活的对象。</span></li></ol><div id="ds3xDz2dLXnx9irSuB4X19" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="3qBeL7fPbpvZ3e464FMeeC" class="wolai-block wolai-text"><div><span class="inline-wrap">整个工作流程可以简述为：</span></div></div><ol class="wolai-block"><li id="ikFShzJqfM5k3Nr4UgyzMz"><div class="marker"></div><span class="inline-wrap">对象分配：在新生代<span class="jill"></span>Eden<span class="jill"></span>区分配新对象。</span></li><li id="iwKGJb2BXdewFbgmgcdzLi"><div class="marker"></div><span class="inline-wrap">第一次垃圾回收：当<span class="jill"></span>Eden<span class="jill"></span>区满时，执行<span class="jill"></span>Minor GC，将存活的对象复制到<span class="jill"></span>From Survivor<span class="jill"></span>区。</span></li><li id="qrmLRgpkANS1vYDVM8iRoV"><div class="marker"></div><span class="inline-wrap">第二次垃圾回收：当<span class="jill"></span>From Survivor<span class="jill"></span>区满时，再次执行<span class="jill"></span>Minor GC，将存活的对象复制到<span class="jill"></span>To Survivor<span class="jill"></span>区。</span></li><li id="hz9Z4aHjdVeuxwhd2hCPvo"><div class="marker"></div><span class="inline-wrap">晋升：重复上述过程，每次回收后，存活的对象年龄增加。当对象的年龄达到某个阈值时，它们将被移动到老年代。</span></li><li id="4ZfWnwAGfhvjK4ANPnJE2P"><div class="marker"></div><span class="inline-wrap">老年代回收：当老年代被填满，或者无法满足内存分配需求时，触发<span class="jill"></span>Major GC，对老年代进行垃圾回收。</span></li></ol><div id="iu3TRjjEpR9LkjKUwEvxWk" class="wolai-block wolai-text"><div><span class="inline-wrap">通过这种分代的方式，垃圾回收器能够有效地管理不同生命周期的对象，提高垃圾回收的效率。</span></div></div><div id="nCgaa59mQYcpLDLcbDbD9h" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pHgsdZwqo7sXGyASt7majt" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">垃圾回收器的比较</span></h1><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="v5YCu57wYH4xr7KQQJVbu2" class="wolai-block wolai-text"><div><span class="inline-wrap">名称</span></div></div><span class="inline-wrap"></span><br/><div id="jALoW8jAG1wES1WiK7eEdT" class="wolai-block wolai-text"><div><span class="inline-wrap">Serial</span></div></div><span class="inline-wrap"></span><br/><div id="rVB6Noys9XKw91hArBXPtS" class="wolai-block wolai-text"><div><span class="inline-wrap">ParNew</span></div></div><span class="inline-wrap"></span><br/><div id="r5hQgAGrrnaX9vXqWuZYgm" class="wolai-block wolai-text"><div><span class="inline-wrap">Parallel Scavenge</span></div></div><span class="inline-wrap"></span><br/><div id="pWh2fqkzC1po2TKMEQ8oVY" class="wolai-block wolai-text"><div><span class="inline-wrap">算法</span></div></div><span class="inline-wrap"></span><br/><div id="4zJ3VKimWccoX8p8gXBxor" class="wolai-block wolai-text"><div><span class="inline-wrap">标记复制</span></div></div><span class="inline-wrap"></span><br/><div id="b1Jga1U1UEg6hVGeZGajHd" class="wolai-block wolai-text"><div><span class="inline-wrap">标记复制</span></div></div><span class="inline-wrap"></span><br/><div id="sCkaeJbDHX3qUUk8ngkMrd" class="wolai-block wolai-text"><div><span class="inline-wrap">标记复制</span></div></div><span class="inline-wrap"></span><br/><div id="d4SjQVK1hFYTDmhWBMq9R3" class="wolai-block wolai-text"><div><span class="inline-wrap">生效区域</span></div></div><span class="inline-wrap"></span><br/><div id="KFm6RcvimjgCVJAKkkmhU" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代</span></div></div><span class="inline-wrap"></span><br/><div id="b5MUxxs7sy4DfNkaem3dab" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代</span></div></div><span class="inline-wrap"></span><br/><div id="hSa42JXhwxYWHsE3y8qWSJ" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代</span></div></div><span class="inline-wrap"></span><br/><div id="iHDePGPQWnds4o73QXpYcv" class="wolai-block wolai-text"><div><span class="inline-wrap">线程</span></div></div><span class="inline-wrap"></span><br/><div id="cRRahcXuiUymX6cp5hjHfD" class="wolai-block wolai-text"><div><span class="inline-wrap">单线程</span></div></div><span class="inline-wrap"></span><br/><div id="rPxtT6oGKsyWDZ3vQvShPq" class="wolai-block wolai-text"><div><span class="inline-wrap">多线程</span></div></div><span class="inline-wrap"></span><br/><div id="9rZPpFxMbFQHc7qnaT18HM" class="wolai-block wolai-text"><div><span class="inline-wrap">多线程</span></div></div><span class="inline-wrap"></span><br/><div id="rRRYNCADYKF5HonWxo86k3" class="wolai-block wolai-text"><div><span class="inline-wrap">工作模式</span></div></div><span class="inline-wrap"></span><br/><div id="iHzKDUrGkS1st982UBdoGE" class="wolai-block wolai-text"><div><span class="inline-wrap">串行</span></div></div><span class="inline-wrap"></span><br/><div id="bgzDPZFwo3QeGEukbjrXgN" class="wolai-block wolai-text"><div><span class="inline-wrap">并行</span></div></div><span class="inline-wrap"></span><br/><div id="h7L2zzHTXnA1Fu1mEWZQwp" class="wolai-block wolai-text"><div><span class="inline-wrap">并行</span></div></div><span class="inline-wrap"></span><br/><div id="sut9ysjkLeozAGnoUJucXv" class="wolai-block wolai-text"><div><span class="inline-wrap">说明</span></div></div><span class="inline-wrap"></span><br/><div id="smRzcmE393kFU1ovdfDqnB" class="wolai-block wolai-text"><div><span class="inline-wrap">简单粗暴，效率低下</span></div></div><span class="inline-wrap"></span><br/><div id="qzpbnqku3sGxRH6zMbsuu9" class="wolai-block wolai-text"><div><span class="inline-wrap">唯一和<span class="jill"></span>CMS<span class="jill"></span>搭配的新生代垃圾回收器</span></div></div><span class="inline-wrap"></span><br/><div id="5wiFHNVmW2sUf28tQuaUFB" class="wolai-block wolai-text"><div><span class="inline-wrap">实现了更大吞吐量</span></div></div><span class="inline-wrap"></span><br/><div id="v9fSeJz8iPP8gnU2nYBZxo" class="wolai-block wolai-text"><div><span class="inline-wrap">Serial Old</span></div></div><span class="inline-wrap"></span><br/><div id="i3FNgKV5o63Vp6ejmqhy4P" class="wolai-block wolai-text"><div><span class="inline-wrap">标记整理</span></div></div><span class="inline-wrap"></span><br/><div id="hkumnx3Zau7NcbDzN8YUYP" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代</span></div></div><span class="inline-wrap"></span><br/><div id="bTSvz1bLYtW98cVVkDRZwp" class="wolai-block wolai-text"><div><span class="inline-wrap">单线程</span></div></div><span class="inline-wrap"></span><br/><div id="qZ8yhFpHvjSELmAPopkXSK" class="wolai-block wolai-text"><div><span class="inline-wrap">串行</span></div></div><span class="inline-wrap"></span><br/><div id="mriVEKUZ7RaqFxHsC7ydBc" class="wolai-block wolai-text"><div><span class="inline-wrap">可以和所有<span class="jill"></span>young GC<span class="jill"></span>搭配使用</span></div></div><span class="inline-wrap"></span><br/><div id="5uBW7YvTZW9Xg4GAYpMv5y" class="wolai-block wolai-text"><div><span class="inline-wrap">Parallel Old</span></div></div><span class="inline-wrap"></span><br/><div id="jRZ1PWwJpmVNunAg3e5aSf" class="wolai-block wolai-text"><div><span class="inline-wrap">标记整理</span></div></div><span class="inline-wrap"></span><br/><div id="4pvMjRXhtXDUb4fo3R6yA1" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代</span></div></div><span class="inline-wrap"></span><br/><div id="7R95FuQAS4rXTJ37sCg7aH" class="wolai-block wolai-text"><div><span class="inline-wrap">多线程</span></div></div><span class="inline-wrap"></span><br/><div id="4jEFRfwVyeyF9UB48uAnbu" class="wolai-block wolai-text"><div><span class="inline-wrap">并行</span></div></div><span class="inline-wrap"></span><br/><div id="aLxVLLKbrjQcgFe4ChnetG" class="wolai-block wolai-text"><div><span class="inline-wrap">搭配<span class="jill"></span>Parallel Scavenge<span class="jill"></span>使用</span></div></div><span class="inline-wrap"></span><br/><div id="qCyeytQf52MEoYJertBSRn" class="wolai-block wolai-text"><div><span class="inline-wrap">CMS</span></div></div><span class="inline-wrap"></span><br/><div id="hcKm5rkXEj5mQD4HJBiLLW" class="wolai-block wolai-text"><div><span class="inline-wrap">标记清除</span></div></div><span class="inline-wrap"></span><br/><div id="rf5WArhnNpiC8hQCcSkjD6" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代</span></div></div><span class="inline-wrap"></span><br/><div id="d4rsv1j8Dw87xJo2EWUSSC" class="wolai-block wolai-text"><div><span class="inline-wrap">多线程</span></div></div><span class="inline-wrap"></span><br/><div id="5eW6CcRdTa3pBmUAnkCJmn" class="wolai-block wolai-text"><div><span class="inline-wrap">并发</span></div></div><span class="inline-wrap"></span><br/><div id="q5cLiryRSvoobekQiinBuC" class="wolai-block wolai-text"><div><span class="inline-wrap">设计理念尽可能将<span class="jill"></span>STW<span class="jill"></span>时间压缩到最短</span></div></div><div id="gK4AH1TDbqr1acJuFK9UVq" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nkfxXHxjZCbCEMpojJjoVC" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">请介绍一下什么是三色标记？</span></h1><h2 id="fCLpfaC2NGCrf2DoqNRh33" class="wolai-block"><span class="wolai-serial-number">17.1</span><span class="inline-wrap">三色标记算法介绍</span></h2><div id="7riZZy7LKjikc4iXeHx7f7" class="wolai-block wolai-text"><div><span class="inline-wrap">三色标记算法是一种应</span><span class="blue inline-wrap"><u><b>用于<span class="jill"></span>CMS<span class="jill"></span>和<span class="jill"></span>G1<span class="jill"></span>垃圾回收器</b></u></span><span class="inline-wrap">中的对象标记策略，主要用于区分内存中的对象是否仍然存活。</span></div></div><div id="6LQ7eSL9NieCmXo568B4Ps" class="wolai-block wolai-text"><div><span class="inline-wrap">通过将对象标记为不同的颜色，垃圾回收器可以高效地追踪和清理不再使用的对象。以下是三色标记算法的详细步骤和原理：</span></div></div><div id="3k443UZmwQn1wfsF3C9XZ3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rWqJ6yYRzZ4tyFWKy4emUc" class="wolai-block"><span class="wolai-serial-number">17.2</span><span class="inline-wrap">颜色定义</span></h2><ol class="wolai-block"><li id="sDawJoXxFzQnJRqDkZVSn6"><div class="marker"></div><span class="inline-wrap"><b>白色（White）：</b></span><span class="inline-wrap">表示尚未访问过的对象，初始状态下所有对象都是白色的。</span></li><li id="f2QuZRFeAE5dgsTShFBY76"><div class="marker"></div><span class="inline-wrap"><b>灰色（Gray）：</b></span><span class="inline-wrap">表示已经访问过但其引用的对象尚未全部访问的对象。灰色对象作为标记过程中的“工作队列”。</span></li><li id="eDdFVfHoXBD8Z3yTHq6dux"><div class="marker"></div><span class="inline-wrap"><b>黑色（Black）：</b></span><span class="inline-wrap">表示已经完全访问过的对象，即该对象及其引用的所有对象都已经被标记为存活。</span></li></ol><div id="qLQPc7dxde1K6FE6G1iQ4C" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mtumX2y6oVLvozawvvVRpU" class="wolai-block"><span class="wolai-serial-number">17.3</span><span class="inline-wrap">标记过程</span></h2><ol class="wolai-block"><li id="hbF9CXn5UKmTvVTLBbpHz"><div class="marker"></div><span class="inline-wrap"><b>初始化</b></span><ul class="wolai-block"><li id="gfqnMXd1Dd8W9Zz9scJ1re"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将所有对象标记为白色。</span></li><li id="4cmKJfRjZvY3vCFHyMyGyq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将根对象（如全局变量、栈中的对象引用等）标记为灰色，并加入到一个工作队列中。</span></li></ul></li><li id="a7Z2mWkqcsb8dkTSZgqLGP"><div class="marker"></div><span class="inline-wrap"><b>标记阶段</b></span><ul class="wolai-block"><li id="hsnc8VGfvb25W7S3Feq2HL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">从工作队列中取出一个灰色对象。</span></li><li id="tuKfQ9DPcVS6vZyUA3uUff"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将该对象标记为黑色。</span></li><li id="hMj3MwHoyyujzziRm5nd9a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">遍历该对象引用的所有对象：</span><ul class="wolai-block"><li id="teTqNcCbaSQiEijQGRMcrq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果引用的对象是白色的，将其标记为灰色并加入工作队列。</span></li><li id="vURFDhkfW9mHS1CaWEDZBN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果引用的对象已经是灰色或黑色，跳过。</span></li></ul></li><li id="b8y7CmkcgwvH3vtG4KyvQn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重复上述步骤，直到工作队列为空。</span></li></ul></li><li id="mtvTTSLkQgTst1rUnZFcuG"><div class="marker"></div><span class="inline-wrap"><b>清理阶段</b></span><ul class="wolai-block"><li id="3rQnfjSkmiV6bcNF4CSyiq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所有仍标记为白色的对象被认为是垃圾，可以被回收。</span></li><li id="ab4nCzpvwPYBo19QrqSXPc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">黑色和灰色对象被认为是存活对象，保留下来。</span></li></ul></li></ol><div id="p8bXLFjerqsruDSkiZWdkL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aQYxu1E4uRShAuxDpKLsMC" class="wolai-block"><span class="wolai-serial-number">17.4</span><span class="inline-wrap">并发标记与<span class="jill"></span>SATB</span></h2><ul class="wolai-block"><li id="wbhKrbLB5nXnr2DC6jr5A3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在并发标记过程中，应用程序可能继续运行并修改对象图。为了确保标记的准确性，一些垃圾回收器（如<span class="jill"></span>G1<span class="jill"></span>和<span class="jill"></span>Shenandoah）使用了</span><span class="inline-wrap"><b>SATB (Snapshot-At-The-Beginning)</b></span><span class="inline-wrap"> 机制。</span></li><li id="8yL6bNMJyH3FATYCTCHCpT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">SATB<span class="jill"></span>的基本思想是在标记开始时创建一个对象图的快照，并记录所有在标记过程中发生的修改，确保所有新创建的引用都能被正确标记。</span></li></ul><blockquote id="uaZ5TH27pMcgLooRHbUQHL" class="wolai-block"><span class="inline-wrap">额外说明：Shenandoah<span class="jill"></span>使用了<span class="jill"></span>SATB<span class="jill"></span>机制，但</span><span class="inline-wrap"><b>Shenandoah<span class="jill"></span>没有使用三色标记算法</b></span><span class="inline-wrap">。Shenandoah<span class="jill"></span>垃圾回收器采用了一种称为颜色指针的技术，而不是传统的三色标记算法。这种技术通过在对象中嵌入额外的位来表示对象的状态，从而避免了在并发环境下对对象进行多次扫描的需求。具体来说，Shenandoah<span class="jill"></span>使用了一种名为<span class="jill"></span>Brooks Forwarding Pointer<span class="jill"></span>的技术，它允许在对象移动时更新引用，而不需要像传统垃圾回收器那样在对象之间复制引用。</span></blockquote><div id="fEe1j7zswzMbfjZUmLad59" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="em1t8gWqNgS4xRLRiEhoaw" class="wolai-block"><span class="wolai-serial-number">17.5</span><span class="inline-wrap">优点</span></h2><ul class="wolai-block"><li id="art1nXXGxQZFZc7GJNPu2F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高效性</b></span><span class="inline-wrap">: 通过分阶段处理，减少了单次垃圾回收的停顿时间。</span></li><li id="xnLx4TYsyXUWrRR4pGz7xA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>并发性</b></span><span class="inline-wrap">: 可以与应用程序并发执行，减少对应用程序性能的影响。</span></li><li id="bo5tGTWwtf2SHqHebnDb9x"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>准确性</b></span><span class="inline-wrap">: 确保所有存活对象都能被正确标记，避免内存泄漏。</span></li></ul><div id="4tfdrGadvshZZZfWUYudzL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mDUtRVDu2DgG1HjDRQTc2E" class="wolai-block"><span class="wolai-serial-number">17.6</span><span class="inline-wrap">缺点</span></h2><ul class="wolai-block"><li id="wcq4ttXNRHHuqtAPCLFtSb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>复杂性</b></span><span class="inline-wrap">: 实现并发标记和<span class="jill"></span>SATB<span class="jill"></span>机制增加了垃圾回收器的复杂性。</span></li><li id="rT6Me7UG3RuiDpUp8eGVPd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>开销</b></span><span class="inline-wrap">: 记录和处理并发修改会带来一定的额外开销。</span></li></ul><div id="5hcD1sgcUDvDzmMcBPtgtQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3AGdH1Vs6LLVrhj67JMmkk" class="wolai-block"><span class="wolai-serial-number">17.7</span><span class="inline-wrap">应用实例</span></h2><ul class="wolai-block"><li id="kDvht1dbnAy3ueBTVJCtXr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>CMS（</b></span><span class="inline-wrap"><b>Concurrent Mark and Sweep</b></span><span class="inline-wrap"><b>）</b></span><span class="inline-wrap">使用三色标记进行并发标记，减少停顿时间。</span></li><li id="5GefV83m4FGDCcfJshWyx5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>G1（</b></span><span class="inline-wrap"><b>Garbage-First Garbage Collector</b></span><span class="inline-wrap"><b>）</b></span><span class="inline-wrap">结合<span class="jill"></span>SATB<span class="jill"></span>机制，实现高效的并发标记。</span></li><li id="3yxkL14qUL8nTzsUTvA2Rr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>ZGC（Z Garbage Collector）</b></span><span class="inline-wrap">利用读屏障和染色标记技术，实现低延迟的垃圾回收。这种染色标记技术是基于三色标记算法的一种优化实现</span></li><li id="oQdrHr7FhfceDEZtqSB1er"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Shenandoah</b></span><span class="inline-wrap">基于颜色指针技术，实现几乎没有停顿的垃圾回收。颜色指针技术可以看做三色标记技术的优化、改进，但从最终形态来说颜色指针和三色标记已经相差很大了</span></li></ul><div id="x4USBLbkhKpdHL15bVtoC9" class="wolai-block wolai-text"><div><span class="inline-wrap">三色标记算法因其高效性和并发性，在现代垃圾回收器中得到了广泛应用，成为垃圾回收领域的重要技术之一。</span></div></div><div id="bVmjhT2mvaFHYoPBCHsVPG" class="wolai-block wolai-text"><div></div></div><div id="cWjfaGxH5NYMF2XgfWZWrK" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="eLEXQRwynjRxMTHgCAeaCE" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">说说三色标记法工作过程中的多标问题</span></h1><h2 id="nLrSAwiyzW4EYVieLcCVW1" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">多标的产生</span></h2><div id="o7bsWUseMmka1xBSVr28Z4" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_10.png" style="width: 100%"/></figure></div><hr id="x4keauDhakY84CEqtVdoUn" class="wolai-block"/><hr id="eKTUVt7Sox6nW7nAAKqRbS" class="wolai-block"/><hr id="rPFMWqcRAtaEUS6UNLeZUP" class="wolai-block"/><div id="wkF7otPDN4X5RCGZXECKDL" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_11.png" style="width: 100%"/></figure></div><hr id="puvnk8BKEcWtZDFSsMPCXb" class="wolai-block"/><hr id="qNCiCRhbRVPubNA9WyLcFx" class="wolai-block"/><hr id="pXHr952JEUf7PedHmZhxYw" class="wolai-block"/><div id="65DsGz28HW6ogx2ZYfZjVH" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_12.png" style="width: 100%"/></figure></div><hr id="vvzFZzoa3M3PtYPbcJGH2x" class="wolai-block"/><hr id="3VdZXtdRHHiwZJy5xoeh47" class="wolai-block"/><hr id="3FYezARs6jEGQcTH6TJvQY" class="wolai-block"/><div id="kuL1KEYpXPuWjPUdLqt9W1" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_13.png" style="width: 100%"/></figure></div><div id="9r4RCW1cssbL95XD4jvxdU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="ghUJebRjKENASJ7kx5Pxnt" class="wolai-block wolai-text"><div><span class="inline-wrap">此时实际上<span class="jill"></span>B<span class="jill"></span>对象已经是垃圾对象了，但是由于<span class="jill"></span>B<span class="jill"></span>已经被标记为了灰色，所以不会再回退到白色状态，那么也就不会被作为垃圾清理掉。最终的结果就是<span class="jill"></span>B<span class="jill"></span>对象会逃过本轮<span class="jill"></span>GC。</span></div></div><div id="k9F7Ed8JEcwdxixp8797a" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pVdvPRGnwEzeAEaiTPYSid" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">多标的危害</span></h2><div id="rbSaMyoMph1YumQ9mErzgN" class="wolai-block wolai-text"><div><span class="inline-wrap">多标危害性不大，仅仅只是部分对象躲过本轮<span class="jill"></span>GC，在一定时间段内浪费部分内存空间，下次<span class="jill"></span>GC<span class="jill"></span>重新扫描即可被清理掉。</span></div></div><div id="9zDZDqmaDeWi1mgEh6us2J" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="26TVaAevqDGGVhDW2dqWe9" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dxYtsrQGdgGifqofiM63aQ" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">说说三色标记法工作过程中的漏标问题</span></h1><h2 id="4XafirBgQerT7ajGQbiWxc" class="wolai-block"><span class="wolai-serial-number">19.1</span><span class="inline-wrap">漏标的产生</span></h2><div id="ryCUhuef44kpNnWFfkMSPM" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_14.png" style="width: 100%"/></figure></div><hr id="6QXCeUzH15EgFbddcBmcSo" class="wolai-block"/><hr id="8EGWSZi2L9NhwUpUwhM2RS" class="wolai-block"/><hr id="dZTxkksVyb38AAs1Km3f6R" class="wolai-block"/><div id="m3VFZNidbFCz3WjNn6fZHq" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_15.png" style="width: 100%"/></figure></div><div id="h2E7Y2zz584DomongHDENp" class="wolai-block wolai-text"><div><span class="inline-wrap">问题分析：</span></div></div><ul class="wolai-block"><li id="fbhmDbzdzvkXxNGfiD8yCz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">D<span class="jill"></span>如果被</span><span class="inline-wrap"><u><b>灰色</b></u></span><span class="inline-wrap">对象引用，那么在未来将会被扫描到（灰色表示该对象引用的对象尚未扫描完成）</span></li><li id="5D9QaSvwZK7v5438d2Utn2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">D<span class="jill"></span>如果被</span><span class="inline-wrap"><u><b>黑色</b></u></span><span class="inline-wrap">对象引用，那么在未来讲不会被扫描到（黑色表示该对象引用的对象全部扫描完成了——但此时事实并非如此）</span></li></ul><div id="5FSt62jbuHXkyvNbFJCEjF" class="wolai-block wolai-text"><div><span class="inline-wrap">按照最终的对象引用关系，D<span class="jill"></span>对象其实应该是黑色的，但是在引用关系改变后，D<span class="jill"></span>被黑色的<span class="jill"></span>A<span class="jill"></span>对象引用，所以不会被扫描检测，颜色就没有机会改变了，最终保持了它原来的白色状态。</span></div></div><div id="pHWv7Rw8Wu52Nbofw9JNA7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4jskQnL8EeYSkJAjvwLxe4" class="wolai-block"><span class="wolai-serial-number">19.2</span><span class="inline-wrap">漏标的危害</span></h2><div id="95XY7TM9wkRgfr3oooN5UK" class="wolai-block wolai-text"><div><span class="inline-wrap">D<span class="jill"></span>对象事实上来说不是垃圾，但是最终因为是白色的，所以会被清理，那么<span class="jill"></span>A<span class="jill"></span>对象要访问<span class="jill"></span>D<span class="jill"></span>对象时就会发生空指针——这就是非常严重的问题</span></div></div><blockquote id="hHHfMLTdR7pwP8UxR17vQ3" class="wolai-block"><span class="inline-wrap">所以个人感觉“漏标”这个名字改成“误标”或“错标”或许会更好理解</span></blockquote><div id="2DBXiSoNypq8VNVNBzX4sa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="r2y6G42eC6XejFaAsNqgNF" class="wolai-block"><span class="wolai-serial-number">19.3</span><span class="inline-wrap">漏标的解决方案</span></h2><h3 id="oR22y7F4BKTnqReGGwmz3h" class="wolai-block"><span class="wolai-serial-number">19.3.1</span><span class="inline-wrap">问题的本质</span></h3><div id="ctu6Qz4edPSBeE3NcanoE9" class="wolai-block wolai-text"><div><span class="inline-wrap">漏标问题的危害就是：引用关系改变之后，非垃圾对象被当做垃圾对象清理了。产生这个问题需要同时满足下面两个条件：</span></div></div><ul class="wolai-block"><li id="7A7VvAcdofg1yaTW27jtWW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">条件一：灰对象断开了一个连接到白对象的引用</span></li><li id="3txqSZymrMgpHaC8Rg3YfG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">条件二：黑对象引用了一个白对象，黑对象本身不会被再次检测，而白对象最终会被当做垃圾清理</span></li></ul><div id="gyGa3GiyxyBc8Q6RtvozhY" class="wolai-block wolai-text"><div><span class="inline-wrap">所以破坏掉上面两个条件中的任何一个就可以解决这个问题</span></div></div><div id="2nbhdH1bjKRLatBAYGw9eE" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="uCygi1TAMLWLW31raARvYh" class="wolai-block"><span class="wolai-serial-number">19.3.2</span><span class="inline-wrap">CMS<span class="jill"></span>解决方案：写屏障<span class="jill"></span>+<span class="jill"></span>增量更新（</span><span class="inline-wrap"><b>Incremental Update</b></span><span class="inline-wrap">）</span></h3><div id="sicufN8e9CjNQX8Z8NgXQh" class="wolai-block wolai-text"><div><span class="inline-wrap">这一方案用大白话描述就是：如果黑色对象引用了白色对象，那么就把这个白色对象改为灰色，灰色对象会在下一轮扫描过程中被加入工作队列，所以这个方案破坏的是第二个条件</span></div></div><div id="cMBiLqLn6XxLJb4HEe59qE" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_16.png" style="width: 100%"/></figure></div><hr id="cenZDAyrBak4kU7fnZhM1y" class="wolai-block"/><hr id="bfp5Zg7K4GAXzjiuUEseaL" class="wolai-block"/><hr id="kbjRqanbRAhhQu4dqVcJY6" class="wolai-block"/><div id="sMyxN1AigADf1QMdKqonBa" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_17.png" style="width: 100%"/></figure></div><hr id="vVCJBoqeFhnHh4XiCNuUaP" class="wolai-block"/><hr id="7ECtZ8KrbiR9ejMBoFUob7" class="wolai-block"/><hr id="42q3ryk4rznA7zM2qdg9Ti" class="wolai-block"/><div id="qm6E9foDJ93mVg4Uxa5Kcs" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_18.png" style="width: 100%"/></figure></div><hr id="gW1Fpyv9CtPzrUGkZ1CkZF" class="wolai-block"/><hr id="rte1hakFDaRLsWMCVR4YP4" class="wolai-block"/><hr id="guskASEcFmej31VWALc5WD" class="wolai-block"/><div id="g3wtyQdB61gE3LcjnBmpfC" class="wolai-block"><figure class="wolai-center" style="width: 617.3333333333334px; flex-direction: column"><img src="media/image_19.png" style="width: 100%"/></figure></div><code-block id="oiA9wYUSAF2128ffWicFnB" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token comment">// 在写操作后执行</span>
<span class="token keyword">void</span> <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录新引用的对象</span>
<span class="token punctuation">}</span>
 写屏障代码参考</pre></div></code-block><h3 id="4f2fCubdWsM9L9zM3hD8HD" class="wolai-block"><span class="wolai-serial-number">19.3.3</span><span class="inline-wrap">G1<span class="jill"></span>解决方案：写屏障<span class="jill"></span>+<span class="jill"></span>原始快照（SATB）</span></h3><h4 id="mikHHB7PDLkegxJqSuchLW" class="wolai-block"><span class="wolai-serial-number">19.3.3.1</span><span class="inline-wrap">方案执行流程</span></h4><div id="cv9WW9trzvMuntxQA25qwj" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>SATB</b></span><span class="inline-wrap">：</span><span class="inline-wrap"><b>Snapshot-At-The-Beginning</b></span></div></div><div id="uvGt6WGb2qTd39fcUtoHw6" class="wolai-block wolai-text"><div><span class="inline-wrap">这一方案用大白话描述就是：灰色对象和一个白色对象断开连接时，把这个白色对象改成灰色，进而使其在下一轮扫描时放入工作队列，从而避免被清理，，所以这个方案破坏的是第一个条件</span></div></div><div id="5pL5jHof5srr7m719eqWPR" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_20.png" style="width: 100%"/></figure></div><hr id="nmWmDGWCRYWKYyaGW24Hct" class="wolai-block"/><hr id="mF3d7ATTCXLuFMSuKitAzP" class="wolai-block"/><hr id="vkBWXazkXLhJ7tQeKo8Ssq" class="wolai-block"/><div id="6Y2eS4ZKWGQRKQQ2mgbH6E" class="wolai-block"><figure class="wolai-center" style="width: 566px; flex-direction: column"><img src="media/image_21.png" style="width: 100%"/></figure></div><code-block id="w67xNzbDWCcx3cRN8o39sa" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token comment">// 在写操作前执行（这里的写操作就是B对D断开引用）</span>
<span class="token keyword">void</span> <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oop old_value <span class="token operator">=</span> <span class="token operator">*</span>field<span class="token punctuation">;</span> <span class="token comment">// 获取旧值</span>
    remark_set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录原来的引用对象</span>
<span class="token punctuation">}</span>
 写屏障代码参考</pre></div></code-block><hr id="oTGuPJXv2zREmMTzveBg9T" class="wolai-block"/><hr id="59vzGsP9wykz3EnHKH4jjm" class="wolai-block"/><hr id="gMscHx12ukvu76iRZ54LWM" class="wolai-block"/><div id="fF3dLodfFgZf5QnLk4grY8" class="wolai-block"><figure class="wolai-center" style="width: 523.3333333333334px; flex-direction: column"><img src="media/image_22.png" style="width: 100%"/></figure></div><div id="dmGuG47mSNFPYJj4v6umgS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="oiGJZDfhFAjmknnYkgEkRz" class="wolai-block"><span class="wolai-serial-number">19.3.3.2</span><span class="inline-wrap">方案存在的问题</span></h4><div id="cHMq6f6kFSBzEUkuWZeKND" class="wolai-block wolai-text"><div><span class="inline-wrap">很明显：在<span class="jill"></span>B<span class="jill"></span>到<span class="jill"></span>D<span class="jill"></span>的连接断开之后，如果<span class="jill"></span>A<span class="jill"></span>或其它任何对象并没有重新引用<span class="jill"></span>D，那么<span class="jill"></span>D<span class="jill"></span>就成了浮动垃圾，需要在下一次<span class="jill"></span>GC<span class="jill"></span>时回收</span></div></div><div id="6QpjHpsGaqffcQi2mmFP5i" class="wolai-block wolai-text"><div><span class="inline-wrap">评估：相对于漏标问题的严重危害，浮动垃圾危害不大，可以接受。这相当于把漏标的危害程度降低到了多标的程度</span></div></div><div id="m2ssDkr3CvRaUMHQhLue4E" class="wolai-block wolai-text"><div></div></div><div id="dr1YHRNXaQg2mX5gFZaTkB" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="aWBD2fjSj36tYJrM2V5KZp" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">JVM<span class="jill"></span>常用的调优工具有哪些？</span></h1><h2 id="8LukUQsMr6K8rvaFpZwE3v" class="wolai-block"><span class="wolai-serial-number">20.1</span><span class="inline-wrap">背记</span></h2><div id="uesm58cjctwSJqrWTaCkXZ" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK<span class="jill"></span>自带了很多监控工具，都位于<span class="jill"></span>JDK<span class="jill"></span>的<span class="jill"></span>bin<span class="jill"></span>目录下，其中最常用的是<span class="jill"></span>jconsole<span class="jill"></span>和<span class="jill"></span>jvisualvm<span class="jill"></span>这两款视图监控工具。</span></div></div><ul class="wolai-block"><li id="nU8nQTqhU2iw7fKo8xLgiA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JConsole：用于对<span class="jill"></span>JVM<span class="jill"></span>中的内存、线程和类等进行监控</span></li><li id="w3SA5bwKME9QaBa6EbS1Jy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JVisualVM</span><span class="inline-wrap">：JDK<span class="jill"></span>自带的全能分析工具，可以分析内存快照、线程快照、程序死锁、监控内存的变化、GC<span class="jill"></span>变化等</span></li></ul><div id="gw5cp2oENxTh4BK4gSCKZ3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="u5VqrZnQorg6BErauP21Yj" class="wolai-block"><span class="wolai-serial-number">20.2</span><span class="inline-wrap">理解</span></h2><div id="fxHmokWtZxF59jL9FPvoh" class="wolai-block wolai-text"><div><span class="inline-wrap">JConsole<span class="jill"></span>和<span class="jill"></span>JVisualVM<span class="jill"></span>是用于监控和管理<span class="jill"></span>Java<span class="jill"></span>应用程序的图形化工具，它们都是<span class="jill"></span>JDK<span class="jill"></span>自带的工具。</span></div></div><div id="hkufrMJSm7zntJ5ceFwDMF" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是这两个工具的具体使用情况：</span></div></div><h3 id="6kHTGA5fFC69x3x2rWUikL" class="wolai-block"><span class="wolai-serial-number">20.2.1</span><span class="inline-wrap">JConsole</span></h3><ol class="wolai-block"><li id="sJLxDqeVTFkaHcPKWyNuUY"><div class="marker"></div><span class="inline-wrap">监控本地或远程<span class="jill"></span>JVM：JConsole<span class="jill"></span>可以监控本地运行的<span class="jill"></span>Java<span class="jill"></span>应用程序，同时也可以连接到远程服务器上的<span class="jill"></span>Java<span class="jill"></span>应用程序进行监控。</span></li><li id="b1BHtJbWFDXiMD8nTCRYFn"><div class="marker"></div><span class="inline-wrap">MBean<span class="jill"></span>的管理：它提供了基于<span class="jill"></span>JMX（Java Management Extensions）的接口，允许用户查看和管理<span class="jill"></span>MBean，这是<span class="jill"></span>Java<span class="jill"></span>平台的一种资源管理机制。</span></li><li id="rc4HKP6qmpkvQgJtj4eY6K"><div class="marker"></div><span class="inline-wrap">性能监控：通过<span class="jill"></span>JConsole，用户可以实时查看<span class="jill"></span>Java<span class="jill"></span>应用程序的内存使用情况、线程状态、类加载情况以及<span class="jill"></span>CPU<span class="jill"></span>使用率等信息。</span></li></ol><h3 id="v5gdhfiQoSaYvfBeM2WLNv" class="wolai-block"><span class="wolai-serial-number">20.2.2</span><span class="inline-wrap">JVisualVM</span></h3><ol class="wolai-block"><li id="pfFftqd7gd9z1bbHfJA64a"><div class="marker"></div><span class="inline-wrap">强大的分析功能：JVisualVM<span class="jill"></span>不仅可以进行监控，还能进行深入的性能分析，如堆内存溢出分析、虚拟机栈溢出分析和线程死锁检测等。</span></li><li id="54BXvtBmdc7rqsEriAZB4X"><div class="marker"></div><span class="inline-wrap">插件支持：JVisualVM<span class="jill"></span>支持多种插件，这些插件可以提供更多的功能，如监控特定的应用服务器或框架。</span></li><li id="tVNs8knqMqYVV3zc27x9eD"><div class="marker"></div><span class="inline-wrap">图形化界面：JVisualVM<span class="jill"></span>提供了一个直观的用户界面，使得查看和分析数据更加方便。</span></li></ol><div id="xvTFSDSeLypoVrFmm74fNJ" class="wolai-block wolai-text"><div><span class="inline-wrap">在使用这两个工具时，通常需要确保目标<span class="jill"></span>Java<span class="jill"></span>应用程序启动时开启了<span class="jill"></span>JMX<span class="jill"></span>代理，并且设置了正确的端口号，以便<span class="jill"></span>JConsole<span class="jill"></span>或<span class="jill"></span>JVisualVM<span class="jill"></span>能够连接到应用程序。</span></div></div><div id="wLJKfiiqhsVRp8LBZNT7Tj" class="wolai-block wolai-text"><div><span class="inline-wrap">在连接后，用户可以通过这些工具的图形化界面来查看各种性能指标，并根据需要进行调整。</span></div></div><div id="ncNBYzFSmMfGqNdnm7Cin" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，JConsole<span class="jill"></span>更适合于快速的监控和管理任务，而<span class="jill"></span>JVisualVM<span class="jill"></span>则提供了更为全面和深入的性能分析功能。在实际使用中，根据需要选择合适的工具进行操作是非常重要的。</span></div></div><div id="JxXQsKkrYVE7FYZaTBjP6" class="wolai-block wolai-text"><div></div></div><div id="uHR3oe5iDjddtPB81oRNGF" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qb7cHZNL5xhLwcGa8Wpct2" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">常用的<span class="jill"></span>JVM<span class="jill"></span>调优的参数都有哪些？</span></h1><h2 id="sxLPoXqZbtXbxbnyhNwi96" class="wolai-block"><span class="wolai-serial-number">21.1</span><span class="inline-wrap">堆内存调优</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="4uRyAqqTdEQthwBaqADieZ" class="wolai-block wolai-text"><div><span class="inline-wrap">参数名称</span></div></div><span class="inline-wrap"></span><br/><div id="gqoZ3zzqGtBvxSV7mkmykh" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xms</span></div></div><span class="inline-wrap"></span><br/><div id="hAew6LXyWuXTEX6sfbvoMa" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmx</span></div></div><span class="inline-wrap"></span><br/><div id="bAyj2LdA98Q2vDuRg5thCH" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:NewRatio</span></div></div><span class="inline-wrap"></span><br/><div id="9uJTWgmnx3jqC59sRajRzk" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="jequSKD64MtdyJNucaD6qp" class="wolai-block wolai-text"><div><span class="inline-wrap">设置<span class="jill"></span>JVM<span class="jill"></span>堆内存的初始大小，影响应用程序启动时分配的内存量</span></div></div><span class="inline-wrap"></span><br/><div id="vVvv8jb2WQ1YMFsLVe4bMR" class="wolai-block wolai-text"><div><span class="inline-wrap">设置<span class="jill"></span>JVM<span class="jill"></span>堆内存的最大大小，限制了应用程序能够使用的最大内存量</span></div></div><span class="inline-wrap"></span><br/><div id="cZWRuXwQXE6ygoXieVJKiZ" class="wolai-block wolai-text"><div><span class="inline-wrap">设置新生代与老年代的比例，影响垃圾回收的性能和频率</span></div></div><span class="inline-wrap"></span><br/><div id="6Bu8bLLLdrrU9hcZeJNTRn" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:SurvivorRatio</span></div></div><span class="inline-wrap"></span><br/><div id="dp3rhgvdKQeDumCxSo9wCn" class="wolai-block wolai-text"><div><span class="inline-wrap">设置<span class="jill"></span>Eden<span class="jill"></span>区与<span class="jill"></span>Survivor<span class="jill"></span>区的比例，进一步细化新生代的内存分配策略</span></div></div><span class="inline-wrap"></span><br/><div id="bBpZ2cEZTRymV5bBVSyAPY" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxTenuringThreshold</span></div></div><span class="inline-wrap"></span><br/><div id="4Wr5G9FMS7cQbWxKeFLY5k" class="wolai-block wolai-text"><div><span class="inline-wrap">设置对象经过多少次垃圾回收后进入老年代，决定了对象的晋升年龄阈值</span></div></div><div id="4WNgSR6Dg2tNHPEyz7CJ9E" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wz2cmZRGhwgiEnB9C7JJ3q" class="wolai-block"><span class="wolai-serial-number">21.2</span><span class="inline-wrap">垃圾回收调优</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="6vhP7sen46Vvn3bGHoZNEu" class="wolai-block wolai-text"><div><span class="inline-wrap">参数名称</span></div></div><span class="inline-wrap"></span><br/><div id="qnRDgF6fEDcJpoUmZ9dHpS" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:+UseSerialGC</span></div></div><span class="inline-wrap"></span><br/><div id="6SUqfgJrh8ZPY5HfAHuC2J" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:+UseParallelGC</span></div></div><span class="inline-wrap"></span><br/><div id="s2DHpDLr8iZ4VPR2C7hRzN" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:+UseConcMarkSweepGC</span></div></div><span class="inline-wrap"></span><br/><div id="xqzSvHE1K9mCXLeXK57czy" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="tKDVUKAG9untocnYb6dYKu" class="wolai-block wolai-text"><div><span class="inline-wrap">指定使用串行垃圾收集器，适用于单核处理器或小内存量的应用场景</span></div></div><span class="inline-wrap"></span><br/><div id="cBRKALvqBq7xjMX7WDFo6B" class="wolai-block wolai-text"><div><span class="inline-wrap">指定使用并行垃圾收集器，适用于多核处理器且希望最大化吞吐量的场景</span></div></div><span class="inline-wrap"></span><br/><div id="vvdjFi5C6SkxYPSsajT3vd" class="wolai-block wolai-text"><div><span class="inline-wrap">指定使用并发标记清除垃圾收集器，适用于需要低延迟的应用</span></div></div><span class="inline-wrap"></span><br/><div id="ni961nBXDypBzERVoyJxmP" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:+UseG1GC</span></div></div><span class="inline-wrap"></span><br/><div id="8EdBd68Sf8SFZncgmb6Pfm" class="wolai-block wolai-text"><div><span class="inline-wrap">指定使用<span class="jill"></span>G1<span class="jill"></span>垃圾收集器，适用于大堆内存和多核处理器的场景，提供平衡的吞吐量和较低的延迟</span></div></div><div id="7C3wBoEGM2DQSXHs3gc6aw" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oofAjKEVdBkub6ZpSiaPY2" class="wolai-block"><span class="wolai-serial-number">21.3</span><span class="inline-wrap">线程调优</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="weq2Y44EwaPaEr8VwgNLhm" class="wolai-block wolai-text"><div><span class="inline-wrap">参数名称</span></div></div><span class="inline-wrap"></span><br/><div id="9bNUpvNnV1MR7jWrwSDDK" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xss</span></div></div><span class="inline-wrap"></span><br/><div id="qtpu71fZuJkmp6V9qkvZFB" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="88BDBhK2u7k3ZcMsqUB8H5" class="wolai-block wolai-text"><div><span class="inline-wrap">设置<span class="jill"></span>Java<span class="jill"></span>线程堆栈大小，影响线程的内存占用和性能</span></div></div><div id="sPTUAueNTJUwEHH5X1LAQU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wud3HkwYAvAyA8cqRJTKY4" class="wolai-block"><span class="wolai-serial-number">21.4</span><span class="inline-wrap">日志设置</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="dBmiTGfEL5kwAcPebRJbKx" class="wolai-block wolai-text"><div><span class="inline-wrap">参数名称</span></div></div><span class="inline-wrap"></span><br/><div id="t3yH8jRZgF5Mpk7pKo6yUS" class="wolai-block wolai-text"><div><span class="inline-wrap">-verbose:class</span></div></div><span class="inline-wrap"></span><br/><div id="5vhBdwqjSCLfiDGtMEyJXh" class="wolai-block wolai-text"><div><span class="inline-wrap">-verbose:gc</span></div></div><span class="inline-wrap"></span><br/><div id="nbHULo8Zoi2QYHKxQjdTQc" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="hGVL1bfGWGegJtq5XRwp7S" class="wolai-block wolai-text"><div><span class="inline-wrap">输出类加载信息，有助于分析类加载过程和性能问题</span></div></div><span class="inline-wrap"></span><br/><div id="7DQdAKezXur2gUYQ49pbm6" class="wolai-block wolai-text"><div><span class="inline-wrap">输出垃圾回收信息，有助于监控垃圾回收活动和性能问题</span></div></div><div id="cBfSLNAmQ2Y7RiGpwRyuJN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hcK61zGdwBN8FWA7uJDaJ4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3QjSbX1WnMeWuNy4Wksieg" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">System.gc()能保证执行<span class="jill"></span>GC<span class="jill"></span>执行吗？</span></h1><h2 id="5xNpMTEMwtZJy5ZvwukZqD" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">背记</span></h2><div id="pioaV1iw5H9yFjAMHNctTd" class="wolai-block wolai-text"><div><span class="inline-wrap">不能保证<span class="jill"></span>GC<span class="jill"></span>一定会执行。</span></div></div><div id="5kF1BRL1isqg1As56nYn4H" class="wolai-block wolai-text"><div><span class="inline-wrap">尽管程序员可以通过调用 System.gc() 来建议<span class="jill"></span>JVM<span class="jill"></span>进行垃圾回收，但<span class="jill"></span>Java<span class="jill"></span>语言规范并没有规定这会导致垃圾回收一定发生。</span></div></div><div id="ustPZKyBwquWJiDd4mU1fC" class="wolai-block wolai-text"><div><span class="inline-wrap">垃圾回收通常是自动进行的，而且它的触发时机取决于<span class="jill"></span>JVM<span class="jill"></span>的具体实现和当前的内存使用状况。</span></div></div><div id="kL8RNZp6SiG2Csiqr9tb2c" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eGE9qxpATBFVsyTjLUvE7P" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">理解</span></h2><div id="d5fn46R5VyQ95onF8djgn3" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一些关于垃圾回收执行的关键点：</span></div></div><h3 id="agzAS2q112ZGdwPVaaCrFB" class="wolai-block"><span class="wolai-serial-number">22.2.1</span><span class="inline-wrap">System.gc()的作用</span></h3><div id="faYUgNx8aXTNqtVziuZuqq" class="wolai-block wolai-text"><div><span class="inline-wrap">System.gc() 是一个建议性的调用，它向<span class="jill"></span>JVM<span class="jill"></span>提出了进行垃圾回收的建议，但<span class="jill"></span>JVM<span class="jill"></span>可能不会立即响应这个请求。</span></div></div><div id="bLY1PeAWCkWyL4U7gnhDD7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="sRYv33ffgq9guBwboQJdHd" class="wolai-block"><span class="wolai-serial-number">22.2.2</span><span class="inline-wrap">垃圾回收的触发条件</span></h3><div id="jQxeGgayAJXU4pGjUBsh4j" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代通常在<span class="jill"></span>Eden<span class="jill"></span>区被填满后会触发垃圾回收，而老年代的触发条件则更为复杂，因为有些并发收集器允许用户线程在清理过程中继续运行。</span></div></div><div id="h4qJMeSXHBhSEmWsU8AUCN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="eUkHqH3FVHQbTt2Fhgcd5h" class="wolai-block"><span class="wolai-serial-number">22.2.3</span><span class="inline-wrap">垃圾回收的不确定性</span></h3><div id="d52V5fPt53FwgaGFXxWamq" class="wolai-block wolai-text"><div><span class="inline-wrap">垃圾回收的发生具有一定的不确定性，通常是在随机的时间点，这取决于对象的分配和存活情况。</span></div></div><div id="6DHfbFEBE6T3pCwFVfzhWW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wgRmA5TUJNKDe9gn1s8wUg" class="wolai-block"><span class="wolai-serial-number">22.2.4</span><span class="inline-wrap">JVM<span class="jill"></span>实现者的角色</span></h3><div id="hVkwesyB4eJ57Qqzw4PnTf" class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>的实现者可以决定如何响应 System.gc() 的调用，这意味着不同的<span class="jill"></span>JVM<span class="jill"></span>实现可能会有不同的行为。</span></div></div><div id="i2ZNJGaqNSHJa7wTsV91AN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="bpB3jng8YjcfVX6oKRPcH4" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，虽然 System.gc() 可以作为一种提示<span class="jill"></span>JVM<span class="jill"></span>进行垃圾回收的手段，但它并不能保证垃圾回收一定会执行。在实践中，通常不建议频繁手动触发垃圾回收，因为这可能会对应用程序的性能产生负面影响。</span></div></div><div id="xnihwioxQxB6qmvpfiFTBs" class="wolai-block wolai-text"><div><span class="inline-wrap">相反，应该依赖于<span class="jill"></span>JVM<span class="jill"></span>的自动垃圾回收机制来管理内存，同时通过合理地设置<span class="jill"></span>JVM<span class="jill"></span>参数来优化垃圾回收的效率。</span></div></div><div id="kCL1jMvbJMB3rfthHenYzm" class="wolai-block wolai-text"><div><span class="inline-wrap">如果确实需要对垃圾回收进行更精细的控制，可以考虑使用特定的<span class="jill"></span>JVM<span class="jill"></span>选项或工具来监控和调整垃圾回收的行为。</span></div></div><div id="px6o2Udro7sq4fmioj2CWZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="h7fGzoCDbKVcA1ZfTLWAQv" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="xjWBNmZJhZuCoHCfGJ3gTP" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">怎么获取<span class="jill"></span>Java<span class="jill"></span>程序使用的内存？堆使用的百分比？</span></h1><div id="5tPese5heHACWYQ4s44f4x" class="wolai-block wolai-text"><div><span class="inline-wrap">要获取<span class="jill"></span>Java<span class="jill"></span>程序使用的内存以及堆使用的百分比，可以使用以下几种方法：</span></div></div><ol class="wolai-block"><li id="hiapEt5hY2evFaszXwAsYf"><div class="marker"></div><span class="inline-wrap"><b>使用<span class="jill"></span>JVM<span class="jill"></span>内置工具</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="4zxeunc2hx1CjsB9VXqNjR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>jstat</b></span><span class="inline-wrap">：这是一个命令行工具，可以用来监控<span class="jill"></span>JVM<span class="jill"></span>的各种性能指标，包括堆内存的使用情况。例如，运行</span><span class="inline-wrap"><code>jstat -gc &lt;pid&gt;</code></span><span class="inline-wrap">可以查看指定进程的垃圾回收统计信息，其中包含了堆内存的使用情况。</span></li><li id="tRNCiV8r13B9dqpWhAuLDK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>jmap</b></span><span class="inline-wrap">：这个工具可以用来生成堆转储快照（heap dump），或者查询堆的详细信息。例如，运行</span><span class="inline-wrap"><code>jmap -heap &lt;pid&gt;</code></span><span class="inline-wrap">可以查看堆的配置和使用情况。</span></li></ul></li><li id="qxGJicENTRrQ8hbELmstMT"><div class="marker"></div><span class="inline-wrap"><b>使用<span class="jill"></span>Java<span class="jill"></span>代码</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="2Cg7aLNahTLgVFTNC5W6a5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以通过</span><span class="inline-wrap"><code>Runtime</code></span><span class="inline-wrap">类来获取当前<span class="jill"></span>JVM<span class="jill"></span>的内存使用情况。例如：</span><code-block id="hDjcKT36GdPc52b2zgUgku" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Runtime</span> runtime <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> totalMemory <span class="token operator">=</span> runtime<span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// JVM总内存</span>

<span class="token keyword">long</span> freeMemory <span class="token operator">=</span> runtime<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// JVM空闲内存</span>

<span class="token keyword">long</span> usedMemory <span class="token operator">=</span> totalMemory <span class="token operator">-</span> freeMemory<span class="token punctuation">;</span> <span class="token comment">// 已使用的内存</span>

<span class="token keyword">double</span> usagePercentage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> usedMemory <span class="token operator">/</span> totalMemory <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 使用百分比</span></pre></div></code-block></li></ul></li><li id="2Um44PiiU1HMpRi1tWTsYy"><div class="marker"></div><span class="inline-wrap"><b>使用第三方库</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="335cSN9G3i6Q6PnS2PBStU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以使用如</span><span class="inline-wrap"><code>SIGAR</code></span><span class="inline-wrap">、</span><span class="inline-wrap"><code>OSHI</code></span><span class="inline-wrap">等第三方库来获取系统和<span class="jill"></span>JVM<span class="jill"></span>的详细性能指标。这些库通常提供了更丰富的<span class="jill"></span>API<span class="jill"></span>来监控系统资源。</span></li></ul></li><li id="kSQ7niSHWMG526edDJZdjF"><div class="marker"></div><span class="inline-wrap"><b>使用<span class="jill"></span>JMX（Java Management Extensions）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="gFVK3esNuYCBWVJesyHnq5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JMX<span class="jill"></span>是<span class="jill"></span>Java<span class="jill"></span>平台的一部分，用于管理和监控应用程序、系统对象、设备等。通过<span class="jill"></span>JMX，你可以连接到正在运行的<span class="jill"></span>JVM<span class="jill"></span>并查询各种管理数据，包括内存使用情况。可以使用<span class="jill"></span>JConsole<span class="jill"></span>或<span class="jill"></span>VisualVM<span class="jill"></span>这样的工具来访问<span class="jill"></span>JMX MBeans。</span></li></ul></li><li id="wW1pJEBns8qWjcfcHAy2Tc"><div class="marker"></div><span class="inline-wrap"><b>集成到应用中</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="5AjZkDoWSc9JCksBAhspQp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果你的应用是一个<span class="jill"></span>Web<span class="jill"></span>应用，许多应用服务器（如<span class="jill"></span>Tomcat, Jetty<span class="jill"></span>等）都提供了监控和管理功能，包括内存使用情况。</span></li></ul></li></ol><div id="j7w1GjMKHrtEw6YXMY3p3T" class="wolai-block wolai-text"><div><span class="inline-wrap">选择哪种方法取决于你的具体需求，比如是否需要实时监控、是否需要跨平台支持等。对于开发和测试环境，使用<span class="jill"></span>JVM<span class="jill"></span>内置工具或<span class="jill"></span>Java<span class="jill"></span>代码可能更为方便；对于生产环境，可能需要更稳定和功能丰富的解决方案，如使用第三方库或<span class="jill"></span>JMX。</span></div></div><div id="hDTBGPT3UfRcxd52jJ9tFL" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div></article><footer></footer></body></html>