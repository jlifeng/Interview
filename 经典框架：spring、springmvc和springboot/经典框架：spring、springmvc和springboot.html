<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>经典框架：Spring、SpringMVC和SpringBoot - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="经典框架：Spring、SpringMVC和SpringBoot" class="main-title"></div></div></header><article><h1 id="jzVxCq4d7bF7TfXwuz33iU" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">什么是 Spring IOC 容器？</span></h1><h2 id="fNerDdGk6pdj8krehG98Ks" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">背记</span></h2><div id="9iVyugsvxZ5tUGTbAuAHQM" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring IoC（控制反转）容器是<span class="jill"></span>Spring<span class="jill"></span>框架的核心组件，它负责创建、配置和管理<span class="jill"></span>Java<span class="jill"></span>对象及其生命周期。</span></div></div><h3 id="dpQzP5eXch9HKN8L38oGi6" class="wolai-block"><span class="wolai-serial-number">1.1.1</span><span class="inline-wrap">IoC<span class="jill"></span>就是控制反转</span></h3><div id="c9t2Gi723gUuuJMJ1W5S33" class="wolai-block wolai-text"><div><span class="inline-wrap">简单的来说就是将创建对象的权利交由<span class="jill"></span>spring<span class="jill"></span>框架进行管理，spring<span class="jill"></span>会根据配置文件去创建实例对象以及管理依赖。以前创建对象的时机都是自己把握，主动权在自己的手上，现在可以使用<span class="jill"></span>java<span class="jill"></span>的反射机制进行自动生产，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法。</span></div></div><div id="vwDEf25ocRBDV4H2uzr56t" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vw6K5tYpRiUPR4ssLVyatu" class="wolai-block"><span class="wolai-serial-number">1.1.2</span><span class="inline-wrap">DI<span class="jill"></span>依赖注入</span></h3><div id="bV8Tae1x338w5W8EBTLW6B" class="wolai-block wolai-text"><div><span class="inline-wrap">DI<span class="jill"></span>依赖注入是<span class="jill"></span>IOC<span class="jill"></span>的一种具体实现方式，就是通过容器获取对象，并进行属性的赋值。IOC<span class="jill"></span>是一种思想，而<span class="jill"></span>DI<span class="jill"></span>是一种实现。</span></div></div><div id="af6jBxhxToFyadN6xe4VuX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4DCFNiHTDAnGsVLZjYC4gV" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">理解</span></h2><div id="mcas3yMpEQn3u3U9oiZvs2" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring IoC（控制反转）是<span class="jill"></span>Spring<span class="jill"></span>框架的核心，它是一种设计原则，旨在减少代码之间的耦合，提高模块之间的独立性和灵活性。</span></div></div><div id="r8PNTHpFnpyKUehovyF1M1" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是对<span class="jill"></span>Spring IoC<span class="jill"></span>的个人理解：</span></div></div><ol class="wolai-block"><li id="kEN6ibTbHz5Ch1PVMB5qQZ"><div class="marker"></div><span class="inline-wrap"><b>管理对象的创建和生命周期</b></span><span class="inline-wrap">：在传统的<span class="jill"></span>Java<span class="jill"></span>应用程序中，对象通常由开发者直接创建和管理。而在<span class="jill"></span>Spring IoC<span class="jill"></span>中，对象的创建和生命周期管理由<span class="jill"></span>Spring<span class="jill"></span>容器负责。这样，开发者可以将注意力集中在业务逻辑上，而不是对象的创建和管理细节。</span></li><li id="cYmijJAwzrDmxGoYtcpkez"><div class="marker"></div><span class="inline-wrap"><b>依赖注入</b></span><span class="inline-wrap">：Spring IoC<span class="jill"></span>通过依赖注入机制，将对象的依赖项（如其他对象、数据源等）动态地注入到对象中。这样，对象不需要自己创建或查找它们的依赖项，而是被动地接收由<span class="jill"></span>Spring<span class="jill"></span>容器提供的依赖项。</span></li><li id="nr5hWVW1MEcxtKfLeMxp5d"><div class="marker"></div><span class="inline-wrap"><b>降低代码耦合</b></span><span class="inline-wrap">：Spring IoC<span class="jill"></span>通过将对象的创建和依赖管理交给外部容器，降低了代码之间的耦合。对象不需要关心如何创建和管理它们的依赖项，只需要通过简单的配置或注解来声明它们的依赖关系。</span></li><li id="kEogWoJ9DaY3vRZtkzNMZW"><div class="marker"></div><span class="inline-wrap"><b>提高代码的可测试性</b></span><span class="inline-wrap">：由于对象是通过<span class="jill"></span>Spring IoC<span class="jill"></span>容器创建和管理的，因此可以轻松地为测试提供模拟对象或虚假实现。这极大地简化了单元测试和集成测试的编写和维护。</span></li><li id="nQjvbWguS5XQvLGSB5rq2J"><div class="marker"></div><span class="inline-wrap"><b>灵活性和扩展性</b></span><span class="inline-wrap">：Spring IoC<span class="jill"></span>容器提供了丰富的配置选项和扩展机制，使得开发者可以根据需要定制和扩展容器的行为。这种灵活性和扩展性使得<span class="jill"></span>Spring IoC<span class="jill"></span>能够适应各种应用场景和需求变化。</span></li><li id="56fmuWXgVUcToX8aNYcqoc"><div class="marker"></div><span class="inline-wrap"><b>促进良好的设计实践</b></span><span class="inline-wrap">：使用<span class="jill"></span>Spring IoC<span class="jill"></span>鼓励开发者遵循良好的设计原则，如单一职责原则、开放封闭原则等。通过将对象的创建和管理交给外部容器，可以促使开发者编写更加模块化、可维护和可重用的代码。</span></li></ol><div id="48myNHa5qyjDKkKoQ3N1Qw" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Spring IoC<span class="jill"></span>是一种强大的设计原则，它通过将对象的创建和管理交给外部容器，降低了代码之间的耦合，提高了模块之间的独立性和灵活性。这使得开发者可以更加专注于业务逻辑的开发，同时提高了代码的可维护性和可测试性。</span></div></div><div id="fFRnKPEwc5xXNGoiReDW2P" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hDnEiF5J7idVDhq37iFrEe" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="iqwX5LvG3HmyjSCt3eyWdw" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">如何实现一个<span class="jill"></span>Spring<span class="jill"></span>容器</span></h1><h2 id="v4CCKne6VeMzf5yx4MBaNj" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">实现基本思路</span></h2><div id="hfTTYEZc7CQbMLrss8Vp8q" class="wolai-block wolai-text"><div><span class="inline-wrap">创建一个集合容器，先将对象创建出来放到容器中，需要使用对象时，只需要从容器中获取对象即可，而不需要重新创建，此时容器就是对象的管理者。</span></div></div><div id="dMJqXGjnt99hMM5KoDGQA7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sUYixjTcQyFRJgNEsuJfTV" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">实现基本步骤</span></h2><div id="v9vRXwBqQ9xTXhAPifx7GH" class="wolai-block wolai-text"><div><span class="inline-wrap">自定义<span class="jill"></span>Spring IoC<span class="jill"></span>容器的步骤如下：</span></div></div><ol class="wolai-block"><li id="ky2aZmwaDKMe7VxZSjJjmk"><div class="marker"></div><span class="inline-wrap"><b>定义<span class="jill"></span>Bean</b></span><span class="inline-wrap">：首先，需要定义具体的<span class="jill"></span>Bean<span class="jill"></span>类，即希望由<span class="jill"></span>Spring<span class="jill"></span>容器管理的对象。这些<span class="jill"></span>Bean<span class="jill"></span>类需要提供默认的构造函数或有参构造函数，并且要有合适的属性和方法。</span></li><li id="pPBvG2XJQcwLDqVWWiPtvG"><div class="marker"></div><span class="inline-wrap"><b>配置<span class="jill"></span>XML<span class="jill"></span>文件</b></span><span class="inline-wrap">：创建一个<span class="jill"></span>XML<span class="jill"></span>配置文件，用于描述<span class="jill"></span>Bean<span class="jill"></span>的定义和它们之间的依赖关系。在该文件中，你需要声明<span class="jill"></span>Bean<span class="jill"></span>的<span class="jill"></span>ID（唯一标识符）和对应的类名，以及其他相关的属性。</span></li><li id="mVeaHg8yhwfPe7AdvPU1go"><div class="marker"></div><span class="inline-wrap"><b>创建<span class="jill"></span>IoC<span class="jill"></span>容器</b></span><span class="inline-wrap">：在你的应用程序中，通过加载<span class="jill"></span>XML<span class="jill"></span>文件来创建一个<span class="jill"></span>Spring IoC<span class="jill"></span>容器。可以使用<span class="jill"></span>ClassPathXmlApplicationContext 或 FileSystemXmlApplicationContext 等容器实现类来加载<span class="jill"></span>XML<span class="jill"></span>文件。</span></li><li id="2K9zFQtG3WjpNwgzHHqvu4"><div class="marker"></div><span class="inline-wrap"><b>获取<span class="jill"></span>Bean</b></span><span class="inline-wrap">：一旦<span class="jill"></span>IoC<span class="jill"></span>容器创建成功，你可以使用 getBean() 方法从容器中获取你所需要的<span class="jill"></span>Bean<span class="jill"></span>对象。根据<span class="jill"></span>Bean<span class="jill"></span>的<span class="jill"></span>ID<span class="jill"></span>或名称，Spring<span class="jill"></span>会在容器中查找相应的<span class="jill"></span>Bean，并将其返回给你。</span></li><li id="5mmqfs9fPhnygEng7R4ovd"><div class="marker"></div><span class="inline-wrap"><b>使用<span class="jill"></span>Bean</b></span><span class="inline-wrap">：拿到<span class="jill"></span>Bean<span class="jill"></span>对象后，你就可以使用它们的属性和方法来完成相应的业务逻辑了。</span></li></ol><div id="s2ygGUKtx1STdMyRoDmJps" class="wolai-block wolai-text"><div></div></div><div id="p3BPQcWNHg5nT6qZxgfVXx" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wyEWW6uyQEdLxjfzpdo8YS" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">什么是依赖注入？可以通过多少种方式完成依赖注入？</span></h1><h2 id="cv6M9YEiXxvDfy1zziHWfC" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背记</span></h2><div id="dVXRefrhomM66owzGBpMP4" class="wolai-block wolai-text"><div><span class="inline-wrap">依赖注入（Dependency Injection，简称<span class="jill"></span>DI）是一种设计模式，它的核心思想是将对象的依赖关系从对象内部转移到外部，由外部容器在创建对象时动态地将依赖关系注入到对象中，具体来说，对象的依赖关系是指对象所需的其他服务或组件。在传统的程序设计中，对象通常自己负责创建它们所依赖的对象，这导致了高度耦合和难以维护的代码，而依赖注入可以改变了这种状况。依赖注入可以通过三种主要方式完成：构造函数注入、Setter<span class="jill"></span>注入和接口注入</span></div></div><div id="jpTMWe7FYWLv63a3J8mESc" class="wolai-block wolai-text"><div><span class="inline-wrap">通常，依赖注入可以通过三种方式完成，即：</span></div></div><ul class="wolai-block"><li id="uhM86aUFWphG5LNKk2jHnc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">构造函数注入</span></li><li id="nnQS3KJkuG8V2gaM9PNtrJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">setter 注入</span></li><li id="ngSEMAZe2fd1evUBHdCNdy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口注入</span></li></ul><div id="ovm5RvMdJMURpZwRSyvpD1" class="wolai-block wolai-text"><div><span class="inline-wrap">在 Spring Framework 中，仅使用构造函数和 setter 注入。</span></div></div><div id="kibbQ3btGXvf3qw9ZfSuL6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2YLCW138UHMVQP9FdfJZMx" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">理解</span></h2><div id="rv8wzCrCCzETTUYNTV36Dd" class="wolai-block wolai-text"><div><span class="inline-wrap">依赖注入（Dependency Injection，简称<span class="jill"></span>DI）是一种设计模式，它的核心思想是将对象的依赖关系从对象内部转移到外部，由外部容器在创建对象时动态地将依赖关系注入到对象中。这种设计模式的目的是降低代码之间的耦合度，提高代码的可维护性和灵活性。</span></div></div><div id="2XJ8K9bGuuZRhx4kdbVDEd" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是对依赖注入的个人理解：</span></div></div><ol class="wolai-block"><li id="xkieYovmZ6QbUDSY8rg1xd"><div class="marker"></div><span class="inline-wrap"><b>解耦</b></span><span class="inline-wrap">：依赖注入通过将对象的依赖关系从对象内部转移到外部，降低了对象之间的耦合度。对象不需要自己创建和管理它们的依赖项，而是通过外部容器来提供这些依赖项。这样，对象只需要关注自己的业务逻辑，而不需要考虑如何获取和处理它们的依赖项。</span></li><li id="e7Ts39PfHkMSwTEYpQMufq"><div class="marker"></div><span class="inline-wrap"><b>可测试性</b></span><span class="inline-wrap">：由于对象是通过外部容器来获取它们的依赖项，因此可以很容易地为测试提供模拟对象或虚假实现。这极大地简化了单元测试和集成测试的编写和维护，提高了代码的可测试性。</span></li><li id="3Xd3HfArjDvvLPmEuTTfvn"><div class="marker"></div><span class="inline-wrap"><b>灵活性和扩展性</b></span><span class="inline-wrap">：依赖注入提高了代码的灵活性和扩展性。由于依赖关系是通过外部容器来提供的，因此可以很容易地替换或添加新的依赖实现，而不会影响到使用这些依赖的代码。这使得在不同的环境或测试场景中切换依赖实现变得更加容易，同时也支持了良好的扩展性。</span></li><li id="7Er52LsMrNP3W4g8E6ndk"><div class="marker"></div><span class="inline-wrap"><b>模块化</b></span><span class="inline-wrap">：依赖注入鼓励开发者编写模块化的代码。由于对象之间的依赖关系被转移到了外部容器，因此每个对象都可以被视为一个独立的模块，它们之间相互独立但又协同工作。这种模块化的设计使得代码更加易于理解、维护和扩展。</span></li><li id="meNHjsJjMRz7rpBxxYJG3U"><div class="marker"></div><span class="inline-wrap"><b>配置集中化</b></span><span class="inline-wrap">：依赖注入通常与配置文件一起使用，以便在一个地方集中管理所有依赖关系。这样可以很容易地查看和管理一个对象所需的所有依赖项，并且可以在不修改代码的情况下更改依赖关系。</span></li></ol><div id="4ekDkrQui9gs9cjgFgviWi" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，依赖注入是一种强大的设计模式，它通过将对象的依赖关系从对象内部转移到外部，降低了代码之间的耦合度，提高了代码的可维护性和灵活性。在实际开发中，依赖注入通常是通过使用专门的框架或库来实现的，如<span class="jill"></span>Spring<span class="jill"></span>框架中的<span class="jill"></span>IoC<span class="jill"></span>容器。</span></div></div><div id="gekm2ZHLRyGMptF7QnxVjP" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="obZfoAbHLdGgbPzo6XN6kE" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">BeanFactory 和 ApplicationContext<span class="jill"></span>的区别？</span></h1><div id="hEoT3WjTR3fX7fWjwxFNX1" class="wolai-block wolai-text"><div><span class="inline-wrap">ApplicationContext<span class="jill"></span>是<span class="jill"></span>BeanFactory<span class="jill"></span>的子接口</span></div></div><div id="irYciUrJXYfVbpTPytV1Go" class="wolai-block wolai-text"><div><span class="inline-wrap">ApplicationContext<span class="jill"></span>提供了更完整的功能：</span></div></div><ul class="wolai-block"><li id="6gq6xedBCapao3tWd3focr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">①继承<span class="jill"></span>MessageSource，因此支持国际化。</span></li><li id="fPQGv4x5c4tS7vLwjXmqr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">②统一的资源文件访问方式。</span></li><li id="8ZA8pyQcpvEfduJSQtVzkZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">③提供在监听器中注册<span class="jill"></span>bean<span class="jill"></span>的事件。</span></li><li id="hBDZ3ku1kRkk9eiea2GdL7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">④同时加载多个配置文件。</span></li><li id="8ktM873EJYKtwY3E59G9Pu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的<span class="jill"></span>web<span class="jill"></span>层。</span></li></ul><div id="iT3i3ZksNXMfSmwhZVxa3v" class="wolai-block wolai-text"><div><span class="inline-wrap">BeanFactroy<span class="jill"></span>采用的是延迟加载形式来注入<span class="jill"></span>Bean<span class="jill"></span>的，即只有在使用到某个<span class="jill"></span>Bean<span class="jill"></span>时(调用<span class="jill"></span>getBean())，才对该<span class="jill"></span>Bean<span class="jill"></span>进行加载实例化。这样，我们就不能发现一些存在的<span class="jill"></span>Spring<span class="jill"></span>的配置问题。如果<span class="jill"></span>Bean<span class="jill"></span>的某一个属性没有注入，BeanFacotry<span class="jill"></span>加载后，直至第一次使用调用<span class="jill"></span>getBean<span class="jill"></span>方法才会抛出异常。ApplicationContext，它是在容器启动时，一次性创建了所有的<span class="jill"></span>Bean。这样，在容器启动时，我们就可以发现<span class="jill"></span>Spring<span class="jill"></span>中存在的配置错误，这样有利于检查所依赖属性是否注入。</span></div></div><div id="izusaPzNQf4KS1tMXug9oD" class="wolai-block wolai-text"><div><span class="inline-wrap">ApplicationContext<span class="jill"></span>启动后预载入所有的单实例<span class="jill"></span>Bean，通过预载入单实例<span class="jill"></span>bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的<span class="jill"></span>BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置<span class="jill"></span>Bean<span class="jill"></span>较多时，程序启动较慢。BeanFactory<span class="jill"></span>通常以编程的方式被创建，ApplicationContext<span class="jill"></span>还能以声明的方式创建，如使用<span class="jill"></span>ContextLoader。</span></div></div><div id="8oQ49exNZGRJzTdFeuqK2j" class="wolai-block wolai-text"><div><span class="inline-wrap">BeanFactory<span class="jill"></span>和<span class="jill"></span>ApplicationContext<span class="jill"></span>都支持<span class="jill"></span>BeanPostProcessor、BeanFactoryPostProcessor<span class="jill"></span>的使用，但两者之间的区别是：BeanFactory<span class="jill"></span>需要手动注册，而<span class="jill"></span>ApplicationContext<span class="jill"></span>则是自动注册</span></div></div><div id="wvwFEKERyh4ZsacTkjKAi6" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jqszzkhxfkK1es5fE4m2Je" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">构造函数注入和 setter 注入</span></h1><div id="8Pzbb3Z3wUnv1bmSbx6NfX" class="wolai-block wolai-text"><div><span class="inline-wrap">构造函数注入和<span class="jill"></span>setter<span class="jill"></span>注入是依赖注入（Dependency Injection）中两种常见的方式，用于将依赖对象注入到目标对象中。它们在注入方式和使用方式上有所不同。</span></div></div><div id="a5FefSFrHcwHC2JWbohtYn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kDpuee5CTVNFmq9tSDr1Vk" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">构造函数注入（Constructor Injection）</span></h2><div id="aRQkNu8kCAjap82onevyCH" class="wolai-block wolai-text"><div><span class="inline-wrap">构造函数注入是通过目标对象的构造函数来接收依赖对象的注入。依赖对象在创建目标对象时通过构造函数的参数传递进来。一旦目标对象被创建，其依赖对象就不能再改变。构造函数注入可以保证目标对象在创建时就具备了必要的依赖，使得目标对象的状态是完整和一致的。</span></div></div><div id="2aLVwnWqSTxD2tuhMVkwzo" class="wolai-block wolai-text"><div><span class="inline-wrap">示例（Java）：</span></div></div><code-block id="bjPAw4bSKpfsgE3wDLbAZ" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository <span class="token operator">=</span> userRepository<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用userRepository进行用户操作</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="szySEESSWQGuPcYxSovbhk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hJYLGDNUxgwyKpfL5ZGHKJ" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">Setter<span class="jill"></span>注入（Setter Injection）</span></h2><ul class="wolai-block"><li id="wUsqtbLPTz6Rq23nJPwcNC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Setter<span class="jill"></span>注入是通过目标对象的<span class="jill"></span>setter<span class="jill"></span>方法来接收依赖对象的注入。  </span></li><li id="qaYDHKbhNsFLbmJD7CVQwA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">依赖对象通过<span class="jill"></span>setter<span class="jill"></span>方法设置到目标对象中。  </span></li><li id="xgqaDsuSPZH1AGpHuNaeBL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">可以在任何时候通过调用<span class="jill"></span>setter<span class="jill"></span>方法来改变目标对象的依赖对象。  </span></li><li id="cqQ7bZbtpwS7NAg2Si65xv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Setter<span class="jill"></span>注入可以提供更灵活的依赖注入方式，允许在运行时动态地改变依赖对象。</span></li></ul><div id="o38iodM33MEwqVKWv2EF9F" class="wolai-block wolai-text"><div><span class="inline-wrap">示例（Java）：</span></div></div><code-block id="284eqnuVzccJWhpLFSS9Ks" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserRepository</span><span class="token punctuation">(</span><span class="token class-name">UserRepository</span> userRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository <span class="token operator">=</span> userRepository<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 使用userRepository进行用户操作</span>
<span class="token punctuation">}</span></pre></div></code-block><h2 id="a5fpLQGtcrE3L8nCcxCnB1" class="wolai-block"><span class="wolai-serial-number">5.3</span><span class="inline-wrap">总结</span></h2><ul class="wolai-block"><li id="icKYCthFDM4mi4Hrqc3gwG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">构造函数注入适用于那些在目标对象创建时就必须具备依赖对象的情况，可以保证目标对象的依赖是不可变的。</span></li><li id="23xYQhfmnXniYcmAWgcjB8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Setter<span class="jill"></span>注入适用于那些依赖对象可以在运行时动态改变的情况，提供了更大的灵活性。</span></li><li id="pfYxYCj6chqJYdkP4ZafkE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在选择注入方式时，应根据具体的需求和设计考虑使用哪种方式，或者在需要时结合两种方式使用。</span></li></ul><div id="tDxVSuJ3BvoEm86wNe8yJm" class="wolai-block wolai-text"><div></div></div><div id="vGCvTecrCLjV1xpMFLQqPP" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="wA5NvHAaxvtv4GEv1nXFfQ" class="wolai-block wolai-text"><div></div></div><h1 id="fXpZrn5c1EAGCpLwWf36Bn" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">Spring 提供了哪些配置方式？</span></h1><h2 id="tyxotZDrfro4qoDbgBMSyC" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">基于<span class="jill"></span>XML<span class="jill"></span>配置方式</span></h2><div id="9QvFJcM7aQ4oAHLqvFSD86" class="wolai-block wolai-text"><div><span class="inline-wrap">bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</span></div></div><code-block id="nzAJES9eA4d5TwMknx54Lu" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentbean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.edureka.firstSpring.StudentBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Edureka<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></pre></div></code-block><div id="aogDDwLN6npz1KPtaxoUN7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fgb316xykY6EtniwYSjcYJ" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">基于注解配置方式</span></h2><div id="cKXVSasDMcYTdGQN7fmEc7" class="wolai-block wolai-text"><div><span class="inline-wrap">您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用<span class="jill"></span>XML<span class="jill"></span>来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</span></div></div><code-block id="91VtJS5yj8N2jrSAJ5SrFq" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>annotation-config</span><span class="token punctuation">/></span></span>
<span class="token comment">&lt;!-- bean definitions go here --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></pre></div></code-block><div id="vFmX7Z7jRUErcyXTs8fCDN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="jW3uz5ABnqYhp8oYp6WVST" class="wolai-block"><span class="wolai-serial-number">6.3</span><span class="inline-wrap">基于 Java Config<span class="jill"></span>配置</span></h2><div id="jRko1ixbUVLbuT8RX7bG63" class="wolai-block wolai-text"><div><span class="inline-wrap">这是目前的主流方式，Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</span></div></div><ol class="wolai-block"><li id="rKwsHnaZMgGB7DgqYhXc86"><div class="marker"></div><span class="inline-wrap">@Bean 注解扮演与 元素相同的角色。  </span></li><li id="8ffsCg8QVDjJW3sB6EeCFG"><div class="marker"></div><span class="inline-wrap">@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。  </span></li><li id="emczv8Nag1XH5fVNW6KSKD"><div class="marker"></div><span class="inline-wrap">@Component<span class="jill"></span>注解  </span></li></ol><div id="4VMGtFn4SfhW5Tgx87fqp3" class="wolai-block wolai-text"><div><span class="inline-wrap">例如：</span></div></div><code-block id="oRbuedPN1wYUM6RLmHwhws" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span><span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token class-name">Student</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span></pre></div></code-block><div id="mNE2AHthtpmgVm3CNfxRYo" class="wolai-block wolai-text"><div></div></div><div id="7xg6pPC52v7HTaf8WSq7fz" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="gdVXogykdi8KhZ51wvukRL" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">Spring 中的 bean 的作用域有哪些?</span></h1><div id="iVfQCWajM9m6zQMfamF3JL" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>singleton</b></span><span class="inline-wrap">：默认，每个容器中只有一个<span class="jill"></span>bean<span class="jill"></span>的实例，单例的模式由<span class="jill"></span>BeanFactory<span class="jill"></span>自身来维护。该对象的生命周期是与<span class="jill"></span>Spring IOC<span class="jill"></span>容器一致的（但在第一次被注入时才会创建） </span></div></div><div id="3FteES3dnHR69oWmJrZnBc" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>prototype </b></span><span class="inline-wrap">: 每次请求都会创建一个新的 bean 实例</span></div></div><div id="sFn7P1L59P4t6mYQTWSpxS" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>request</b></span><span class="inline-wrap">：bean<span class="jill"></span>被定义为在每个<span class="jill"></span>HTTP<span class="jill"></span>请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</span></div></div><div id="pZh7PJ6ZXeS7oBdKvZUKJi" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>session</b></span><span class="inline-wrap">：与<span class="jill"></span>request<span class="jill"></span>范围类似，确保每个<span class="jill"></span>session<span class="jill"></span>中有一个<span class="jill"></span>bean<span class="jill"></span>的实例，在<span class="jill"></span>session<span class="jill"></span>过期后，bean<span class="jill"></span>会随之失效。</span></div></div><div id="eUgJjQV7pisoztakTQHUg7" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>application</b></span><span class="inline-wrap">：bean<span class="jill"></span>被定义为在<span class="jill"></span>ServletContext<span class="jill"></span>的生命周期中复用一个单例对象。</span></div></div><div id="p7Svtf3wotDBqW9QCW5QB6" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>websocket</b></span><span class="inline-wrap">：bean<span class="jill"></span>被定义为在<span class="jill"></span>websocket<span class="jill"></span>的生命周期中复用一个单例对象。</span></div></div><div id="nQ9K7LE1Pg5M416oF3j7AQ" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>global-session</b></span><span class="inline-wrap">：全局作用域，global-session<span class="jill"></span>和<span class="jill"></span>Portlet<span class="jill"></span>应用相关。当你的应用部署在<span class="jill"></span>Portlet<span class="jill"></span>容器中工作时，它包含很多<span class="jill"></span>portlet。如果你想要声明让所有的<span class="jill"></span>portlet<span class="jill"></span>共用全局的存储变量的话，那么这全局变量需要存储在<span class="jill"></span>global-session<span class="jill"></span>中。全局作用域与<span class="jill"></span>Servlet<span class="jill"></span>中的<span class="jill"></span>session<span class="jill"></span>作用域效果相同。</span></div></div><div id="rk5VT6DNoXARnPYxzJPCsr" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>refesh</b></span><span class="inline-wrap">:Springcloud<span class="jill"></span>组件扩展了<span class="jill"></span>Bean<span class="jill"></span>对象的作用域在一次配置文件修改之后有效。</span></div></div><div id="bBP9bFMPzH7dFv1QVDDuLT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kivBNYcFFd6FQhqH8p5U48" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dW5XnYVBomao7Q2XDAkzFu" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">深入谈谈对<span class="jill"></span>Ioc<span class="jill"></span>的理解？</span></h1><h2 id="mWKbxVe2WYfzSTj9EHA2QM" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">IoC<span class="jill"></span>容器</span></h2><div id="aue3aumhTc3wBrPHTBex7K" class="wolai-block wolai-text"><div><span class="inline-wrap">实际上就是个<span class="jill"></span>Map（key，value），里面存的是各种对象（在<span class="jill"></span>xml<span class="jill"></span>里配置的<span class="jill"></span>bean<span class="jill"></span>节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的<span class="jill"></span>bean<span class="jill"></span>节点，根据全限定类名使用反射创建对象放到<span class="jill"></span>map<span class="jill"></span>里、扫描到打上上述注解的类还是通过反射创建对象放到<span class="jill"></span>map<span class="jill"></span>里。这个时候<span class="jill"></span>map<span class="jill"></span>里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过<span class="jill"></span>DI<span class="jill"></span>注入（@autowired、@resource<span class="jill"></span>等注解，xml<span class="jill"></span>里<span class="jill"></span>bean<span class="jill"></span>节点内的<span class="jill"></span>ref<span class="jill"></span>属性，项目启动的时候会读取<span class="jill"></span>xml<span class="jill"></span>节点<span class="jill"></span>ref<span class="jill"></span>属性根据<span class="jill"></span>id<span class="jill"></span>注入，也会扫描这些注解，根据类型或<span class="jill"></span>id<span class="jill"></span>注入；id<span class="jill"></span>就是对象名）。</span></div></div><div id="qVjZ4cyZwpYKVciJ2jhdVM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rKhCw4ZTLXMS3FHiWnbU1S" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">控制反转</span></h2><div id="5WwyqHT1koz6tMxNkg9534" class="wolai-block wolai-text"><div><span class="inline-wrap">没有引入<span class="jill"></span>IOC<span class="jill"></span>容器之前，对象<span class="jill"></span>A<span class="jill"></span>依赖于对象<span class="jill"></span>B，那么对象<span class="jill"></span>A<span class="jill"></span>在初始化或者运行到某一点的时候，自己必须主动去创建对象<span class="jill"></span>B<span class="jill"></span>或者使用已经创建的对象<span class="jill"></span>B。无论是创建还是使用对象<span class="jill"></span>B，控制权都在自己手上。引入<span class="jill"></span>IOC<span class="jill"></span>容器之后，对象<span class="jill"></span>A<span class="jill"></span>与对象<span class="jill"></span>B<span class="jill"></span>之间失去了直接联系，当对象<span class="jill"></span>A<span class="jill"></span>运行到需要对象<span class="jill"></span>B<span class="jill"></span>的时候，IOC<span class="jill"></span>容器会主动创建一个对象<span class="jill"></span>B<span class="jill"></span>注入到对象<span class="jill"></span>A<span class="jill"></span>需要的地方。</span></div></div><div id="n8dCxVJG59Z1WqTQMDekyG" class="wolai-block wolai-text"><div><span class="inline-wrap">通过前后的对比，不难看出来：对象<span class="jill"></span>A<span class="jill"></span>获得依赖对象<span class="jill"></span>B<span class="jill"></span>的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。全部对象的控制权全部上缴给“第三方”IOC<span class="jill"></span>容器，所以，IoC<span class="jill"></span>容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把<span class="jill"></span>IOC<span class="jill"></span>容器比喻成“粘合剂”的由来。</span></div></div><div id="3yCoAaPSNsMJzUoJCQHTHs" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2FFkqeEUtD5bQyH5RMDsrD" class="wolai-block"><span class="wolai-serial-number">8.3</span><span class="inline-wrap">依赖注入</span></h2><div id="scCFJSvK4GcN4J678qSY5n" class="wolai-block wolai-text"><div><span class="inline-wrap">&quot;获得依赖对象的过程被反转了&quot;。控制被反转之后，获得依赖对象的过程由自身管理变为了由<span class="jill"></span>IOC<span class="jill"></span>容器主动注入。依赖注入是实现<span class="jill"></span>IOC<span class="jill"></span>的方法，就是由<span class="jill"></span>IOC<span class="jill"></span>容器在运行期间，动态地将某种依赖关系注入到对象之中。</span></div></div><div id="dNNFqrYbJtzoFnY1Xa1Tjm" class="wolai-block wolai-text"><div></div></div><div id="f3FsTVAt3YUcLW4RR8urwh" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pkMiSdR2we4LbPjLZmj6yL" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">将一个类声明为<span class="jill"></span>Spring<span class="jill"></span>的 bean 的注解有哪些?</span></h1><div id="kXJq9Yi9ePWQ1CpzsZGEeq" class="wolai-block wolai-text"><div><span class="inline-wrap">我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的<span class="jill"></span>bean 的类,采用以下注解可实现：</span></div></div><ul class="wolai-block"><li id="ai9pYF8Dux9fNiTTqvVyj1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个<span class="jill"></span>Bean<span class="jill"></span>不知道属于哪个层，可以使用<span class="jill"></span>@Component 注解标注。</span></li><li id="n7PpxvbCePPsCHMKZSVpJq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</span></li><li id="tzyBhn8N2Pd8QaxJYD9Vpm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao<span class="jill"></span>层。</span></li><li id="gb1yNpAKiLqX2UqobpN8Ph"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</span></li><li id="c1qaht6QCx6a2mp32SYQnt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@Configuration+\@Bean<span class="jill"></span>的方式</span></li></ul><div id="rBtEkr8X5qrD2wKm7zPQut" class="wolai-block wolai-text"><div></div></div><div id="iwMPirRvur7guuTSJzRVZn" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tntoLkunFJYTfjgCPrnwXE" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">Spring 中的 bean 生命周期?</span></h1><div id="qVinGz1GDgFRQKNg8yGrh1" class="wolai-block wolai-text"><div><span class="inline-wrap">1.读取配置文件或配置类生成<span class="jill"></span>BeanDefinition，并注册到<span class="jill"></span>BeanDefinitionMap<span class="jill"></span>中</span></div></div><div id="diaDZ3iAbxM8ZTX5qGdmAx" class="wolai-block wolai-text"><div><span class="inline-wrap">2.合并得到<span class="jill"></span>BeanDefiniton</span></div></div><div id="bNhRHBXfQvBbNU4wXvHBF1" class="wolai-block wolai-text"><div><span class="inline-wrap">3.加载类<span class="jill"></span>resolveBeanClass</span></div></div><div id="e4idvZuVk9iHWWzjn7w3V9" class="wolai-block wolai-text"><div><span class="inline-wrap">4.实例化前</span></div></div><div id="afQJedNBmS3n98SUbneH9T" class="wolai-block wolai-text"><div><span class="inline-wrap">5.实例化</span></div></div><div id="29XxzQtdrMB5m5Q7xQxW17" class="wolai-block wolai-text"><div><span class="inline-wrap">6.实例化后</span></div></div><div id="ffpRcAg6KQFuxUuVjXp1m2" class="wolai-block wolai-text"><div><span class="inline-wrap">7.属性填充</span></div></div><div id="tLJeqLkDfTqmiCGgEXXY2V" class="wolai-block wolai-text"><div><span class="inline-wrap">8.执行各种<span class="jill"></span>Aware</span></div></div><div id="qCg79Hkoyurqd53pAjNY1v" class="wolai-block wolai-text"><div><span class="inline-wrap">9.初始化前</span></div></div><div id="2TzzbRKyxmEdUXKEEvMUsp" class="wolai-block wolai-text"><div><span class="inline-wrap">10.初始化</span></div></div><div id="k5tXyzgSD4e9sUjejsLgYd" class="wolai-block wolai-text"><div><span class="inline-wrap">11.初始化后</span></div></div><div id="pMpRHE2qmR7n9mwreHYULF" class="wolai-block wolai-text"><div><span class="inline-wrap">12.放入单例池</span></div></div><div id="vFVNhoQgUk7JAQkJdmNCdE" class="wolai-block wolai-text"><div><span class="inline-wrap">13.使用<span class="jill"></span>Bean<span class="jill"></span>对象</span></div></div><div id="fHkKbKPiAqqYfhYWL7n5qS" class="wolai-block wolai-text"><div><span class="inline-wrap">14.销毁<span class="jill"></span>Spring<span class="jill"></span>容器关闭时调用<span class="jill"></span>DisposableBean<span class="jill"></span>中<span class="jill"></span>destory()方法。</span></div></div><div id="sHBusgfo8CN26BNDwZXGsw" class="wolai-block wolai-text"><div><span class="inline-wrap">其中在实例化前后以及初始化前后程序员都可以通过<span class="jill"></span>BeanPostProcessor<span class="jill"></span>或者<span class="jill"></span>BeanPostProcessor<span class="jill"></span>接口的子接口<span class="jill"></span>InstantiationAwareBeanPostProcessor<span class="jill"></span>进行扩展。</span></div></div><div id="jmXeng8xKF5rYK6EKEmwU6" class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>Bean<span class="jill"></span>的生命周期涉及到的细节太多了...具体源码分析流程，可参考面试题精讲。</span></div></div><div id="rVhLE9UszxwoQqsUdJni5B" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="84nJkai85Ype3dVq7Yr5sV" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">什么是<span class="jill"></span>bean<span class="jill"></span>的自动装配，有哪些方式？</span></h1><div id="uHCPC8guBzb3BFKAPV2wFm" class="wolai-block wolai-text"><div><span class="inline-wrap">开启自动装配，只需要在<span class="jill"></span>XML<span class="jill"></span>配置文件中定义“autowire”属性。</span></div></div><code-block id="9AxsMZDSVXnJQNTxfr3sTH" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Customer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></div></code-block><div id="pf73qMQMPjHg8fnkU63Dv8" class="wolai-block wolai-text"><div><span class="inline-wrap">autowire<span class="jill"></span>属性有六种装配的方式：</span></div></div><h2 id="3Tz8S5snfAR3oA53GtCQai" class="wolai-block"><span class="wolai-serial-number">11.1</span><span class="inline-wrap">no</span></h2><div id="VxSEbdj9xFGyUq5WYije2" class="wolai-block wolai-text"><div><span class="inline-wrap">缺省情况下，自动配置是通过“ref”属性手动设定。手动装配：以<span class="jill"></span>value<span class="jill"></span>或<span class="jill"></span>ref<span class="jill"></span>的方式明确指定属性值都是手动装配。需要通过‘ref’属性来连接<span class="jill"></span>bean。</span></div></div><div id="xjbuJa2nfnJ5mdtH6nsHEM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="g43F3ieBDQHmKog1RfVLTk" class="wolai-block"><span class="wolai-serial-number">11.2</span><span class="inline-wrap">byName</span></h2><div id="iuFZiywd2p32rs6yVMBK9d" class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>bean<span class="jill"></span>的属性名称进行自动装配。</span></div></div><code-block id="rppNRVKNmQKdxf43LTGu4A" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装
配。</pre></div></code-block><div id="cSnSjbgGnFWaaYBXfxDhgm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="otAfW9grbDW6aFQTGE4BtG" class="wolai-block"><span class="wolai-serial-number">11.3</span><span class="inline-wrap">byType</span></h2><div id="ktS2nEojRs2bJDK5uLf3hi" class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>bean<span class="jill"></span>的类型进行自动装配</span></div></div><code-block id="ec9ziyZku9MTJEXWrxoAdr" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>byType<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</pre></div></code-block><div id="S425QhYapw4szSap5sc61" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cKpFJrQbKkFEeWYPurBHAh" class="wolai-block"><span class="wolai-serial-number">11.4</span><span class="inline-wrap">constructor</span></h2><div id="5EGexC9XQy8Fxp57VQhnkR" class="wolai-block wolai-text"><div><span class="inline-wrap">类似<span class="jill"></span>byType，不过是应用于构造器的参数。如果一个<span class="jill"></span>bean<span class="jill"></span>与构造器参数的类型形相同，则进行自动装配，否则导致失效。</span></div></div><code-block id="fgYd5u3ravaXTVpHkSfkiG" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Cutomer<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>construtor<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.xxx.Person<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装
配。</pre></div></code-block><div id="seN1VmzVBqmxRNUfBuXrYn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3KghoZL82owiTKgPYg4SpP" class="wolai-block"><span class="wolai-serial-number">11.5</span><span class="inline-wrap">autodetect</span></h2><div id="hYCiELS6aCDirt9HQgrMPK" class="wolai-block wolai-text"><div><span class="inline-wrap">如果有默认的构造器，则通过<span class="jill"></span>constructor<span class="jill"></span>方式进行自动装配，否则使用<span class="jill"></span>byType<span class="jill"></span>方式进行自动装配。但是<span class="jill"></span>spring3.0+<span class="jill"></span>已将该值废弃。</span></div></div><div id="ex5S6BVdNRUDN5Jv3pyKuN" class="wolai-block wolai-text"><div><span class="inline-wrap">如果有默认的构造器，则通过<span class="jill"></span>constructor<span class="jill"></span>方式进行自动装配，否则使用<span class="jill"></span>byType<span class="jill"></span>方式进行自动装配</span></div></div><div id="wPKtgR1oyupNd3fNakrHE1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="29rCdqx7pGMuAMM5C8UhQX" class="wolai-block"><span class="wolai-serial-number">11.6</span><span class="inline-wrap">default</span></h2><div id="8vjbacFHQcDaFMpvKDTt9U" class="wolai-block wolai-text"><div><span class="inline-wrap">由上级标签&lt;beans&gt;的<span class="jill"></span>default-autowire<span class="jill"></span>属性确定。</span></div></div><div id="sLKQrNUK5BetPJ2jziCv6P" class="wolai-block wolai-text"><div><span class="inline-wrap">@Autowired<span class="jill"></span>自动装配<span class="jill"></span>bean，可以在字段、setter<span class="jill"></span>方法、构造函数上使用。相比<span class="jill"></span>Spring<span class="jill"></span>自带的自动注入方式，更加灵活。</span></div></div><div id="mupX9VBGHwGfcP6yb6KMF6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="qmX3FDGJh6qKMWYEyenzbj" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cDgTKCZYYUiVy5j78WeEqV" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">Spring<span class="jill"></span>中出现同名<span class="jill"></span>bean<span class="jill"></span>怎么办？</span></h1><h2 id="fDrAxVgeeSuw8262ztuF1t" class="wolai-block"><span class="wolai-serial-number">12.1</span><span class="inline-wrap">情况一</span></h2><div id="fBjcNRVeYfMsNUdpFpynkp" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是在不同的<span class="jill"></span>@Component<span class="jill"></span>注解中定义的同一个<span class="jill"></span>BeanName，那么<span class="jill"></span>Spring<span class="jill"></span>会直接报错。</span></div></div><div id="mHaaKDdk5AxVUSxZYwhtBD" class="wolai-block"><figure class="wolai-center" style="width: 582px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="kCrKxJnFsvRdoJEDPYP1F1" class="wolai-block"><figure class="wolai-center" style="width: 606.6666666666666px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><blockquote id="mkWLpdCdJbXW7ou58hR973" class="wolai-block"><span class="inline-wrap">报错信息节录如下：
org.springframework.context.annotation.</span><span class="inline-wrap"><b>Conflicting</b></span><span class="inline-wrap">BeanDefinitionException: Annotation-specified bean name &#39;userService&#39; for bean class [com.atguigu.demo.service.impl.UserServiceImpl] </span><span class="inline-wrap"><b>conflicts </b></span><span class="inline-wrap">with existing, non-compatible bean definition of same name and class [com.atguigu.demo.service.impl.OrderServiceImpl]</span></blockquote><div id="myESXESxPUHHuQVbYTqK5f" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pBkai6yUkd1wqq5gN4PCHj" class="wolai-block"><span class="wolai-serial-number">12.2</span><span class="inline-wrap">情况二</span></h2><div id="4U9bHpzzRnHvdquRQ1T3D7" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是<span class="jill"></span>ComponentScan<span class="jill"></span>和<span class="jill"></span>@Bean<span class="jill"></span>出现同名<span class="jill"></span>Bean。那么<span class="jill"></span>@Bean<span class="jill"></span>的会生效，@ComponentScan<span class="jill"></span>扫描进来不会生效。原因就是扫描进来的<span class="jill"></span>Bean<span class="jill"></span>定义是最先被注册的,而<span class="jill"></span>Spring<span class="jill"></span>默认又是支持<span class="jill"></span>BeanDefinition<span class="jill"></span>重写。也即<span class="jill"></span>allowBeanDefinitionOverriding<span class="jill"></span>为<span class="jill"></span>true,因此<span class="jill"></span>Spring<span class="jill"></span>底层就会以后解析的<span class="jill"></span>@Bean<span class="jill"></span>生成一个新<span class="jill"></span>BeanDefinition,且名字仍然是<span class="jill"></span>BeanName.然后注册到<span class="jill"></span>BeanDefinitonMap<span class="jill"></span>中，因此对于<span class="jill"></span>Map<span class="jill"></span>来说，同一个<span class="jill"></span>key<span class="jill"></span>的<span class="jill"></span>value<span class="jill"></span>值以最后一次为准。</span></div></div><div id="oKXJXvY3QPZTuDLVJUB6nj" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="3MQ24xuk3PpyJFrJkLjZkk" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">Spring 怎么解决循环依赖问题？</span></h1><h2 id="qXDHQQcs9yqavgmw5pAj4E" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">什么是循环依赖？</span></h2><h3 id="5nWymBsayz8ns8Y6cP9jBZ" class="wolai-block"><span class="wolai-serial-number">13.1.1</span><span class="inline-wrap">简单概括</span></h3><ul class="wolai-block"><li id="xv7ZawSvA5GHAVEBS2cxHD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>对象创建时需要注入<span class="jill"></span>B<span class="jill"></span>对象；</span></li><li id="vcBiA9VVKiE4Xu54uV62iy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B<span class="jill"></span>对象创建时需要注入<span class="jill"></span>A<span class="jill"></span>对象；</span></li></ul><div id="4VJ8vek5gVhYjNEEKm9M4D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3XrpdWP7fhvzRiRVu3YBQQ" class="wolai-block"><span class="wolai-serial-number">13.1.2</span><span class="inline-wrap">详细分析</span></h3><div id="thrEQdCsqiLFwVR1Yn2DdL" class="wolai-block wolai-text"><div><span class="inline-wrap">这里不会对<span class="jill"></span>Bean<span class="jill"></span>的生命周期进行详细的描述，只描述一下大概的过程。</span></div></div><div id="5aoYTdCrxVdUr27EAUckYm" class="wolai-block wolai-text"><div><span class="inline-wrap">Bean<span class="jill"></span>的生命周期指的就是：在<span class="jill"></span>Spring<span class="jill"></span>中，Bean<span class="jill"></span>是如何生成的？</span></div></div><div id="jEMXaaGsidMq9RHXR8DfiT" class="wolai-block wolai-text"><div><span class="inline-wrap">被<span class="jill"></span>Spring<span class="jill"></span>管理的对象叫做<span class="jill"></span>Bean。Bean<span class="jill"></span>的生成步骤如下：</span></div></div><ol class="wolai-block"><li id="n4bbAEFrXatSUow6nEkQ3o"><div class="marker"></div><span class="inline-wrap">Spring<span class="jill"></span>扫描<span class="jill"></span>class<span class="jill"></span>得到<span class="jill"></span>BeanDefinition</span></li><li id="q6UikFFeqbGbzaK6F81Jp8"><div class="marker"></div><span class="inline-wrap">根据得到的<span class="jill"></span>BeanDefinition<span class="jill"></span>去生成<span class="jill"></span>bean</span></li><li id="cPiR2kV6fqh6CXYd92fwN3"><div class="marker"></div><span class="inline-wrap">首先根据<span class="jill"></span>class<span class="jill"></span>推断构造方法</span></li><li id="3LevmPyRHEeo3EHdUMn2u6"><div class="marker"></div><span class="inline-wrap">根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</span></li><li id="9LPKA1AMJHbcrCsf4AXt6p"><div class="marker"></div><span class="inline-wrap">填充原始对象中的属性（依赖注入）</span></li><li id="6RbL7ibv69wonQcQnfZSQ3"><div class="marker"></div><span class="inline-wrap">如果原始对象中的某个方法被<span class="jill"></span>AOP<span class="jill"></span>了，那么则需要根据原始对象生成一个代理对象</span></li><li id="865DajkS8yfR5BWNfRHC5k"><div class="marker"></div><span class="inline-wrap">把最终生成的代理对象放入单例池（源码中叫做<span class="jill"></span>singletonObjects）中，下次<span class="jill"></span>getBean<span class="jill"></span>时就直接从单例池拿即可</span></li></ol><div id="aQy9p2ZfJgWzcXjUniH2UQ" class="wolai-block wolai-text"><div><span class="inline-wrap">可以看到，对于<span class="jill"></span>Spring<span class="jill"></span>中的<span class="jill"></span>Bean<span class="jill"></span>的生成过程，步骤还是很多的，并且不仅仅只有上面的<span class="jill"></span>7<span class="jill"></span>步，还有很多很多，比如<span class="jill"></span>Aware<span class="jill"></span>回调、初始化等等，不详细讨论。</span></div></div><div id="m5KDLzjgBKFEHA7QxFeEEg" class="wolai-block wolai-text"><div><span class="inline-wrap">可以发现，在<span class="jill"></span>Spring<span class="jill"></span>中，构造一个<span class="jill"></span>Bean，包括了<span class="jill"></span>new<span class="jill"></span>这个步骤（第<span class="jill"></span>4<span class="jill"></span>步构造方法反射）。</span></div></div><div id="phhrjVeKZWN1gDu3Fr4g4E" class="wolai-block wolai-text"><div><span class="inline-wrap">得到一个原始对象后，Spring<span class="jill"></span>需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</span></div></div><div id="314ZLuWZ5NHG4UyzGUdv7t" class="wolai-block wolai-text"><div><span class="inline-wrap">比如上文说的<span class="jill"></span>A<span class="jill"></span>类，A<span class="jill"></span>类中存在一个<span class="jill"></span>B<span class="jill"></span>类的<span class="jill"></span>b<span class="jill"></span>属性，所以，当<span class="jill"></span>A<span class="jill"></span>类生成了一个原始对象之后，就会去给<span class="jill"></span>b<span class="jill"></span>属性去赋值，此时就会根据<span class="jill"></span>b<span class="jill"></span>属性的类型和属性名去<span class="jill"></span>BeanFactory<span class="jill"></span>中去获取<span class="jill"></span>B<span class="jill"></span>类所对应的单例<span class="jill"></span>bean。</span></div></div><ul class="wolai-block"><li id="uGbb3a42ZgV75KtM1QrTUK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果此时<span class="jill"></span>BeanFactory<span class="jill"></span>中存在<span class="jill"></span>B<span class="jill"></span>对应的<span class="jill"></span>Bean，那么直接拿来赋值给<span class="jill"></span>b<span class="jill"></span>属性；</span></li><li id="hn2mGTTDdnEybFAsXB8yLU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果此时<span class="jill"></span>BeanFactory<span class="jill"></span>中不存在<span class="jill"></span>B<span class="jill"></span>对应的<span class="jill"></span>Bean，则需要生成一个<span class="jill"></span>B<span class="jill"></span>对应的<span class="jill"></span>Bean，然后赋值给<span class="jill"></span>b<span class="jill"></span>属性。</span></li></ul><div id="28qH6yyYt2QRy3XXqcFFaG" class="wolai-block wolai-text"><div><span class="inline-wrap">问题就出现在第二种情况，如果此时<span class="jill"></span>B<span class="jill"></span>类在<span class="jill"></span>BeanFactory<span class="jill"></span>中还没有生成对应的<span class="jill"></span>Bean，那么就需要去生成，就会经过<span class="jill"></span>B<span class="jill"></span>的<span class="jill"></span>Bean<span class="jill"></span>的生命周期。</span></div></div><div id="paSc3kJg2xypteiC9fsBph" class="wolai-block wolai-text"><div><span class="inline-wrap">那么在创建<span class="jill"></span>B<span class="jill"></span>类的<span class="jill"></span>Bean<span class="jill"></span>的过程中，如果<span class="jill"></span>B<span class="jill"></span>类中存在一个<span class="jill"></span>A<span class="jill"></span>类的<span class="jill"></span>a<span class="jill"></span>属性，那么在创建<span class="jill"></span>B<span class="jill"></span>的<span class="jill"></span>Bean<span class="jill"></span>的过程中就需要<span class="jill"></span>A<span class="jill"></span>类对应的<span class="jill"></span>Bean，但是，触发<span class="jill"></span>B<span class="jill"></span>类<span class="jill"></span>Bean<span class="jill"></span>的创建的条件是<span class="jill"></span>A<span class="jill"></span>类<span class="jill"></span>Bean<span class="jill"></span>在创建过程中的依赖注入，所以这里就出现了循环依赖：</span></div></div><div id="skSaneMi3GMUijidyur1tq" class="wolai-block wolai-text"><div><span class="inline-wrap">ABean<span class="jill"></span>创建--&gt;依赖了<span class="jill"></span>B<span class="jill"></span>属性--&gt;触发<span class="jill"></span>BBean<span class="jill"></span>创建---&gt;B<span class="jill"></span>依赖了<span class="jill"></span>A<span class="jill"></span>属性---&gt;需要<span class="jill"></span>ABean（但<span class="jill"></span>ABean<span class="jill"></span>还在创建过程中）从而导致<span class="jill"></span>ABean<span class="jill"></span>创建不出来，BBean<span class="jill"></span>也创建不出来。</span></div></div><div id="qt6c7xARbjmXjxiUgarBEx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="o8dyt9HpdpjKfiwHHqYupC" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">如何解决循环依赖？</span></h2><h3 id="kg68W3jb7NviASEpQLeNro" class="wolai-block"><span class="wolai-serial-number">13.2.1</span><span class="inline-wrap">关键核心思想</span></h3><div id="aNMyHSpVU2enAEGYWXUA7M" class="wolai-block wolai-text"><div><span class="inline-wrap">设置一个缓存区域，把正在创建过程中的对象临时性的暂时保存起来，如此一来<span class="jill"></span>A<span class="jill"></span>需要<span class="jill"></span>B<span class="jill"></span>同时<span class="jill"></span>B<span class="jill"></span>需要<span class="jill"></span>A<span class="jill"></span>的时候，就可以把创建了一半的<span class="jill"></span>A<span class="jill"></span>放入缓存，B<span class="jill"></span>把缓存里的<span class="jill"></span>A<span class="jill"></span>注入进来就能创建完成，然后再给<span class="jill"></span>A<span class="jill"></span>注入<span class="jill"></span>B，整个过程就完成了</span></div></div><div id="jgMHqx9ZWU32XUW731WLFV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wbfN54qh9ukvnF6Govnwgy" class="wolai-block"><span class="wolai-serial-number">13.2.2</span><span class="inline-wrap">详细说明</span></h3><div id="oULTCTn25dnJgVxdSici6G" class="wolai-block"><figure class="wolai-center" style="width: 304px; flex-direction: column"><img src="media/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6(6).jpg" style="width: 100%"/></figure></div><div id="kMuxBxgTAyXeQqJYqfkHFm" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>底层最终解决靠的是四个<span class="jill"></span>Map（其中三个缓存<span class="jill"></span>Map,还有一个是判断有没有提前进行过<span class="jill"></span>Aop<span class="jill"></span>的<span class="jill"></span>Map<span class="jill"></span>以及一个<span class="jill"></span>Set（判断当前对象是否处于正在创建中）</span></div></div><ol class="wolai-block"><li id="dwFsoYHc9THadhg6NU45s7"><div class="marker"></div><span class="inline-wrap">singletonObjects：缓存某个<span class="jill"></span>beanName<span class="jill"></span>对应的经过了完整生命周期的<span class="jill"></span>bean<span class="jill"></span>也即我们平时说的单例池。</span></li><li id="a6oAfquea7PvK2NYpLYvNy"><div class="marker"></div><span class="inline-wrap">earlySingletonObjects：缓存提前通过原始对象进行了<span class="jill"></span>AOP<span class="jill"></span>之后得到的代理对象，原始对象还没有进行属性注入和后续的<span class="jill"></span>BeanPostProcessor<span class="jill"></span>等生命周期</span></li><li id="kDrJgayGXCBYyTcY5Y8wv4"><div class="marker"></div><span class="inline-wrap">singletonFactories：缓存的是一个<span class="jill"></span>ObjectFactory，也就是一个<span class="jill"></span>Lambda<span class="jill"></span>表达式。在创建一个<span class="jill"></span>Bean<span class="jill"></span>时，在每个<span class="jill"></span>Bean<span class="jill"></span>的生成过程中，都会提前暴露一个<span class="jill"></span>Lambda<span class="jill"></span>表达式，并保存到三级缓存中，这个<span class="jill"></span>Lambda<span class="jill"></span>表达式可能用到，也可能用不到，如果没有出现循环依赖依赖本<span class="jill"></span>bean，那么这个<span class="jill"></span>Lambda<span class="jill"></span>表达式无用，本<span class="jill"></span>bean<span class="jill"></span>按照自己的生命周期执行，执行完后直接把本<span class="jill"></span>bean<span class="jill"></span>放入<span class="jill"></span>singletonObjects<span class="jill"></span>中即可，如果出现了循环依赖依赖了本<span class="jill"></span>bean，则从三级缓存中获取<span class="jill"></span>Lambda<span class="jill"></span>表达式，并执行<span class="jill"></span>Lambda<span class="jill"></span>表达式得到一个<span class="jill"></span>AOP<span class="jill"></span>之后的代理对象(如果有<span class="jill"></span>AOP<span class="jill"></span>的话，如果无需<span class="jill"></span>AOP，则直接得到一个原始对象)，并把得到的对象放入二级缓存</span></li><li id="v96w727XcB63cGr9TUPAmZ"><div class="marker"></div><span class="inline-wrap">其实还要一个缓存，就是<span class="jill"></span>earlyProxyReferences，它用来记录某个原始对象是否进行过<span class="jill"></span>AOP<span class="jill"></span>了。</span></li><li id="pYxAvNRwveCtWrLczGgvjB"><div class="marker"></div><span class="inline-wrap"><b>creatingMap </b></span><span class="inline-wrap">这个作用是去判断是不是出现了循环依赖 也即是不是某个类是不是在创建中。</span></li></ol><div id="szYJnjixszRrxUBZcNnRqf" class="wolai-block wolai-text"><div><span class="inline-wrap">详情流程分析很多...笔者也不能一下子展开，请结合面试精讲课上的源码分析。</span></div></div><div id="aX1jmAjRzCwS2R4uxKz369" class="wolai-block wolai-text"><div></div></div><div id="jrwY6nCjaEB31dRhM2HkJL" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="chmUyL6pDWw5nhsQ2dGsFs" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">Spring 中的单例 bean 的线程安全问题？</span></h1><div id="u7hUSeBRbGwMcJc2mY6MyE" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>中的<span class="jill"></span>Bean<span class="jill"></span>默认是单例模式的，框架并没有对<span class="jill"></span>bean<span class="jill"></span>进行多线程的封装处理。</span></div></div><div id="orwCQgFGShL7Mgb3T5Mkpb" class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>Bean<span class="jill"></span>是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变<span class="jill"></span>bean<span class="jill"></span>的作用域把 &quot;singleton&quot;改为&quot;protopyte&quot; 这样每次请求<span class="jill"></span>Bean<span class="jill"></span>就相当于是 new Bean() 这样就可以保证线程的安全了。</span></div></div><div id="hL1q96gghKeVZBatgmWXpt" class="wolai-block wolai-text"><div><span class="inline-wrap">有状态就是有数据存储功能。无状态就是不会保存数据 controller、service<span class="jill"></span>和<span class="jill"></span>dao<span class="jill"></span>层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</span></div></div><div id="s61sV15hGFnd7ithBbEKNo" class="wolai-block wolai-text"><div><span class="inline-wrap">Dao<span class="jill"></span>会操作数据库<span class="jill"></span>Connection，Connection<span class="jill"></span>是带有状态的，比如说数据库事务，Spring<span class="jill"></span>的事务管理器使用<span class="jill"></span>Threadlocal<span class="jill"></span>为不同线程维护了一套独立的<span class="jill"></span>connection<span class="jill"></span>副本，保证线程之间不会互相影响（Spring<span class="jill"></span>是如何保证事务获取同一个<span class="jill"></span>Connection<span class="jill"></span>的）不要在<span class="jill"></span>bean<span class="jill"></span>中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用<span class="jill"></span>ThreadLocal<span class="jill"></span>把变量变为线程私有的，如果<span class="jill"></span>bean<span class="jill"></span>的实例变量或类变量需要在多个线程之间共享，那么就只能使用<span class="jill"></span>synchronized、lock、CAS<span class="jill"></span>等这些实现线程同步的方法了。</span></div></div><div id="6TjwjQ35kxkL6ytxJP3e9E" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="7chunGZtZSURCGGRKm2o98" class="wolai-block wolai-text"><div></div></div><div id="sk3G3mVm21MLox3HdgY5wD" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="q3ZS48CsacDFgPhu9te4uX" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">什么是<span class="jill"></span>AOP？</span></h1><div id="dXaC6QMpu5TX7iBYdZq89g" class="wolai-block wolai-text"><div><span class="inline-wrap">AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</span></div></div><div id="co97DB4A8fK2yLuiQgW87v" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="gN88uonefFmdehHqjcYNJ4" class="wolai-block wolai-text"><div></div></div><div id="mi489LXLYwBtt3inTiSYtC" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="24jo8KiiJThGhjhp7oxP3Y" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">谈谈你对<span class="jill"></span>AOP<span class="jill"></span>的理解</span></h1><div id="eM3VGRdq7gCDEMNLtSiaWQ" class="wolai-block wolai-text"><div><span class="inline-wrap">系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。</span></div></div><div id="aR6r5asFmBMsztZE3UcbTx" class="wolai-block wolai-text"><div><span class="inline-wrap">例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</span></div></div><div id="3TFKUzjGSKqS8HMM3Ldprt" class="wolai-block wolai-text"><div><span class="inline-wrap">当我们需要为分散的对象引入公共行为的时候，OOP<span class="jill"></span>则显得无能为力。也就是说，OOP<span class="jill"></span>允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</span></div></div><div id="ktN3E9coiMW6E85jY355yd" class="wolai-block wolai-text"><div><span class="inline-wrap">日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在<span class="jill"></span>OOP<span class="jill"></span>设计中，它导致了大量代码的重复，而不利于各个模块的重用。</span></div></div><div id="kYyu7j5foibhyQT3FmdkDi" class="wolai-block wolai-text"><div><span class="inline-wrap">AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP<span class="jill"></span>可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情。</span></div></div><div id="5FjMCEV3TgfZM1hqxa1v1r" class="wolai-block wolai-text"><div></div></div><div id="5CDGByyZYdCgWDWqLNCY9t" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="eiw8WX74xbjztSXPRC7FUu" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">AOP 有哪些实现方式？</span></h1><div id="vrdJ6zUShBgDwhCQ4qspWK" class="wolai-block wolai-text"><div><span class="inline-wrap">实现 AOP 的技术，主要分为两大类：  </span></div></div><div id="pE5q2gCSpNreZTaECYiHKQ" class="wolai-block wolai-text"><div><span class="inline-wrap">静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也  </span></div></div><div id="t94nT6oCByq2G4f4rjzFTf" class="wolai-block wolai-text"><div><span class="inline-wrap">称为编译时增强；  </span></div></div><div id="rXM2YdsMFmekM4Myj4Jy6Y" class="wolai-block wolai-text"><div><span class="inline-wrap">编译时编织（特殊编译器实现）  </span></div></div><div id="tvKLhVBtd31ieUxLVjC4BS" class="wolai-block wolai-text"><div><span class="inline-wrap">类加载时编织（特殊的类加载器实现）。  </span></div></div><div id="bjGhbKeSkTVJn88FkR3a4P" class="wolai-block wolai-text"><div><span class="inline-wrap">动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。  </span></div></div><div id="k71WNyF1nDeD2rD3tJtCGs" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动  </span></div></div><div id="eYpGqMxDZJ4HheUELq4D2Q" class="wolai-block wolai-text"><div><span class="inline-wrap">态代理的核心是 InvocationHandler 接口和 Proxy 类。</span></div></div><div id="7ZYc3bLKPZ46atvMWxJnN1" class="wolai-block wolai-text"><div><span class="inline-wrap">CGLIB<span class="jill"></span>动态代理： 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。</span></div></div><div id="5QnWSQBXXhnK91ZqkZ215Y" class="wolai-block wolai-text"><div><span class="inline-wrap">CGLIB ，是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意：CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用<span class="jill"></span>CGLIB 做动态代理的。</span></div></div><div id="nux4WoU5LK1S1aA5SxvCRX" class="wolai-block wolai-text"><div></div></div><div id="pTd8S3KEDR8tp2Cec5ACR3" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="pvAGzJDffsqp8xfWecQPdY" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">Spring 框架中用到了哪些设计模式？</span></h1><h2 id="sZaxnBSY396ink4VWQDtcd" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">工厂设计模式</span></h2><h3 id="ncSfRraUfsvDM63oQDh1vW" class="wolai-block"><span class="wolai-serial-number">18.1.1</span><span class="inline-wrap">简单工厂</span></h3><div id="kQM8NSGZdjEDtZFXW3zxt8" class="wolai-block wolai-text"><div><span class="inline-wrap">由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类<span class="jill"></span>Spring<span class="jill"></span>中的<span class="jill"></span>BeanFactory<span class="jill"></span>就是简单工厂模式的体现，根据传入一个唯一的标识来获得<span class="jill"></span>Bean<span class="jill"></span>对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</span></div></div><div id="bTVpAgbZMWVBp1tTKA9z3L" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="sFPAeJBoNntCGqmgxMWvUy" class="wolai-block"><span class="wolai-serial-number">18.1.2</span><span class="inline-wrap">工厂方法</span></h3><div id="u5tJth4njWtxRissQ7NyYx" class="wolai-block wolai-text"><div><span class="inline-wrap">实现了<span class="jill"></span>FactoryBean<span class="jill"></span>接口的<span class="jill"></span>bean<span class="jill"></span>是一类叫做<span class="jill"></span>factory<span class="jill"></span>的<span class="jill"></span>bean。其特点是，Spring<span class="jill"></span>会在使用<span class="jill"></span>getBean()调用获得该<span class="jill"></span>bean<span class="jill"></span>时，会自动调用该<span class="jill"></span>bean<span class="jill"></span>的<span class="jill"></span>getObject()方法，所以返回的不是<span class="jill"></span>factory<span class="jill"></span>这个<span class="jill"></span>bean，而是这个<span class="jill"></span>bean.getOjbect()方法的返回值。</span></div></div><div id="pnGHxGH4nj5MQXZy9YBG6t" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eBR4vPxBsADGzr9naYHMQN" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">单例模式</span></h2><div id="uB4bCzrYD9vGTqAJbHU3UG" class="wolai-block wolai-text"><div><span class="inline-wrap">保证一个类仅有一个实例，并提供一个访问它的全局访问点。Spring<span class="jill"></span>对单例的实现： Spring<span class="jill"></span>中的单例模式完成了后半句话，即提供了全局的访问点<span class="jill"></span>BeanFactory。</span></div></div><div id="vkeHrDbBC1esZDTe3dMWp1" class="wolai-block wolai-text"><div><span class="inline-wrap">但没有从构造器级别去控制单例，这是因为<span class="jill"></span>Spring<span class="jill"></span>管理的是任意的<span class="jill"></span>java<span class="jill"></span>对象。</span></div></div><div id="joxbZhkSns7xYqg2fiWS3t" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mRL8wKekyiT9YFP5yGsy9Y" class="wolai-block"><span class="wolai-serial-number">18.3</span><span class="inline-wrap">适配器模式</span></h2><div id="nH9eS2i8bgBsPsUHu71U7q" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>定义了一个适配接口，使得每一种<span class="jill"></span>Controller<span class="jill"></span>有一种对应的适配器实现类，让适配器代替<span class="jill"></span>Controller<span class="jill"></span>执行相应的方法。</span></div></div><div id="vGS3wVuApzZk3SGfhRLSnY" class="wolai-block wolai-text"><div><span class="inline-wrap">这样在扩展<span class="jill"></span>Controller<span class="jill"></span>时，只需要增加一个适配器类就完成了<span class="jill"></span>SpringMVC<span class="jill"></span>的扩展了。</span></div></div><div id="6Gjp1U1BSA9inXxsehvBzk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qiKfk8xUaKFYY9zXJBRC3r" class="wolai-block"><span class="wolai-serial-number">18.4</span><span class="inline-wrap">装饰器模式</span></h2><div id="i6XGy6NtsxUuZLGfsXQByL" class="wolai-block wolai-text"><div><span class="inline-wrap">动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator<span class="jill"></span>模式相比生成子类更为灵活。</span></div></div><div id="d4WDVh3iPk94qYJBvYhgXs" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>中用到的装饰器模式在类名上有两种表现：一种是类名中含有<span class="jill"></span>Wrapper，另一种是类名中含有<span class="jill"></span>Decorator。</span></div></div><div id="iu3sVxhH52jKnhQT4579jX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cgZgh6xRqtPFavcQm8kSWv" class="wolai-block"><span class="wolai-serial-number">18.5</span><span class="inline-wrap">代理模式</span></h2><div id="eMbcJbv9FhtmxPAtfffkZ7" class="wolai-block wolai-text"><div><span class="inline-wrap">切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP<span class="jill"></span>容器会为目标对象创建动态的创建一个代理对象。SpringAOP<span class="jill"></span>就是以这种方式织入切面的。</span></div></div><blockquote id="x9HvVYfoCmAtHkGCpsGzvn" class="wolai-block"><span class="inline-wrap">织入：把切面应用到目标对象并创建新的代理对象的过程。</span></blockquote><div id="vsp1dVuM5FfMRkVw9GN2YA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aNGyhwhmqjioL6MmbHhHmJ" class="wolai-block"><span class="wolai-serial-number">18.6</span><span class="inline-wrap">观察者模式</span></h2><div id="e3m3yoFw3iMpN3yNmkJ2rg" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>的事件驱动模型使用的是观察者模式 ，Spring<span class="jill"></span>中<span class="jill"></span>Observer<span class="jill"></span>模式常用的地方是<span class="jill"></span>listener<span class="jill"></span>的实现。</span></div></div><div id="s8aUg7tTCebZb8yahaJU1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="drw8AF3bGbS6yrzztSCKuf" class="wolai-block"><span class="wolai-serial-number">18.7</span><span class="inline-wrap">策略模式</span></h2><div id="GZndHp7iXiGW3WJvQce42" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>框架的资源访问<span class="jill"></span>Resource<span class="jill"></span>接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了<span class="jill"></span>Resource 接口来访问底层资源。</span></div></div><div id="m3yubhUfRkSNQPTp5iVi8Y" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bGmzdMAGH6VGy166uqSu33" class="wolai-block"><span class="wolai-serial-number">18.8</span><span class="inline-wrap">模板方法模式</span></h2><div id="ifzwFRiSieMLrRm18ZvkL3" class="wolai-block wolai-text"><div><span class="inline-wrap">父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现<span class="jill"></span>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模  </span></div></div><div id="8PktTeAJaAnQHGQPUVdnwN" class="wolai-block wolai-text"><div><span class="inline-wrap">板模式。</span></div></div><div id="eZYECcuLzE6hjbvy3fxQ13" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hZoMqTuaEJQhdxaswJpQoi" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">Spring 事务实现方式有哪些以及原理</span></h1><h2 id="8CZP31unTGWvWZFv3PKVGv" class="wolai-block"><span class="wolai-serial-number">19.1</span><span class="inline-wrap">编程式事务管理</span></h2><div id="w5ZGCyKk1D95LHZg3NjEHR" class="wolai-block wolai-text"><div><span class="inline-wrap">这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</span></div></div><div id="qGFBSN33vkzfgtp7LKi6QL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pTRCZ2TUZdi3hA3jYYyMa" class="wolai-block"><span class="wolai-serial-number">19.2</span><span class="inline-wrap">声明式事务管理</span></h2><div id="jrE4jzcY6WDer5oa6dHRiP" class="wolai-block wolai-text"><div><span class="inline-wrap">这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者<span class="jill"></span>XML<span class="jill"></span>配置管理事务。@Transactional<span class="jill"></span>注解就是声明式事务。</span></div></div><div id="qw1uXJva9dXLmZbuAjftYq" class="wolai-block wolai-text"><div><span class="inline-wrap">首先，事务这个概念是数据库层面的，Spring<span class="jill"></span>只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</span></div></div><div id="poVxG8ytp5J3Kk69aURNku" class="wolai-block wolai-text"><div><span class="inline-wrap">比如我们可以通过在某个方法上增加<span class="jill"></span>@Transactional<span class="jill"></span>注解，就可以开启事务，这个方法中所有的<span class="jill"></span>SQL<span class="jill"></span>都会在一个事务中执行，统一成功或失败。</span></div></div><div id="9GruFvozdtywKpPPnSmeTy" class="wolai-block wolai-text"><div><span class="inline-wrap">在一个方法上加了<span class="jill"></span>@Transactional<span class="jill"></span>注解后，Spring<span class="jill"></span>会基于这个类生成一个代理对象，会将这个代理对象作为<span class="jill"></span>bean，当在使用这个代理对象的方法时，如果这个方法上存在<span class="jill"></span>@Transactional<span class="jill"></span>注解，那么代理逻辑会先把事务的自动提交设置为<span class="jill"></span>false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。</span></div></div><div id="kuRaVec4hCVi58CAdo8bQW" class="wolai-block wolai-text"><div><span class="inline-wrap">当然，针对哪些异常回滚事务是可以配置的，可以利用<span class="jill"></span>@Transactional<span class="jill"></span>注解中的<span class="jill"></span>rollbackFor<span class="jill"></span>属性进行配置，默认情况下会对<span class="jill"></span>RuntimeException<span class="jill"></span>和<span class="jill"></span>Error<span class="jill"></span>进行回滚。</span></div></div><div id="jeTJmfBYhCToVCU76bM5kU" class="wolai-block wolai-text"><div></div></div><div id="wdWJdUHYBYvZ4obvL64Rsn" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ohud4AuAvYfJMXLejLZrov" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">Spring<span class="jill"></span>事务的隔离级别</span></h1><div id="uRPcKrJfU8nex7XrHv221d" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>事务隔离级别就是数据库的隔离级别：外加一个默认级别</span></div></div><div id="7z89YbePUJLzjJGZxAzJKV" class="wolai-block wolai-text"><div><span class="inline-wrap">read uncommitted（未提交读）</span></div></div><div id="9PAZEn1SQq3dWuYxur7tjc" class="wolai-block wolai-text"><div><span class="inline-wrap">read committed（提交读、不可重复读）</span></div></div><div id="t64GjAPQF5kYB5qjv52Xmu" class="wolai-block wolai-text"><div><span class="inline-wrap">repeatable read（可重复读）</span></div></div><div id="fh9ocsjYzaToD35W15dLEJ" class="wolai-block wolai-text"><div><span class="inline-wrap">serializable（可串行化）</span></div></div><div id="9oJNmCrahXpe6xR4UJA6zR" class="wolai-block wolai-text"><div><span class="inline-wrap">注意：</span></div></div><div id="9pxNKNQiCQRf5mb7Yqs2GB" class="wolai-block wolai-text"><div><span class="inline-wrap">数据库的配置隔离级别是<span class="jill"></span>Read Commited，而<span class="jill"></span>Spring<span class="jill"></span>配置的隔离级别是<span class="jill"></span>Repeatable Read，请问这时隔离级别时以哪一个为准？</span></div></div><div id="6KnBoaGnDohMR61MBc1xNb" class="wolai-block wolai-text"><div><span class="inline-wrap">以<span class="jill"></span>Spring<span class="jill"></span>配置的为准，如果<span class="jill"></span>Spring<span class="jill"></span>设置的隔离级别数据库不支持，效果取决于数据库。</span></div></div><div id="aKXZh8rU75xPDRSi7YPS77" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="n9Sr85LUcpnaqs7bnfh8Bo" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wPPKRsnNVWEhoQhi1ZCDno" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">Spring<span class="jill"></span>事务定义的传播规则</span></h1><div id="jfnEgc9x1wDjE5jAKgfciH" class="wolai-block wolai-text"><div><span class="inline-wrap">多个事务方法相互调用时,事务如何在这些方法间传播。</span></div></div><div id="cQ2weHSakbfaeeQDvRz179" class="wolai-block wolai-text"><div><span class="inline-wrap">方法<span class="jill"></span>A<span class="jill"></span>是一个事务的方法，方法<span class="jill"></span>A<span class="jill"></span>执行过程中调用了方法<span class="jill"></span>B，那么方法<span class="jill"></span>B<span class="jill"></span>有无事务以及方法<span class="jill"></span>B<span class="jill"></span>对事务的要求不同都会对方法<span class="jill"></span>A<span class="jill"></span>的事务具体执行造成影响，同时方法<span class="jill"></span>A<span class="jill"></span>的事务对方法<span class="jill"></span>B<span class="jill"></span>的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</span></div></div><div id="qz2dvUAXAK85LqXQEgARRx" class="wolai-block wolai-text"><div><span class="inline-wrap">REQUIRED( Spring<span class="jill"></span>默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务。</span></div></div><div id="rVnWdH3EFUqTw7buWhSzm5" class="wolai-block wolai-text"><div><span class="inline-wrap">SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行。</span></div></div><div id="8gFtCVU4xxBBvEMox341Hy" class="wolai-block wolai-text"><div><span class="inline-wrap">MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</span></div></div><div id="xz22HJNmRR7TPTys1oiMMV" class="wolai-block wolai-text"><div><span class="inline-wrap">REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</span></div></div><div id="5W7nuFpUfvP7ep1kZYmnpr" class="wolai-block wolai-text"><div><span class="inline-wrap">NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务。</span></div></div><div id="3JAV6WK3wXqWZ4rJdVDsMx" class="wolai-block wolai-text"><div><span class="inline-wrap">NEVER：不使用事务，如果当前事务存在，则抛出异常。</span></div></div><div id="2Jk7Pv9YBNEhXxZopjQhjn" class="wolai-block wolai-text"><div><span class="inline-wrap">NESTED：如果当前事务存在，则在嵌套事务中执行，否则<span class="jill"></span>REQUIRED<span class="jill"></span>的操作一样（开启一个事务）。</span></div></div><div id="rXQoU8gyT3Fq46WUuBNiTN" class="wolai-block wolai-text"><div><span class="inline-wrap">NESTED<span class="jill"></span>和<span class="jill"></span>REQUIRES_NEW<span class="jill"></span>的区别</span></div></div><div id="sqjUgHzrVi2NyWvkTaM92o" class="wolai-block wolai-text"><div><span class="inline-wrap">REQUIRES_NEW<span class="jill"></span>是新建一个事务并且新开启的这个事务与原有事务无关，而<span class="jill"></span>NESTED<span class="jill"></span>则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。</span></div></div><div id="w46DAFyJMbkJ1c6NbLKCLK" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>NESTED<span class="jill"></span>情况下父事务回滚时，子事务也会回滚，而在<span class="jill"></span>REQUIRES_NEW<span class="jill"></span>情况下，原有事务回滚，不会影响新开启的事务。</span></div></div><div id="hw2TQyzrtv75KH878dN8XH" class="wolai-block wolai-text"><div><span class="inline-wrap">NESTED<span class="jill"></span>和<span class="jill"></span>REQUIRED<span class="jill"></span>的区别<span class="jill"></span>REQUIRED<span class="jill"></span>情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否<span class="jill"></span>catch<span class="jill"></span>其异常，事务都会回滚 而在<span class="jill"></span>NESTED<span class="jill"></span>情况下，被调用方发生异常时，调用方可以<span class="jill"></span>catch<span class="jill"></span>其异常，这样只有子事务回滚，父事务不受影响</span></div></div><div id="pc8ZYGrPbtQxzYpRNTvsp2" class="wolai-block wolai-text"><div></div></div><div id="gPZRzKE7Abu9i44kUq6AUe" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9E9qiB3nRsNCn5xnNoVkHC" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">Spring<span class="jill"></span>事务什么时候会失效</span></h1><div id="qSYKr5nnUMSfd8WaxJca7x" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>事务的原理是<span class="jill"></span>AOP，进行了切面增强，那么失效的根本原因是这个<span class="jill"></span>AOP<span class="jill"></span>不起作用了！常见情况有如 下几种</span></div></div><div id="n1ijYfqgyPzMAKgKZtn8vf" class="wolai-block wolai-text"><div><span class="inline-wrap">1、发生自调用，类里面使用<span class="jill"></span>this<span class="jill"></span>调用本类的方法（this<span class="jill"></span>通常省略），此时这个<span class="jill"></span>this<span class="jill"></span>对象不是代理类，而是该类的实例对象本身！解决方法很简单，让那个<span class="jill"></span>this<span class="jill"></span>变成该类的的代理类实例对象即可！</span></div></div><div id="gHNH3safpJ2Upqfmp3PRgV" class="wolai-block wolai-text"><div><span class="inline-wrap">2、方法不是<span class="jill"></span>public<span class="jill"></span>的</span></div></div><div id="3iw2p5BcMrvaHQCsRvE6df" class="wolai-block wolai-text"><div><span class="inline-wrap">3、数据库不支持事务</span></div></div><div id="rhLYgPpJ4BYp55W4AcNfd2" class="wolai-block wolai-text"><div><span class="inline-wrap">4、没有被<span class="jill"></span>Spring<span class="jill"></span>管理</span></div></div><div id="taTAPjsMEx5eQwdEYNW2fx" class="wolai-block wolai-text"><div><span class="inline-wrap">5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为<span class="jill"></span>RuntimeException)</span></div></div><div id="pAvn44brfKk7ajBGzAXg19" class="wolai-block wolai-text"><div></div></div><div id="8CUwJw8MYHEep5ACkpSjg6" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="8EqNX1WnL33XYxwqkDymFk" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">SpringMVC 工作原理了解吗?</span></h1><div id="ptNTTT9iH6SXEbTN3yE9zY" class="wolai-block wolai-text"><div><span class="inline-wrap">流程说明（重要）：</span></div></div><div id="jLvwksuzhsNwGHc9g9K9W8" class="wolai-block wolai-text"><div><span class="inline-wrap">1) 用户发送请求至前端控制器 DispatcherServlet。</span></div></div><div id="98gjU6ujpWEcPUXNcSuS7y" class="wolai-block wolai-text"><div><span class="inline-wrap">2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</span></div></div><div id="aP4Y6WU5mwukNQLCr7KWvX" class="wolai-block wolai-text"><div><span class="inline-wrap">3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</span></div></div><div id="5aXEZD825rd3LLtmuiXGLK" class="wolai-block wolai-text"><div><span class="inline-wrap">4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。</span></div></div><div id="dA1NE8wPBE1ue92TKLxfiv" class="wolai-block wolai-text"><div><span class="inline-wrap">5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)</span></div></div><div id="mzeuQLbD1uWrgu6xcpZdtC" class="wolai-block wolai-text"><div><span class="inline-wrap">6）Controller 执行完成返回 ModelAndView。</span></div></div><div id="dcQeQRZc67CqhR52dE6ZAb" class="wolai-block wolai-text"><div><span class="inline-wrap">7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</span></div></div><div id="pzLC8FEpQ8Zoaakgtsx4jf" class="wolai-block wolai-text"><div><span class="inline-wrap">8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</span></div></div><div id="pPkuyGLEcJ3HUVWkb1uMZh" class="wolai-block wolai-text"><div><span class="inline-wrap">9）ViewReslover 解析后返回具体 View。</span></div></div><div id="9mWh3RRCHpv1dR7WE9S7fv" class="wolai-block wolai-text"><div><span class="inline-wrap">10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</span></div></div><div id="t5gKgSAZZPrPAR2AXTbnE4" class="wolai-block wolai-text"><div><span class="inline-wrap">11）DispatcherServlet 响应用户。</span></div></div><div id="rB544gmxwz9oHaLPHB8seK" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hwHeNadwb6BPtSvKxssi8d" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">简单介绍 Spring MVC 的核心组件</span></h1><h2 id="hWKCZisA6JdXLf472m7qqh" class="wolai-block"><span class="wolai-serial-number">24.1</span><span class="inline-wrap">Handler</span></h2><div id="b58DDL4RT2z8kwvda72J3r" class="wolai-block wolai-text"><div><span class="inline-wrap">Handler</span><span class="inline-wrap">：也就是处理器。它直接应对着<span class="jill"></span>MVC<span class="jill"></span>中的<span class="jill"></span>C<span class="jill"></span>也就是<span class="jill"></span>Controller<span class="jill"></span>层，它的具体表现形式有很多，可以是类，也可以是方法。在<span class="jill"></span>Controller<span class="jill"></span>层中<span class="jill"></span>@RequestMapping<span class="jill"></span>标注的所有方法都可以看成是一个<span class="jill"></span>Handler，只要可以实际处理请求就可以是<span class="jill"></span>Handler。</span></div></div><div id="sNAxsiqHDotiLHFtnBoxN7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cpBzjki8733AyVJLSKfVif" class="wolai-block"><span class="wolai-serial-number">24.2</span><span class="inline-wrap">HandlerMapping</span></h2><div id="gwTc5QgiYwVWFpAKtW1fK6" class="wolai-block wolai-text"><div><span class="inline-wrap">initHandlerMappings(context)，处理器映射器，根据用户请求的资源<span class="jill"></span>uri<span class="jill"></span>来查找<span class="jill"></span>Handler<span class="jill"></span>的。在<span class="jill"></span>SpringMVC<span class="jill"></span>中会有很多请求，每个请求都需要一个<span class="jill"></span>Handler<span class="jill"></span>处理，具体接收到一个请求之后使用哪个<span class="jill"></span>Handler<span class="jill"></span>进行，这就是<span class="jill"></span>HandlerMapping<span class="jill"></span>需要做的事。</span></div></div><div id="tTFFX3vqKs28YUojymHPN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="gd47qgb9vh3MqQSg38Y8vE" class="wolai-block"><span class="wolai-serial-number">24.3</span><span class="inline-wrap">HandlerAdapter</span></h2><div id="qZCR467chH7VSrzSxF24Wk" class="wolai-block wolai-text"><div><span class="inline-wrap">initHandlerAdapters(context)，适配器。因为<span class="jill"></span>SpringMVC<span class="jill"></span>中的<span class="jill"></span>Handler<span class="jill"></span>可以是任意的形式，只要能处理请求就<span class="jill"></span>ok，但是<span class="jill"></span>Servlet<span class="jill"></span>需要的处理方法的结构却是固定的，都是以<span class="jill"></span>request<span class="jill"></span>和<span class="jill"></span>response<span class="jill"></span>为参数的方法。如何让固定的<span class="jill"></span>Servlet<span class="jill"></span>处理方法调用灵活的<span class="jill"></span>Handler<span class="jill"></span>来进行处理呢？这就是<span class="jill"></span>HandlerAdapter<span class="jill"></span>要做的事情。Handler<span class="jill"></span>是用来干活的工具；HandlerMapping<span class="jill"></span>用于根据需要干的活找到相应的工具；HandlerAdapter<span class="jill"></span>是使用工具干活的人。</span></div></div><div id="3nT48omFuhiJB592esYB2J" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4qJiCrA2g489bksekxwr8y" class="wolai-block"><span class="wolai-serial-number">24.4</span><span class="inline-wrap">HandlerExceptionResolver</span></h2><div id="sypLo9cL2cZ9vuNPyVCZXR" class="wolai-block wolai-text"><div><span class="inline-wrap">initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在<span class="jill"></span>SpringMVC<span class="jill"></span>中就是<span class="jill"></span>HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置<span class="jill"></span>ModelAndView，之后再交给<span class="jill"></span>render<span class="jill"></span>方法进行渲染。</span></div></div><div id="wuE7pxBSvEZ2HiMjH6PA75" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4hbX5iv6D9G82bNYjUC7nr" class="wolai-block"><span class="wolai-serial-number">24.5</span><span class="inline-wrap">ViewResolver</span></h2><div id="aPzsh1acVikUbeSioWcE7f" class="wolai-block wolai-text"><div><span class="inline-wrap">initViewResolvers(context)，ViewResolver<span class="jill"></span>用来将<span class="jill"></span>String<span class="jill"></span>类型的视图名和<span class="jill"></span>Locale<span class="jill"></span>解析为<span class="jill"></span>View<span class="jill"></span>类型的视图。View<span class="jill"></span>是用来渲染页面的，也就是将程序返回的参数填入模板里，生成<span class="jill"></span>html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是<span class="jill"></span>ViewResolver<span class="jill"></span>主要要做的工作，ViewResolver<span class="jill"></span>需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。</span></div></div><div id="oEqY18iphYBn2xdpqexTo5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="g87HX2u7G2PykHGnrKhKJJ" class="wolai-block"><span class="wolai-serial-number">24.6</span><span class="inline-wrap">RequestToViewNameTranslator</span></h2><div id="kogTf3sqgTRdBR5HtdXjVv" class="wolai-block wolai-text"><div><span class="inline-wrap">initRequestToViewNameTranslator(context)，ViewResolver<span class="jill"></span>是根据<span class="jill"></span>ViewName<span class="jill"></span>查找<span class="jill"></span>View，但有的<span class="jill"></span>Handler<span class="jill"></span>处理完后并没有设置<span class="jill"></span>View<span class="jill"></span>也没有设置<span class="jill"></span>ViewName，这时就需要从<span class="jill"></span>request<span class="jill"></span>获取<span class="jill"></span>ViewName<span class="jill"></span>了，如何从<span class="jill"></span>request<span class="jill"></span>中获取<span class="jill"></span>ViewName<span class="jill"></span>就是<span class="jill"></span>RequestToViewNameTranslator<span class="jill"></span>要做的事情了。RequestToViewNameTranslator<span class="jill"></span>在<span class="jill"></span>Spring MVC<span class="jill"></span>容器里只可以配置一个，所以所有<span class="jill"></span>request<span class="jill"></span>到<span class="jill"></span>ViewName<span class="jill"></span>的转换规则都要在一个<span class="jill"></span>Translator<span class="jill"></span>里面全部实现。</span></div></div><div id="ba45ZSx73wCyZLSCW5aSwK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cAhV631Z3Jjr3DY3rixyBV" class="wolai-block"><span class="wolai-serial-number">24.7</span><span class="inline-wrap">LocaleResolver</span></h2><div id="9SbhTVnkDKbam52b4Un8yo" class="wolai-block wolai-text"><div><span class="inline-wrap">initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是<span class="jill"></span>Locale。视图名是处理器返回的，Locale<span class="jill"></span>是从哪里来的？这就是<span class="jill"></span>LocaleResolver<span class="jill"></span>要做的事情。LocaleResolver<span class="jill"></span>用于从<span class="jill"></span>request<span class="jill"></span>解析出<span class="jill"></span>Locale，Locale<span class="jill"></span>就是<span class="jill"></span>zh-cn<span class="jill"></span>之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC<span class="jill"></span>主要有两个地方用到了<span class="jill"></span>Locale：一是<span class="jill"></span>ViewResolver<span class="jill"></span>视图解析的时候；二是用到国际化资源或者主题的时候。</span></div></div><div id="hDtww2ZVpKTmAHxB1k4Wxb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cEdWfd1228m2UKmV3qBv7S" class="wolai-block"><span class="wolai-serial-number">24.8</span><span class="inline-wrap">ThemeResolver</span></h2><div id="gCPSwQBFWGoSYWzuYJSe9a" class="wolai-block wolai-text"><div><span class="inline-wrap">initThemeResolver(context)，用于解析主题。SpringMVC<span class="jill"></span>中一个主题对应一个<span class="jill"></span>properties<span class="jill"></span>文件，里面存放着跟当前主题相关的所有资源、如图片、css<span class="jill"></span>样式等。SpringMVC<span class="jill"></span>的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC<span class="jill"></span>中跟主题相关的类有 ThemeResolver、ThemeSource<span class="jill"></span>和<span class="jill"></span>Theme。</span></div></div><div id="oimDpVJ7PPXm4FocbGn2e6" class="wolai-block wolai-text"><div><span class="inline-wrap">主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是<span class="jill"></span>ThemeResolver<span class="jill"></span>的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是<span class="jill"></span>ThemeSource<span class="jill"></span>的工作。最后从主题中获取资源就可以了。</span></div></div><div id="rFqEDepuBHzoTvQhUvAC9n" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="72M33ASHevrYJN5StRetD9" class="wolai-block"><span class="wolai-serial-number">24.9</span><span class="inline-wrap">MultipartResolver</span></h2><div id="uQrCo9smZzLv1JUTNSUPBX" class="wolai-block wolai-text"><div><span class="inline-wrap">initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的<span class="jill"></span>request<span class="jill"></span>包装成<span class="jill"></span>MultipartHttpServletRequest，后者可以直接调用<span class="jill"></span>getFile<span class="jill"></span>方法获取<span class="jill"></span>File，如果上传多个文件，还可以调用<span class="jill"></span>getFileMap<span class="jill"></span>得到<span class="jill"></span>FileName-&gt;File<span class="jill"></span>结构的<span class="jill"></span>Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将<span class="jill"></span>request<span class="jill"></span>包装成<span class="jill"></span>MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</span></div></div><div id="oicDumZqZWbAvf1ZMSy26B" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="i9G7mKPqh6DqA6thTjzr82" class="wolai-block"><span class="wolai-serial-number">24.10</span><span class="inline-wrap">FlashMapManager</span></h2><div id="jpp8yJpsu17i2gTQqxcQyZ" class="wolai-block wolai-text"><div><span class="inline-wrap">initFlashMapManager(context)，用来管理<span class="jill"></span>FlashMap<span class="jill"></span>的，FlashMap<span class="jill"></span>主要用在<span class="jill"></span>redirect<span class="jill"></span>中传递参数。</span></div></div><div id="oWKqozyZYqx4NtPqZF1D1R" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kCgp78JsXffy1Pb2PqXbr4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="92Z1EGDqxEme3AJ5Tts1G4" class="wolai-block"><span class="wolai-serial-number">25</span><span class="inline-wrap">@Controller 注解有什么用？</span></h1><div id="t53xL6H5PR3SVfE9WbTCAX" class="wolai-block wolai-text"><div><span class="inline-wrap">@Controller 注解标记一个类为 Spring Web MVC 控制器 Controller。</span></div></div><div id="apajdZuJpYdgvKQgzuvjqn" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring MVC 会将扫描到该注解的类，然后扫描这个类下面带有 @RequestMapping 注解的方法，根据注解信息，为这个方法生成一个对应的处理器对象，在上面的 HandlerMapping 和 HandlerAdapter<span class="jill"></span>组件中讲到过。</span></div></div><div id="uLuf9RvKFmQx2kpFff4BaQ" class="wolai-block wolai-text"><div><span class="inline-wrap">当然，除了添加 @Controller 注解这种方式以外，你还可以实现 Spring MVC 提供的 Controller 或者 HttpRequestHandler 接口，对应的实现类也会被作为一个处理器对象</span></div></div><div id="h6iPVY2MpcCpyPbkZamUDa" class="wolai-block wolai-text"><div></div></div><div id="prUtXAorsAK2g3Rck3SDaY" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="xrmiNJEn7SPcMxGyFFkJwd" class="wolai-block"><span class="wolai-serial-number">26</span><span class="inline-wrap">@RestController 和 @Controller 有什么区别？</span></h1><div id="7Mt5DF75GZkUxffZETrpwk" class="wolai-block wolai-text"><div><span class="inline-wrap">@RestController 注解，在 @Controller 基础上，增加了 @ResponseBody 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的<span class="jill"></span>ACCEPT 请求头来决定。</span></div></div><div id="98DMytWPkqstkHJQEELtLf" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="hzsmd7StaURARrSSiYh2sN" class="wolai-block"><span class="wolai-serial-number">27</span><span class="inline-wrap">@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</span></h1><ol class="wolai-block"><li id="sMVFkAMYWw3ZbYnKHRJVrY"><div class="marker"></div><span class="inline-wrap">@RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上</span></li><li id="wirY2xAr4NxXbHaCjF2KfX"><div class="marker"></div><span class="inline-wrap">@RequestMapping：可进行 GET、POST、PUT、DELETE 等请求方法；@GetMapping 是<span class="jill"></span>@RequestMapping 的 GET 请求方法的特例，目的是为了提高清晰度。</span></li></ol><div id="jc3F1qSLDvB3psTQSkHXdq" class="wolai-block wolai-text"><div></div></div><div id="kgGwgZZUkSSndx6BB5qJhz" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tdsVtAV7FJXgHhSkb4L6JQ" class="wolai-block"><span class="wolai-serial-number">28</span><span class="inline-wrap">@RequestParam 和 @PathVariable 两个注解的区别</span></h1><div id="5WgxUMfofEetKh2KWbvrAu" class="wolai-block wolai-text"><div><span class="inline-wrap">两个注解都用于方法参数，获取参数值的方式不同，@RequestParam 注解的参数从请求携带的参数中获取，而 @PathVariable 注解从请求的 URI 中获取。</span></div></div><div id="4kTuUBstW1GfHNew7LbGEv" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4vuPaCktpknwpDCSyrJMg3" class="wolai-block"><span class="wolai-serial-number">29</span><span class="inline-wrap">返回 JSON 格式使用什么注解？</span></h1><div id="br9cjCKp87ev2BkaS37HFm" class="wolai-block wolai-text"><div><span class="inline-wrap">可以使用 @ResponseBody 注解，或者使用包含 @ResponseBody 注解的 @RestController 注解。</span></div></div><div id="3Ju5zF4edM1h7fmxwppHio" class="wolai-block wolai-text"><div><span class="inline-wrap">当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。</span></div></div><div id="tyaTw5E9xsKRgY8r7mXqQu" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter。</span></div></div><div id="4qSvHDdSuoP8ki1uYptya3" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nSJUen6CSoX9CCs6Q4dR39" class="wolai-block"><span class="wolai-serial-number">30</span><span class="inline-wrap">什么是<span class="jill"></span>SpringMVC<span class="jill"></span>拦截器以及如何使用它？</span></h1><div id="hXxNvjxgjpV5bckDqELL1p" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring MVC<span class="jill"></span>拦截器（Interceptor）是一种用于拦截和处理请求的组件，它可以在请求的前后进行处理，并对请求进行修改或添加额外的功能。拦截器可以用于实现一些通用的功能，例如身份验证、日志记录、性能监控等。</span></div></div><div id="oqExDh6dF7oMfgv87UEW4N" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是使用<span class="jill"></span>Spring MVC<span class="jill"></span>拦截器的步骤：</span></div></div><div id="djdZ4bAuBwAXb2uRJ9pgdL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="enXLm1mTHP1Mz43ZgnsA6q" class="wolai-block"><span class="wolai-serial-number">30.1</span><span class="inline-wrap">创建拦截器类</span></h2><div id="d2eriApmNuRdU7ZPaVoGTv" class="wolai-block wolai-text"><div><span class="inline-wrap">创建一个实现<span class="jill"></span>HandlerInterceptor<span class="jill"></span>接口的拦截器类。拦截器类可以包含在<span class="jill"></span>Spring MVC<span class="jill"></span>应用程序的任何位置，例如包下的一个单独类或者一个独立的模块。</span></div></div><div id="vqK86y4u4S7XW58n3uWdGp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aqveD8qXSc68SZR2Hkirsu" class="wolai-block"><span class="wolai-serial-number">30.2</span><span class="inline-wrap">实现拦截器方法</span></h2><div id="dTyKtWr19ZfHUmWHfS9u69" class="wolai-block wolai-text"><div><span class="inline-wrap">在拦截器类中实现<span class="jill"></span>preHandle、postHandle<span class="jill"></span>和<span class="jill"></span>afterCompletion<span class="jill"></span>等方法。</span></div></div><div id="ms5LgXHUphb4SQVyPcM1GT" class="wolai-block wolai-text"><div><span class="inline-wrap">preHandle()方法在请求处理之前执行，可以进行一些前置处理，例如身份验证、权限检查等。</span></div></div><div id="iVyGxdbrbNHGYhwZjjm1XF" class="wolai-block wolai-text"><div><span class="inline-wrap">postHandle()方法在请求处理之后、视图渲染之前执行，可以对模型数据进行处理或添加额外的功能。</span></div></div><div id="5MUM69QrFWQ9ezcqiaCNrZ" class="wolai-block wolai-text"><div><span class="inline-wrap">afterCompletion()方法在整个请求完成之后执行，可以进行一些资源清理或日志记录等操作。</span></div></div><div id="nvWNFhjoyaZBZaMs25eJBv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kzKTTV568NdcLSBfaoB1B5" class="wolai-block"><span class="wolai-serial-number">30.3</span><span class="inline-wrap">配置拦截器</span></h2><div id="eL7UJjifiS6BsYv3WQtLyH" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Spring MVC<span class="jill"></span>配置文件（如<span class="jill"></span>XML<span class="jill"></span>配置文件或<span class="jill"></span>Java<span class="jill"></span>配置类）中配置拦截器。通过注册拦截器类的方式将其添加到拦截器链中。可以指定拦截器的拦截路径（URL<span class="jill"></span>模式）或排除路径，以确定哪些请求会被拦截。</span></div></div><div id="9XkPDWcYU3pX9UA32AWwzJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5XS8NPARMCETneQ61JiXdn" class="wolai-block"><span class="wolai-serial-number">30.4</span><span class="inline-wrap">测试拦截器</span></h2><div id="eesmh7kc9tc41HBpoeNU9F" class="wolai-block wolai-text"><div><span class="inline-wrap">启动<span class="jill"></span>Spring MVC<span class="jill"></span>应用程序，并发送请求进行测试。</span></div></div><div id="dhFAv52LMHQzsfMBSEjkuy" class="wolai-block wolai-text"><div><span class="inline-wrap">拦截器将根据配置的规则拦截相应的请求，并执行拦截器方法。通过使用<span class="jill"></span>Spring MVC<span class="jill"></span>拦截器，您可以在请求的前后进行处理，实现一些通用的功能和逻辑。</span></div></div><div id="uq63D6FDLNdgjQMcy1nDmk" class="wolai-block wolai-text"><div><span class="inline-wrap">拦截器提供了一种灵活的方式来对请求进行拦截和处理，使您能够在应用程序中添加额外的功能和行为。</span></div></div><div id="czUxDqAqkFrF5jJe5WnkY" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tAMSXhtYj9UQFubiqCbcnW" class="wolai-block"><span class="wolai-serial-number">31</span><span class="inline-wrap">为什么要用<span class="jill"></span>SpringBoot?</span></h1><div id="xseEG5kwPYtN7ZGSx8Hr3A" class="wolai-block wolai-text"><div><span class="inline-wrap">在使用<span class="jill"></span>Spring<span class="jill"></span>框架进行开发的过程中，需要配置很多<span class="jill"></span>Spring<span class="jill"></span>框架包的依赖，如<span class="jill"></span>spring-core、spring-bean、spring-context<span class="jill"></span>等，而这些配置通常都是重复添加的，而且需要做很多框架使用及环境参数的重复配置，如开启注解、配置日志等。Spring Boot<span class="jill"></span>致力于弱化这些不必要的操作，提供默认配置，当然这些默认配置是可以按需修改的，快速搭建、开发和运行<span class="jill"></span>Spring<span class="jill"></span>应用。</span></div></div><div id="5a511JaLV17vua1SYwyzQN" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是使用<span class="jill"></span>SpringBoot<span class="jill"></span>的一些好处：自动配置，使用基于类路径和应用程序上下文的智能默认值，当然也可以根据需要重写它们以满足开发人员的需求。创建<span class="jill"></span>Spring Boot Starter 项目时，可以选择选择需要的功能，Spring Boot<span class="jill"></span>将为你管理依赖关系。SpringBoot<span class="jill"></span>项目可以打包成<span class="jill"></span>jar<span class="jill"></span>文件。可以使用<span class="jill"></span>Java-jar<span class="jill"></span>命令从命令行将应用程序作为独立的<span class="jill"></span>Java<span class="jill"></span>应用程序运行。在开发<span class="jill"></span>web<span class="jill"></span>应用程序时，springboot<span class="jill"></span>会配置一个嵌入式<span class="jill"></span>Tomcat<span class="jill"></span>服务器，以便它可以作为独立的应用程序运行。（Tomcat<span class="jill"></span>是默认的，当然你也可以配置<span class="jill"></span>Jetty<span class="jill"></span>或<span class="jill"></span>Undertow）SpringBoot<span class="jill"></span>包括许多有用的非功能特性（例如安全和健康检查）。</span></div></div><div id="6NzLaUXXpvyQrfzpx9WQKd" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="5N9bTEhcmhWcgnSqbWwE9E" class="wolai-block"><span class="wolai-serial-number">32</span><span class="inline-wrap">Spring Boot 自动配置原理？</span></h1><div id="jAgaDhSgwu5VY3p6EufjCk" class="wolai-block wolai-text"><div><span class="inline-wrap">@Import + @Configuration + Spring<span class="jill"></span>自动配置类由各个<span class="jill"></span>starter<span class="jill"></span>提供，使用<span class="jill"></span>@Configuration + @Bean<span class="jill"></span>定义配置类，放到<span class="jill"></span>META-INF/spring.factories<span class="jill"></span>下。使用<span class="jill"></span>Spring spi<span class="jill"></span>扫描<span class="jill"></span>META-INF/spring.factories<span class="jill"></span>下的配置类。使用<span class="jill"></span>@Import<span class="jill"></span>导入自动配置类。</span></div></div><div id="oBkpE1TLYKaQfzE1KnkVmm" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="hkrH7ivegt9SUcmUCP8JKC" class="wolai-block wolai-text"><div><span class="inline-wrap">详细流程原理分析，参考毕业精讲课。</span></div></div><div id="rdP6cBm3VDyRzkpXqrC4Br" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="2p1C7pabvzUbsghk7raMM4" class="wolai-block"><span class="wolai-serial-number">33</span><span class="inline-wrap">Spring Boot<span class="jill"></span>中如何实现对不同环境的属性配置文件的支持？</span></h1><div id="v1fKUru6nWY4fJVPDD97Rj" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring Boot<span class="jill"></span>支持不同环境的属性配置文件切换，通过创建<span class="jill"></span>application-{profile}.properties<span class="jill"></span>文件，其中<span class="jill"></span>{profile}<span class="jill"></span>是具体的环境标识名称，</span></div></div><div id="bzqSB7UpvZb6VUteQjUmgH" class="wolai-block wolai-text"><div><span class="inline-wrap">例如：</span></div></div><div id="2CmjYwAiCoemFDUss4DLmN" class="wolai-block wolai-text"><div><span class="inline-wrap">application-dev.properties<span class="jill"></span>用于开发环境，application-test.properties<span class="jill"></span>用于测试环境，application-uat.properties<span class="jill"></span>用于<span class="jill"></span>uat<span class="jill"></span>环境。</span></div></div><div id="hjqr6vUUdQ3oVLvgXpbVUw" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要想使用<span class="jill"></span>application-dev.properties<span class="jill"></span>文件，则在<span class="jill"></span>application.properties<span class="jill"></span>文件中添加<span class="jill"></span>spring.profiles.active=dev。</span></div></div><div id="bmFoKRKEyN7ffiMaawJRZ6" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要想使用<span class="jill"></span>application-test.properties<span class="jill"></span>文件，则在<span class="jill"></span>application.properties<span class="jill"></span>文件中添加<span class="jill"></span>spring.profiles.active=test。</span></div></div><div id="hgNwmEwEPkQse5uZaNpiuJ" class="wolai-block wolai-text"><div></div></div><div id="jP9AVzGL6j7bE3x5Ysk6C9" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="fDhcoWo4EFW9Jme3JVYYin" class="wolai-block"><span class="wolai-serial-number">34</span><span class="inline-wrap">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></h1><div id="97QP3Vkue3daMYLKGMyF6k" class="wolai-block wolai-text"><div><span class="inline-wrap">启动类上面的注解是<span class="jill"></span>@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下<span class="jill"></span>3<span class="jill"></span>个注解：</span></div></div><ul class="wolai-block"><li id="6vZ6EKWPusRncbJwt8sHEs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>@SpringBootConfiguration</b></span><span class="inline-wrap">：组合了 @Configuration 注解，实现配置文件的功能。</span></li><li id="8Wy7inqUs1Bv4fchv27RPx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>@EnableAutoConfiguration</b></span><span class="inline-wrap">：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</span></li><li id="aQsEsmi5bfTjR9Wa9dvtqe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>@ComponentScan</b></span><span class="inline-wrap">：Spring<span class="jill"></span>组件扫描。</span></li></ul><div id="wJPeLHAQaaNz4KqFzWh3rT" class="wolai-block wolai-text"><div></div></div><div id="uTQ1yjoNQpUaVcAnJQsbGA" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="eddWzRxXys8AKDUxF6CyKw" class="wolai-block"><span class="wolai-serial-number">35</span><span class="inline-wrap">你如何理解 Spring Boot 中的 Starter？</span></h1><div id="vuzYLojWNz8CNVcGaAMnha" class="wolai-block wolai-text"><div><span class="inline-wrap">starter<span class="jill"></span>就是定义一个<span class="jill"></span>starter<span class="jill"></span>的<span class="jill"></span>jar<span class="jill"></span>包，写一个<span class="jill"></span>@Configuration<span class="jill"></span>配置类、将这些<span class="jill"></span>bean<span class="jill"></span>定义在里面，然后在<span class="jill"></span>starter<span class="jill"></span>包的<span class="jill"></span>META-INF/spring.factories<span class="jill"></span>中写入该配置类，springboot<span class="jill"></span>会按照约定来加载该配置类。开发人员只需要将相应的<span class="jill"></span>starter<span class="jill"></span>包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如<span class="jill"></span>mybatis-spring-boot--starter，spring-boot-starter-redis</span></div></div><div id="aPWGCwRkfGVRJcEMZnNqTr" class="wolai-block wolai-text"><div></div></div><div id="cyvn9Xu5vCQ8Td7i8ftxnq" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bG2NVeyu2b4di8uozTRX7M" class="wolai-block"><span class="wolai-serial-number">36</span><span class="inline-wrap">Spring Boot Starter 的工作原理是什么？</span></h1><div id="kxQTkmfZDvR29Qq5wNjHPd" class="wolai-block wolai-text"><div><span class="inline-wrap">Spring Boot 在启动的时候会干这几件事情：</span></div></div><ul class="wolai-block"><li id="oWzXs5q6KVftE7SbWzWmS5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根</span></li><li id="u5yBCn3JD8niTLgnrjS6Yk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</span></li><li id="vJne51zSQ7BAeJ5eD8f1rd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根据 spring.factories 配置加载 AutoConfigure 类</span></li><li id="ctdof7o3p6cbnMQ17B3fm9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</span></li></ul><div id="eNUeMmVhomRHz2myFAScjt" class="wolai-block wolai-text"><div><span class="inline-wrap">总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可</span></div></div><div id="7niMBYAYaxRZVA2Hy8dz3m" class="wolai-block wolai-text"><div></div></div><div id="dcZs9uw8X3YSULzdUtBPQp" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="xuTnFbNubNJUs9CEyYvDmw" class="wolai-block"><span class="wolai-serial-number">37</span><span class="inline-wrap">什么是嵌入式服务器？为什么要使用嵌入式服务器?</span></h1><div id="pQexzXM327uLwGVr6TXEJj" class="wolai-block wolai-text"><div><span class="inline-wrap">节省了下载安装<span class="jill"></span>Tomcat<span class="jill"></span>的时间，应用也不需要先打<span class="jill"></span>war<span class="jill"></span>包然后放到<span class="jill"></span>webapp<span class="jill"></span>目录下再运行</span></div></div><div id="87aVuqtGewzRUgD697UeHD" class="wolai-block wolai-text"><div><span class="inline-wrap">只需要一个安装了<span class="jill"></span>JVM，就可以直接在上面部署应用程序了</span></div></div><div id="7wU3cHFzUWtALXeAVhjNE2" class="wolai-block wolai-text"><div><span class="inline-wrap">SpringBoot<span class="jill"></span>已经内置了<span class="jill"></span>tomcat.jar，运行<span class="jill"></span>main<span class="jill"></span>方法时会去启动<span class="jill"></span>Tomcat，并利用<span class="jill"></span>Tomcat<span class="jill"></span>的<span class="jill"></span>SPI<span class="jill"></span>机制加载<span class="jill"></span>SpringMVC</span></div></div></article><footer></footer></body></html>