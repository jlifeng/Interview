<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>中间件：RabbitMQ - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="中间件：RabbitMQ" class="main-title"></div></div></header><article><h1 id="rGEmHQ4q6wpjNbMr1mu5gJ" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">简述<span class="jill"></span>RabbitMQ<span class="jill"></span>的架构设计</span></h1><div id="eyVDVFgfv3bB19ht982hSV" class="wolai-block"><figure class="wolai-center" style="width: 954.6666666666666px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="4GyqySJ6s4QGuKG9KjK7jD" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>是一个开源的消息队列系统，其内部结构设计灵活且扩展性强。以下是对<span class="jill"></span>RabbitMQ<span class="jill"></span>内部结构的详细说明：</span></div></div><ol class="wolai-block"><li id="peH1jLu4Qg5b7Z9Q2j9o1h"><div class="marker"></div><span class="inline-wrap"><b>服务器（Broker）</b></span><ul class="wolai-block"><li id="fq6EirngEDZxBf34vLn1r5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>核心组件</b></span><span class="inline-wrap">：服务器是<span class="jill"></span>RabbitMQ<span class="jill"></span>的核心组件，负责管理所有的交换器和队列。一个<span class="jill"></span>RabbitMQ<span class="jill"></span>实例可以包含多个服务器，每个服务器负责一部分交换器和队列。</span></li><li id="4eHWUGhFgWxF8E8e7mYAVL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>通信方式</b></span><span class="inline-wrap">：服务器之间通过<span class="jill"></span>HTTP<span class="jill"></span>协议通信，可以使用多种方式进行部署，如单机、集群、云服务等。</span></li></ul></li><li id="9rH5VJwGQxfNiKXbMtNw8s"><div class="marker"></div><span class="inline-wrap"><b>交换器（Exchange）</b></span><ul class="wolai-block"><li id="aopzBCLWd2Y57swzXKoVbT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>消息传递核心</b></span><span class="inline-wrap">：交换器是<span class="jill"></span>RabbitMQ<span class="jill"></span>中的消息传递核心，负责接收、路由、传递消息。RabbitMQ<span class="jill"></span>支持多种交换器类型，如<span class="jill"></span>fanout、direct、topic<span class="jill"></span>等，每种类型的交换器都有不同的消息传递方式和应用场景。</span></li><li id="kQRwcep9gVUnaPjnxQd8xx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>路由规则</b></span><span class="inline-wrap">：生产者将消息发送到交换器后，交换器根据路由键（RoutingKey）将消息路由到一个或多个队列中。</span></li></ul></li><li id="8rWPtuiuc1swqwdoDPBEHe"><div class="marker"></div><span class="inline-wrap"><b>队列（Queue）</b></span><ul class="wolai-block"><li id="k47hsYKULokuAJtXhGNuoL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>消息存储容器</b></span><span class="inline-wrap">：队列是<span class="jill"></span>RabbitMQ<span class="jill"></span>中的消息存储容器，用于存储消息。RabbitMQ<span class="jill"></span>支持多种队列类型，如持久化、非持久化、排他访问等，每种类型的队列都有不同的存储方式和应用场景。</span></li><li id="cxW35qghUDGTbYSThEPY9z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>FIFO<span class="jill"></span>处理机制</b></span><span class="inline-wrap">：队列提供<span class="jill"></span>FIFO（先进先出）的处理机制，并具有缓存消息的能力。</span></li></ul></li><li id="aeL1tUo6UWpSjHwWoNQjcw"><div class="marker"></div><span class="inline-wrap"><b>信道（Channel）</b></span><ul class="wolai-block"><li id="iytrHYxva9bhyc1h3dQMQ1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>虚拟连接</b></span><span class="inline-wrap">：信道是建立在<span class="jill"></span>Connection<span class="jill"></span>之上的虚拟连接。当应用程序与<span class="jill"></span>Rabbit Broker<span class="jill"></span>建立<span class="jill"></span>TCP<span class="jill"></span>连接时，客户端紧接着可以创建一个<span class="jill"></span>AMQP<span class="jill"></span>信道（Channel），每个信道都会被指派一个唯一的<span class="jill"></span>ID。</span></li><li id="eNucBuXrogNwtVHH6r3h1u"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>功能</b></span><span class="inline-wrap">：RabbitMQ<span class="jill"></span>处理的每条<span class="jill"></span>AMQP<span class="jill"></span>指令都是通过信道完成的。信道就像电缆里的光纤束，允许所有的连接通过多条光线束进行传输和接收。</span></li></ul></li><li id="qwnSYAToGEBegSTVrJ2NuL"><div class="marker"></div><span class="inline-wrap"><b>绑定（Binding）</b></span><ul class="wolai-block"><li id="9wix1S9TRqJU9GfV7ywSNh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>关联关系</b></span><span class="inline-wrap">：绑定用于将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键（BindingKey），这样<span class="jill"></span>RabbitMQ<span class="jill"></span>就可以指定如何正确地路由到队列了。</span></li><li id="6bFhV5K3iK7f5jEAuU1GxQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>多对多关系</b></span><span class="inline-wrap">：交换器和队列实际上是多对多关系，就像关系数据库中的两张表通过外键做关联一样。</span></li></ul></li><li id="2RoCg5rSj1bAitoDD2M4tR"><div class="marker"></div><span class="inline-wrap"><b>虚拟主机（Virtual Host）</b></span><ul class="wolai-block"><li id="nLtFfUpbmFhJeixskEEwJT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>隔离机制</b></span><span class="inline-wrap">：每个<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器可以开设多个虚拟主机（Virtual Host，简称<span class="jill"></span>vhost）。每个<span class="jill"></span>vhost<span class="jill"></span>本质上是一个<span class="jill"></span>mini<span class="jill"></span>版的<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器，拥有自己的<span class="jill"></span>Exchange、Queue<span class="jill"></span>和权限机制。这种设计使得一个<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器可以安全地服务于多个应用程序，每个<span class="jill"></span>vhost<span class="jill"></span>对应一个应用程序。</span></li></ul></li></ol><div id="pAXYV8G5gruGbpF5XkrJF1" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>的内部结构由多个核心组件组成，包括服务器、交换器、队列、信道、绑定和虚拟主机等。这些组件共同协作，实现了高效、可靠和灵活的消息传递系统。</span></div></div><div id="mFPpkx8KEXfQ1CsvQ5jLkD" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4gXyP4ezDZrQTEGZ7ymczU" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">介绍一下<span class="jill"></span>RabbitMQ<span class="jill"></span>有几种工作模式？</span></h1><div id="smquRieSE5bRLUyPEisyM5" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>提供了多种工作模式，每种模式适用于不同的应用场景。以下是对<span class="jill"></span>RabbitMQ<span class="jill"></span>六种主要工作模式的详细介绍：</span></div></div><ol class="wolai-block"><li id="arxCyWMfvUXDbeW5G1rzpg"><div class="marker"></div><span class="inline-wrap"><b>简单模式（Simple Mode）</b></span><span class="inline-wrap">：这是最基本的消息传递模式。在简单模式下，一个生产者向一个消费者发送一条消息。这种模式也称为点对点（Point-to-Point）模式，因为只有一个生产者和一个消费者直接通信。</span><div id="uZvgmkChMPEnJkoTgaStSw" class="wolai-block"><figure class="wolai-center" style="width: 192px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div></li><li id="rrZXpYamwPj6gfYRXxRpH4"><div class="marker"></div><span class="inline-wrap"><b>工作队列模式（Work Queues）</b></span><span class="inline-wrap">：工作队列模式实现了多个消费者从同一个队列中获取并处理消息。消费者之间是竞争关系，每个消息只会被其中一个消费者处理。这种模式适用于并发性高、需要处理多个任务的场景，例如任务队列和消息处理。</span><div id="8FZBneXUbGc1rKXUaJMfHn" class="wolai-block"><figure class="wolai-center" style="width: 192px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div></li><li id="tZQ2qH3N61cF5Di78qtf2a"><div class="marker"></div><span class="inline-wrap"><b>发布/订阅模式（Publish/Subscribe）</b></span><span class="inline-wrap">：在发布/订阅模式中，一个生产者向多个消费者发送消息，每个消费者都可以接收到相同的消息。这种模式适用于多个消费者需要接收相同消息的场景，例如日志系统和广播消息。</span><div id="7q9ADNY2Uq8daFC8Tnthqf" class="wolai-block"><figure class="wolai-center" style="width: 217.33333333333334px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div></li><li id="tVsH1NKtFvHX7JUhJ7CV7h"><div class="marker"></div><span class="inline-wrap"><b>路由模式（Routing）</b></span><span class="inline-wrap">：路由模式中，消息会被发送到指定的接收者。生产者将消息发送到交换机，交换机根据消息的路由键将消息路由到对应的队列中，消费者从队列中获取并处理消息。这种模式适用于需要根据消息的路由键将消息路由到指定队列中的场景，例如订单系统和用户通知。</span><div id="mropqBoqHUkKkhnghtyXyq" class="wolai-block"><figure class="wolai-center" style="width: 192px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div></li><li id="d5o2WoxV9xwFUB7XTz54ZJ"><div class="marker"></div><span class="inline-wrap"><b>主题模式（Topics）</b></span><span class="inline-wrap">：主题模式是路由模式的扩展，它允许生产者发送消息时指定主题（topic），消费者可以使用通配符匹配符合条件的消息。这种模式适用于需要支持复杂消息路由规则的场景，例如搜索系统和匹配系统。</span><div id="3BaWj7PdTC6oSmigXxNt7n" class="wolai-block"><figure class="wolai-center" style="width: 217.33333333333334px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div></li><li id="hX1cHEmE6tYzkiRvxn7Tt5"><div class="marker"></div><span class="inline-wrap"><b>RPC<span class="jill"></span>模式（Remote Procedure Call）</b></span><span class="inline-wrap">：RPC<span class="jill"></span>模式实现了远程过程调用，客户端发送请求消息给服务端，服务端返回响应消息给客户端。客户端和服务端之间可以通过<span class="jill"></span>RabbitMQ<span class="jill"></span>传递消息进行通信。这种模式适用于需要实现分布式系统间通信的场景，例如远程调用服务和数据处理。</span><div id="mtaK5XKNk4cvBA9W55h8fz" class="wolai-block"><figure class="wolai-center" style="width: 350.6666666666667px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div></li></ol><div id="9TqktnLgXLR6vnAcqsVexM" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>提供了多种工作模式，以满足不同应用场景的需求。开发者可以根据具体需求选择合适的模式来实现高效、可靠和灵活的消息传递系统。</span></div></div><div id="vmzjEGSGy1nLnBAnzj32Cc" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ncm7AEBE2NXNNzFuhdQKJG" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">RabbitMQ<span class="jill"></span>如何确保消息发送？消息接收？</span></h1><div id="nrunFaDgiy5y9pcQLcbKie" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>通过一系列机制确保消息的发送和接收，以下是详细的说明：</span></div></div><h3 id="o8ix6Tmjr5JYrjmJaCgTTV" class="wolai-block"><span class="wolai-serial-number">3.?.1</span><span class="inline-wrap">确保消息发送</span></h3><ol class="wolai-block"><li id="rU9njLC3b1gY3PQFv8jjfV"><div class="marker"></div><span class="inline-wrap"><b>生产者确认机制</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="mGWjEGvidfzVePtL7xKgKE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者在发布消息后，可以等待服务器返回确认消息。这通过设置信道为<span class="jill"></span>confirm<span class="jill"></span>模式来实现。</span></li><li id="4j13MdHTA7zW6EctnCbpy5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一旦消息被<span class="jill"></span>RabbitMQ<span class="jill"></span>确认接收（即投递到队列，对于持久化的消息需要写入磁盘），信道会发送一个确认给生产者。</span></li><li id="4zPxeMRJXpZvzbRZFDKmQq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果<span class="jill"></span>RabbitMQ<span class="jill"></span>发生内部错误导致消息丢失，会发送一条<span class="jill"></span>nack（未确认）消息给生产者。</span></li></ul></li><li id="7oT5ms9bB1uVQomqbhv57d"><div class="marker"></div><span class="inline-wrap"><b>事务机制</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="eTGHyoMJMPjcYJjpEYVHkW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者可以使用事务模式，将一系列操作包装在事务内。如果其中任何一个步骤失败，整个事务将被回滚，包括消息的发布。</span></li><li id="k13f2cj5qscuFSwmKjQTNY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用事务机制可以确保消息要么全部成功发送，要么全部不发送。</span></li></ul></li></ol><h3 id="tZPKSzBw6vFx8e74Bu3BCE" class="wolai-block"><span class="wolai-serial-number">3.?.2</span><span class="inline-wrap">确保消息接收</span></h3><ol class="wolai-block"><li id="gfMHMbaWyxgXYNssRp8rvs"><div class="marker"></div><span class="inline-wrap"><b>消费者确认机制</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="v7Mdq4Exm3RrkMS9uV4ecZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者在成功处理消息后，向<span class="jill"></span>RabbitMQ<span class="jill"></span>发送确认。这可以通过设置<span class="jill"></span>autoAck<span class="jill"></span>参数为<span class="jill"></span>false，然后在消费者处理完消息后手动发送确认来实现。</span></li><li id="eBV9J7PPNiLnxkWxv33NVS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">只有消费者确认了消息，RabbitMQ<span class="jill"></span>才能安全地把消息从队列中删除。</span></li><li id="d1nPNyoaLEbjbcVq1NP58T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果消费者在处理过程中发生异常，没有发送确认，RabbitMQ<span class="jill"></span>会认为这条消息没有被成功消费，可能会重新分发给下一个订阅的消费者。</span></li></ul></li><li id="4Ti3hrW1L3uJDHDp5kA5hw"><div class="marker"></div><span class="inline-wrap"><b>手动确认与自动确认</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="usdkTJxciXf1Dq7XEQF5bh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">手动确认模式较为灵活，但可能影响性能。自动确认模式可以提高性能，但在发生异常时，消息可能会被丢失。</span></li></ul></li><li id="wRzccw4yk87PrWwwuKMbPy"><div class="marker"></div><span class="inline-wrap"><b>消息重试机制</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="k1tWEjJxtV1T7PBpKCBR4U"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在消息发送或消费失败时，可以实现消息的重试机制。通过在失败时将消息重新放回队列，允许它重新被消费]。</span></li></ul></li><li id="3cvy5bETP8ZgefrqSpXwYz"><div class="marker"></div><span class="inline-wrap"><b>死信队列（DLQ）</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="cSoTMUXJWakk69kjkbwXLT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">设置死信队列，当消息无法被消费时，将其路由到死信队列，以便后续检查和处理失败的消息。</span></li></ul></li></ol><div id="k55UhkevFpPe4R21AKccCC" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>通过生产者确认机制、事务机制、消费者确认机制、手动与自动确认的选择、消息重试机制以及死信队列等多种手段，确保了消息的可靠发送和接收。这些机制共同协作，提高了消息传递系统的可靠性和稳定性。</span></div></div><div id="k2CMDLfPc2tMVqmU1ja8F4" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kLTyNVBN7GRu6exNmMLxBy" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">请谈谈你对<span class="jill"></span>RabbitMQ<span class="jill"></span>事务消息的理解</span></h1><h2 id="p44xosavsHEnQtWSCjgp5D" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">概述</span></h2><div id="sC7gyp3M4AdR4WAh2ccKFA" class="wolai-block wolai-text"><div><span class="inline-wrap">在客户端有多条消息要发送到<span class="jill"></span>RabbitMQ<span class="jill"></span>时，如果希望这些消息要么都发送，要么都不发送，就可以使用事务消息机制</span></div></div><div id="3HuX77LWPVx6aVpCaNhiCL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rtKeWHonQuYfNQbCDrNAdd" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">机制说明</span></h2><ul class="wolai-block"><li id="5g7NwRBVE8NSqK5rUgn7kU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每一条消息在正式发送前都会先放入缓存</span></li><li id="t3puXH2ouwxMuXuykwg7UQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果所有待发送的消息都顺利存入缓存，则提交事务，缓存中的所有消息都发送给<span class="jill"></span>RabbitMQ</span></li></ul><div id="3wQzcvmw3VkyMotMW9gCdN" class="wolai-block"><figure class="wolai-center" style="width: 790px; flex-direction: column"><img src="media/image_7.png" style="width: 100%"/></figure></div><ul class="wolai-block"><li id="pA8CkeRQszdrPvXwZ4sBtj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果有的消息没能存入缓存，则回滚事务，所有消息都不发送</span></li></ul><div id="kMPaLfX9ViCDYiCb9RzNQq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wtjZUPSsrKtdim38LDDt24" class="wolai-block"><span class="wolai-serial-number">4.3</span><span class="inline-wrap">局限</span></h2><ul class="wolai-block"><li id="nWr3d8weza8g5SmWdjFXR7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在生产者端使用事务消息和消费端没有关系</span></li><li id="bThWRNaHeqUVJV7oJqggHy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在生产者端使用事务消息仅仅是控制事务内的消息是否发送</span></li><li id="f8pzUPfZ3Zm7YjJC9CC7m1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">提交事务就把事务内所有消息都发送到交换机</span></li><li id="5e7PUYcttMwiWLeis6QB52"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回滚事务则事务内任何消息都不会被发送</span></li><li id="m6NPaLWmHxjBvLMkTpWT5q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>事务控制对消费端</b></span><span class="red inline-wrap"><b>无效</b></span><span class="inline-wrap"><b>！！！</b></span></li></ul><div id="uSUtUqSJ5cejvL3fCHLEuk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6sZKSkSmc1kTbwDydctXGx" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6RsTc4yXs5UxEoBd4HUT7G" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">RabbitMQ<span class="jill"></span>如何实现延迟消息？</span></h1><div id="u943mVZGbyBthiKU6k5UVj" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>实现延迟消息的方式主要有两种，一种是使用死信队列实现，另一种是使用延迟插件实现。以下是对这两种方式的详细说明：</span></div></div><h2 id="n4vsziNLwyQ9twsHHmdJXg" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">一、死信队列（Dead Letter Queue）</span></h2><div id="tYC9GBBGzsfhWP1PkZcjs3" class="wolai-block wolai-text"><div><span class="inline-wrap">死信队列是<span class="jill"></span>RabbitMQ<span class="jill"></span>的一种特殊功能，用于处理无法被正常消费的消息。通过结合<span class="jill"></span>TTL（Time To Live）和<span class="jill"></span>DLX（Dead Letter Exchange），可以实现延迟消息的效果。</span></div></div><ol class="wolai-block"><li id="doKqULPHftKGukZcXWfry6"><div class="marker"></div><span class="inline-wrap"><b>原理</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="mAB3Vq8d9T51VbyeMS3pYn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者将消息发送到具有<span class="jill"></span>TTL<span class="jill"></span>设置的队列中。</span></li><li id="gxXp6LWPcKiic2n4exTrMj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果消息在<span class="jill"></span>TTL<span class="jill"></span>时间内未被消费，它将被转发到与该队列绑定的死信交换器（DLX）。</span></li><li id="hgYqB4Bc8GdTvL5f2vkpYw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">死信交换器再将消息路由到一个或多个死信队列中，供消费者处理。</span></li></ul></li><li id="ojhej9o1iSq2E3Ld8HKq2v"><div class="marker"></div><span class="inline-wrap"><b>实现步骤</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="BQ5vzQVJqxbSjiK5Snf1C"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建一个具有<span class="jill"></span>TTL<span class="jill"></span>设置的队列，并绑定到一个死信交换器。</span></li><li id="oaqntKRemGoCtVqtFaMNxp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建死信交换器，并将其与一个或多个死信队列绑定。</span></li><li id="rvdgcQM7tswDVhurz8xzWD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者发送消息到<span class="jill"></span>TTL<span class="jill"></span>队列。</span></li><li id="g7cMK7MAXjzrm2yB6ECKR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者从死信队列中获取并处理过期的消息。</span></li></ul></li><li id="bxFXgMq1gLb48WCVtYu3Hc"><div class="marker"></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">（基于<span class="jill"></span>Spring Boot）：</span><code-block id="3DoPNBkR2NbP8YgdqiEZbp" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 配置RabbitMQ相关组件</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token constant">DELAY_TIME</span> <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">// 延迟时间30秒</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">strokeOverQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> <span class="token string">"STROKE_DEAD_QUEUE_EXCHANGE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"STROKE_DEAD_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token constant">DELAY_TIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"STROKE_OVER_QUEUE"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">strokeOverQueueExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"STROKE_OVER_QUEUE_EXCHANGE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingStrokeOverDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">strokeOverQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">strokeOverQueueExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"STROKE_OVER_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">strokeDeadQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"STROKE_DEAD_QUEUE"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">strokeDeadQueueExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"STROKE_DEAD_QUEUE_EXCHANGE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingStrokeDeadDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">strokeDeadQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">strokeDeadQueueExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"STROKE_DEAD_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></li></ol><h2 id="62LRvcFZvbE91maECLE7Wx" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">二、延迟插件（Delayed Message Exchange）</span></h2><div id="isNoFAPHYnPn8C38CzXsxm" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>官方提供了一款延迟消息插件，名为<span class="jill"></span>rabbitmq_delayed_message_exchange。这款插件原生支持延迟消息功能，简化了延迟消息的处理过程。</span></div></div><ol class="wolai-block"><li id="n4ZxFRp5L4L53ATpqGc1Bp"><div class="marker"></div><span class="inline-wrap"><b>安装步骤</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="bPS1L6aDgphK193YnXfYGJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">下载与<span class="jill"></span>RabbitMQ<span class="jill"></span>配套版本的延迟插件。</span></li><li id="kKbp5Vj9vrv4kFww4VnKtU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将插件文件复制到<span class="jill"></span>RabbitMQ<span class="jill"></span>安装目录的<span class="jill"></span>plugins<span class="jill"></span>目录下。</span></li><li id="uCLFnH3UWv9erqPNBrne44"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进入<span class="jill"></span>RabbitMQ<span class="jill"></span>安装目录的<span class="jill"></span>sbin<span class="jill"></span>目录下，使用命令启用延迟插件。</span></li></ul></li><li id="hm7fEmyV4a1Xskfa3DkeEh"><div class="marker"></div><span class="inline-wrap"><b>使用步骤</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="fRgnyu4hHLmZ8wyrzV5nWT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建一个延迟交换机（Delayed Exchange）。</span></li><li id="89pwpyBfPpvKhV882mXdyC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">生产者发送消息到延迟交换机时，通过消息头</span><span class="inline-wrap"><code>x-delay</code></span><span class="inline-wrap">设置延迟时间（单位为毫秒）。</span></li><li id="i56mU4XJ1QcFivrg6GNnji"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者订阅与延迟交换机绑定的队列，以接收延迟后的消息。</span></li></ul></li><li id="sAsBdcmqJx11LSUs6xUheM"><div class="marker"></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">（基于<span class="jill"></span>Spring Boot）：</span><code-block id="gu69hiMQohSnCL8EYXdFnU" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 配置RabbitMQ延迟交换机和队列</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitDelayConfig</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DELAY_EXCHANGE</span> <span class="token operator">=</span> <span class="token string">"DELAY_EXCHANGE"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DELAY_QUEUE</span> <span class="token operator">=</span> <span class="token string">"DELAY_QUEUE"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DELAY_ROUTING_KEY</span> <span class="token operator">=</span> <span class="token string">"DELAY_ROUTING_KEY"</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">CustomExchange</span> <span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-delayed-type"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CustomExchange</span><span class="token punctuation">(</span><span class="token constant">DELAY_EXCHANGE</span><span class="token punctuation">,</span> <span class="token string">"x-delayed-message"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token constant">DELAY_QUEUE</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">delayQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">delayExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token constant">DELAY_ROUTING_KEY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noargs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 生产者发送延迟消息</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendDelayMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">expiration</span><span class="token punctuation">(</span><span class="token string">"永不过期"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">delay</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span> <span class="token comment">// 设置延迟时间，单位毫秒</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token constant">DELAY_EXCHANGE</span><span class="token punctuation">,</span> <span class="token constant">DELAY_ROUTING_KEY</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 消费者接收延迟消息</span>
<span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token constant">DELAY_QUEUE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveDelayMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received delayed message: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block></li></ol><div id="hnwQPgLRtEofogtnLCPjQw" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>实现延迟消息的方式有死信队列和延迟插件两种。死信队列方式需要配置<span class="jill"></span>TTL<span class="jill"></span>和<span class="jill"></span>DLX，适用于简单的延迟消息需求；而延迟插件方式则提供了更直接、更灵活的延迟消息功能，适用于复杂的应用场景。开发者可以根据具体需求选择合适的实现方式。</span></div></div><div id="9xnqB7VMPdS63iBZ3V38G9" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bmAkUEqWyoEBdUzxcsFwGr" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">RabbitMQ<span class="jill"></span>如何保证消息的顺序性？</span></h1><div id="65Ct8MFwNvt1cFJkKLYmzK" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>保证消息顺序性的方法主要包括</span><span class="inline-wrap"><b>使用单一队列、控制并发消费者数量、避免消息重排以及实施合适的消息确认机制等</b></span><span class="inline-wrap">。以下是对<span class="jill"></span>RabbitMQ<span class="jill"></span>如何保证消息的顺序性的详细说明：</span></div></div><ol class="wolai-block"><li id="jgYPzBznfXphx4RDzLBRJ3"><div class="marker"></div><span class="inline-wrap"><b>使用单一队列</b></span><span class="inline-wrap">：使用单个队列是确保消息顺序性的最简单直接的方法，因为单个队列天然地保证了进入队列的消息先进先出（FIFO）。但在实际应用中，这种方法限制了系统的并发处理能力。</span></li><li id="sAPD53b27rutmmjjYBRJci"><div class="marker"></div><span class="inline-wrap"><b>控制并发的消费者数量</b></span><span class="inline-wrap">：消费者的数量直接影响了消息处理的顺序。同一时间处理一个消息可以保障顺序，但这种方式效率低下。相反，多个消费者可能会导致顺序错乱。因此，如果顺序性对业务至关重要，推荐限制消费者的数量，或者设定消费者之间的协调机制。</span></li><li id="snz5J7vfDEePummrC6yRaL"><div class="marker"></div><span class="inline-wrap"><b>避免消息重排</b></span><span class="inline-wrap">：在某些情况下，消息可能会重新进入队列，这种情况通常发生在消息处理失败或消费者拒绝消息时。为了避免破坏消息的顺序性，需要合理设计消息重试机制，并正确应用消息拒绝和确认策略。</span></li><li id="4mKLK99zpTQzJXy6onGFS7"><div class="marker"></div><span class="inline-wrap"><b>实施消息确认机制</b></span><span class="inline-wrap">：消息的确认机制是<span class="jill"></span>RabbitMQ<span class="jill"></span>保证消息可靠性的关键部分，同时也关系到消息顺序性。手动确认模式下，即使在消费者处理中途失败，消息也不会丢失，可以保证稍后重新处理。</span></li><li id="64BuoaHSHozDWD3UWrT1ph"><div class="marker"></div><span class="inline-wrap"><b>事务机制</b></span><span class="inline-wrap">：RabbitMQ<span class="jill"></span>的事务机制可以保证一系列操作的原子性，从而在一定程度上保证消息的顺序性和一致性。但开启事务会降低<span class="jill"></span>RabbitMQ<span class="jill"></span>的吞吐量。</span></li><li id="oBtPzhNcQhZQq7DTp91rdE"><div class="marker"></div><span class="inline-wrap"><b>发布确认</b></span><span class="inline-wrap">：发布确认是一种异步的机制，生产者在发送消息后会得到一个确认，确保消息已经被<span class="jill"></span>RabbitMQ<span class="jill"></span>接受。这不仅能增强消息的可靠性，还可以与顺序保障机制结合使用。</span></li><li id="eYhzhv89DyMpVwUe8VvgMJ"><div class="marker"></div><span class="inline-wrap"><b>分区策略</b></span><span class="inline-wrap">：通过某种分区策略（如基于某个字段的哈希值），将消息发送到多个队列中的一个，这样每个队列中的消息都能保持顺序，同时可以提高并发处理能力。</span></li><li id="jdL7vCSKZDt3KQW482bsVX"><div class="marker"></div><span class="inline-wrap"><b>延迟消息的顺序处理</b></span><span class="inline-wrap">：确保在处理延迟消息或重试消息时，消息顺序不被打乱。</span></li></ol><div id="g9NaYyNuEHw2b5BRM8MZRT" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>通过多种策略来保证消息的顺序性，包括使用单一队列、控制并发消费者数量、避免消息重排、实施消息确认机制、使用事务和发布确认机制以及分区策略等。在设计系统时，需要平衡消息顺序性和系统吞吐量，并采取适当措施以防止消息的丢失或重复。</span></div></div><div id="tt2hezVJhiWEFTgtxu6tjk" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qvLKXSpFVE6RuJv9PM71dq" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">如何使用<span class="jill"></span>RabbitMQ<span class="jill"></span>实现分布式事务？</span></h1><div id="qVeronWJKB1Pi1gW3VxF8e" class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>实现分布式事务主要依赖于其消息确认机制和补偿措施。以下是详细的步骤和原理：</span></div></div><ol class="wolai-block"><li id="sjkPN2JViHa5mDjqUryauS"><div class="marker"></div><span class="inline-wrap"><b>安装并启动<span class="jill"></span>RabbitMQ</b></span><ul class="wolai-block"><li id="vSUbUYLxmoAinHncGixJS3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>安装步骤</b></span><span class="inline-wrap">：访问官方网址下载<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器，并根据操作系统进行安装。安装完成后，可以通过浏览器访问管理界面进行配置和管理。</span></li><li id="ebrYpX9rxa5axRuSfjEHFd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>启动服务</b></span><span class="inline-wrap">：启动<span class="jill"></span>RabbitMQ<span class="jill"></span>服务，确保其正常运行。</span></li></ul></li><li id="aWWYbLmLxT6eXA7B4XJ43j"><div class="marker"></div><span class="inline-wrap"><b>搭建消息发布端</b></span><ul class="wolai-block"><li id="cYVrB8UMtddV8cQXDZz38v"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>添加依赖</b></span><span class="inline-wrap">：在项目中添加<span class="jill"></span>Spring Boot<span class="jill"></span>和<span class="jill"></span>RabbitMQ<span class="jill"></span>的依赖。</span></li><li id="hAL9LPMoBAahEenWtLJwxb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>配置连接工厂</b></span><span class="inline-wrap">：配置<span class="jill"></span>RabbitMQ<span class="jill"></span>的连接工厂，包括主机、端口、用户名和密码等信息。</span></li><li id="m9LumufqvaUAgEX628gq4o"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>创建交换机和队列</b></span><span class="inline-wrap">：根据业务需求创建交换机和队列，并设置相应的绑定关系。例如，可以创建一个主题交换机和两个队列，分别用于不同的消息路由。</span></li></ul></li><li id="gHpkcSSMNgZZkdNGL2wha1"><div class="marker"></div><span class="inline-wrap"><b>消息发送与确认</b></span><ul class="wolai-block"><li id="nDw1Z6o13eUC4tE152viV2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>开启<span class="jill"></span>Publisher Confirms</b></span><span class="inline-wrap">：在连接工厂中开启<span class="jill"></span>Publisher Confirms<span class="jill"></span>模式，以便在消息发送到交换机后接收确认回调。</span></li><li id="xwfGyQQXtqX7M63mAg1cqF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>发送消息</b></span><span class="inline-wrap">：使用<span class="jill"></span>RabbitTemplate<span class="jill"></span>发送消息，并通过回调函数处理消息发送的结果。如果消息发送失败，可以进行重试或记录日志。</span></li><li id="61Ktm7dyZEd1S7PzkPiHmE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>消息重试机制</b></span><span class="inline-wrap">：在消息发送失败时，可以实现重试机制，确保消息最终被成功发送到<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器。</span></li></ul></li><li id="w5QMdXD2CGEUeeC5L2EERv"><div class="marker"></div><span class="inline-wrap"><b>消费者消息确认</b></span><ul class="wolai-block"><li id="9dMxhubRRJAn9vdKequNzX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>手动<span class="jill"></span>ACK<span class="jill"></span>模式</b></span><span class="inline-wrap">：消费者采用手动<span class="jill"></span>ACK<span class="jill"></span>模式，确保在消息处理成功后才发送<span class="jill"></span>ACK<span class="jill"></span>给<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器。</span></li><li id="m4sKNc7YmHva5Yu2TVRmqo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>幂等性处理</b></span><span class="inline-wrap">：由于网络问题或消费者故障可能导致消息重复消费，因此需要在消费者端实现幂等性处理，避免重复操作。</span></li></ul></li><li id="tjCThRkzXNsf3qRLCKVCyo"><div class="marker"></div><span class="inline-wrap"><b>补偿机制</b></span><ul class="wolai-block"><li id="riDKW198BuMvpxjyzPEvp4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>补单机制</b></span><span class="inline-wrap">：如果生产者投递消息到<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器成功，但消费者消费失败导致订单回滚，可以通过补单机制进行补偿。具体来说，可以创建一个补单消费者监听特定的队列或交换机，当检测到需要补偿的订单时，重新执行相关操作。</span></li></ul></li><li id="4MxvA6cokzXdJ24eQy2ZDb"><div class="marker"></div><span class="inline-wrap"><b>定时任务扫描日志</b></span><ul class="wolai-block"><li id="2w6yu1HGGRWVqCM5Cn8xS7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>扫描消息日志表</b></span><span class="inline-wrap">：通过定时任务扫描本地数据库中的消息日志表，将未成功发送的消息重新发送至<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器。</span></li><li id="3L1eEEP6Dfy2uMy1EJuNGn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>删除已发送消息</b></span><span class="inline-wrap">：在消息成功发送至<span class="jill"></span>RabbitMQ<span class="jill"></span>服务器后，从本地数据库中删除相应的消息日志记录。</span></li></ul></li></ol><div id="qpkN4121pBSeanTNpFQwni" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，RabbitMQ<span class="jill"></span>实现分布式事务的关键在于利用其消息确认机制确保消息的可靠投递，并通过补偿机制处理可能的事务回滚情况。同时，还需要注意幂等性问题和消息重试机制的设计。在实际应用中，可以根据具体业务场景选择合适的解决方案和技术栈来实现分布式事务的一致性和可靠性。</span></div></div><div id="8Dw7y3uHd5AvtEgiKBavUe" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bsqRZjq9XhomRGUjS1gHbq" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">如何防止<span class="jill"></span>RabbitMQ<span class="jill"></span>消息重复消费？</span></h1><div id="2gvkGFiePvGFrUkUX4j3Lv" class="wolai-block wolai-text"><div><span class="inline-wrap">为了防止<span class="jill"></span>RabbitMQ<span class="jill"></span>消息重复消费，可以采取以下几种策略：</span></div></div><ol class="wolai-block"><li id="864mvA3mFepMBTbEY46Qt3"><div class="marker"></div><span class="inline-wrap"><b>消息去重</b></span><span class="inline-wrap">：在发送消息之前，为每条消息生成一个唯一的消息<span class="jill"></span>ID，并将该消息<span class="jill"></span>ID<span class="jill"></span>与消息一起发送到<span class="jill"></span>RabbitMQ。消费者在接收到消息后，可以记录已经处理的消息<span class="jill"></span>ID，并在处理消息之前检查该消息<span class="jill"></span>ID<span class="jill"></span>是否已经存在。如果消息<span class="jill"></span>ID<span class="jill"></span>已存在，则说明该消息已经被处理过，可以选择忽略重复的消息或进行相应的处理操作。</span></li><li id="oZzwdbJPSCV2qWPWPHMN2e"><div class="marker"></div><span class="inline-wrap"><b>消费者幂等性</b></span><span class="inline-wrap">：确保消费者的处理逻辑具备幂等性，即多次处理相同的消息不会产生额外的影响。这样即使消息被重复消费，也不会导致不一致状态。</span></li><li id="hhRZGPrCiTmJ6NSBcgD66N"><div class="marker"></div><span class="inline-wrap"><b>消息确认机制</b></span><span class="inline-wrap">：确保消息在被消费者成功处理后才被标记为已消费。RabbitMQ<span class="jill"></span>提供了消费者应答（ack）机制，只有在消息被成功处理后才发送<span class="jill"></span>ack，否则<span class="jill"></span>RabbitMQ<span class="jill"></span>会重新将消息放入队列。</span></li><li id="aoetPWKDftNjjqwi8MAAMW"><div class="marker"></div><span class="inline-wrap"><b>使用<span class="jill"></span>Redis<span class="jill"></span>实现幂等性</b></span><span class="inline-wrap">：可以利用<span class="jill"></span>Redis<span class="jill"></span>的原子性指令（如<span class="jill"></span>SETNX、SETEX、GETSET）来确保操作的原子性，从而避免重复消费。例如，在消费者处理消息前，可以使用<span class="jill"></span>setnx<span class="jill"></span>命令向<span class="jill"></span>Redis<span class="jill"></span>中插入一条数据，key<span class="jill"></span>是消息<span class="jill"></span>id，设置一个较短的过期时间。如果获取锁成功，则允许处理消息；否则，说明消息已经被其他消费者处理过了。</span></li><li id="pscLhmPXKBVFd9cQExiJ7K"><div class="marker"></div><span class="inline-wrap"><b>设置消息过期时间</b></span><span class="inline-wrap">：为消息设置合理的超时时间。如果消费者未能在指定时间内确认处理完成，RabbitMQ<span class="jill"></span>会将该消息重新投递给其他消费者进行处理。</span></li><li id="hDvHV1422YoRFFSj95hqf4"><div class="marker"></div><span class="inline-wrap"><b>使用第三方消息去重插件</b></span><span class="inline-wrap">：可以考虑使用第三方提供的消息去重插件，这些插件通常具有更高效的去重算法和更丰富的功能。</span></li><li id="qkxokd9Q9LPJwQBnAqxcRc"><div class="marker"></div><span class="inline-wrap"><b>合理配置消费者数量和重试机制</b></span><span class="inline-wrap">：通过限制消费者的数量或设定消费者之间的协调机制，可以避免多个消费者同时处理同一消息而导致的顺序错乱。同时，可以实现消息重试机制，确保在消息处理失败时能够重新进入队列供其他消费者重新消费。</span></li></ol><div id="bLhhYrYjUhxTRKBwEuuq8e" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，防止<span class="jill"></span>RabbitMQ<span class="jill"></span>消息重复消费需要综合考虑多种因素，包括消息去重、消费者幂等性、消息确认机制以及使用<span class="jill"></span>Redis<span class="jill"></span>等工具来实现幂等性等。在实际应用中，可以根据具体业务需求和系统架构来选择合适的策略和方法。</span></div></div><div id="nDmui4sEge2hnTZENmRrUe" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="nRKce1rNMsE7E2x4ReRDa8" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">如何解决消息队列的延时以及过期失效问题？</span></h1><div id="qoPqCeEe3JuDwhzs8ye2qW" class="wolai-block wolai-text"><div><span class="inline-wrap">解决消息队列的延时以及过期失效问题，需要从多个方面进行考虑和优化。以下是一些有效的策略：</span></div></div><ol class="wolai-block"><li id="jNXVf3ovJtCrMSxPR9oYJt"><div class="marker"></div><span class="inline-wrap"><b>合理设置消息的<span class="jill"></span>TTL（Time-To-Live）</b></span><span class="inline-wrap">：在<span class="jill"></span>RabbitMQ<span class="jill"></span>中，可以为每条消息设置一个<span class="jill"></span>TTL<span class="jill"></span>值，表示该消息在队列中的存活时间。如果消息在<span class="jill"></span>TTL<span class="jill"></span>时间内没有被消费，它将被自动删除。通过合理设置<span class="jill"></span>TTL，可以有效避免消息长时间滞留在队列中，从而减少资源浪费。</span></li><li id="33uNSSCQJjHmCykcUxWNCf"><div class="marker"></div><span class="inline-wrap"><b>使用死信队列（DLX）</b></span><span class="inline-wrap">：死信队列是一种特殊的队列，用于存储那些无法被正常消费的消息。当消息在队列中过期或达到最大重试次数时，这些消息将被发送到死信队列。通过监控死信队列，可以及时发现并处理异常情况，确保系统的健壮性。</span></li><li id="okRx5Mikvx2RQKVrqaFLM9"><div class="marker"></div><span class="inline-wrap"><b>优化消费者性能</b></span><span class="inline-wrap">：消费者处理消息的速度直接影响到消息在队列中的停留时间。因此，优化消费者的性能是解决消息延时问题的关键。可以通过以下几种方式来优化消费者性能：</span><ul class="wolai-block"><li id="mcf6HA6VYH7SuqkhGY9rqh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提高并发度</b></span><span class="inline-wrap">：增加消费者的数量，以提高消息的处理速度。但需要注意，过多的消费者可能会导致资源竞争，反而降低系统性能。因此，需要根据实际情况调整消费者数量，以达到最佳性能。</span></li><li id="gcx73zyugis3554FKeMoTC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优化代码逻辑</b></span><span class="inline-wrap">：检查消费者的代码逻辑，找出瓶颈并进行优化。例如，减少不必要的计算、优化数据库查询等。</span></li><li id="ty274kURqNRF3Yc51hQSLq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用异步处理</b></span><span class="inline-wrap">：将耗时的操作（如<span class="jill"></span>I/O<span class="jill"></span>操作、网络请求等）放在异步任务中执行，避免阻塞主线程。</span></li></ul></li><li id="fViUGTwUk8E16wbwQrm4WF"><div class="marker"></div><span class="inline-wrap"><b>合理配置<span class="jill"></span>RabbitMQ<span class="jill"></span>参数</b></span><span class="inline-wrap">：RabbitMQ<span class="jill"></span>提供了多种参数配置，可以根据实际需求进行调整。例如，可以调整预取计数（prefetch count），控制每个消费者一次最多接收多少条消息；可以调整帧大小（frame size），以适应大消息的处理。</span></li><li id="5BCTye4MZ9rDWfMfGobDVj"><div class="marker"></div><span class="inline-wrap"><b>使用优先级队列</b></span><span class="inline-wrap">：对于不同优先级的消息，可以使用优先级队列进行处理。高优先级的消息会优先被消费，从而减少低优先级消息的等待时间。</span></li><li id="rhq7XzSgaXCdHpmfQhJiSJ"><div class="marker"></div><span class="inline-wrap"><b>监控和报警</b></span><span class="inline-wrap">：建立完善的监控和报警机制，实时监控系统中消息的流动情况。当发现消息延迟或失效问题时，能够及时采取措施进行处理。</span></li><li id="eqeAz81V9GFUfNsg8q58ab"><div class="marker"></div><span class="inline-wrap"><b>定期清理过期消息</b></span><span class="inline-wrap">：虽然<span class="jill"></span>RabbitMQ<span class="jill"></span>会自动删除过期消息，但在某些情况下，可能需要手动清理过期消息。可以通过编写脚本定期扫描队列，删除过期的消息。</span></li></ol><div id="2xoPUGLYCKwjMGPe7CEM8A" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，解决消息队列的延时以及过期失效问题需要综合考虑多方面的因素，包括合理设置<span class="jill"></span>TTL、使用死信队列、优化消费者性能、合理配置<span class="jill"></span>RabbitMQ<span class="jill"></span>参数、使用优先级队列、建立监控和报警机制以及定期清理过期消息等。通过这些措施的综合应用，可以有效解决消息队列的延时以及过期失效问题，提高系统的可靠性和稳定性。</span></div></div><div id="51yA4ehzUxkXwV4rsGM42Y" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ry4LEbsUQLppJo5b8kfSfc" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">消息队列满了之后该如何处理？</span></h1><div id="vF2yodybcFV3sAyDUCPqo9" class="wolai-block wolai-text"><div><span class="inline-wrap">当消息队列满了之后，需要采取一系列措施来确保系统的稳定运行和数据的完整性。以下是一些有效的策略：</span></div></div><ol class="wolai-block"><li id="kz1tZJC3zz1tWttedikbLV"><div class="marker"></div><span class="inline-wrap"><b>增加队列容量</b></span><span class="inline-wrap">：如果消息队列满了，首先可以考虑增加队列的容量。这可以通过调整<span class="jill"></span>RabbitMQ<span class="jill"></span>的配置参数来实现，例如增加磁盘空间或调整内存限制。</span></li><li id="cwmp5PTsuovirFxhjc7N9b"><div class="marker"></div><span class="inline-wrap"><b>优化消费者性能</b></span><span class="inline-wrap">：如果增加队列容量无法解决问题，那么需要优化消费者的性能。可以通过以下几种方式来提高消费者的处理速度：</span><ul class="wolai-block"><li id="rzQDyNQyhbfTCXuihnGtof"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提高并发度</b></span><span class="inline-wrap">：增加消费者的数量，以提高消息的处理速度。但需要注意，过多的消费者可能会导致资源竞争，反而降低系统性能。因此，需要根据实际情况调整消费者数量，以达到最佳性能。</span></li><li id="pXuqQnhTwbzPyV2P6WfucQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优化代码逻辑</b></span><span class="inline-wrap">：检查消费者的代码逻辑，找出瓶颈并进行优化。例如，减少不必要的计算、优化数据库查询等。</span></li><li id="8uFcafsbFQtox2NuJnAn6u"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用异步处理</b></span><span class="inline-wrap">：将耗时的操作（如<span class="jill"></span>I/O<span class="jill"></span>操作、网络请求等）放在异步任务中执行，避免阻塞主线程。</span></li></ul></li><li id="93EZNB5bnFyHomXrXmqYBK"><div class="marker"></div><span class="inline-wrap"><b>使用优先级队列</b></span><span class="inline-wrap">：对于不同优先级的消息，可以使用优先级队列进行处理。高优先级的消息会优先被消费，从而减少低优先级消息的等待时间。</span></li><li id="fYxrvZ5PA9yQsNfbcoUDb6"><div class="marker"></div><span class="inline-wrap"><b>设置合理的<span class="jill"></span>TTL</b></span><span class="inline-wrap">：为消息设置合理的<span class="jill"></span>TTL<span class="jill"></span>值，表示该消息在队列中的存活时间。如果消息在<span class="jill"></span>TTL<span class="jill"></span>时间内没有被消费，它将被自动删除。通过合理设置<span class="jill"></span>TTL，可以有效避免消息长时间滞留在队列中，从而减少资源浪费。</span></li><li id="fCE1yNiz2bBX7DR8KSHcLn"><div class="marker"></div><span class="inline-wrap"><b>使用死信队列（DLX）</b></span><span class="inline-wrap">：死信队列是一种特殊的队列，用于存储那些无法被正常消费的消息。当消息在队列中过期或达到最大重试次数时，这些消息将被发送到死信队列。通过监控死信队列，可以及时发现并处理异常情况，确保系统的健壮性。</span></li><li id="2c68fELBEDPAgNfvmiJRTs"><div class="marker"></div><span class="inline-wrap"><b>建立报警机制</b></span><span class="inline-wrap">：建立完善的报警机制，实时监控系统中消息的流动情况。当发现消息延迟或失效问题时，能够及时采取措施进行处理。</span></li><li id="gfjzDADg8V5qFng51Tz66X"><div class="marker"></div><span class="inline-wrap"><b>定期清理过期消息</b></span><span class="inline-wrap">：虽然<span class="jill"></span>RabbitMQ<span class="jill"></span>会自动删除过期消息，但在某些情况下，可能需要手动清理过期消息。可以通过编写脚本定期扫描队列，删除过期的消息。</span></li><li id="6NPZavcxWmJba1f54EpbBe"><div class="marker"></div><span class="inline-wrap"><b>分布式部署</b></span><span class="inline-wrap">：如果单节点的<span class="jill"></span>RabbitMQ<span class="jill"></span>无法满足需求，可以考虑采用分布式部署的方式，将消息队列分布在多个节点上，从而提高系统的吞吐量和可靠性。</span></li></ol><div id="tmXSaUMZqQb5Zumf2t31AY" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，当消息队列满了之后，需要综合考虑多方面的因素，采取一系列措施来确保系统的稳定运行和数据的完整性。通过增加队列容量、优化消费者性能、使用优先级队列、设置合理的<span class="jill"></span>TTL、使用死信队列、建立报警机制、定期清理过期消息以及分布式部署等方法，可以有效解决消息队列满的问题，提高系统的可靠性和稳定性。</span></div></div><div id="gJHdnXfCrmeJrC6f8DULp5" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="w3HRrBhmPDzFxq5QgcJpZZ" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">有几百万的消息持续积压几小时，这种情况如何解决？</span></h1><div id="42Dka4AByMAaMnSitCfvCL" class="wolai-block wolai-text"><div><span class="inline-wrap">当消息队列中积压了几百万条消息，且这种情况持续了几小时，需要采取紧急措施来解决问题。以下是一些有效的策略：</span></div></div><ol class="wolai-block"><li id="eKXhiWqVD9EJnCLBvPXycL"><div class="marker"></div><span class="inline-wrap"><b>增加消费者数量</b></span><span class="inline-wrap">：如果当前消费者的处理速度无法满足积压的消息量，可以考虑临时增加消费者的数量。通过增加更多的消费者实例，可以加快消息的处理速度，从而减少积压的时间。</span></li><li id="pP9X1xvJu6o21PVRruNFjk"><div class="marker"></div><span class="inline-wrap"><b>优化消费者性能</b></span><span class="inline-wrap">：除了增加消费者数量外，还需要优化消费者的代码逻辑和性能。可以通过以下几种方式来提高消费者的处理速度：</span><ul class="wolai-block"><li id="kTfFs2bmncV8RLcXtSpzYU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提高并发度</b></span><span class="inline-wrap">：增加消费者的数量，以提高消息的处理速度。但需要注意，过多的消费者可能会导致资源竞争，反而降低系统性能。因此，需要根据实际情况调整消费者数量，以达到最佳性能。</span></li><li id="q7jMbekbh93RECe58z1upW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优化代码逻辑</b></span><span class="inline-wrap">：检查消费者的代码逻辑，找出瓶颈并进行优化。例如，减少不必要的计算、优化数据库查询等。</span></li><li id="gXqBru5cAEAtj6pvr1yXtZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>使用异步处理</b></span><span class="inline-wrap">：将耗时的操作（如<span class="jill"></span>I/O<span class="jill"></span>操作、网络请求等）放在异步任务中执行，避免阻塞主线程。</span></li></ul></li><li id="tKKV9APKUpXe4K7CejzSmQ"><div class="marker"></div><span class="inline-wrap"><b>设置合理的<span class="jill"></span>TTL</b></span><span class="inline-wrap">：为消息设置合理的<span class="jill"></span>TTL<span class="jill"></span>值，表示该消息在队列中的存活时间。如果消息在<span class="jill"></span>TTL<span class="jill"></span>时间内没有被消费，它将被自动删除。通过合理设置<span class="jill"></span>TTL，可以有效避免消息长时间滞留在队列中，从而减少资源浪费。</span></li><li id="wfRKnq54wcBho5k4Ahe8kK"><div class="marker"></div><span class="inline-wrap"><b>使用死信队列（DLX）</b></span><span class="inline-wrap">：死信队列是一种特殊的队列，用于存储那些无法被正常消费的消息。当消息在队列中过期或达到最大重试次数时，这些消息将被发送到死信队列。通过监控死信队列，可以及时发现并处理异常情况，确保系统的健壮性。</span></li><li id="34ZrEkNa7Csf6nqvm1Vx7m"><div class="marker"></div><span class="inline-wrap"><b>建立报警机制</b></span><span class="inline-wrap">：建立完善的报警机制，实时监控系统中消息的流动情况。当发现消息延迟或失效问题时，能够及时采取措施进行处理。</span></li><li id="hXwMYXTJ5nnz8THZT3swWB"><div class="marker"></div><span class="inline-wrap"><b>定期清理过期消息</b></span><span class="inline-wrap">：虽然<span class="jill"></span>RabbitMQ<span class="jill"></span>会自动删除过期消息，但在某些情况下，可能需要手动清理过期消息。可以通过编写脚本定期扫描队列，删除过期的消息。</span></li><li id="srMRuuqGUgypsTejqyLPr8"><div class="marker"></div><span class="inline-wrap"><b>分布式部署</b></span><span class="inline-wrap">：如果单节点的<span class="jill"></span>RabbitMQ<span class="jill"></span>无法满足需求，可以考虑采用分布式部署的方式，将消息队列分布在多个节点上，从而提高系统的吞吐量和可靠性。</span></li><li id="61Wdvps1vKfrVdRPG3UYKM"><div class="marker"></div><span class="inline-wrap"><b>临时扩容</b></span><span class="inline-wrap">：如果以上方法都无法解决问题，可以考虑临时扩容，即增加更多的服务器或节点来分担消息的处理压力。这可以通过增加<span class="jill"></span>RabbitMQ<span class="jill"></span>集群的节点数来实现。</span></li><li id="fM5SqezdQttn4fxKRBT6Br"><div class="marker"></div><span class="inline-wrap"><b>数据迁移</b></span><span class="inline-wrap">：对于已经积压的消息，可以考虑将其迁移到其他系统或服务进行处理。例如，可以将消息导出到文件或数据库中，然后通过其他系统进行批量处理。</span></li></ol><div id="vrWMHEWqC33fK4tee9ToGP" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，当消息队列中积压了几百万条消息，且这种情况持续了几小时时，需要采取一系列紧急措施来解决。通过增加消费者数量、优化消费者性能、设置合理的<span class="jill"></span>TTL、使用死信队列、建立报警机制、定期清理过期消息、分布式部署、临时扩容以及数据迁移等方法，可以有效解决消息积压的问题，恢复系统的正常运行。</span></div></div><div id="rovMXzy2SNEyRFZn5VfsjT" class="wolai-block wolai-text"><div></div></div><div id="qxgQaGSTkrBxziLSGZoQ9Z" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div></article><footer></footer></body></html>