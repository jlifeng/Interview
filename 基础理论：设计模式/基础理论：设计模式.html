<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>基础理论：设计模式 - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="基础理论：设计模式" class="main-title"></div></div></header><article><h1 id="dS2iQBiZHn7TwCv4nU9nUF" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">什么是设计模式？有什么好处？</span></h1><h2 id="gRr6Fw9aqY6uke73BAKPaG" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">背记</span></h2><div id="eZgaQubkNnvVBmA7C2HniG" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式是一种经过验证的解决特定问题的软件设计思想，不是具体的实现代码，而是关于类和对象之间交互和组织的一种结构化的描述。  </span></div></div><div id="dnKjonkPi9wSz8dAsTjPb1" class="wolai-block wolai-text"><div><span class="inline-wrap">优点：</span></div></div><div id="qNEucDwR9MoLsdteQT6Mw3" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式是一种被广泛应用的软件设计思想，通过提供通用的解决方案，提高了代码的重用性、可维护性、可扩展性和团队协作效率，同时也提高了软件系统的可靠性</span></div></div><div id="nPWCMs6F1bz2bQJvAT6E9N" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eLBoR2Ue6FwAs2rZDPXk98" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">理解</span></h2><div id="oSiyrbfqtCKohagkbuFonP" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式是解决软件设计问题的通用解决方案，它的好处在于增加了系统的可重用性、健壮性、易修改性和可扩展性。</span></div></div><div id="okLwewmwwr1c96ecMUeZCU" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式源于面向对象编程的四大基本特性：封装、抽象、继承和多态。它们是软件开发中的最佳实践，由经验丰富的开发人员所采用，用于解决共通的问题。设计模式并非语法规定，而是一套成熟的套路或模板，用来处理特定情况下的设计问题，提高代码的可复用性和可维护性。</span></div></div><div id="6aaxy1evVJDPecaQYpyBrR" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式的优势具体体现在以下几个方面：</span></div></div><ol class="wolai-block"><li id="6o1VvacXQjNk95Bvj83D9o"><div class="marker"></div><span class="inline-wrap"><b>可重用性</b></span><span class="inline-wrap">：设计模式提供了经过验证的解决方案，这些方案可以在不同的软件项目中重复使用，节省了开发时间和资源。</span></li><li id="m92eP4gwpxoHdYvntg3JHP"><div class="marker"></div><span class="inline-wrap"><b>与语言无关</b></span><span class="inline-wrap">：设计模式是一种思想，并不依赖于特定的编程语言，这意味着它们的原则和概念可以跨语言应用。</span></li><li id="9kYYraijqAuwT85L4MWGtR"><div class="marker"></div><span class="inline-wrap"><b>描述问题的通用词汇</b></span><span class="inline-wrap">：设计模式为开发者提供了一套共同的术语，使得在讨论软件设计时能够有更清晰的交流。</span></li><li id="q6gL1G1W63rLJNwfkc5G5G"><div class="marker"></div><span class="inline-wrap"><b>系统稳定性和灵活性</b></span><span class="inline-wrap">：在大型软件开发中，合理运用设计模式可以增强系统的稳定性，使系统易于修改和扩展。</span></li><li id="6comt54syLuvEna52q1XFz"><div class="marker"></div><span class="inline-wrap"><b>面向对象设计原则的实践</b></span><span class="inline-wrap">：设计模式是对类的封装性、继承性、多态性以及类之间关系理解的实际应用，有助于提升软件质量。</span></li></ol><div id="hV5JBcPhuvyhtsvs2f6fAC" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，设计模式不仅帮助开发者高效解决特定问题，而且通过提供可靠的设计框架来提升软件的整体质量和未来的可维护性。</span></div></div><div id="m2ePn7yVU4pNbY89BqxYnr" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="6mkYqqgvUnF64dBdC175WL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="pPgJxwJWMPz45od3YXYDM1" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">设计模式的<span class="jill"></span>7<span class="jill"></span>大基本原则有哪些？</span></h1><h2 id="a9hg9kyHzDRmM5NXSewhbU" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">背记</span></h2><div id="8XoFZJrFL4ckFHNQKXbfab" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式的<span class="jill"></span>7<span class="jill"></span>大基本原则指的是单一职责原则、开放-关闭原则、里氏替换原则、依赖倒转原则、接口隔离原则、迪米特法则和组合/聚合复用原则</span></div></div><div id="4thmNjc5VjPHEZ6ZBMvReV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sSPSmZimia51dNfHiM2Bvg" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">理解</span></h2><div id="upBjhm4ZMaiyWbwfVCPqCP" class="wolai-block wolai-text"><div><span class="inline-wrap">设计模式的<span class="jill"></span>7<span class="jill"></span>大基本原则是指软件设计中的基本原则和准则，它们可以指导我们在使用设计模式时做出正确的设计决策。这些原则包括：</span></div></div><ol class="wolai-block"><li id="g8g4MsEF4ByzE3gjL9ytAZ"><div class="marker"></div><span class="inline-wrap"><b>单一职责原则</b></span><span class="inline-wrap">（Single Responsibility Principle，SRP）：一个类只负责一项职责。一个类应该只有一个引起它变化的原因。</span></li><li id="2So32QtpPo7soVBWiUHB6Q"><div class="marker"></div><span class="inline-wrap"><b>开放封闭原则</b></span><span class="inline-wrap">（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。通过抽象和多态来实现对软件实体的扩展，而不是通过修改已有的代码。</span></li><li id="iRL2XDekeDmpr9LxkfRuJ8"><div class="marker"></div><span class="inline-wrap"><b>里氏替换原则</b></span><span class="inline-wrap">（Liskov Substitution Principle，LSP）：子类应该能够替换掉父类并且工作正常，子类必须能够完全替代父类的行为。</span></li><li id="f8T7TRaheR52zkSmk4SCpR"><div class="marker"></div><span class="inline-wrap"><b>依赖倒置原则</b></span><span class="inline-wrap">（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</span></li><li id="5SjgJh4Abozw8wotbGCZ3a"><div class="marker"></div><span class="inline-wrap"><b>接口隔离原则</b></span><span class="inline-wrap">（Interface Segregation Principle，ISP）：客户端不应该依赖它不需要的接口。类之间的依赖关系应该建立在最小的接口上。</span></li><li id="429rsSJjmWodma9W5X3GDc"><div class="marker"></div><span class="inline-wrap"><b>迪米特法则</b></span><span class="inline-wrap">（Law of Demeter，LoD）：一个对象应该对其他对象有尽可能少的了解。只与其直接的朋友进行通信，不需要了解朋友的朋友。</span></li><li id="sLcpMKZPwWPEK8tBrdAqgU"><div class="marker"></div><span class="inline-wrap"><b>合成复用原则</b></span><span class="inline-wrap">（Composite Reuse Principle，CRP）：尽量使用对象组合和聚合，而不是继承来达到复用的目的。通过组合已有的对象来实现新的功能。</span></li></ol><div id="aVXJMcGY3aiwQvWDqbdoyD" class="wolai-block wolai-text"><div><span class="inline-wrap">这些原则旨在指导我们进行良好的软件设计，提高软件的可读性、可维护性、可扩展性和可测试性。</span></div></div><div id="bMe1xQYRauEzEvWLGoaafK" class="wolai-block wolai-text"><div><span class="inline-wrap">同时，它们也是设计模式的基础，设计模式的目的就是通过遵循这些原则来实现灵活、可复用和可扩展的软件系统。</span></div></div><div id="wuhBiEiruYkWKQienLerWz" class="wolai-block wolai-text"><div></div></div><div id="eEzLX9yv9WoJttNP37ZzPk" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="fGPHMrqzyKK8HNszaEpK31" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">使用哪种设计模式可以提高代码可维护性？</span></h1><div id="dcznqCG1yq2vBZQAvYVyKY" class="wolai-block wolai-text"><div><span class="inline-wrap">其实设计模式存在的意义本身就是为了提高代码的可维护性、可读性和可扩展性。设计模式提供了经过验证的解决方案，用于解决常见的软件设计问题，使开发者能够更高效地编写和理解代码。</span></div></div><div id="pvb1Z4y4tBBaGo5W4ZdkJL" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一些常见的设计模式及其目的：</span></div></div><ol class="wolai-block"><li id="4bTxWSiE9o3AWYkpkfvZst"><div class="marker"></div><span class="inline-wrap"><b>单例模式（Singleton）</b></span><span class="inline-wrap">：确保一个类只有一个实例，并提供一个全局访问点。</span></li><li id="ptbvAtvNob1oyQrHxwyYjK"><div class="marker"></div><span class="inline-wrap"><b>工厂模式（Factory）</b></span><span class="inline-wrap">：定义一个创建对象的接口，但让子类决定实例化哪个类。</span></li><li id="7zNVXhWPxhiEEX5EZGc6qx"><div class="marker"></div><span class="inline-wrap"><b>观察者模式（Observer）</b></span><span class="inline-wrap">：定义对象间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会收到通知并自动更新。</span></li><li id="kFBp7H1oh8M4W5JHQKzv5y"><div class="marker"></div><span class="inline-wrap"><b>策略模式（Strategy）</b></span><span class="inline-wrap">：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。</span></li><li id="bGncKQko49k8vWhvgVEJMg"><div class="marker"></div><span class="inline-wrap"><b>装饰器模式（Decorator）</b></span><span class="inline-wrap">：动态地给一个对象添加一些额外的职责。</span></li><li id="4Z1CyvKubTAHjGeokEFQEC"><div class="marker"></div><span class="inline-wrap"><b>适配器模式（Adapter）</b></span><span class="inline-wrap">：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></li><li id="8nJWrRw2rQFUV44F9kEq5L"><div class="marker"></div><span class="inline-wrap"><b>命令模式（Command）</b></span><span class="inline-wrap">：将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。</span></li><li id="4LyLp5ehDnqzXfyCm5Cotd"><div class="marker"></div><span class="inline-wrap"><b>模板方法模式（Template Method）</b></span><span class="inline-wrap">：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</span></li><li id="9g2LYDu3waxXo5ep6TBy1w"><div class="marker"></div><span class="inline-wrap"><b>迭代器模式（Iterator）</b></span><span class="inline-wrap">：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</span></li></ol><div id="o911PXwFVUsP3rTJyfyHvw" class="wolai-block wolai-text"><div><span class="inline-wrap">这些设计模式通过提供通用的解决方案，帮助开发者避免重复劳动，减少错误，并使代码更加清晰和易于维护。</span></div></div><div id="io66ZGJ2ifYqtApdonyqfp" class="wolai-block wolai-text"><div></div></div><div id="a3ELx9LvZGQHefHvuW4hRx" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="aGq9UaiFshBxKCmY4FkPDZ" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">在<span class="jill"></span>23<span class="jill"></span>种常用设计模式中，哪些是用来提高代码复用程度的？</span></h1><div id="6cjsMJYijFNyNkgY4U4o8" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>23<span class="jill"></span>种常用设计模式中，</span><span class="inline-wrap"><b>单例模式、工厂模式、观察者模式、享元模式、桥接模式和模板方法模式</b></span><span class="inline-wrap">是用来提高代码复用程度的。下面将详细介绍这些设计模式：</span></div></div><ol class="wolai-block"><li id="jmXfzynbqv44iDyDHrBGHd"><div class="marker"></div><span class="inline-wrap"><b>单例模式</b></span><ul class="wolai-block"><li id="2uPYVvD5VEpoNemBeNGXu3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问点[^1^]。</span></li><li id="bZVRWNiVCnzFxaMo8XkMfK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于需要频繁创建和销毁的对象，例如数据库连接池或线程池[^1^]。</span></li><li id="hZ1PbAKJ6JUpbSFHSTwDG7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：通过控制实例数目来减少系统内存开销，同时避免对资源的多重占用[^1^]。</span></li></ul></li><li id="hbhVRBfwbuf9q9evWkqA4K"><div class="marker"></div><span class="inline-wrap"><b>工厂模式</b></span><ul class="wolai-block"><li id="mPnfvLyctpVDoXDkkuh2kb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式，通过工厂类封装对象的创建逻辑[^1^]。</span></li><li id="wQ1n3Dc5F52WdSZ9HqjZMC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于创建过程复杂或者创建过程容易出错的对象[^1^]。</span></li><li id="tipJzNNzVyVZcRqKNaz45V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：客户端无需关心对象的创建细节，提高了代码的灵活性和可维护性[^1^]。</span></li></ul></li><li id="r3j2Fo4NYDn1wjWdmGEGBf"><div class="marker"></div><span class="inline-wrap"><b>观察者模式</b></span><ul class="wolai-block"><li id="hr3YWhAJhCwNFmEU3d5XaQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：观察者模式是一种行为型设计模式，定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新[^1^]。</span></li><li id="f3vAiTo1vDyzejZkDgRxPe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于对象间存在大量依赖关系的情况，如<span class="jill"></span>GUI<span class="jill"></span>事件处理、订阅发布系统等[^1^]。</span></li><li id="v5Qw5crMu9wgYE6si4Nvnv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：支持广播通信，自动通知所有依赖对象，提高了系统的扩展性和灵活性[^1^]。</span></li></ul></li><li id="46qBdvTxos8aCqpBTRdp8o"><div class="marker"></div><span class="inline-wrap"><b>享元模式</b></span><ul class="wolai-block"><li id="qgGWPGhFvJAN3XZdkGj8xN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：享元模式是一种结构型设计模式，通过共享技术有效地支持大量细粒度对象的复用[^2^][^3^]。</span></li><li id="ezf2SivgVcAA1b7JcqkpS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于系统中有大量相似对象的场景，如缓存实现、数据库连接管理等[^2^][^3^]。</span></li><li id="7fbm6mKxBNGg4bxFM9xHtz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：显著减少了内存中对象的数量，降低了内存的使用和提高了性能[^2^][^3^]。</span></li></ul></li><li id="jMsqntwDozXf9JYxVzmFFF"><div class="marker"></div><span class="inline-wrap"><b>桥接模式</b></span><ul class="wolai-block"><li id="nnSgpNKwLKHFJf9YB7m2SS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：桥接模式是一种结构型设计模式，将抽象部分与实现部分分离，使它们可以独立变化[^2^][^3^]。</span></li><li id="8xQCLTBcTyE9tWBdx3iht4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于不希望在抽象和实现之间建立一个固定的绑定关系的场景[^2^][^3^]。</span></li><li id="3BeYKFetTpVErFUn795Ao"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：实现了抽象和实现的分离，提高了系统的灵活性和扩展性[^2^][^3^]。</span></li></ul></li><li id="f9hYZpeWvTUtVx27XPwyZh"><div class="marker"></div><span class="inline-wrap"><b>模板方法模式</b></span><ul class="wolai-block"><li id="48anE7WTRo2JksP11ATvij"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：模板方法模式是一种行为型设计模式，定义了一个操作中的算法框架，而将一些步骤延迟到子类中[^2^][^3^]。</span></li><li id="9tEiwyCfaXbPWizr25yXny"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>应用场景</b></span><span class="inline-wrap">：适用于多个子类具有共同的方法但具体实现不同的情况[^2^][^3^]。</span></li><li id="2yCsN2wtXSMjdfLroWt3ht"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：通过继承复用公共的方法，避免了代码重复，提高了代码的可维护性[^2^][^3^]。</span></li></ul></li></ol><div id="fW2tgAJY8eeX3VZsobcXwQ" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，这些设计模式各有其适用场景和优势，通过合理选择和应用这些设计模式，可以大大提高代码的复用性，降低系统的复杂度和维护成本。</span></div></div><div id="tBtREH67ppTQeuKBY5xqzm" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="k966sBhoMkUgEXxPHNRFWa" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">你在工作中是如何使用设计模式的？</span></h1><h2 id="odW9mHDQYnJdRP6PKyRC8T" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">背记</span></h2><div id="kSGPsYdNtn1uNSU5LyUUTa" class="wolai-block wolai-text"><div><span class="inline-wrap">根据下面各个设计模式，选择至少<span class="jill"></span>5<span class="jill"></span>个模式进行理解和背记，最好结合项目中具体的使用场景</span></div></div><div id="f6PwLhbMZ8neex3yaTTQaq" class="wolai-block wolai-text"><div><span class="inline-wrap">计模式根据其使用场景和解决的问题可以分为创建型、结构型和行为型三种类型。以下是一些常见设计模式及其具体使用场景：</span></div></div><h3 id="rE5qUSaGHCKwWJkMHqTzDz" class="wolai-block"><span class="wolai-serial-number">5.1.1</span><span class="inline-wrap">创建型设计模式</span></h3><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="8dhxQsFxxBf22LoRQbvTcN" class="wolai-block wolai-text"><div><span class="inline-wrap">模式名称</span></div></div><span class="inline-wrap"></span><br/><div id="kC272viEkGt2rDCyiASYWB" class="wolai-block wolai-text"><div><span class="inline-wrap">工厂方法模式</span></div></div><span class="inline-wrap"></span><br/><div id="ePdPq7q1gf5t54tbwqbMoH" class="wolai-block wolai-text"><div><span class="inline-wrap">抽象工厂模式</span></div></div><span class="inline-wrap"></span><br/><div id="t6Teg2axvyYK521Drtbviz" class="wolai-block wolai-text"><div><span class="inline-wrap">单例模式</span></div></div><span class="inline-wrap"></span><br/><div id="kqGHS6osEeuwh2t5nFeKTs" class="wolai-block wolai-text"><div><span class="inline-wrap">应用场景</span></div></div><span class="inline-wrap"></span><br/><div id="sKXALfQphkT4mcexzWd59t" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个类无法明确知道需要创建哪个类的实例时，可以使用工厂方法模式来创建对象的实例</span></div></div><span class="inline-wrap"></span><br/><div id="9sg8YBvfUC1tx69eq7H5F" class="wolai-block wolai-text"><div><span class="inline-wrap">适用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类</span></div></div><span class="inline-wrap"></span><br/><div id="mrSGosTdQushyroF1g6naY" class="wolai-block wolai-text"><div><span class="inline-wrap">用于确保一个类只有一个实例，并提供一个全局访问点</span></div></div><span class="inline-wrap"></span><br/><div id="hSXpn39fdwD5t9K5xEFqno" class="wolai-block wolai-text"><div><span class="inline-wrap">建造者模式</span></div></div><span class="inline-wrap"></span><br/><div id="3BTBbB4Pf3WZBwAwcnTCRq" class="wolai-block wolai-text"><div><span class="inline-wrap">当创建一个复杂对象需要很多步骤时，将这些步骤从该对象的构造函数中分离</span><span class="inline-wrap">出来</span></div></div><span class="inline-wrap"></span><br/><div id="sjHeMUoxYxFPrPUoFPWXeF" class="wolai-block wolai-text"><div><span class="inline-wrap">原型模式</span></div></div><span class="inline-wrap"></span><br/><div id="oxFQfbD6mAATLcMLVJBhQr" class="wolai-block wolai-text"><div><span class="inline-wrap">适用于创建对象成本较大，或者创建的对象数量不确定的情况</span></div></div><h3 id="vgDgRJGGbWcur1j3Xh2LWH" class="wolai-block"><span class="wolai-serial-number">5.1.2</span><span class="inline-wrap">结构型设计模式</span></h3><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="9ziZzFvT5Rp53aUgYrgQqY" class="wolai-block wolai-text"><div><span class="inline-wrap">模式名称</span></div></div><span class="inline-wrap"></span><br/><div id="uMfqy7RHMnzsGqEH48VsYZ" class="wolai-block wolai-text"><div><span class="inline-wrap">适配器模式</span></div></div><span class="inline-wrap"></span><br/><div id="p7wRrFwuxo3VgbErVFUpRQ" class="wolai-block wolai-text"><div><span class="inline-wrap">装饰器模式</span></div></div><span class="inline-wrap"></span><br/><div id="uVhk9oX3FWdaTYV8j3YdgP" class="wolai-block wolai-text"><div><span class="inline-wrap">代理模式</span></div></div><span class="inline-wrap"></span><br/><div id="vpfb7apYGQKJDsRE1Euo3H" class="wolai-block wolai-text"><div><span class="inline-wrap">应用场景</span></div></div><span class="inline-wrap"></span><br/><div id="48QVo7CPgcWWiCPvsJwURC" class="wolai-block wolai-text"><div><span class="inline-wrap">用于将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作</span></div></div><span class="inline-wrap"></span><br/><div id="eWDDSHywDHom2uMs4hPBk" class="wolai-block wolai-text"><div><span class="inline-wrap">用于动态地给一个对象添加额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活</span></div></div><span class="inline-wrap"></span><br/><div id="k9z9J1QLv25vfNpUUnfBgy" class="wolai-block wolai-text"><div><span class="inline-wrap">为其他对象提供一种代理以控制对这个对象的访问</span></div></div><span class="inline-wrap"></span><br/><div id="pSLD1PtUceiDKLHFygtkqS" class="wolai-block wolai-text"><div><span class="inline-wrap">外观模式</span></div></div><span class="inline-wrap"></span><br/><div id="k88u5NE9JzyRPSXPDJdR8E" class="wolai-block wolai-text"><div><span class="inline-wrap">用于简化接口或为多个复杂的子系统提供一个统一的高级接口</span></div></div><span class="inline-wrap"></span><br/><div id="kbAVkifyatuvPjkDSPVvyK" class="wolai-block wolai-text"><div><span class="inline-wrap">桥接模式</span></div></div><span class="inline-wrap"></span><br/><div id="rqqy1xVB5T7Cc4JGgCPYUt" class="wolai-block wolai-text"><div><span class="inline-wrap">用于将抽象部分与实现部分分离，使它们可以独立地变化</span></div></div><h3 id="4eRx78E4iGTK6nCpkzDegL" class="wolai-block"><span class="wolai-serial-number">5.1.3</span><span class="inline-wrap">行为型设计模式</span></h3><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="drfs56Pp8ZCDrdSi1JTjzS" class="wolai-block wolai-text"><div><span class="inline-wrap">模式名称</span></div></div><span class="inline-wrap"></span><br/><div id="4UjggdAgpErSYsj1ADG4Kp" class="wolai-block wolai-text"><div><span class="inline-wrap">策略模式</span></div></div><span class="inline-wrap"></span><br/><div id="83HZhSr5xJZ3NhaQkqoV6c" class="wolai-block wolai-text"><div><span class="inline-wrap">观察者模式</span></div></div><span class="inline-wrap"></span><br/><div id="cDgvqfs2tkNVuW11Vva4dh" class="wolai-block wolai-text"><div><span class="inline-wrap">迭代器模式</span></div></div><span class="inline-wrap"></span><br/><div id="3H8MRSsLwdAFDWaJwMFg84" class="wolai-block wolai-text"><div><span class="inline-wrap">应用场景</span></div></div><span class="inline-wrap"></span><br/><div id="jxVrGZ7e26cHWQQuw1LMM9" class="wolai-block wolai-text"><div><span class="inline-wrap">用于定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换</span></div></div><span class="inline-wrap"></span><br/><div id="cSRNgeWWErCb7yTroka4Pg" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</span></div></div><span class="inline-wrap"></span><br/><div id="iHMzDfZXm1XB6zq3tTb2nG" class="wolai-block wolai-text"><div><span class="inline-wrap">提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表</span><span class="inline-wrap">示</span></div></div><span class="inline-wrap"></span><br/><div id="rmUEwAWQXr4cF7Q9e2pxPk" class="wolai-block wolai-text"><div><span class="inline-wrap">命令模式</span></div></div><span class="inline-wrap"></span><br/><div id="7R89b4giRXfLkRhjgAzvfG" class="wolai-block wolai-text"><div><span class="inline-wrap">将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化</span></div></div><span class="inline-wrap"></span><br/><div id="a8dUWavUf515JTu4X6QACN" class="wolai-block wolai-text"><div><span class="inline-wrap">状态模式</span></div></div><span class="inline-wrap"></span><br/><div id="vyNj65bCdh69nJzTDZM5E8" class="wolai-block wolai-text"><div><span class="inline-wrap">用于在对象的内部状态改变时改变其行为</span></div></div><span class="inline-wrap"></span><br/><div id="5CqnYZeSJMP3vw417Lf1t9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><span class="inline-wrap"></span><br/><div id="hXnvrKg1tZ1STvP4kGeZz1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="oBb61XcF2QN7HPB7Nnxrqe" class="wolai-block wolai-text"><div><span class="inline-wrap">这些设计模式的具体使用场景可能会根据实际的软件开发需求和环境而有所不同。在实际开发中，选择合适的设计模式可以有效地提高代码的可读性、可维护性和可扩展性。</span></div></div><div id="vEMLCvEcb9SJ1ZUkwQJNDW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hsoBLPkeEpRrJNCiFGAxuu" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">理解  </span></h2><div id="goCNUBpzvnn5sim2LxxtGp" class="wolai-block wolai-text"><div><span class="inline-wrap">SSM<span class="jill"></span>框架（Spring + Spring MVC + MyBatis）是<span class="jill"></span>Java<span class="jill"></span>开发中常用的一种整合方案，它集成了<span class="jill"></span>Spring、Spring MVC<span class="jill"></span>和<span class="jill"></span>MyBatis<span class="jill"></span>三个流行的开源框架。在<span class="jill"></span>SSM<span class="jill"></span>框架中，使用了多种设计模式来提高代码的可维护性、可扩展性和灵活性。以下是一些在<span class="jill"></span>SSM<span class="jill"></span>框架中使用的设计模式：</span></div></div><ol class="wolai-block"><li id="dtXmgwGnXJipdmHqaScWLJ"><div class="marker"></div><span class="inline-wrap">单例模式：在<span class="jill"></span>Spring<span class="jill"></span>框架中，默认情况下，Bean<span class="jill"></span>是单例的，即在整个应用中只有一个实例。这是通过单例模式实现的，确保了资源的有效利用和性能优化。</span></li><li id="kxnCJX94696tcYGknfFG7E"><div class="marker"></div><span class="inline-wrap">工厂模式：在<span class="jill"></span>Spring<span class="jill"></span>框架中，IoC<span class="jill"></span>容器通过工厂模式创建<span class="jill"></span>Bean<span class="jill"></span>实例。开发者只需要配置好相应的配置文件，Spring<span class="jill"></span>容器会自动创建所需的<span class="jill"></span>Bean<span class="jill"></span>实例，无需手动创建对象。</span></li><li id="4ZvgYHubBtWtqGmLHGnoMy"><div class="marker"></div><span class="inline-wrap">模板方法模式：在<span class="jill"></span>Spring MVC<span class="jill"></span>中，Controller<span class="jill"></span>的处理方法通常使用模板方法模式。Controller<span class="jill"></span>类定义了处理请求的模板方法，具体的子类可以实现这些方法以完成具体的业务逻辑。</span></li><li id="kGAsohSUyF2uM8HKSrhBcW"><div class="marker"></div><span class="inline-wrap">策略模式：在<span class="jill"></span>Spring<span class="jill"></span>框架中，通过使用策略模式，可以轻松地更换算法或策略。例如，可以通过更换不同的视图解析器来改变视图的解析策略。</span></li><li id="paZTUVABR5UNNG443Y5p1j"><div class="marker"></div><span class="inline-wrap">观察者模式：在<span class="jill"></span>Spring<span class="jill"></span>中，事件发布/订阅机制使用了观察者模式。当一个事件发生时，所有注册为该事件的监听器都会自动收到通知。</span></li><li id="e5tQ68isEwEeqBZsYWt791"><div class="marker"></div><span class="inline-wrap">装饰器模式：在<span class="jill"></span>Spring<span class="jill"></span>中，通过使用装饰器模式，可以为一个对象动态添加功能。例如，通过为一个<span class="jill"></span>Bean<span class="jill"></span>添加不同的<span class="jill"></span>AOP<span class="jill"></span>切面，可以为该<span class="jill"></span>Bean<span class="jill"></span>添加额外的功能。</span></li><li id="7ukoGCpgqr7aXRCfAGZeSe"><div class="marker"></div><span class="inline-wrap">代理模式：在<span class="jill"></span>MyBatis<span class="jill"></span>中，通过使用代理模式，可以实现对数据库操作的拦截和增强。</span></li></ol><div id="9NxHZRK5mktMriwiX7LyZc" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，SSM<span class="jill"></span>框架通过使用多种设计模式，使得整个框架更加灵活、易于扩展和维护。在实际开发中，开发者可以根据需要选择合适的设计模式来解决问题。</span></div></div><div id="fu5sUwJEwfVagQi4Lucksj" class="wolai-block wolai-text"><div></div></div><div id="trFVFmNXSVgdmdYPUUJc7X" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="sG6rgMRuW4wpMRTNC5PMZC" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">Java<span class="jill"></span>语言可以用哪些方式实现单例模式？</span></h1><div id="9bzsqTiz4LdzqyurMpoWyP" class="wolai-block wolai-text"><div><span class="inline-wrap">单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问点。以下是几种常见的单例模式的实现方式：</span></div></div><h2 id="3EkCSQC3ZATrf1YteLFAv3" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">懒汉式</span></h2><div id="h4epyReE8qRgygvNWCB4HU" class="wolai-block wolai-text"><div><span class="inline-wrap">在需要获取对象时才创建对象</span></div></div><code-block id="sJACdhD38jWKmJz7WLND52" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 基础版实现：存在线程安全问题</pre></div></code-block><div id="mR5RXC3pNs6TArfYnAHRxC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eiivqPYkJkVVt8JGy3oXXa" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">懒汉式（改进版）</span></h2><code-block id="heTagN1cCCTdh3RDXrfsPB" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 改进版实现：在上一版的基础上解决线程安全问题</pre></div></code-block><div id="68Y8FgFMW8NUq3RBe1tQm2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pJKHtms9RBzu4w5nUSrLBb" class="wolai-block"><span class="wolai-serial-number">6.3</span><span class="inline-wrap">饿汉式</span></h2><div id="51xJc9nKNcXJVuUs3TnTMn" class="wolai-block wolai-text"><div><span class="inline-wrap">在类加载时即创建对象</span></div></div><code-block id="tro9FVBGe9q9qKenLMsH8p" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="p4UB92RG9SM2eviwK1KgRG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="8EQrYmSvHB7SDKgvb5gd4T" class="wolai-block"><span class="wolai-serial-number">6.4</span><span class="inline-wrap">双重检查锁定</span></h2><div id="6VG9TiXwhehqXxx85iXFru" class="wolai-block wolai-text"><div><span class="inline-wrap">第一次检查：if (instance == null)
目的是减少不必要的同步开销。如果 instance 已经被初始化，那么直接返回 instance，不需要进入同步块。
</span></div></div><div id="qdkMic9yS3deJGotGMmxYm" class="wolai-block wolai-text"><div><span class="inline-wrap">第二次检查：在同步块内的 if (instance == null)
目的是确保在多线程环境下只有一个线程能够创建 Singleton 实例。即使多个线程同时进入第一个 if 判断，也只会有一个线程能够进入同步块并创建实例。</span></div></div><code-block id="eYBq2XCqEaLMMmD9rTSm7K" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="vqFhAWYNXwFHPGiTwQ9Tsv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="iUceadeyTJ7xngZzAvnz1N" class="wolai-block"><span class="wolai-serial-number">6.5</span><span class="inline-wrap">静态内部类</span></h2><div id="c7c22e3m5zLdtX6VkeMYc8" class="wolai-block wolai-text"><div><span class="inline-wrap">使用静态内部类实现单例模式的原因
</span></div></div><ul class="wolai-block"><li id="fgfMkyd7NaLxbQvj9rvU5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>延迟初始化</b></span><span class="inline-wrap">：静态内部类在第一次被使用时才会被加载，因此 Singleton 实例在第一次调用 getInstance() 方法时才被创建，实现了延迟初始化。</span></li><li id="oE8YbAtFBk57sSMfFizucJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>线程安全</b></span><span class="inline-wrap">：由于静态内部类的加载是由 JVM 保证线程安全的，因此 Singleton 实例的创建是线程安全的，无需额外的同步机制。</span></li><li id="oCVzeWbXFKnm9pMViZL8xk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>性能优化</b></span><span class="inline-wrap">：相比其他单例模式实现（如饿汉式、懒汉式），静态内部类方式在保证线程安全的同时，避免了每次获取实例时的同步开销，提高了性能。</span></li></ul><div id="sQQySB7xVgQCL1LSTjS4ES" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="eboQX8VdhU9qdNH3WhnWgN" class="wolai-block wolai-text"><div><span class="inline-wrap">静态内部类实现单例模式的缺点：
</span></div></div><ul class="wolai-block"><li id="mKVegbjcgikmVeaYRhG22X"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">反射攻击：</span></li><li id="m4tEcZ1UTSbxEHPUthD5qy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">问题：虽然私有构造方法可以防止外部直接实例化，但通过反射机制仍然可以调用私有构造方法，破坏单例。
解决方案：可以在构造方法中添加检查，防止多次实例化。</span></li></ul><div id="v1AZDE3HtxeWKrEM5swngd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><ul class="wolai-block"><li id="jdiU6vAypWHXZmA7hYCc36"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">序列化问题：</span></li><li id="8dN9Qr8J6HF77tzStvkFg4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">问题：如果 Singleton 类实现了 Serializable 接口，反序列化时会创建新的实例，破坏单例。
解决方案：重写 readResolve 方法，确保反序列化时返回同一个实例。</span></li></ul><div id="kKVNxzeJJQbBCJPxqNQw4w" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><ul class="wolai-block"><li id="ddHCWFCFi4NTogAgEr7qhn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类加载器依赖：</span></li><li id="c7b7MCesnXiLsPmd1TUA1s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">问题：不同的类加载器可能会加载同一个类的多个实例，导致多个单例对象。
解决方案：确保在同一个类加载器下加载 Singleton 类。</span></li></ul><code-block id="8LwgVc5wtZFTtFxRnsJdee" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="go4XqSfwJ7aLH29Yy5mzC4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="foSCEysi36hBc5YgjvRFE8" class="wolai-block"><span class="wolai-serial-number">6.6</span><span class="inline-wrap">枚举</span></h2><div id="hrigcjP9RuTwXFjyZEhYSG" class="wolai-block wolai-text"><div><span class="inline-wrap">使用枚举实现单例模式是一种简单且高效的方法，能够天然地解决反射攻击和序列化问题。以下是具体的实现方式和优点</span></div></div><code-block id="m4LQcsuYLn4bz4u5Zw5VWT" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token comment">// 可以在这里添加其他方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实现具体逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 代码实现思路：</pre></div></code-block><div id="wZEnaDfq9dM148wrmDEwpX" class="wolai-block wolai-text"><div><span class="inline-wrap">详细解释：
</span><span class="inline-wrap"><b>枚举定义</b></span><span class="inline-wrap">：public enum Singleton 定义了一个枚举类型，其中 INSTANCE 是唯一的实例。
</span><span class="inline-wrap"><b>方法定义</b></span><span class="inline-wrap">：可以在枚举中定义其他方法，如 someMethod。
</span><span class="inline-wrap"><b>获取实例</b></span><span class="inline-wrap">：通过 Singleton.INSTANCE 获取单例实例。
</span><span class="inline-wrap"><b>调用方法</b></span><span class="inline-wrap">：调用实例上的方法，如 someMethod。</span></div></div><code-block id="fCPiC8nNVWy8oL96rfvpCo" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
        singleton<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 应用举例</pre></div></code-block><div id="a7LYMh8LqfLBctF19bFMss" class="wolai-block wolai-text"><div><span class="inline-wrap">优点：
</span><span class="inline-wrap"><b>线程安全</b></span><span class="inline-wrap">：枚举类型的实例在类加载时由 JVM 自动保证线程安全，无需额外的同步机制。
</span><span class="inline-wrap"><b>防止反射攻击</b></span><span class="inline-wrap">：枚举类型不允许通过反射创建实例，因为 JVM 对枚举类型的反射进行了限制。
</span><span class="inline-wrap"><b>防止序列化问题</b></span><span class="inline-wrap">：枚举类型的序列化机制由 JVM 保证，反序列化时不会创建新的实例，而是返回已有的实例。
</span><span class="inline-wrap"><b>简洁性</b></span><span class="inline-wrap">：代码简洁明了，易于理解和维护。</span></div></div><div id="9a4SDvYnNuiRiH9nxN8q1m" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="g9owETnS4FnNeJdWSgrext" class="wolai-block wolai-text"><div><span class="inline-wrap">以上是几种常见的单例模式的实现方式。每种方式都有其优缺点，选择合适的实现方式取决于具体的需求和场景。需要考虑线程安全性、延迟加载、性能等方面的因素。</span></div></div><div id="o9HEwmQrehZL5Kf81uPWHK" class="wolai-block wolai-text"><div></div></div><div id="jqwrsqJ46n8h7YuWnEeEgJ" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="77z3GhcStsFbKNRCYw9KtV" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">如何破坏单例模式？</span></h1><h2 id="pvXUyZStsFJ8jWnYuzDVND" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">背记</span></h2><div id="aJP9yicoUxEinhkUAsg3JK" class="wolai-block wolai-text"><div><span class="inline-wrap">破坏单例模式有以下四种方式：</span></div></div><div id="2ahyUjTr2ZsoeawzZevREN" class="wolai-block wolai-text"><div><span class="inline-wrap">1.通过反射机制，绕过私有构造限制  </span></div></div><div id="uHp2Vp8whH8LUS8vGFSbrE" class="wolai-block wolai-text"><div><span class="inline-wrap">2.通过反序列化，创建多实例  </span></div></div><div id="EJR2jLUARULv9wgaf6uu4" class="wolai-block wolai-text"><div><span class="inline-wrap">3.多线程安全处理不当，导致创建多实例  </span></div></div><div id="niH5RqyKXCuyxnzpYc9Z5s" class="wolai-block wolai-text"><div><span class="inline-wrap">4.通过克隆创建多个实例  </span></div></div><div id="qyd1qKPcjPD9pMvnAEkTae" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sT3G94d8VX9WZWpPgruhmq" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">理解  </span></h2><div id="bT5zCasXxW5URKU5pXaUQa" class="wolai-block wolai-text"><div><span class="inline-wrap">破坏单例模式的方法主要有以下几种：</span></div></div><ol class="wolai-block"><li id="qbYj4vZvPENvLiVHUzRZQQ"><div class="marker"></div><span class="inline-wrap">反射破坏：通过反射机制，可以访问私有构造函数并创建多个实例。可以构造函数中添加逻辑来防止反射破坏单例模式。  </span></li><li id="93VKGKqCtouVUrzpC19qWz"><div class="marker"></div><span class="inline-wrap">序列化与反序列化破坏：当一个单例类被序列化后，再次反序列化会创建一个新的实例。可以通过在单例类中添加 readResolve() 方法，返回已有的实例，从而避免破坏。</span></li><li id="eGSzWjnPRf1pWZg6R36md3"><div class="marker"></div><span class="inline-wrap">多线程环境下的破坏：在多线程环境下，如果没有合适的同步机制，可能会创建多个实例。可以使用双重检查锁定或者静态内部类等线程安全的方式来防止破坏。  </span></li><li id="p47zEJjXdyXVffZKQK59Bj"><div class="marker"></div><span class="inline-wrap">克隆破坏：如果单例类实现了 Cloneable 接口并重写了 clone() 方法，可以通过克隆对象创建多个实例。可以在 clone() 方法中抛出 CloneNotSupportedException 异常，阻止克隆破坏。  </span></li></ol><div id="5EWbyqAum9pb6n7LJRDCtB" class="wolai-block wolai-text"><div><span class="inline-wrap">破坏单例模式需要在特殊情况下有意识地使用上述方法，一般情况下，单例模式是为了保证全局唯一性和访问性，不建议破坏。</span></div></div><div id="nmN7Bx6YmUaxgeDbSreaBU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="vJBzxN5cYj8T7Mv48j9upA" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cbQYMmfp6HEafxyP4mtaQR" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">为什么说枚举是实现单例最好的方式？</span></h1><h2 id="ruffaEDeRYmHAhwsuxwQTD" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">背记</span></h2><div id="37iqwq4dCZVwwBevme5tu2" class="wolai-block wolai-text"><div><span class="inline-wrap">枚举是实现单例模式最好的方式之一，原因如下：</span></div></div><ol class="wolai-block"><li id="hYXefAcWkYfpbkv1YPcPrh"><div class="marker"></div><span class="inline-wrap"><b>线程安全性</b></span><span class="inline-wrap">：枚举实例的创建是由<span class="jill"></span>JVM<span class="jill"></span>在加载枚举类的时候保证的，因此在多线程环境下也能保证单例的唯一性。枚举的实例创建是线程安全的，无需担心并发访问导致的多实例问题。  </span></li><li id="sqhJjScN4mpj6DPgKVEqCc"><div class="marker"></div><span class="inline-wrap"><b>反射安全性</b></span><span class="inline-wrap">：枚举类的实例是在枚举类加载的时候被创建的，而且枚举类不支持通过反射来创建实例。即使使用反射强制访问枚举类的私有构造函数，也无法创建新的实例，因为枚举类的构造函数默认是私有的。  </span></li><li id="uAjGatpe3riMyrJfPTVYQV"><div class="marker"></div><span class="inline-wrap"><b>序列化安全性</b></span><span class="inline-wrap">：枚举类默认实现了 java.io.Serializable 接口，因此可以安全地进行序列化和反序列化。枚举实例在序列化和反序列化过程中保持单例的状态，不会创建新的实  例。</span></li><li id="sbvA5hUsmLKXGYEZA3hsS7"><div class="marker"></div><span class="inline-wrap"><b>简洁性和可读性</b></span><span class="inline-wrap">：使用枚举实现单例模式非常简洁，只需定义一个枚举类型，枚举值即为单例实例。同时，使用枚举实现的单例模式也更易于理解和维护。</span></li></ol><div id="79FMsMieBR2vMxHszahfDg" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rY591H18RKj2WrPzDXuGjk" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">理解</span></h2><h3 id="roucz9FSjrGuXkPs7g9mUM" class="wolai-block"><span class="wolai-serial-number">8.2.1</span><span class="inline-wrap">定义枚举单例模式</span></h3><code-block id="t6kgzGTuxoEnNjF1FuenCA" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">businessMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是一个单例！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="qY5rPird6mws36jEMggs3D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="dSCocpM8bZMUHSDaoo4z4p" class="wolai-block"><span class="wolai-serial-number">8.2.2</span><span class="inline-wrap">使用枚举单例模式</span></h3><code-block id="37dKZSpJgee4ETkZvErCBM" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Singleton</span> s1 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
        <span class="token class-name">Singleton</span> s2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="vYXKFMFU6aTwYs3aRawVvG" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jRXnMVtDfcY5ayxVmzpRNm" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">不使用锁如何实现线程安全的单例？</span></h1><h2 id="pRnUYQGcDekCQENp3xt7uL" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">背记</span></h2><div id="gtcimJdnJV92U2QAu3dzLJ" class="wolai-block wolai-text"><div><span class="inline-wrap">不使用锁如何实现线程安全的单例可以有一下几种方式：</span></div></div><ul class="wolai-block"><li id="97P1Z5TuswCfkDDBtHXNDk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量饿汉式</span></li><li id="6XrxwjdrkrdKyQN91ahipv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态内部类懒汉式</span></li><li id="q1Va3VJiKAwoTcscNGyggF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">枚举方式</span></li></ul><div id="uRcqKS3LbaiEpQrw5AD9oe" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rs86KFtcvfDt4xiR1sJ1k4" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">理解</span></h2><div id="sVHVbZsrN1bL5Hk4Kb1rDD" class="wolai-block wolai-text"><div><span class="inline-wrap">除了使用如双重检查锁定）来实现线程安全的单例模式，还有其他几种方式可以实现线程安全的单例，而不需要使用锁。以下是其中两种常见的方式：</span></div></div><h3 id="nWPk5DgH1WmRQ5iFR2dhVD" class="wolai-block"><span class="wolai-serial-number">9.2.1</span><span class="inline-wrap">饿汉式</span></h3><code-block id="bFjpQkkC5wU1MvA2SCZKZK" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="8AoqCPzDn11Q4GGYziCGVT" class="wolai-block wolai-text"><div><span class="inline-wrap">在饿汉式中，单例实例在类加载时就被创建，因此不存在并发访问的问题。由于实例的创建是在静态初始化阶段完成的，所以可以保证线程安全性。</span></div></div><div id="kvAyt6wmGoD1khebWZMXCM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="mbkJXbWuEB8XY3cTb75HdP" class="wolai-block"><span class="wolai-serial-number">9.2.2</span><span class="inline-wrap">静态内部类</span></h3><code-block id="tTA4P9EZiYyB5QE8Gqw844" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="p1GF8odRTT1DDsmpzfoCA2" class="wolai-block wolai-text"><div><span class="inline-wrap">在静态内部类中，单例实例的创建是在调用 getInstance() 方法时进行的，利用了类加载的特性实现了懒加载。</span></div></div><div id="mjXGX3UJMRZEtdEC9iDTv1" class="wolai-block wolai-text"><div><span class="inline-wrap">由于静态内部类只有在被使用时才会被加载，所以也能保证线程安全性。</span></div></div><div id="jUtFBEiuqLdXyWxLex5kWC" class="wolai-block wolai-text"><div><span class="inline-wrap">这些方式都不需要显式地使用锁，因此可以避免锁带来的性能开销。</span></div></div><div id="tLFhXCoy7TgWQErvqrqUrv" class="wolai-block wolai-text"><div><span class="inline-wrap">不过需要注意的是，这些方式在某些特殊情况下（如序列化、反射等）可能仍然存在安全问题，需要进行适当的处理来防止破坏单例模式。</span></div></div><div id="5W24qMhiDfSZw28ncbYBLA" class="wolai-block wolai-text"><div></div></div><div id="4zAerVxRBVChSScCHgKCWf" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="oAAnL2G4MK4zvRqeyrhYz9" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">什么是享元模式，有哪些具体应用？</span></h1><div id="gGhpohW9vFRKBvG4PrU9Kz" class="wolai-block wolai-text"><div><span class="inline-wrap">享元模式（Flyweight Pattern）是一种结构型设计模式，其目的是通过共享对象来减少内存使用和提高性能。享元模式通过将对象的状态划分为内部状态（Intrinsic State）和外部状态（Extrinsic State），来实现对象的共享。</span></div></div><div id="eM1fKKtEumaouqfh6p5evv" class="wolai-block wolai-text"><div><span class="inline-wrap">具体用场景和示例：</span></div></div><ol class="wolai-block"><li id="fEqj8vNwrqfa5gVoEjWDJp"><div class="marker"></div><span class="inline-wrap">文字编辑器：在文字编辑器中，每个字符都是一个对象，但是字符的属性（如字体、颜色等）可以作为内部状态进行共享，而文字的位置等属性可以作为外部状态进行传递。</span></li><li id="7JYe9RE8P1KN1hWY78aGNb"><div class="marker"></div><span class="inline-wrap">线程池：在线程池中，每个线程对象可以看作是一个享元对象，线程的内部状态（如线程<span class="jill"></span>ID、状态标识等）是可以共享的，而外部状态（如任务）是不同的，通过外部传入。</span></li><li id="aWbBrSjdaquE4o1xLP49Qy"><div class="marker"></div><span class="inline-wrap">资源池：在数据库连接池中，可以使用享元模式来共享和复用资源对象，提高资源的利用率。</span></li><li id="ejuXZ6VcbjXRn1xAqXFK2Y"><div class="marker"></div><span class="inline-wrap">游戏中的角色：在游戏中，角色的外观、动作等可以作为内部状态进行共享，而角色的位置、血量等信息可以作为外部状态。</span></li></ol><div id="76pa9egEFHBMmgvZfqknoS" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，享元模式适用于存在大量细粒度对象的场景，通过共享内部状态来减少对象的开销，提高系统的性能和资源利用率。</span></div></div><div id="unLggRUMiwN7RjV7DRPuMh" class="bg-fluorescent_yellow wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div></article><footer></footer></body></html>