<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>开发实践：场景题 - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="开发实践：场景题" class="main-title"></div></div></header><article><h1 id="Y19N4kcFprhFPtia3t8TT" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">业务量突然提升<span class="jill"></span>100<span class="jill"></span>倍<span class="jill"></span>QPS<span class="jill"></span>如何应对？</span></h1><h2 id="iCqRsN4XUzJN3KT2iSwFpQ" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">不同水准的不同工程师有不同回答</span></h2><ul class="wolai-block"><li id="swyV2CKNaNf1zZJxaYwf5L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">没有进取心的工程师这么说：这是运维岗负责的事情，不归我管</span></li><li id="8XE6dh5Y13JKriNeMNXYTF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">有进取心的工程师</span><span class="inline-wrap">看到公司的项目因为突发流量和被压垮，用户体验直线下降，大量用户投诉，给公司带来了很大的经济损失，开始思考如何优化系统结构，弹性配置资源</span></li><li id="2wuzmRx2L15ihS2frfvErk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">身经百战的工程师这么说：无需应对，因为我们早已从项目各个组成部分都做好了充分的预案，即使<span class="jill"></span>QPS<span class="jill"></span>突然提升<span class="jill"></span>100<span class="jill"></span>倍也不会突破系统的弹性运算能力，保证系统平稳可靠运行。具体优化措施如下：</span><ul class="wolai-block"><li id="eZpXGfbUTvNtaqoy3cnxUV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">镜像系统多地部署，基于<span class="jill"></span>CDN<span class="jill"></span>技术实现就近访问</span></li><li id="dF8zMEmwe5NCzk4q95Zm6y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">项目入口<span class="jill"></span>Nginx<span class="jill"></span>服务器保障与优化</span></li><li id="4tBo4oQtZFXwboUCtKYGTH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">业务运算动静分离</span></li><li id="acx7CES3sWjP6k1DHeE5pi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">业务运算动态部分低更新概率：页面静态化</span></li><li id="pisRvRtog48S2wwG8rL5T3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">业务运算入口<span class="jill"></span>Gateway<span class="jill"></span>网关微服务集群化配置</span></li><li id="dAihRQVdNzpptDzVfKX68o"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">业务运算动态部分高更新概率：动态扩缩容</span></li></ul></li></ul><div id="4PsAq3f7nvbCMVjgahDxU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="vh6AyAcge3PjCX2Bc5Gx65" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">镜像系统</span><span class="inline-wrap">多地部署</span></h2><h3 id="cU91b3bAAJnUGqyqpPi2Kd" class="wolai-block"><span class="wolai-serial-number">1.2.1</span><span class="inline-wrap">概念</span></h3><div id="8dMepNvm6RF7mLQBB7iWP" class="wolai-block wolai-text"><div><span class="inline-wrap">把全球划分为多个区域，在每一个区域运算平台部署一个系统镜像，原始节点和镜像节点之间运算逻辑相同，数据同步。好处：</span></div></div><ul class="wolai-block"><li id="wYjZ98s9RpgaL6ipQropj1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对我们的系统来说：把全网各个地区的总负载分摊到各个区域，降低系统的并发压力</span></li><li id="81SYynEzEoe9Pkjhw9hepR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对用户来说：就近访问镜像节点，缩短响应时间，提升用户体验</span></li></ul><div id="k8UNoY3FSpmUrQ6nZG8Jar" class="wolai-block"><figure class="wolai-center" style="width: 810px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="qZr7Fmz46xakuCAi3PQyRx" class="wolai-block"><figure class="wolai-center" style="width: 810px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="b6YQWPqFEUJmH8PxuyfsB5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4zwtzyrJ3K8ydxMMpaPhk3" class="wolai-block"><span class="wolai-serial-number">1.2.2</span><span class="inline-wrap">技术实现方案</span></h3><div id="qfjGY2QbTWeBG2wgBHfVai" class="wolai-block wolai-text"><div><span class="inline-wrap">以阿里云<span class="jill"></span>CDN<span class="jill"></span>技术为例：</span></div></div><div id="aJXgLeRxq49vBpY8ofethu" class="wolai-block"><figure class="wolai-center" style="width: 831.3333333333334px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="fzBAUZxs1ioZL9wnJfRr3R" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5GXGrNm1RPn3FXo41Cz9JY" class="wolai-block"><span class="wolai-serial-number">1.3</span><span class="inline-wrap">项目入口<span class="jill"></span>Nginx<span class="jill"></span>服务器保障与优化</span></h2><div id="nWKa1Qh33ngKum8YB2bWHh" class="wolai-block"><figure class="wolai-center" style="width: 1086px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><ul class="wolai-block"><li id="muzqhXzaZf3oELLY5bCPCf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Nginx+Keepalived<span class="jill"></span>双主热备、一主一备等方式实现高可用</span></li><li id="4YJqQbqvbZGdXyWfcjkNSE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于<span class="jill"></span>LVS<span class="jill"></span>负载均衡技术搭建<span class="jill"></span>Nginx<span class="jill"></span>集群</span></li><li id="sWtmoePHsr2ZH2kExCE652"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于<span class="jill"></span>HAProxy<span class="jill"></span>负载均衡技术搭建<span class="jill"></span>Nginx<span class="jill"></span>集群</span></li></ul><div id="gt5QeuWUH5NemHBs7VcdR5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sxkMcLgTD3Lumn9UWhVHNh" class="wolai-block"><span class="wolai-serial-number">1.4</span><span class="inline-wrap">业务运算动静分离</span></h2><div id="w9jHj2kQpzY2icaZmhKaTG" class="wolai-block"><figure class="wolai-center" style="width: 1078px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><div id="2CzruRMmjdPNuLXoGKATjK" class="wolai-block wolai-text"><div><span class="inline-wrap">发挥<span class="jill"></span>Nginx<span class="jill"></span>高性能的优势，索取静态资源的请求由<span class="jill"></span>Nginx<span class="jill"></span>负责响应，提高响应速度的同时减轻后端<span class="jill"></span>Java<span class="jill"></span>程序服务器的压力</span></div></div><div id="cEk7nP5GWyzFQjZ6kcFMpN" class="wolai-block wolai-text"><div><span class="inline-wrap">动态资源由<span class="jill"></span>Nginx<span class="jill"></span>路由到后端<span class="jill"></span>Java<span class="jill"></span>程序服务器</span></div></div><div id="hvBoHY2n8gbHkGWWqM4cQP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hAYX67xNGjBKDiwu5GmneW" class="wolai-block"><span class="wolai-serial-number">1.5</span><span class="inline-wrap">业务运算动态部分低更新概率：页面静态化</span></h2><div id="c1DfRuYE4qD31jqYu1Ah7m" class="wolai-block"><figure class="wolai-center" style="width: 1078px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><h3 id="q4zWpxXHwXoh8a1niQZhA1" class="wolai-block"><span class="wolai-serial-number">1.5.1</span><span class="inline-wrap">典型应用场景</span></h3><div id="dahc4yqarFLnFhXifMXyxH" class="wolai-block wolai-text"><div><span class="inline-wrap">在电商系统中，商品详情数据就是更新频率很低，查询频率很高的数据</span></div></div><ul class="wolai-block"><li id="7VdaNDQa6wKXCTcyQeSUxi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">为什么更新频率低？因为商品更新换代速度快，一款商品还没有修改就被新产品替代了，上架之后基本不会修改</span></li><li id="tPJbfYhUK7EMHR4tT3UQkD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">为什么查询频率高？因为用户购买商品之前肯定要仔细了解商品详情再决定是否购买</span></li></ul><div id="dqFiHHADreQd76MW5rzG3A" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bktN4ymJJtzZFFjQy199Hs" class="wolai-block"><span class="wolai-serial-number">1.5.2</span><span class="inline-wrap">大致的实现原理</span></h3><ul class="wolai-block"><li id="gej5QLPnhAHxdh9pHLxvCD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第一步：用户第一次访问指定<span class="jill"></span>id<span class="jill"></span>的商品数据时，使用视图模板技术生成完整的<span class="jill"></span>HTML<span class="jill"></span>页面（后端<span class="jill"></span>Java<span class="jill"></span>程序执行）</span></li><li id="sKdH5FmPdaqTT9Jk6Q9hCY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第二步：把<span class="jill"></span>HTML<span class="jill"></span>页面放到<span class="jill"></span>Nginx<span class="jill"></span>上缓存</span></li><li id="t1G6FePE4tNEh5kHWNwgom"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第三步：以后用户再访问该指定<span class="jill"></span>id<span class="jill"></span>的商品数据页面，从<span class="jill"></span>Nginx<span class="jill"></span>上即可获取，不需要执行<span class="jill"></span>Java<span class="jill"></span>程序</span></li><li id="nP5DDcJxFzjqvyuFLqMEXi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第四步：后续如果商品数据有变动</span><ul class="wolai-block"><li id="61mimN8KwTEXXV6fWGmvXM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">商品数据修改：重新生成<span class="jill"></span>HTML<span class="jill"></span>页面并保存到<span class="jill"></span>Nginx</span></li><li id="h6foXZ9mhR25ftex1UyFci"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">商品下架：把<span class="jill"></span>Nginx<span class="jill"></span>上的<span class="jill"></span>HTML<span class="jill"></span>页面删除</span></li></ul></li></ul><div id="4CrEMUXSGDh4sZoEs5GpEK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="npg7iF9LSNPV56xGkEUcFJ" class="wolai-block"><span class="wolai-serial-number">1.6</span><span class="inline-wrap">业务运算入口<span class="jill"></span>Gateway<span class="jill"></span>网关微服务集群化配置</span></h2><div id="ciDN7oDvhX8jhXPNh82zXk" class="wolai-block"><figure class="wolai-center" style="width: 1078px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div><div id="rKupL2xpexdH1rJbAwpvU1" class="wolai-block wolai-text"><div><span class="inline-wrap">Gateway<span class="jill"></span>网关作为整个微服务系统的入口，所有请求都要从这里经过，所以非常容易成为整个系统的性能瓶颈</span></div></div><div id="2be8oNjXH4bR239tJrRRe6" class="wolai-block wolai-text"><div><span class="inline-wrap">那么为了提高<span class="jill"></span>Gateway<span class="jill"></span>网关的吞吐量，并提高可用性，需要根据实际需求搭建集群</span></div></div><div id="dmC7hoKiDnouuXxBmoyyb6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="c5Ptr62EY6Ma6KGKwqkWx3" class="wolai-block"><span class="wolai-serial-number">1.7</span><span class="inline-wrap">业务运算动态部分高更新概率：动态扩缩容</span></h2><div id="uNFjhvKrMqH7N7kpCQUj9s" class="wolai-block"><figure class="wolai-center" style="width: 542px; flex-direction: column"><img src="media/image_7.png" style="width: 100%"/></figure></div><h3 id="4Q2ZfH3KJs5bi4Gh8pZZk" class="wolai-block"><span class="wolai-serial-number">1.7.1</span><span class="inline-wrap">需求背景</span></h3><div id="jMzTDBTTy2S2MhSSsPjdQc" class="wolai-block wolai-text"><div><span class="inline-wrap">用户在访问系统时，流量并不是均匀分布的，而是有高峰，有低谷，而为了应对流量波动传统的做法是手动增减服务器资源</span></div></div><ul class="wolai-block"><li id="ux67Ak1nvTFjKbbpBnNGmy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">流量高峰到来：增加服务器资源，应对高峰</span></li><li id="xACiYBkjZc2GHxd5m1jamE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">流量高峰过去：减少服务器资源，节约成本</span></li></ul><div id="wWXC4mc3zqTvs7mpkBprDr" class="wolai-block wolai-text"><div><span class="inline-wrap">但人工手动的来做上述操作会有如下问题：</span></div></div><ul class="wolai-block"><li id="pWzMSXsSTeWKsqKyGb8Xv9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">滞后性：对于突发流量增加，从系统发出警报再到人工操作完成需要较长的时间；</span></li><li id="ah24CTHKt5esJCsbYAj1Sm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不精准：手动管理服务器资源增减，往往前期大流量没有承接住，后面高峰过去又白白浪费资源</span></li><li id="stbkwWCfmqPhX4zRUZefjF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">工作繁琐：所有重复性、枯燥、无聊的事情都不适合人来做</span></li></ul><div id="pbNNJUNwR48wWendvuPkUN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="66ra8MZFYAC31VC1pQeMMB" class="wolai-block"><span class="wolai-serial-number">1.7.2</span><span class="inline-wrap">解决方案：云原生动态扩缩容</span></h3><div id="eHEUunzW7gJPoPyEgQWq5e" class="wolai-block wolai-text"><div><span class="inline-wrap">每一个微服务都封装为一个<span class="jill"></span>Docker<span class="jill"></span>实例并交由<span class="jill"></span>Kubernetes<span class="jill"></span>管理：</span></div></div><div id="cW9KjbhbiNsB2Cj7RFYSv6" class="wolai-block"><figure class="wolai-center" style="width: 379.3333333333333px; flex-direction: column"><img src="media/image_8.png" style="width: 100%"/></figure></div><div id="qWe9VejpxyEnAWTYroiZsa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hnZDgVqnqnQBeW4F29tnDY" class="wolai-block wolai-text"><div><span class="inline-wrap">某个实例访问压力增加时<span class="jill"></span>Kubernetes<span class="jill"></span>自动复制实例构成集群分摊负载：</span></div></div><div id="4jxNn1RfGUCVNw5kHivjgg" class="wolai-block"><figure class="wolai-center" style="width: 620.6666666666666px; flex-direction: column"><img src="media/image_9.png" style="width: 100%"/></figure></div><div id="3XftHPBAeHbjKPifsyxkQq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="5ndJ8NMxYe2BXjeEBka5xH" class="wolai-block wolai-text"><div><span class="inline-wrap">访问压力下降，Kubernetes<span class="jill"></span>自动释放空闲实例：</span></div></div><div id="21UJdj9fVpSV4wDW3be7YN" class="wolai-block"><figure class="wolai-center" style="width: 379.3333333333333px; flex-direction: column"><img src="media/image_10.png" style="width: 100%"/></figure></div><div id="qy2hpTQMPwk1yvMeT9RYK9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kk6qwBwyKEYDVoiozF7Bs8" class="wolai-block"><span class="wolai-serial-number">1.7.3</span><span class="inline-wrap">方案优势</span></h3><ul class="wolai-block"><li id="h1eQhmxx4khL7Wk1yjKbSa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">节约人力资源，减轻维护工作压力</span></li><li id="rehyKaDf4N7mKC3iZagfWw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">节约资金成本，让消耗的资金更精准的用于承接访问压力</span></li><li id="gK7HCj6prMk8ktAyLu7V4S"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">快速配置资源，提升用户体验</span></li></ul><div id="6XvZY7WvzyQNXytreMYao9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="9QzKcrnBHwMx8nuccsGK4x" class="wolai-block"><span class="wolai-serial-number">1.8</span><span class="inline-wrap">相关扩展</span></h2><div id="eMphHbDMAUxjc4iTv4AY7d" class="wolai-block wolai-text"><div><span class="inline-wrap">把频繁查询数据存入<span class="jill"></span>Redis<span class="jill"></span>作为缓存，是为了应对高并发问题吗？</span></div></div><div id="hCk9yKThAofD8TJHYoRggX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="e3aRYnaHFFKtj5a36PaAsf" class="wolai-block"><span class="wolai-serial-number">1.8.1</span><span class="inline-wrap">缓存的作用</span></h3><div id="raar3mAXPzQZArcLgimTXa" class="wolai-block wolai-text"><div><span class="inline-wrap">缓存的作用是『缩短响应时间』，例如<span class="jill"></span>Redis<span class="jill"></span>从内存提取数据就比<span class="jill"></span>MySQL<span class="jill"></span>从硬盘提取数据要快，这样就缩短了请求响应时间</span></div></div><div id="fVr8n92LyqGiSBxiTnuS8p" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="o9r2eHFdxySw3zQjEZ1VE1" class="wolai-block"><span class="wolai-serial-number">1.8.2</span><span class="inline-wrap">应对高并发</span></h3><div id="5eUane3PuhvtV5x6hrd7ga" class="wolai-block wolai-text"><div><span class="inline-wrap">所谓『并发量』其实就是应用服务器在同一时间要处理的请求数量</span></div></div><div id="Pr6YXsNNTdQcyx6drn4ZE" class="wolai-block wolai-text"><div><span class="inline-wrap">而处理每一个请求都需要占用应用服务器内的一个线程</span></div></div><div id="aaBT65fcatdpiV3AfT6gGc" class="wolai-block wolai-text"><div><span class="inline-wrap">那么『并发压力大』其实就是应用服务器内『用来处理请求的线程』不够用了</span></div></div><div id="kQneuTSDixva65zZsztk5p" class="wolai-block wolai-text"><div><span class="inline-wrap">所以应对高并发的本质就是在并发量大的时候增加处理请求的线程数量</span></div></div><div id="s5kbhfR4FAVMNTpwz5SaJE" class="wolai-block wolai-text"><div><span class="inline-wrap">而『使用缓存』并没有增加『线程资源』，所以使用缓存其实并不是直接用于解决高并发问题的</span></div></div><div id="kTgr6mbbrMDpzYc1SujfYS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="asH2rL62NYnz3hQ8dWBhFa" class="wolai-block"><span class="wolai-serial-number">1.8.3</span><span class="inline-wrap">有帮助</span></h3><div id="eAcBKb3jFcdB7FxjpqtyQY" class="wolai-block wolai-text"><div><span class="inline-wrap">虽然没有直接关系，但从效果上使用缓存对于缓解并发压力也是有帮助的，为什么这么说呢？</span></div></div><ul class="wolai-block"><li id="9QoM5DNLV22PHN3WPjiwov"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果不使用缓存，处理一个请求平均需要<span class="jill"></span>800ms，那么一个请求占用线程资源就是<span class="jill"></span>800ms；</span></li><li id="37i4dQeDGpbEgFEoNtwisR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果使用缓存，处理一个请求平均需要<span class="jill"></span>300ms，这就大大缩短了线程资源被占用的时间。</span></li></ul><div id="roWHWsd6KAYnY1yCzmCojc" class="wolai-block wolai-text"><div><span class="inline-wrap">线程资源被占用的时间短了，就更容易被释放出来，去处理其它请求</span></div></div><div id="kdiQLYufcm1TBtt2YhcxMF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bPe2gnC1H4GLgnqXnux2G2" class="wolai-block"><span class="wolai-serial-number">1.8.4</span><span class="inline-wrap">举例说明</span></h3><div id="8UBoddTwGyTpmr6PyPdMmM" class="wolai-block wolai-text"><div><span class="inline-wrap">一个饭馆客人太多了，如何应对？</span></div></div><ul class="wolai-block"><li id="41WsuzQmRPsSyQqtYverkB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">单店内部增加服务员的数量（应用服务器内增加线程池的容量）</span></li><li id="2Jz968qetNDt6EamiBYuLu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">开连锁店（应用服务器配置集群）</span></li><li id="4NH3BNnqcwVKdsRxvzHvzr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">改进单店内部服务流程，原来服务员上菜需要到后厨去拿，现在在饭厅门口就能拿到，上菜更快（应用缓存缩短响应时间）</span></li></ul><div id="8XPW8pHRP9VZqT8AuUTy95" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="2U3wR4aWE89PDSQBaF1At4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="53EKFKLkEsqQKe8uE2kyH3" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">让你设计一个订单号生成服务，该怎么做？</span></h1><h2 id="fkyuC5bhkonDQWvb3MhNtc" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">订单号格式的基本要求</span></h2><ul class="wolai-block"><li id="PNPNeikuRgNECxr8xb7S3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">唯一性：在整个系统的全局范围内，订单号是不能重复的</span></li><li id="7EzYLUqUa1Va1gf84gcHA6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">高效性：订单服务访问量很大，所以订单号要设计一个高效的生成算法，以避免长时间的等待或计算开销</span></li><li id="p4zzE7jgezPHQm6KDnU9gu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不溢出：订单号生成方式要充分考虑系统订单数量，如果是通过整数值自增方式生成订单号，那么一定要避免在临界值上<span class="jill"></span>+1<span class="jill"></span>导致数值溢出</span></li><li id="xnCgDyFiy7UEUv6xbavHUz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">易读性：就系统使用者来说，无论是用户还是后台管理员，都需要经常查阅订单号，所以订单号格式如果非常复杂就不好</span></li><li id="sMk43fprGL9Qsimy1Vm4cd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">表意性：订单号在满足上述要求的基础上最好还能够直观体现出该订单的生成时间、用户<span class="jill"></span>id<span class="jill"></span>等信息</span></li></ul><div id="vv6zzL3ubB1r27E4QRZqNc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ao5EESVsJXGfPwzEu3upgX" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">方案举例</span></h2><h3 id="sQBexyqP31kMqwp5GmSUr9" class="wolai-block"><span class="wolai-serial-number">2.2.1</span><span class="inline-wrap">自增序列</span></h3><div id="nGR1SKv4TMiu5iQCcsasaX" class="wolai-block wolai-text"><div><span class="inline-wrap">最简单、最容易想到的方案，但需要考虑很多相关问题：</span></div></div><ul class="wolai-block"><li id="B6Jpw7Bq7VpNA12o6Ezgk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程安全问题导致的订单号重复：为了解决这个问题应尽量不在<span class="jill"></span>Java<span class="jill"></span>代码中执行自增，因为<span class="jill"></span>Java<span class="jill"></span>代码自增如果不加锁会有线程安全问题，加锁会严重降低执行效率；较好的方式是使用数据库表的<span class="jill"></span>AUTO_INCREMENT<span class="jill"></span>自增机制</span></li><li id="hX1tUYi9miE4yMhJFFAdqk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">防止数据溢出：每个数据类型都存在有效范围，一旦在临界值上<span class="jill"></span>+1<span class="jill"></span>就会导致溢出，所以务必全面考虑</span></li></ul><div id="4r8EB9CXaZEsn45iPo2xj1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="qebPNcjRUsm7NV2LWpPY3P" class="wolai-block wolai-text"><div><span class="inline-wrap">方案优势：</span></div></div><ul class="wolai-block"><li id="ivL8bMEUnBFFFBAuodiFMF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实现方式简单</span></li><li id="udtPoiVmtaSLCWaJZ9DGQJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">计算效率较高</span></li></ul><div id="rpoTCoGUpkZVBKEQkreksC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6FCWSu1GxPAh7WGnVnSfEZ" class="wolai-block wolai-text"><div><span class="inline-wrap">方案缺陷：</span></div></div><ul class="wolai-block"><li id="6cUJFckk5CgQ1hmh7qCZmf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用自增的方式生成的订单号没有表意性，无法看出订单相关信息</span></li><li id="gVsdWkswJpwNwzdFWzzqA1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存在溢出的风险</span></li><li id="5KPCekTzh6CULLcZW1aog6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在并发环境下有可能导致订单号重复</span></li></ul><div id="sBwGZLxeVD8chyi248TCBw" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5TrAWte5gzoHua4A45dmCi" class="wolai-block"><span class="wolai-serial-number">2.2.2</span><span class="inline-wrap">UUID</span></h3><div id="7zFYQd1VBKyYabDJyvfGMT" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>UUID<span class="jill"></span>作为订单号，几乎可以保证全局唯一性，计算效率可以接受。但是，UUID<span class="jill"></span>相对较长，可能影响存储和索引效率，表意性也不好。</span></div></div><div id="cBH3DL2qjbxsy5C7btqY3e" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iE6ECQz3UqLAJtZwPV3xah" class="wolai-block"><span class="wolai-serial-number">2.2.3</span><span class="inline-wrap">分布式<span class="jill"></span>id<span class="jill"></span>生成器</span></h3><div id="ksL5SmmaqX2UoDD41SuwnL" class="wolai-block wolai-text"><div><span class="inline-wrap">点击参考：《</span><span class="inline-wrap"><a href="https://www.wolai.com/66VHx8Uany7KSTLLy8Am7k"><span>基础理论：分布式</span></a></span><span class="inline-wrap">》中《分布式<span class="jill"></span>id<span class="jill"></span>生成方案》</span></div></div><div id="xcJut6tDp5dDsiJuS4e4m1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="63gjjQC8mvJo8iVWopHXCW" class="wolai-block"><span class="wolai-serial-number">2.2.4</span><span class="inline-wrap">相关信息拼接</span></h3><div id="i6aXxUAeoMNz8wfjEKSigV" class="wolai-block wolai-text"><div><span class="inline-wrap">如果我们能够限定『系统中同一个用户在同一个时间不能生成多个订单』，那么就可以据此设定订单格式如下：</span></div></div><ul class="wolai-block"><li id="jcvvR3RGpqVnz1hd9TMdBx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">紧凑格式的年月日、小时、分、秒、毫秒，例如：20250102163724088</span></li><li id="w43pCwR5NKRozwVtDLUicu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户<span class="jill"></span>ID：270316</span></li></ul><div id="vCbjDxeYJxSx6Gm1u7nrf5" class="wolai-block wolai-text"><div><span class="inline-wrap">那么拼接后得到：</span><span class="inline-wrap">20250102163724088</span><span class="inline-wrap">270316</span></div></div><div id="sYRdAEkaU1fdiC9uD663cj" class="wolai-block wolai-text"><div><span class="inline-wrap">这种方式的最大优势是表意性很好，一看就知道订单生成时间和所属的用户</span></div></div><div id="qMdk1h175goS2PQCT3KNeE" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="e5PCfdL9P9zbLrHanV3AuX" class="wolai-block"><span class="wolai-serial-number">2.2.5</span><span class="inline-wrap">相关信息汇总后<span class="jill"></span>HASH</span></h3><div id="ayj9qxEepk4u6ioK8RjxNZ" class="wolai-block wolai-text"><div><span class="inline-wrap">如果特定功能不希望相关信息直接暴露出来，也可以把相关信息封装到对象中，然后将对象执行<span class="jill"></span>HASH<span class="jill"></span>运算得到唯一值。</span></div></div><div id="iSMEvP3piaEmaqqyP71d5V" class="wolai-block wolai-text"><div><span class="inline-wrap">相关信息可以包括：</span></div></div><ul class="wolai-block"><li id="ut6CdEoEfv1NFbRYAftwg8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">下单时间</span></li><li id="mVwNZ2svpKERHXHgi7aHqL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户<span class="jill"></span>ID</span></li><li id="3kywUwrqYmFugsY6avDG3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">订单商品列表，包括商品的<span class="jill"></span>ID、价格等信息</span></li><li id="k1CKTYdCEijzJPaJS6fy9v"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">……</span></li></ul><div id="qZf9jA8YZPnBogxGUuPPL5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="eJv2NMj6dkGYeZkbqxetDB" class="wolai-block"><span class="wolai-serial-number">2.3</span><span class="inline-wrap">方案补充完善</span></h2><ul class="wolai-block"><li id="vkxmo6AgNzshdq5SxALDjU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">缓存机制： 为了提高性能，可以引入缓存机制。将最近生成的订单号缓存起来，避免频繁地访问数据库或分布式<span class="jill"></span>ID<span class="jill"></span>生成器。</span></li><li id="dC3SaqxhJoqCGrAW5nujYD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">高可用性： 考虑实现多个订单号生成服务的实例，以提供高可用性。可以使用负载均衡来分配请求，同时保证各实例之间的订单号唯一性。</span></li><li id="ukr1xFzm65KxachYFizzJ4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">错误处理： 考虑异常情况，如数据库连接断开或分布式<span class="jill"></span>ID<span class="jill"></span>生成器不可用。设计适当的错误处理机制，确保系统的稳定性。</span></li><li id="qPXJz4nZ2gzsaYjBLM5bCN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">日志记录： 记录每个生成的订单号，包括生成时间、相关信息等，以便后续追踪和排查问题。</span></li></ul><div id="5rxTRvxHcZDn3zT5Mh9nTy" class="wolai-block wolai-text"><div></div></div><div id="d4csU82NFF7mtyv7MVq8vP" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cA2bYagX8KDtDqwx28qEwH" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">订单到期关闭如何实现？</span></h1><h2 id="7XhELaRHnfZdreK8qdPysR" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">总体思路</span></h2><ul class="wolai-block"><li id="6z6QudBA5SUuhJzxWp2NQ5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定时任务</span><ul class="wolai-block"><li id="x9QE2bAxjv1Qe2Wsq2Qfjx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">宏观扫描：宏观上扫描所有订单，发现超时未支付订单后执行关闭，时间误差较大</span></li><li id="xzGPV8QKabxu9HDHywhBVZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">精准定时：下单操作完成后就触发一个延迟指定时间的定时任务，时间精准但性能开销较大</span></li></ul></li><li id="7qi79umYKTbsSMG6wF3NL9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消息队列中的延迟队列：下单操作完成后把一个延迟消息存入消息队列，由消费端在收到消息时检查订单是否超时，精准度和性能方面基本可以接受，但实现起来较为复杂</span></li></ul><div id="6UN5knE9FoaGvsoRXpCkTo" class="wolai-block wolai-text"><div><span class="inline-wrap">实际开发中采用的通常是延迟队列方式</span></div></div><div id="jPFs3e8eLLiWz5oXfTGKaA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="YJCJbMhU99Hy588vDAdkV" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">具体方案参考</span></h2><ol class="wolai-block"><li id="xf5A5CVxvLYnhC6EUyURT1"><div class="marker"></div><span class="inline-wrap"><b>被动关闭</b></span><ul class="wolai-block"><li id="2JkHtWnof64Vg3SxVH2oyt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：用户创建订单后，系统不做主动关单操作，而是在用户访问订单时判断是否超时，如果超过时间则进行关单操作。</span></li><li id="fQvjctbgKPCSuAFPd7QY96"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：实现简单，不需要开发定时任务功能。</span></li><li id="pXviEkhXHdKff5veosEdcE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：如果用户一直不查看订单，脏数据会一直存在数据库中；查询过程中进行写操作，耗时长且有失败的可能。</span></li></ul></li><li id="broMfKKBXNyQEgN3dEh9zi"><div class="marker"></div><span class="inline-wrap"><b>定时任务</b></span><ul class="wolai-block"><li id="RTKkBDeE3wu2gyZrDPgrD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：通过调度平台定期扫描所有到期的订单并执行关单动作。</span></li><li id="r1xNryPSLCdvRhMzJEpb9c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：实现简单，适用于小型项目。</span></li><li id="aEVusa8oeDM4phJ8mZMfp7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：时间不精准，无法处理大订单量，对数据库造成压力，分库分表问题复杂。</span></li></ul></li><li id="gGe5CWaromedpkJupgLhge"><div class="marker"></div><span class="inline-wrap"><b>JDK<span class="jill"></span>自带的延迟队列</b></span><ul class="wolai-block"><li id="5vZeRKDEUPAm41E3JUk9t1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：使用<span class="jill"></span>JDK<span class="jill"></span>自带的</span><span class="inline-wrap"><code>DelayQueue</code></span><span class="inline-wrap">实现订单的延迟关闭。</span></li><li id="63216azUprW3Wrjc55K8Ct"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：无需依赖第三方框架，实现简单。</span></li><li id="pYWLGDcAmmYXqSMkvHWQH3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：基于<span class="jill"></span>JVM<span class="jill"></span>内存，数据量大时可能导致<span class="jill"></span>OOM<span class="jill"></span>问题，不适合分布式场景。</span></li></ul></li><li id="wADBCaj8LTYUBBaNPifdL9"><div class="marker"></div><span class="inline-wrap"><b>Netty<span class="jill"></span>的时间轮</b></span><ul class="wolai-block"><li id="w14XpZ7PS1tqAB4kL58cRa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：利用<span class="jill"></span>Netty<span class="jill"></span>的</span><span class="inline-wrap"><code>HashedWheelTimer</code></span><span class="inline-wrap">实现时间轮，降低插入和删除操作的时间复杂度。</span></li><li id="wkjy8WK1YHPU3rr2ATi2h5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：效率高，任务触发延迟低。</span></li><li id="jcAzUnNifUz2tRapsYERV4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：基于内存，扩展性差，不适合分布式场景。</span></li></ul></li><li id="e6P2J5BtAg6Qjuioadmjum"><div class="marker"></div><span class="inline-wrap"><b>Kafka<span class="jill"></span>的时间轮</b></span><ul class="wolai-block"><li id="auEdS2zkgVbn6uLUc2GS5r"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：使用<span class="jill"></span>Kafka<span class="jill"></span>的时间轮（TimingWheel）实现订单的延迟关闭。</span></li><li id="iXGvw1gbJhTgtd7RsAjoHT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：O(1)时间复杂度，性能高，适合分布式场景。</span></li><li id="p98DXfAxzXXfraTkj5Xc4j"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：实现复杂，需要依赖<span class="jill"></span>Kafka。</span></li></ul></li><li id="rnqbfD4t1hFyAMbgijf8Sw"><div class="marker"></div><span class="inline-wrap"><b>RocketMQ<span class="jill"></span>延迟消息</b></span><ul class="wolai-block"><li id="2aqSTUViNVt343pbU1ZoTF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：利用<span class="jill"></span>RocketMQ<span class="jill"></span>的延迟消息功能，在订单创建后发送一个延迟消息，等待指定时长后取消订单。</span></li><li id="3xDwBNMAgTGdVf7z2payLF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：实现简单，支持高并发和分布式。</span></li><li id="vM3Dy2wg37wzkdwBGoEcmA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：延迟消息的时长受限于预定义的时长，灵活性较低。</span></li></ul></li><li id="6KNY2oLckczt9kLsinxLHk"><div class="marker"></div><span class="inline-wrap"><b>RabbitMQ<span class="jill"></span>延迟队列</b></span><ul class="wolai-block"><li id="87YnHPqMZfBrMuo6Fcepbs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：通过<span class="jill"></span>RabbitMQ<span class="jill"></span>的死信队列或</span><span class="inline-wrap"><code>rabbitmq_delayed_message_exchange</code></span><span class="inline-wrap">插件实现延迟消息。</span></li><li id="myJAEAVqFGX4KFe73nJ9EZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：易于部署和使用，支持消息重试和顺序处理。</span></li><li id="oWWjLfoGkiy2QdtcjkTQf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：性能较低，不适合高吞吐量场景。</span><div id="u3ot6ixbvox1D9D2i9DkC" class="wolai-block"><figure class="wolai-left" style="width: 441.3333333333333px; flex-direction: column"><img src="media/image_11.png" style="width: 100%"/></figure></div></li></ul></li><li id="tU8XyY9NdujH4FJhxyvTUC"><div class="marker"></div><span class="inline-wrap"><b>Redis<span class="jill"></span>的<span class="jill"></span>zset</b></span><ul class="wolai-block"><li id="5wYfbuPEvp1BXb2F9eBBLx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>描述</b></span><span class="inline-wrap">：使用<span class="jill"></span>Redis<span class="jill"></span>的有序集合（zset），将订单超时时间戳与订单号关联，通过扫描第一个元素判断是否超时。</span></li><li id="eqybqkepRkvc9MCyFarS2s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>优点</b></span><span class="inline-wrap">：性能高，支持高并发。</span></li><li id="capUK29rnKNNi1SRRwLzhp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>缺点</b></span><span class="inline-wrap">：可靠性相对较低，可能会丢失消息，需要手动实现消息重试机制。</span></li></ul></li></ol><div id="w4k1mKGcaSkbAmUSXQ4XPc" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，这些方案各有优缺点，可以根据实际业务需求和系统架构选择合适的方案。例如，对于实时性要求高且数据量不大的场景，可以选择<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>zset<span class="jill"></span>或<span class="jill"></span>RocketMQ<span class="jill"></span>延迟消息；对于需要高并发和分布式支持的场景，可以选择<span class="jill"></span>Kafka<span class="jill"></span>的时间轮或<span class="jill"></span>RocketMQ<span class="jill"></span>延迟消息。</span></div></div><div id="t4azjJEjbuC4Do73ECf3Sk" class="wolai-block wolai-text"><div></div></div><div id="gzNVhS48xvA4MXxXkHaq1v" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="j8ydUQkENRAttPrArrCyKH" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">如何设计一个购物车功能？</span></h1><h2 id="8q9JRT2JcszoZLfNFCMKuE" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">功能入口</span></h2><ul class="wolai-block"><li id="w7g7ncM22Y8Jtks3kqzuwt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">查看购物车列表</span></li><li id="vyXsh6KNjdAZZ57iNFf5pv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在商品搜索结果列表页，把商品添加到购物车</span></li><li id="rHoCFongeHdmwG3QjdicUb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在商品详情页，</span><span class="inline-wrap">把商品添加到购物车</span></li></ul><div id="otgLS4i2gmUN1ZYykvt4L6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aLa5H6zJWQyZEUzVrCLdYd" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">业务功能</span></h2><ul class="wolai-block"><li id="tFfWTQnT7NZ8Ur9DonNxUh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">添加商品</span></li><li id="4JfS5Dw4FLzMCgZxR1hiCu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">查看购物车中商品列表</span><ul class="wolai-block"><li id="gxGDzDpQFVrmwPuxwgN1eN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">细节<span class="jill"></span>1：显示购物车中所有商品的列表</span></li><li id="9baYRRw9i6u9M3RAWdpPbR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">细节<span class="jill"></span>2：修改购物车中某一项商品的数量</span></li><li id="fEioDKVen8gTwtWB9bN7tj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">细节<span class="jill"></span>3：删除购物车中某一项商品</span></li><li id="26HzRsJcZzhjx7749EDBMM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">细节<span class="jill"></span>4：展示每一项商品的单价、数量、小计金额</span></li><li id="pSpWjTNsiQu8WFWEepiyQh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">细节<span class="jill"></span>5：展示整个购物车中所有被选中商品小计金额累加的总金额</span></li></ul></li></ul><div id="eaqobtqmBbDhWP8nsDzdWJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3ZGTKsgBVvMYfUGTYTmkwy" class="wolai-block"><span class="wolai-serial-number">4.3</span><span class="inline-wrap">购物车数据和用户关联</span></h2><div id="sxXxU5Rsgs9LKpcLAxdG8a" class="wolai-block wolai-text"><div><span class="inline-wrap">购物车中添加的商品肯定是属于添加购物车的用户，但是如果用户没有登录呢？</span></div></div><ul class="wolai-block"><li id="t7TZhVKSuDQm1HZKcdbYiv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应对措施<span class="jill"></span>1：如果用户没有登录，则禁止添加购物车（大多数电商平台的做法，不必考虑数据合并）</span></li><li id="uPsiTznFVuKh5YuMK4uVek"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应对措施<span class="jill"></span>2：允许用户在没有登录时添加购物车，那么就需要解决两个问题：</span><ul class="wolai-block"><li id="duhAWA7dh5geT5huuNPtab"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">问题<span class="jill"></span>1：用户未登录时购物车数据如何储存</span></li><li id="7dwMFEPh2YKmxuEgqz1TUZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">问题<span class="jill"></span>2：用户登录后数据合并</span></li></ul></li></ul><div id="kaCRozms5QD3CY5kzseCXL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sEC5BecKXWsvaFYCRyjGhH" class="wolai-block"><span class="wolai-serial-number">4.4</span><span class="inline-wrap">数据存储方案</span></h2><h3 id="fx7AsGe4yKkETSAfdBN5Qt" class="wolai-block"><span class="wolai-serial-number">4.4.1</span><span class="inline-wrap">关系型数据库中的数据结构</span></h3><div id="aNWwpJMpCjC3mf4FJoYJFi" class="wolai-block wolai-text"><div><span class="inline-wrap">为了数据持久化保存，在<span class="jill"></span>MySQL<span class="jill"></span>中创建购物车数据库表：cart_info</span></div></div><div id="j4wMwNEDk9asnqvjZviLjB" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 121px"><span class="inline-wrap">字段名称</span></th><th style="width: 419px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">id</span></td><td><span class="inline-wrap">主键</span></td></tr><tr><td><span class="inline-wrap">user_id</span></td><td><span class="inline-wrap">可能性：正式用户<span class="jill"></span>id
可能性：临时用户<span class="jill"></span>id</span></td></tr><tr><td><span class="inline-wrap">sku_id</span></td><td><span class="inline-wrap">商品<span class="jill"></span>id</span></td></tr><tr><td><span class="inline-wrap">cart_price</span></td><td><span class="inline-wrap">购物车中商品价格</span></td></tr><tr><td><span class="inline-wrap">sku_num</span></td><td><span class="inline-wrap">商品的数量</span></td></tr><tr><td><span class="inline-wrap">img_url</span></td><td><span class="inline-wrap">商品的默认图片地址（冗余字段）</span></td></tr><tr><td><span class="inline-wrap">sku_name</span></td><td><span class="inline-wrap">商品的名称（冗余字段）</span></td></tr><tr><td><span class="inline-wrap">is_checked</span></td><td><span class="inline-wrap">当前商品条目是否被选中，被选中的商品会参与结算</span></td></tr></tbody></table></div><div id="5T63SGRwSBRRgcQrqNj2Cd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="eoy582PpdWHbGHCDUg27VQ" class="wolai-block"><span class="wolai-serial-number">4.4.2</span><span class="inline-wrap">NoSQL<span class="jill"></span>数据库中的数据结构</span></h3><div id="8BjbMkGRMvr6NtiNb5QDqN" class="wolai-block wolai-text"><div><span class="inline-wrap">为了提高查询速度，在<span class="jill"></span>Redis<span class="jill"></span>中对数据进行缓存</span></div></div><h4 id="kEZp5GKK4kF2XeiemZsjWT" class="wolai-block"><span class="wolai-serial-number">4.4.2.1</span><span class="inline-wrap">Key<span class="jill"></span>结构设计</span></h4><div id="7eC4VC1L5bh9VZh7F6Co1a" class="wolai-block wolai-text"><div><span class="inline-wrap">前缀和后缀都有了：</span></div></div><code-block id="jUTzafV7S7V7iSct3GSaKT" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">USER_KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">"user:"</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">USER_CART_KEY_SUFFIX</span> <span class="token operator">=</span> <span class="token string">":cart"</span><span class="token punctuation">;</span></pre></div></code-block><div id="rWMuELFAKLphvtXMDFhXTR" class="wolai-block wolai-text"><div><span class="inline-wrap">我们需要考虑的是中间的数据，key<span class="jill"></span>彼此之间互相区分也是靠中间部分。考虑到每一个购物车数据都是属于某一位用户的，所以中间部分使用用户<span class="jill"></span>id。</span></div></div><div id="utm7iSNcs5uGwHWADuXh6Q" class="wolai-block wolai-text"><div><span class="inline-wrap">但是需要注意：用户<span class="jill"></span>id<span class="jill"></span>分两种情况</span></div></div><ul class="wolai-block"><li id="d9zQKLEWyEZx7xU7ZwDx4E"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">正式用户<span class="jill"></span>id（登录）</span></li><li id="aMEGZZs2W3FXsov2G2XU24"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">临时用户<span class="jill"></span>id（未登录）</span></li></ul><div id="wm4n1cQ2vGwNUmnyQ5sHRk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="xt9bjNk2JipenjN4mosboG" class="wolai-block"><span class="wolai-serial-number">4.4.2.2</span><span class="inline-wrap">value<span class="jill"></span>结构</span></h4><div id="onFaGB1YE4cEdTbLhXCvAa" class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>中数据结构适用场景：</span></div></div><div id="uikJakvE25fNxFw9YkUH3M" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">数据类型</span></th><th style="width: 386px"><span class="inline-wrap">适用场景</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">string</span></td><td><span class="inline-wrap">单个简单字符串
复杂对象序列化得到的字符串，通常是<span class="jill"></span>JSON<span class="jill"></span>格式</span></td></tr><tr><td><span class="inline-wrap">list</span></td><td><span class="inline-wrap">需要模拟队列或堆栈的情况</span></td></tr><tr><td><span class="inline-wrap">set</span></td><td><span class="inline-wrap">多个数据需要去重</span></td></tr><tr><td><span class="inline-wrap">zset</span></td><td><span class="inline-wrap">集合成员同时附带一个分数值</span></td></tr><tr><td><span class="inline-wrap">hash</span></td><td><span class="inline-wrap">键值对形式
filed：作为键
value：作为值，单个值没有嵌套结构</span></td></tr></tbody></table></div><div id="57zoz4BoGZKSVTxuhJMD55" class="wolai-block wolai-text"><div><span class="inline-wrap">考虑到我们购物车功能中需要针对具体任何一条商品数据修改价格或做删除操作，所以适合使用<span class="jill"></span>hash<span class="jill"></span>类型来保存。</span></div></div><ul class="wolai-block"><li id="qHQHgfqsW4nvovg9f7dydw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">filed：使用<span class="jill"></span>skuId<span class="jill"></span>的值来设定</span></li><li id="9WLMVFQg8P1swcKDV3kbWL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">value：CartInfo<span class="jill"></span>对象的<span class="jill"></span>JSON<span class="jill"></span>字符串（不需要我们自己转换、解析，RedisTemplate<span class="jill"></span>已设定<span class="jill"></span>JSON<span class="jill"></span>序列化器）</span></li></ul><div id="fpDFacNqXpoz86wKVUH2Da" class="wolai-block wolai-text"><div></div></div><div id="94YwrtHBmd4r8hPWguqJZQ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="rkjUTmHiZ5xyoRoxC1VNVg" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">每天<span class="jill"></span>100w<span class="jill"></span>次登录请求，4C8G<span class="jill"></span>机器如何做<span class="jill"></span>JVM<span class="jill"></span>调优？</span></h1><h2 id="m9WDnsL7e6v77EyyJhhpeP" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">名词解释</span></h2><div id="xnnjqs2BWhzDKEjmFXxkk6" class="wolai-block wolai-text"><div><span class="inline-wrap">4C：4 CPU cores，4<span class="jill"></span>个<span class="jill"></span>CPU<span class="jill"></span>核心</span></div></div><div id="gEYdM8eQg4reRzUidRL3kn" class="wolai-block wolai-text"><div><span class="inline-wrap">8G：8G<span class="jill"></span>内存</span></div></div><div id="gM1MoTtGDe3DiEbc95PpuK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pLao5HvRY11zCXkKXSh648" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">内存分配</span></h2><h3 id="CPCJjaciz3Syph2fcWdVf" class="wolai-block"><span class="wolai-serial-number">5.2.1</span><span class="inline-wrap">JVM<span class="jill"></span>默认设置</span></h3><span class="inline-wrap"></span><br/><div id="bqMA3YsdaSNoAkk8K5yWNf" class="wolai-block wolai-text"><div><span class="inline-wrap">参数</span></div></div><span class="inline-wrap"></span><br/><div id="kC7efkMDc29wKouTi53Hek" class="wolai-block wolai-text"><div><span class="inline-wrap">描述</span></div></div><span class="inline-wrap"></span><br/><div id="s3syK471gD8anducRJxAC7" class="wolai-block wolai-text"><div><span class="inline-wrap">示例</span></div></div><span class="inline-wrap"></span><br/><div id="8kgEu5DzENG2JerE1eiQFe" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xms</span></div></div><span class="inline-wrap"></span><br/><div id="3cDG8WyttHnnf8WV34DsmD" class="wolai-block wolai-text"><div><span class="inline-wrap">初始堆大小</span></div></div><span class="inline-wrap"></span><br/><div id="2hi27QczkUXJrmXz9mJtHM" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xms512m（初始堆大小为<span class="jill"></span>512MB）</span></div></div><span class="inline-wrap"></span><br/><div id="5ZuyT1uA3GCrY4UShvTuT7" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmx</span></div></div><span class="inline-wrap"></span><br/><div id="b9D64gwvhpuuHvfmt5q7fy" class="wolai-block wolai-text"><div><span class="inline-wrap">最大堆大小</span></div></div><span class="inline-wrap"></span><br/><div id="mQEmTV7U34y892cihd9pg9" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmx2g（最大堆大小为<span class="jill"></span>2GB）</span></div></div><span class="inline-wrap"></span><br/><div id="7op9FQxd8kHWyeYeR2gbjs" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:PermSize</span></div></div><span class="inline-wrap"></span><br/><div id="aN5b8qJ8JvWm3aV1YanS2N" class="wolai-block wolai-text"><div><span class="inline-wrap">永久代的初始大小（JDK 8<span class="jill"></span>及以后被<span class="jill"></span>Metaspace<span class="jill"></span>取代）</span></div></div><span class="inline-wrap"></span><br/><div id="mDbYsBPwXzC9TH6YE32tPK" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:PermSize=128m</span></div></div><span class="inline-wrap"></span><br/><div id="7pUoMwSpr5hEa5UK1SGTcd" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxPermSize</span></div></div><span class="inline-wrap"></span><br/><div id="8akesXi6dYT8mvZGUHMJcs" class="wolai-block wolai-text"><div><span class="inline-wrap">永久代的最大大小（JDK 8<span class="jill"></span>及以后被<span class="jill"></span>Metaspace<span class="jill"></span>取代）</span></div></div><span class="inline-wrap"></span><br/><div id="iokBWVa1T97xPQf4agNHYc" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxPermSize=256m</span></div></div><span class="inline-wrap"></span><br/><div id="hqUrZzUHtpxLBES7ZJ6B4y" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MetaspaceSize</span></div></div><span class="inline-wrap"></span><br/><div id="vHV1TQXWaPuQU5vutJ5ALz" class="wolai-block wolai-text"><div><span class="inline-wrap">元空间的初始大小</span></div></div><span class="inline-wrap"></span><br/><div id="nZR8A4BWEeeubf3Pc1tBrV" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MetaspaceSize=128m</span></div></div><span class="inline-wrap"></span><br/><div id="oSQBkGntRGaGdLZZ811yxv" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxMetaspaceSize</span></div></div><span class="inline-wrap"></span><br/><div id="o6X9kQHRwVs1rnfcppCcuZ" class="wolai-block wolai-text"><div><span class="inline-wrap">元空间的最大大小</span></div></div><span class="inline-wrap"></span><br/><div id="xvQQ35i4B8r2mDokVHL1MC" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxMetaspaceSize=256m</span></div></div><span class="inline-wrap"></span><br/><div id="rsnMyUPh3VNTWhVsaWNAEY" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmn</span></div></div><span class="inline-wrap"></span><br/><div id="mijn3HHmSvzzJ6p1yEma4x" class="wolai-block wolai-text"><div><span class="inline-wrap">年轻代的大小（JDK 8<span class="jill"></span>及以后使用-Xmn<span class="jill"></span>替代-XX:NewSize<span class="jill"></span>和-XX:MaxNewSize）</span></div></div><span class="inline-wrap"></span><br/><div id="jgdqMBuLPwsCM5usg6T2Mg" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmn512m</span></div></div><span class="inline-wrap"></span><br/><div id="vXWdjVpRnsTSe26iykSfVi" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:NewSize</span></div></div><span class="inline-wrap"></span><br/><div id="vYEjEZmxTMoJDPjfWxv5xM" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代的初始大小（旧版<span class="jill"></span>JDK）</span></div></div><span class="inline-wrap"></span><br/><div id="o4zBiXH7PeBXorYE7TE2AJ" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:NewSize=512m</span></div></div><span class="inline-wrap"></span><br/><div id="cLQ69oKzwMudyVYfADC2KU" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxNewSize</span></div></div><span class="inline-wrap"></span><br/><div id="4Jc1GguUXCGfBwLhe7kDz7" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代的最大大小（旧版<span class="jill"></span>JDK）</span></div></div><span class="inline-wrap"></span><br/><div id="5bwq48719p1cma2wNvrr5n" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:MaxNewSize=512m</span></div></div><span class="inline-wrap"></span><br/><div id="3HZFskSp291Y31SPC4mUhN" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:NewRatio</span></div></div><span class="inline-wrap"></span><br/><div id="je7ycvAehPbTjxFmV2XZXf" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代与年轻代的比例</span></div></div><span class="inline-wrap"></span><br/><div id="oPQbU7Ba8GzwL9t3hLkT8Q" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:NewRatio=2</span></div></div><span class="inline-wrap"></span><br/><div id="wEpmbyW1yBRq5p3ZshmujX" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:SurvivorRatio</span></div></div><span class="inline-wrap"></span><br/><div id="pdibF8yrVeuydD9WuUeGmz" class="wolai-block wolai-text"><div><span class="inline-wrap">Eden<span class="jill"></span>区与<span class="jill"></span>Survivor<span class="jill"></span>区的比例</span></div></div><span class="inline-wrap"></span><br/><div id="2RaNt6ycE6nzdH1gaZfici" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:SurvivorRatio=8</span></div></div><span class="inline-wrap"></span><br/><div id="nmPXA3nmNqp5sTsZUD9fEX" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:TargetSurvivorRatio</span></div></div><span class="inline-wrap"></span><br/><div id="7HeUAuKY9GMsXBFC3EYMrV" class="wolai-block wolai-text"><div><span class="inline-wrap">目标幸存区比例，用于计算动态调整的幸存区比例</span></div></div><span class="inline-wrap"></span><br/><div id="7PDgntwAVztTHpDgEwhuuk" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:TargetSurvivorRatio=90</span></div></div><span class="inline-wrap"></span><br/><div id="nJf4TppPWkLkEDhYX26jJ" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xss</span></div></div><span class="inline-wrap"></span><br/><div id="6J4mmQizLe8F141P8zZxpP" class="wolai-block wolai-text"><div><span class="inline-wrap">每个线程的栈大小</span></div></div><span class="inline-wrap"></span><br/><div id="cDUnXHirfBTmxRyDUpiUMb" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xss1m（每个线程的栈大小为<span class="jill"></span>1MB）</span></div></div><span class="inline-wrap"></span><br/><div id="kxJS58kerTiAXn7C6vLNw2" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:ThreadStackSize</span></div></div><span class="inline-wrap"></span><br/><div id="2uCvizpUNZvd1wY2dxDPpJ" class="wolai-block wolai-text"><div><span class="inline-wrap">设置线程栈大小（与-Xss<span class="jill"></span>相同，但更明确）</span></div></div><span class="inline-wrap"></span><br/><div id="bYGPAnC1EcHBUVSBGTnjLU" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:ThreadStackSize=1024k</span></div></div><div id="vwsVvLUCrvsqPDUq9BkshR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="oN4atKatvdZsrVAGDum1oN" class="wolai-block"><span class="wolai-serial-number">5.2.2</span><span class="inline-wrap">实际设置</span></h3><div id="szC5TtaBErKDVj1KnrJUPv" class="wolai-block wolai-text"><div><span class="inline-wrap">题目中给出的服务器内存是<span class="jill"></span>8G，在<span class="jill"></span>8GB<span class="jill"></span>内存的服务器上配置<span class="jill"></span>JVM<span class="jill"></span>参数时，需要综合考虑堆内存、新生代大小、老年代大小、栈内存以及垃圾收集器的选择。以下是一个基于通用场景的配置建议：</span></div></div><ol class="wolai-block"><li id="nA68Fr7V7VxY8X3UhPam4q"><div class="marker"></div><span class="inline-wrap"><b>堆内存设置</b></span><ul class="wolai-block"><li id="iY9fJKrLe3k2DkPW9WsZCV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>初始堆大小（-Xms）和最大堆大小（-Xmx）</b></span><span class="inline-wrap">：通常建议将两者设置为相同的值，以避免堆内存的动态调整带来的性能开销。对于<span class="jill"></span>8GB<span class="jill"></span>内存的服务器，可以将堆内存设置为<span class="jill"></span>4GB，即</span><span class="inline-wrap"><code>-Xms4g -Xmx4g</code></span><span class="inline-wrap">。</span></li></ul></li><li id="djVZBWKTCXvBzZUdu8RyNe"><div class="marker"></div><span class="inline-wrap"><b>新生代大小</b></span><ul class="wolai-block"><li id="ewNCcPrrqFAivqqm9RT8B6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新生代的大小可以设置为堆内存的<span class="jill"></span>1/3<span class="jill"></span>至<span class="jill"></span>1/4。在这个例子中，可以将新生代大小设置为<span class="jill"></span>1GB，即</span><span class="inline-wrap"><code>-XX:NewSize=1g -XX:MaxNewSize=1g</code></span><span class="inline-wrap">。</span></li></ul></li><li id="6tCCEnoQYQuKucrmypK7ab"><div class="marker"></div><span class="inline-wrap"><b>老年代大小</b></span><ul class="wolai-block"><li id="sLt35DBZ8V16gnvbK7JmjE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">老年代的大小通常是堆内存减去新生代大小后的剩余部分。在这个配置中，老年代大小将是<span class="jill"></span>3GB（4GB<span class="jill"></span>堆内存 - 1GB<span class="jill"></span>新生代）。</span></li></ul></li><li id="dgVfv9RhDroUfVqkqrPAPz"><div class="marker"></div><span class="inline-wrap"><b>栈内存</b></span><ul class="wolai-block"><li id="8gbunBC7HNNs5SHjQz3s55"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">栈内存用于存储线程相关的信息，建议设置为较小的值，例如<span class="jill"></span>512KB，即</span><span class="inline-wrap"><code>-Xss512k</code></span><span class="inline-wrap">。</span></li></ul><blockquote id="bWXBocdLtc8acCwdxwZFF7" class="wolai-block"><span class="inline-wrap">细节说明：
从逻辑上来说，JVM<span class="jill"></span>支持的线程总数量=栈内存总大小<span class="jill"></span>÷<span class="jill"></span>单个线程可申请的空间大小（也就是-Xss）
但<span class="jill"></span>JVM<span class="jill"></span>中并不存在专门针对栈内存总大小的参数设置，也就是说我们无法人为指定栈内存总大小
当<span class="jill"></span>JVM<span class="jill"></span>启动新的线程就会向操作系统申请更大的内存空间，如果申请失败则抛出<span class="jill"></span>OutOfMemoryError

有人说：哎，不对呀？搞错了吧！栈溢出不是抛<span class="jill"></span>StackOverflowError<span class="jill"></span>么？
没搞错，分配给单个线程的栈空间，在线程运行时发生内存溢出抛出<span class="jill"></span>StackOverflowError。

而如果<span class="jill"></span>JVM<span class="jill"></span>运行的线程太多，导致操作系统都无法分配更多的内存空间，此时抛出的就是<span class="jill"></span>OutOfMemoryError
但是考虑到线程通常存在的时间很短，朝生夕死，这样又不断的释放出可用的空间，再加上每个线程占用的空间都不大，所以其实因为线程过多而导致内存溢出的情况几乎不可能出现

回到题目上来，我们上面说了这么多就是为了证明我们无法通过<span class="jill"></span>JVM<span class="jill"></span>内存参数设置来限定业务线程的数量
那么业务线程的数量怎么限制呢？
答：线程池</span></blockquote></li><li id="fJ1q2wb9MG85GBCrg9kaHp"><div class="marker"></div><span class="inline-wrap"><b>垃圾收集器选择</b></span><ul class="wolai-block"><li id="wk24HK1h2RzmSptA8v4KTx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果服务器有多个<span class="jill"></span>CPU<span class="jill"></span>核心，可以考虑使用并行垃圾收集器，如</span><span class="inline-wrap"><code>-XX:+UseParallelGC</code></span><span class="inline-wrap">。</span></li><li id="kCkJfBJ5xUXk9EYbq1DLwU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对于延迟敏感的应用，推荐使用<span class="jill"></span>CMS<span class="jill"></span>垃圾收集器，即</span><span class="inline-wrap"><code>-XX:+UseConcMarkSweepGC</code></span><span class="inline-wrap">。</span></li><li id="hcReMBBhxhbzmDJTnoMm3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对于大内存服务且要求高吞吐量的应用，G1<span class="jill"></span>垃圾收集器是一个不错的选择，即</span><span class="inline-wrap"><code>-XX:+UseG1GC</code></span><span class="inline-wrap">。</span></li></ul></li><li id="iyQpUuV2QcTm8MoLxqzvnz"><div class="marker"></div><span class="inline-wrap"><b>并发线程数</b></span><span class="inline-wrap">： 调整并发线程数以充分利用多核<span class="jill"></span>CPU。对于<span class="jill"></span>4<span class="jill"></span>核的机器，可以考虑设置参数 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=2。</span></li><li id="hMwzACzm1BMvgLZ47pUf3L"><div class="marker"></div><span class="inline-wrap"><b>内存回收周期</b></span><span class="inline-wrap">： 根据应用的特点和负载，调整垃圾回收的时间间隔。可以使用参数 -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent 来控制新生代的内存分配百分比。</span></li><li id="tusez7evaWviePsnYzLC3L"><div class="marker"></div><span class="inline-wrap"><b>堆区域划分</b></span><span class="inline-wrap">： G1<span class="jill"></span>垃圾回收器允许将堆内存划分为多个区域，可以通过参数-XX:G1HeapRegionSize 来调整每个区域的大小，以优化垃圾回收的效率。</span></li><li id="9asYhs7wJ6YMEr82QEnxqT"><div class="marker"></div><span class="inline-wrap"><b>元空间设置</b></span><span class="inline-wrap">： 对于大量的类加载和反射操作，需要适当调整元空间的大小。可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize。</span></li><li id="gAEwacPWkxBEMMcY3i2Eeb"><div class="marker"></div><span class="inline-wrap"><b>JVM<span class="jill"></span>日志和监控</b></span><span class="inline-wrap">： 开启<span class="jill"></span>JVM<span class="jill"></span>的日志和监控可以帮助你实时了解<span class="jill"></span>JVM<span class="jill"></span>的运行状态和性能指标，以便及时调整参数。
可以使用参数 -XX:+PrintGC -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps 来输出垃圾回收日志。</span></li></ol><div id="pN6cxSR29kRDYtVoEek53N" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="asERMnkNLzh6RESr3uYEz2" class="wolai-block"><span class="wolai-serial-number">5.3</span><span class="inline-wrap">并发能力分析</span></h2><div id="i5NsjKcf2rQXLHSq4C7dT8" class="wolai-block wolai-text"><div><span class="inline-wrap">每天<span class="jill"></span>100<span class="jill"></span>万次登录请求是表面现象，具体分解拆开来看，它意味着什么呢？</span></div></div><div id="3MTLA6BPcYgMY4GLnHmGPk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="sqwuJkRDzPRVcVXyVG4crw" class="wolai-block"><span class="wolai-serial-number">5.3.1</span><span class="inline-wrap">登录请求</span></h3><div id="ahuZJmBsEZhLtq2dSoAnpD" class="wolai-block wolai-text"><div><span class="inline-wrap">用户登录是属于登录认证模块的业务功能，那么接下来需要考虑的是：</span></div></div><ul class="wolai-block"><li id="umYAr9srfJb3qeHtcScKXL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">整个项目是单体应用还是分布式应用？</span></li><li id="es1Yue17B1RTeb5feYQEUs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果是分布式应用，那么各个模块是全部部署到这台<span class="jill"></span>4C8G<span class="jill"></span>的机器上，还是分别分开部署？</span></li><li id="a7fN9BMobBkME7M8Pok1rn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果每一台<span class="jill"></span>4C8G<span class="jill"></span>机器运行一个模块，那么该登录认证模块是否搭建集群？</span></li></ul><div id="oMvJQgj9U6CmSUdx22L34E" class="wolai-block wolai-text"><div><span class="inline-wrap">这里我们假设整个项目是分布式项目，各个模块单独部署，登录认证模块部署在<span class="jill"></span>4C8G<span class="jill"></span>的机器上。至于说这台机器是否需要搭建集群，需要根据访问压力继续分析。</span></div></div><div id="qt7dfJGR4jhHJScRn4DSHF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="xprJEfvoPNzLfqe32ZXc5r" class="wolai-block"><span class="wolai-serial-number">5.3.2</span><span class="inline-wrap">每天<span class="jill"></span>100<span class="jill"></span>万次登录请求的业务分析</span></h3><div id="uhYEUuxPn2RYH9n2nDgfBB" class="wolai-block wolai-text"><div><span class="inline-wrap">就登录认证模块而言，登录只是多个不同业务功能的其中一个，所以为了推算<span class="jill"></span>4C8G<span class="jill"></span>机器内线程池该如何设置，4C8G<span class="jill"></span>是否需要搭建集群，我们需要一个总的访问量，而不是一个单独的业务功能。</span></div></div><div id="isuM9r2qaBBKAtn6fHYrLq" class="wolai-block wolai-text"><div><span class="inline-wrap">假设登录认证模块的业务功能如下所示：</span></div></div><ol class="wolai-block"><li id="4vvKjPr73GDv6Fkrkco3ub"><div class="marker"></div><span class="inline-wrap">用户登录</span></li><li id="m7cVrCVtBveqPoggpCPDk4"><div class="marker"></div><span class="inline-wrap">忘记密码</span></li><li id="arqPZq5Pf9Fmj78JiiotNy"><div class="marker"></div><span class="inline-wrap">用户注册</span></li><li id="8mgYcmkbcuxi1poVpBgAcc"><div class="marker"></div><span class="inline-wrap">用户名是否重复的校验</span></li><li id="r4DdWhXXACwNSN6tWYzK92"><div class="marker"></div><span class="inline-wrap">发送短信验证码</span></li><li id="gn61MfmLVEpxz3YZjCZ2a4"><div class="marker"></div><span class="inline-wrap">token<span class="jill"></span>有序性验证</span></li><li id="dDc1qwJzAAaG13NuUr5WLp"><div class="marker"></div><span class="inline-wrap">用户个人中心页面展示</span></li><li id="ibrGJ3wNqUpMPMwWdqG4sG"><div class="marker"></div><span class="inline-wrap">用户充值</span></li><li id="tjFsTUf35B69Wa6THHW3Bx"><div class="marker"></div><span class="inline-wrap">VIP<span class="jill"></span>会员有效性验证</span></li><li id="PPvanit15x3RWv9jK1my3"><div class="marker"></div><span class="inline-wrap">VIP<span class="jill"></span>会员权益校验</span></li></ol><div id="amu1uy4Z7YiGGaSACaGvP2" class="wolai-block wolai-text"><div><span class="inline-wrap">所以假设模块的总访问量是登录访问量的<span class="jill"></span>10<span class="jill"></span>倍，那就是每天<span class="jill"></span>1000<span class="jill"></span>万次</span></div></div><div id="jkEprXf9KfDuoiyzfwucNd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bSUXH15Wcku1aex4nb5jjV" class="wolai-block"><span class="wolai-serial-number">5.3.3</span><span class="inline-wrap">总访问量的时间分布</span></h3><div id="gcG7QKFfEYf2KnNbiTSstP" class="wolai-block wolai-text"><div><span class="inline-wrap">每天<span class="jill"></span>1000<span class="jill"></span>万次访问是在<span class="jill"></span>24<span class="jill"></span>小时内均匀分布的吗？</span></div></div><div id="ageAvv54Ta2MiBm4KF4jCh" class="wolai-block wolai-text"><div><span class="inline-wrap">很显然不是，大部分请求都会集中在高峰期的时间段内。</span></div></div><div id="otqaLaRRhu1E2LK2izoAz1" class="wolai-block wolai-text"><div><span class="inline-wrap">为了计算出最高峰的访问压力，我们基于二八定律来分析：</span></div></div><ul class="wolai-block"><li id="8Y4KQWJTv5usBSPeBCjtDw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">80%<span class="jill"></span>的访问量发生在<span class="jill"></span>20%<span class="jill"></span>的高峰期时间段内</span></li><li id="kfhzKhU8arf3WsitMmCnkH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">1000<span class="jill"></span>万的<span class="jill"></span>80%=800<span class="jill"></span>万</span></li><li id="qtRTohNTv5UHJ4PNv8fF6k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">24<span class="jill"></span>小时的<span class="jill"></span>20%=4.8<span class="jill"></span>小时</span></li></ul><div id="8nTFkmRBjWU72YXe9GHJdi" class="wolai-block wolai-text"><div><span class="inline-wrap">但是在这<span class="jill"></span>4.8<span class="jill"></span>小时内，访问量也不是均匀分布的，我们继续使用二八定律来进行两轮计算：</span></div></div><ul class="wolai-block"><li id="vc3Tzdc78KF8WvrYkquiEL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">800<span class="jill"></span>万的访问量发生在高峰期时间段的<span class="jill"></span>20%<span class="jill"></span>时间内</span></li><li id="5e46xeYLNqYp3BJVFurkmG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">800<span class="jill"></span>万的<span class="jill"></span>80%=640<span class="jill"></span>万</span></li><li id="cNSsshuUGjunbEjDPntpvF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">4.8<span class="jill"></span>小时的<span class="jill"></span>20%=57.6<span class="jill"></span>分钟</span></li><li id="dbTJB2Nm91vf78LcNH5SMq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">640<span class="jill"></span>万的<span class="jill"></span>80%=512<span class="jill"></span>万</span></li><li id="rHAbRi26RQAfRitQnAuA9C"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">57.6<span class="jill"></span>分钟的<span class="jill"></span>20%=11.52<span class="jill"></span>分钟=691.2<span class="jill"></span>秒</span></li></ul><div id="mWLsf9dVN36ETA3wL1i5qd" class="wolai-block wolai-text"><div><span class="inline-wrap">也就是说在最高峰时期，服务器需要在<span class="jill"></span>691.2<span class="jill"></span>秒内处理<span class="jill"></span>512<span class="jill"></span>万个请求</span></div></div><div id="p2K9qnsfNMcXXRSGTmJ8xF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="p8uAAbDEDrf27P7c5Bw7u4" class="wolai-block"><span class="wolai-serial-number">5.3.4</span><span class="inline-wrap">QPS</span></h3><div id="3Tk6zzF2ux453bMcQjbACs" class="wolai-block wolai-text"><div><span class="inline-wrap">QPS（Queries Per Second，每秒查询率）是衡量服务器处理能力的一个重要指标。它表示每秒钟服务器能够处理的请求数量。</span></div></div><div id="8rTp8mU5KCCXe5ixBG6brw" class="wolai-block wolai-text"><div><span class="inline-wrap">QPS<span class="jill"></span>的计算很简单：在一定的时间段内总请求数量<span class="jill"></span>÷<span class="jill"></span>时间段内有多少秒</span></div></div><div id="qbC7mHFNP8V5aAis9WA66m" class="wolai-block wolai-text"><div><span class="inline-wrap">代入上面分析得出的数据：服务器需要在<span class="jill"></span>691.2<span class="jill"></span>秒内处理<span class="jill"></span>512<span class="jill"></span>万个请求</span></div></div><div id="aEC9UmHsmUZXcEDG1gCb2U" class="wolai-block wolai-text"><div><span class="inline-wrap">QPS=512<span class="jill"></span>万请求<span class="jill"></span>÷691.2<span class="jill"></span>秒<span class="jill"></span>≈7407</span></div></div><div id="4Xt9fQkoA4uyiHX4AADJLg" class="wolai-block wolai-text"><div><span class="inline-wrap">也就是说：服务器在访问量最高峰的时候需要在<span class="jill"></span>1<span class="jill"></span>秒内处理大约<span class="jill"></span>7000<span class="jill"></span>个请求</span></div></div><div id="pjj4fkDkp7xU48Nw8X4Jh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jk6ZfKkC9kpCK3c9ggH6QS" class="wolai-block"><span class="wolai-serial-number">5.3.5</span><span class="inline-wrap">并发量</span></h3><div id="9FgNXJNfzwvbXZFpEuAMAe" class="wolai-block wolai-text"><div><span class="inline-wrap">那么<span class="jill"></span>QPS<span class="jill"></span>是不是就是并发量呢？二者有极高的相关性，但是并不等同。</span></div></div><div id="eTv4SKuEfDid8Yer4ZVKqR" class="wolai-block wolai-text"><div><span class="inline-wrap">QPS<span class="jill"></span>能直观帮助我们看到服务器的访问压力，但是<span class="jill"></span>QPS<span class="jill"></span>并不直接等于并发量。</span></div></div><div id="7BV52N1Qx39R6woucRHkqd" class="wolai-block wolai-text"><div><span class="inline-wrap">为什么这么说呢？</span></div></div><ul class="wolai-block"><li id="vwQd4eYBQksLySbSWXUWza"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设<span class="jill"></span>QPS<span class="jill"></span>是<span class="jill"></span>3，每秒处理<span class="jill"></span>3<span class="jill"></span>个请求；</span></li><li id="mNfuxAWhHetMm4rQzdvfMP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">服务器执行每个请求只需要<span class="jill"></span>100ms，且三个请求是先后到达</span></li><li id="vgMnjTHf6F1jLN97W7qY5U"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所以此时服务器面对这三个请求是一个一个处理的，那么在这个局部来看，并发量始终是<span class="jill"></span>1</span></li></ul><div id="jU1vuENWqZcw8gSdWdvCeT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="3CpgBXqc6u2iWpcmmDVuep" class="wolai-block wolai-text"><div><span class="inline-wrap">那么服务器的并发能力到底是由什么决定的呢？</span></div></div><div id="8V95CK7oZmh12ut7tbsEwT" class="wolai-block wolai-text"><div><span class="inline-wrap">由于每一个请求都需要一个线程来处理，所以服务器并发能力的上限，就是它最多能够同时运行多少个线程——这么说还是很笼统</span></div></div><div id="3uUr3KY1aeQpMsG2QFt8Yt" class="wolai-block wolai-text"><div><span class="inline-wrap">因为我们不是关心操作系统最多运行多少个线程，而是<span class="jill"></span>JVM<span class="jill"></span>最多运行多少个业务线程</span></div></div><div id="veCGjWjU6jPbeCoszguWiV" class="wolai-block wolai-text"><div><span class="inline-wrap">实际开发中不允许私自创建新的线程，而是要使用线程池，所以这个问题就进一步明确：服务器并发能力受限于线程池中的最大线程数</span></div></div><div id="jLSccNfxQDWKHRmqwZKzoL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="pzUaXTNoipgEdtr7GXCkk" class="wolai-block wolai-text"><div><span class="inline-wrap">那现在基于上一部分的推导，我们要面临的<span class="jill"></span>QPS<span class="jill"></span>大约是<span class="jill"></span>7000，此时的并发量会是多少呢？</span></div></div><div id="iV5MBTiDUY3iC4fKrVHReb" class="wolai-block wolai-text"><div><span class="inline-wrap">假设服务器处理一个请求需要<span class="jill"></span>0.5<span class="jill"></span>秒，相当于每一个线程每秒处理两个请求，7000<span class="jill"></span>个请求对应的并发量需要<span class="jill"></span>3500<span class="jill"></span>个线程</span></div></div><div id="2xq4YKWALtiTNqBz94m7n" class="wolai-block wolai-text"><div></div></div><div id="d5h2pUHiBZyAZnJoMLD3AD" class="wolai-block wolai-text"><div><span class="inline-wrap">所以接下来要考虑的就是：为了应对并发压力，线程池中的最大线程数设置成多少合适？</span></div></div><div id="gN2cx1atZHBFVjPkb35BiD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9KNZSJEDKLhKFRPhM3jbgA" class="wolai-block"><span class="wolai-serial-number">5.3.6</span><span class="inline-wrap">线程池设置</span></h3><div id="h3hREkT2N1EbMUq5NiGtM4" class="wolai-block wolai-text"><div><span class="inline-wrap">基于上面的分析，我们得出：</span><span class="inline-wrap">访问量最高峰的时间段内需要有<span class="jill"></span>3500<span class="jill"></span>个线程同时运行</span></div></div><div id="jmHDaujHW1rk9aAgrS5WQ2" class="wolai-block wolai-text"><div><span class="inline-wrap">那么这是否意味着线程池的最大线程数就设置为<span class="jill"></span>3500<span class="jill"></span>呢？</span></div></div><div id="6vgTfu1592DcTNBmhnwtXX" class="wolai-block wolai-text"><div><span class="inline-wrap">线程池中最大线程数的设置首先要考虑<span class="jill"></span>CPU<span class="jill"></span>核心数量，那么：</span></div></div><ul class="wolai-block"><li id="mNVPPY7miF8RDh4GYqHiZC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">计算密集型任务：最大线程数=CPU<span class="jill"></span>核心数量<span class="jill"></span>+1</span></li><li id="n4iPPvQfdZ52eTuXBCjZp2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">I/O<span class="jill"></span>密集型任务：最大线程数=CPU<span class="jill"></span>核心数量<span class="jill"></span>×N（N<span class="jill"></span>是正整数）</span></li></ul><div id="rcmZwByTim7uDHkwR1H4zV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fuTmMSyHN57GhPovknC6MJ" class="wolai-block wolai-text"><div><span class="inline-wrap">那么如何区分任务类型呢？</span></div></div><ul class="wolai-block"><li id="2cWLsEwSeYDEoKpduuYTtb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">计算密集型任务：游戏、视频、图像、声音等多媒体数据的浮点数计算</span></li><li id="h9gyuezVBgx44BWJmufQNP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">I/O<span class="jill"></span>密集型任务：一般的后端程序大量调用内部接口或第三方接口、访问数据库、访问<span class="jill"></span>Redis、访问消息队列……这些都是<span class="jill"></span>I/O<span class="jill"></span>操作</span></li></ul><div id="uUGpK3YV7wc1mRdKFxmAdx" class="wolai-block wolai-text"><div><span class="inline-wrap">所以通常来说后端程序属于<span class="jill"></span>I/O<span class="jill"></span>密集型任务</span></div></div><div id="xqndWwwLuW2CwhAj8HRjT8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6bG3zq5CDhtYYZKNS7nFMv" class="wolai-block wolai-text"><div><span class="inline-wrap">题目中设定的<span class="jill"></span>CPU<span class="jill"></span>核心数是<span class="jill"></span>4<span class="jill"></span>个核心，3500÷4=875</span></div></div><div id="oaB2TRU9wMYCuD4rR3VmNU" class="wolai-block wolai-text"><div><span class="inline-wrap">这么看来把最大线程数设置为<span class="jill"></span>CPU<span class="jill"></span>核心数的<span class="jill"></span>875<span class="jill"></span>倍还是太多</span></div></div><div id="gT7F6iJHtH2ob11xh8WCmn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="6Rh9bc8VinwJcMUCzA4ycs" class="wolai-block"><span class="wolai-serial-number">5.3.7</span><span class="inline-wrap">集群化配置</span></h3><ul class="wolai-block"><li id="7nVikFyvxZZvqNzAu59QS2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">登录认证模块进行集群化配置，假设集群中有<span class="jill"></span>10<span class="jill"></span>个实例</span></li><li id="uKTq2bFq3h21bAXke44Rgp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集群中每个实例内部的线程池最大线程数设置为<span class="jill"></span>4×100=400</span></li><li id="xnBtB5FPSN3pSaUAiETzzk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">那么总的线程数=400×10=4000，能够涵盖<span class="jill"></span>3500<span class="jill"></span>个线程的要求</span></li></ul><div id="cSevDiKcaBHjfhidZgDREK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="uHcMGvUkutGgWxtNhSUntL" class="wolai-block"><span class="wolai-serial-number">5.3.8</span><span class="inline-wrap">动态扩缩容</span></h3><div id="qMMBUS8ZUFUa5xLz9aR76i" class="wolai-block wolai-text"><div><span class="inline-wrap">考虑到项目仅仅只是在有限的时间内才会面临较大的并发压力，所以没有必要在低谷期也按照高峰期的配置运行</span></div></div><div id="2XaHGChEsPBCXXtCNFWBeS" class="wolai-block wolai-text"><div><span class="inline-wrap">此时使用<span class="jill"></span>Kubernetes+Docker<span class="jill"></span>实现动态扩缩容就是很好的选择（本页上面已有相关介绍，不再赘述）</span></div></div><div id="dZsDKe7DNe1W6Lm3PbGncj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kV8YCWAZoaS9voWE2PrkS5" class="wolai-block"><span class="wolai-serial-number">5.4</span><span class="inline-wrap">总结</span></h2><h3 id="m5D2Mw4tskFUMF1cWyFr9Q" class="wolai-block"><span class="wolai-serial-number">5.4.1</span><span class="inline-wrap">内存设置</span></h3><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="6xYGkHhqkNV3LuVXXbxHG7" class="wolai-block wolai-text"><div><span class="inline-wrap">内存区域</span></div></div><span class="inline-wrap"></span><br/><div id="izn4an8b5HdSE6nwwbTQXE" class="wolai-block wolai-text"><div><span class="inline-wrap">初始堆空间大小</span></div></div><span class="inline-wrap"></span><br/><div id="wixPv6iwTpb4yGM8QvnY3a" class="wolai-block wolai-text"><div><span class="inline-wrap">最大堆空间大小</span></div></div><span class="inline-wrap"></span><br/><div id="ht8g1Fpf44wp53p4Ns4eH1" class="wolai-block wolai-text"><div><span class="inline-wrap">新生代空间大小</span></div></div><span class="inline-wrap"></span><br/><div id="dzmgTsmw4rHXRJ9jX1jv1o" class="wolai-block wolai-text"><div><span class="inline-wrap">参数设置</span></div></div><span class="inline-wrap"></span><br/><div id="43Ah5wyibmYLFCcnFk4xWy" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xms4G</span></div></div><span class="inline-wrap"></span><br/><div id="iBEicGa8JPBE12ByGcsF6v" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmx4G</span></div></div><span class="inline-wrap"></span><br/><div id="erHE7eSkctJTXSVVrC26n5" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xmn1G</span></div></div><span class="inline-wrap"></span><br/><div id="gGc5e5dF6UCpenWNLaKVFC" class="wolai-block wolai-text"><div><span class="inline-wrap">老年代空间大小</span></div></div><span class="inline-wrap"></span><br/><div id="qRAhD15TivZ5XxcSf9Gbca" class="wolai-block wolai-text"><div><span class="inline-wrap">计算得到：3G</span></div></div><span class="inline-wrap"></span><br/><div id="dEnDbehPhWGzALiC5duLys" class="wolai-block wolai-text"><div><span class="inline-wrap">每个线程的栈空间大小</span></div></div><span class="inline-wrap"></span><br/><div id="sSsxj5LXyFoHESkgPsepAV" class="wolai-block wolai-text"><div><span class="inline-wrap">-Xss512K</span></div></div><span class="inline-wrap"></span><br/><div id="sqJr4mGwwcrytSanCo8TX9" class="wolai-block wolai-text"><div><span class="inline-wrap">垃圾回收器</span></div></div><span class="inline-wrap"></span><br/><div id="v37DUVMASj2cgaNFfCxZqs" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:+UseG1GC</span></div></div><span class="inline-wrap"></span><br/><div id="tZtXJtUQF428bgL58B3J9q" class="wolai-block wolai-text"><div><span class="inline-wrap">并发线程数</span></div></div><span class="inline-wrap"></span><br/><div id="qipom4NZpyjYCj8mc5qyzf" class="wolai-block wolai-text"><div><span class="inline-wrap">-XX:ParallelGCThreads=4
-XX:ConcGCThreads=2</span></div></div><div id="vA9owyY3jFgf67prM2mBXS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="k42nH5vvjjmodJqmcEYXbM" class="wolai-block"><span class="wolai-serial-number">5.4.2</span><span class="inline-wrap">并发能力设置</span></h3><ul class="wolai-block"><li id="w4fKSVFzx6XzFF5zyWTzDn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">4C8G<span class="jill"></span>服务器只运行登录认证模块</span></li><li id="4poN5ZMQwBTwrHC3vNUiYf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">线程池中最大线程数设置为<span class="jill"></span>4<span class="jill"></span>的<span class="jill"></span>100<span class="jill"></span>倍</span></li><li id="hhiv13ZqFHbfb1MR7AfHSH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">结合动态扩缩容技术动态匹配访问压力</span></li></ul><div id="ev6t6U73K9m8LRedadgvCG" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qNVwGqCpADk3htnFbfcFus" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">不用<span class="jill"></span>Redis<span class="jill"></span>分布式锁，如何防止用户重复点击？</span></h1><div id="3sRB6j4wvNkm5c3imunfCu" class="wolai-block wolai-text"><div><span class="inline-wrap">不使用 Redis 分布式锁时，你仍然可以采取其他方法来防止用户重复点击。以下是一些可能的替代方案：</span></div></div><ol class="wolai-block"><li id="hybzWus2KTGqvH9oRJQhyt"><div class="marker"></div><span class="inline-wrap"><b>前端防御</b></span><span class="inline-wrap">： 在前端实现一些防御措施，例如在用户点击后禁用相应的按钮或链接，直到后台处理完成。这可以通过 JavaScript 来实现。虽然前端控制不是绝对可靠的方法（用户可能通过浏览器开发工具绕过），但可以防止大部分普通用户的重复点击。</span></li><li id="etXZuXDz9GfzAKe3wVKXvt"><div class="marker"></div><span class="inline-wrap"><b>请求队列</b></span><span class="inline-wrap">： 在后端服务中实现一个请求队列，当用户发起请求时，将请求放入队列中进行处理，并且确保同一个用户的相同请求在队列中只有一个。这可以通过用户标识（如用户<span class="jill"></span>ID）来实现。在请求处理完成之前，拒绝队列中同一用户的相同请求。</span></li><li id="bBiRrWGianpAgAZEHBPSPt"><div class="marker"></div><span class="inline-wrap"><b>记录请求时间</b></span><span class="inline-wrap">： 对于每个用户，记录其最近一次请求的时间戳。当用户发起请求时，先检查距离上一次请求的时间间隔是否足够，如果不够则拒绝处理。这可以防止用户在短时间内连续点击。</span></li><li id="h5DVAEZo1oMfpFo1akzQBM"><div class="marker"></div><span class="inline-wrap"><b>限制请求频率</b></span><span class="inline-wrap">： 设置一个全局的请求频率限制，确保同一个用户在一段时间内只能发起有限次数的请求。这可以通过限制 IP 地址、用户标识等来实现。</span></li><li id="cmp6pGVKDd6EbCMPmLgQrK"><div class="marker"></div><span class="inline-wrap"><b>使用数据库锁</b></span><span class="inline-wrap">： 尽管不如 Redis 分布式锁高效，但你可以在数据库中使用行级锁或者悲观锁来防止并发修改，从而防止用户重复点击。</span></li></ol><div id="9BPJHxTc27dFP8G5ESBWJo" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，这些方法并不能完全消除用户重复点击的可能性，因为客户端和网络环境复杂多变，总会存在一些特殊情况。综合使用多种方法可以提高防御效果。最终的选择应该基于你的应用需求、可用技术以及风险承受能力来确定。</span></div></div><div id="p91c94weGUDYt3wSfGzwrS" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bne7YFhwmiGff2f418KAt" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">让你设计一个秒杀系统，你会考虑哪些问题？</span></h1><div id="aPbXZ1KRjW6TBWs6xHDyFe" class="wolai-block wolai-text"><div><span class="inline-wrap">当设计一个秒杀系统时，需要考虑以下一些关键问题：  </span></div></div><ol class="wolai-block"><li id="fisUcgQYpbVPJCD3H3A5T7"><div class="marker"></div><span class="inline-wrap"><b>高并发处理</b></span><span class="inline-wrap">： 秒杀活动通常会引起巨大的并发请求，系统需要能够处理大量用户同时发起的请求，确保系统稳定运行，不会因为负载过重而崩溃。</span></li><li id="qHwjUKuD2z5JBqZhZzCKDR"><div class="marker"></div><span class="inline-wrap"><b>数据一致性</b></span><span class="inline-wrap">： 在秒杀过程中，多个用户可能会竞争有限的资源，如商品库存。需要确保并发操作不会导致数据不一致或超卖现象。 </span></li><li id="qsupLBMEWwQBYJ1jQfKM8F"><div class="marker"></div><span class="inline-wrap"><b>库存管理</b></span><span class="inline-wrap">： 如何高效地管理商品库存，避免超卖和卖完的情况，同时能够迅速更新库存状态，是一个关键问题。</span></li><li id="9dwczK9oinvfVDVMSkpo1n"><div class="marker"></div><span class="inline-wrap"><b>限流和防刷</b></span><span class="inline-wrap">： 需要采取措施限制用户频繁的请求，以防止恶意刷单和重复点击。</span></li><li id="rL3yN8pdk3B74fqdTX3Rkr"><div class="marker"></div><span class="inline-wrap"><b>队列和异步处理</b></span><span class="inline-wrap">： 使用队列技术可以将请求缓冲起来，然后异步处理，以减轻数据库和服务器压力，提高系统性能。</span></li><li id="nKM2YsDGd3fSBzXf7nx3fP"><div class="marker"></div><span class="inline-wrap"><b>缓存策略</b></span><span class="inline-wrap">： 合理使用缓存可以减轻数据库压力，提高数据访问速度，但需要注意缓存的更新策略，以确保数据的实时性和准确性。</span></li><li id="aKzinFrKUM4JQ2V9CSMFzw"><div class="marker"></div><span class="inline-wrap"><b>分布式架构</b></span><span class="inline-wrap">： 考虑采用分布式架构，将不同功能模块分散在不同的服务器上，以提高系统的扩展性和可用性。</span></li><li id="tmGiQDVJHcUYzaHk9Xe5b6"><div class="marker"></div><span class="inline-wrap"><b>安全性和防护</b></span><span class="inline-wrap">： 防止恶意攻击、SQL 注入、XSS 等安全问题，保障用户数据安全和系统稳定。</span></li><li id="uK6opdTxhuCkqTa8rCEwyW"><div class="marker"></div><span class="inline-wrap"><b>用户体验</b></span><span class="inline-wrap">： 设计友好的用户界面和流程，确保用户能够顺利参与秒杀活动，同时避免因为系统问题造成用户体验不佳。</span></li><li id="7hqmGfk9WdooebB1f7w43U"><div class="marker"></div><span class="inline-wrap"><b>监控和调优</b></span><span class="inline-wrap">： 设置合适的监控系统，实时监测系统运行状态、性能指标和异常情况，及时进行调优和处理故障。</span></li><li id="tdRYpeT7UkSzmV3xTTnpor"><div class="marker"></div><span class="inline-wrap"><b>容灾和备份</b></span><span class="inline-wrap">： 考虑系统的容灾和备份方案，确保系统在故障时能够快速恢复，并保障数据不会丢失。</span></li><li id="no534FD4TZwexw1bSyMX1z"><div class="marker"></div><span class="inline-wrap"><b>业务流程设计</b></span><span class="inline-wrap">： 定义清晰的秒杀流程，包括商品展示、下单、支付、发货等环节，确保整个流程顺畅运行。</span></li></ol><div id="5zbppyx4Xf9QWYSsnAMQcD" class="wolai-block wolai-text"><div><span class="inline-wrap">这些只是设计秒杀系统时需要考虑的一些关键问题，具体方案需要根据业务需求和技术栈来定制。</span></div></div><div id="eqvTEhVpdaWFTj7PBEUZMg" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="7YpHCxnzrxW5U31NEGVLj1" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">如果让你实现消息队列，会考虑哪些问题？</span></h1><div id="3tkqxFGoxHb4pt3h5jCNj6" class="wolai-block wolai-text"><div><span class="inline-wrap">如果要设计和实现一个消息队列，需要考虑以下问题：  </span></div></div><ol class="wolai-block"><li id="7AYD1xJGcTMyXVpB9oYxQE"><div class="marker"></div><span class="inline-wrap"><b>消息传递方式</b></span><span class="inline-wrap">： 确定消息是通过什么方式进行传递，常见的方式包括点对点传递和发布-订阅模式。</span></li><li id="sdvCyEYFLrp8H8Ax5UVput"><div class="marker"></div><span class="inline-wrap"><b>消息持久化</b></span><span class="inline-wrap">： 考虑消息是否需要被持久化，以防止消息在系统故障时丢失。可以选择将消息存储在数据库、文件系统或者其他持久化存储中。</span></li><li id="pv9L7ErwzQByXr1cW2STNz"><div class="marker"></div><span class="inline-wrap"><b>消息顺序性</b></span><span class="inline-wrap">： 某些场景下，消息的顺序性非常重要。设计时需要确保相同的消息顺序被保留，并且不同消息之间的顺序不会混淆。</span></li><li id="bBwxPTnqCbrcWW12vcprEM"><div class="marker"></div><span class="inline-wrap"><b>消息传递的可靠性</b></span><span class="inline-wrap">： 系统应该能够保证消息的可靠传递，即使在网络不稳定或者其他异常情况下也能够确保消息的送达。</span></li><li id="izEKARhFpZLmwccMJLZwmV"><div class="marker"></div><span class="inline-wrap"><b>消息重试机制</b></span><span class="inline-wrap">： 考虑在消息处理失败时的重试机制，以确保消息最终被成功处理，避免因为一次失败就丢失了重要信息。</span></li><li id="rC1cCvTdD9peaN3G44SavP"><div class="marker"></div><span class="inline-wrap"><b>消息格式与序列化</b></span><span class="inline-wrap">： 确定消息的格式以及如何进行序列化和反序列化，以便消息能够在不同组件之间进行传递和解析。</span></li><li id="2AERRw65GW4JiKu2gWLowV"><div class="marker"></div><span class="inline-wrap"><b>消息过滤与路由</b></span><span class="inline-wrap">： 考虑如何根据消息的内容对消息进行过滤和路由，确保消息被正确地发送到目标处理程序。</span></li><li id="pdHaTNfnuiPpW1WXTBqxFr"><div class="marker"></div><span class="inline-wrap"><b>性能和吞吐量</b></span><span class="inline-wrap">： 根据预期的负载和性能需求，选择合适的消息队列实现，并进行性能测试和优化。</span></li><li id="2VtQZRaWGCtpn4G3hFQAgL"><div class="marker"></div><span class="inline-wrap"><b>扩展性</b></span><span class="inline-wrap">： 系统应该能够方便地进行横向扩展，以适应日益增长的消息量。</span></li><li id="2rJXSL74MTnswCMYWevTS1"><div class="marker"></div><span class="inline-wrap"><b>监控和管理</b></span><span class="inline-wrap">： 设计合适的监控系统，实时监测消息队列的状态和性能指标，同时提供管理工具来管理消息的发送、消费和处理。</span></li><li id="fSHFGKqtAbAMJnAGUpFapG"><div class="marker"></div><span class="inline-wrap"><b>安全性</b></span><span class="inline-wrap">： 考虑消息队列的安全性，防止未经授权的访问和消息篡改。</span></li><li id="bHaRuXsCQjqWDtJF7KX4z9"><div class="marker"></div><span class="inline-wrap"><b>集成和支持</b></span><span class="inline-wrap">： 考虑消息队列与其他系统的集成，提供适当的<span class="jill"></span>API<span class="jill"></span>和文档，以便开发人员能够方便地使用消息队列。</span></li></ol><div id="dWYQZ4krXcFsg7Fs25tsdx" class="wolai-block wolai-text"><div><span class="inline-wrap">这些是设计和实现消息队列时需要考虑的一些关键问题，具体方案会根据实际需求和技术选择进行定制。</span></div></div><div id="tkFaBorSsQ4rD7VW1umsoN" class="wolai-block wolai-text"><div></div></div><div id="97kJUMDFNaSozeQ8bLpiq9" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="8QECazvP8VxMZ7UiFjogZD" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">库存扣减如何避免超卖和少卖？</span></h1><div id="hgBaiBxEpSjoJyr18QBHLt" class="wolai-block wolai-text"><div><span class="inline-wrap">针对库存扣减避免超卖和少卖的问题，你可以结合消息队列的设计和实现来解决。以下是一个基本的思路：</span></div></div><ol class="wolai-block"><li id="vjmRcjWqh8JKNAJtRdiutd"><div class="marker"></div><span class="inline-wrap"><b>库存管理系统</b></span><span class="inline-wrap">：首先，你需要一个库存管理系统来跟踪每个商品的库存数量。这个系统应该能够及时更新库存数量，记录每次的库存变动。</span></li><li id="beLQUXHnHHpE51Z7sMfgb6"><div class="marker"></div><span class="inline-wrap"><b>消息队列应用</b></span><span class="inline-wrap">：对于库存扣减操作，你可以将其转化为消息队列的任务。每次有订单需要扣减库存时，将一个消息发送到消息队列。</span></li><li id="k5M4gNNcqRx5iYEroDYceo"><div class="marker"></div><span class="inline-wrap"><b>消费者服务</b></span><span class="inline-wrap">：在消息队列中，你可以有一个或多个消费者服务，负责实际的库存扣减操作。这样做的好处是，你可以控制同时进行库存扣减的并发量，从而避免超卖和少卖的问题。</span></li><li id="rq2KPmX4MszUQN4tgLxme2"><div class="marker"></div><span class="inline-wrap"><b>事务处理</b></span><span class="inline-wrap">：在库存扣减操作中，确保消息队列中的每个消息都被消费者服务原子性地处理。这可以使用消息队列的事务特性或者结合数据库事务来实现。如果扣减库存和订单的状态更新在不同系统中进行，确保这两个操作要么同时成功，要么同时失败，以保持数据的一致性。</span></li><li id="nWiUX8iwhLMmrLRYctc2vp"><div class="marker"></div><span class="inline-wrap"><b>库存预检查</b></span><span class="inline-wrap">：在处理消息之前，消费者服务可以进行库存预检查，检查库存是否足够以执行扣减操作。如果库存不足，可以将消息退回到队列或者将其标记为失败。</span></li><li id="vLxMZX4t2UP127sEzyCud1"><div class="marker"></div><span class="inline-wrap"><b>库存补偿机制</b></span><span class="inline-wrap">：如果发生了少卖的情况，你可以设计一个库存补偿机制。例如，定期检查库存和实际销售情况，如果有差异，则自动增加库存以补偿。</span></li><li id="nqNViJ8eV2W1pXpdyj59p"><div class="marker"></div><span class="inline-wrap"><b>监控和报警</b></span><span class="inline-wrap">：针对库存扣减过程，设计监控系统来实时监测消息队列状态和性能，同时监控库存的变化。设置报警机制，如果出现异常情况（比如消息积压、库存异常等），及时通知相关人员进行处理。8. 安全性和集成： 确保消息队列的安全性，只允许授权的操作访问消息队列。同时，提供集成接口和文档，让开发人员能够方便地使用消息队列进行库存扣减。</span></li></ol><div id="bCM7r5fAd3XcTgG32FHjwo" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，通过合理的消息队列设计、事务处理、预检查和监控机制，你可以有效地避免库存的超卖和少卖问题，保证系统的稳定和一致性。具体的实现会根据你所选择的消息队列系统和技术栈有所不同。</span></div></div><div id="4fc9z6cN8YebrdP64MXgkh" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qvrz85n1S1qMv7h3amcf3K" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">如何用<span class="jill"></span>Redis<span class="jill"></span>实现朋友圈点赞功能？</span></h1><div id="vS3rt7FFppfXnaqposwywM" class="wolai-block wolai-text"><div><span class="inline-wrap">当使用<span class="jill"></span>Redis<span class="jill"></span>来实现朋友圈点赞功能时，可以按照以下步骤进行设计和实现：</span></div></div><ol class="wolai-block"><li id="jHivcvBDTUEBe7Zcv4fQBR"><div class="marker"></div><span class="inline-wrap">存储点赞关系： 使用<span class="jill"></span>Redis<span class="jill"></span>的数据结构，例如<span class="jill"></span>Set，来存储点赞关系。对于每篇朋友圈动态，可以使用一个<span class="jill"></span>Set<span class="jill"></span>来存储点赞的用户<span class="jill"></span>ID。每个用户<span class="jill"></span>ID<span class="jill"></span>只能在<span class="jill"></span>Set<span class="jill"></span>中出现一次，确保每个用户只能点赞一次。</span></li><li id="niGBYiUqEkKL4ASQybcaYi"><div class="marker"></div><span class="inline-wrap">点赞计数： 可以使用<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>Sorted Set<span class="jill"></span>来存储点赞计数信息。每篇朋友圈动态都对应一个<span class="jill"></span>Sorted Set，其中成员是用户<span class="jill"></span>ID，分数是点赞的时间戳。这样可以实现点赞时间的排序，并且可以通过<span class="jill"></span>Sorted Set<span class="jill"></span>的长度来获取点赞的总数。</span></li><li id="r1oN2RpUNNKJ9kGtzBq3ZT"><div class="marker"></div><span class="inline-wrap">取消点赞： 如果用户取消点赞，只需从点赞关系的<span class="jill"></span>Set<span class="jill"></span>中移除相应的用户<span class="jill"></span>ID，同时从<span class="jill"></span>Sorted Set<span class="jill"></span>中删除对应的成员。</span></li><li id="gpNFY7cr6YJEESMmme38FJ"><div class="marker"></div><span class="inline-wrap">查看点赞状态： 通过判断用户<span class="jill"></span>ID<span class="jill"></span>是否在点赞关系的<span class="jill"></span>Set<span class="jill"></span>中，可以确定用户是否已经点赞。</span></li><li id="vnpKYFcSaTVYhCECGLDdF3"><div class="marker"></div><span class="inline-wrap">获取点赞列表： 如果需要展示最近点赞的用户列表，可以通过获取<span class="jill"></span>Sorted Set<span class="jill"></span>中的成员（用户<span class="jill"></span>ID）和分数（时间戳），然后根据时间戳排序，得到最近点赞的用户列表。  </span></li></ol><div id="ohdMwmr5xT5UbWCLzCuRdZ" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个简化的示例代码</span></div></div><code-block id="6tqwFQLRvWSv9ziL9v1quu" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisLikeDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">LIKE_PREFIX</span> <span class="token operator">=</span> <span class="token string">"like:"</span><span class="token punctuation">;</span>

    <span class="token comment">//点赞</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">likePost</span><span class="token punctuation">(</span><span class="token class-name">String</span> postId<span class="token punctuation">,</span> <span class="token class-name">String</span> userId<span class="token punctuation">,</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">LIKE_PREFIX</span> <span class="token operator">+</span> postId<span class="token punctuation">;</span>
        <span class="token class-name">Long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedis<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将用户ID及当前时间戳加入有序集合</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//取消点赞</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unlikePost</span><span class="token punctuation">(</span><span class="token class-name">String</span> postId<span class="token punctuation">,</span> <span class="token class-name">String</span> userId<span class="token punctuation">,</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">LIKE_PREFIX</span> <span class="token operator">+</span> postId<span class="token punctuation">;</span>
        jedis<span class="token punctuation">.</span><span class="token function">zrem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将用户ID从有序集合中移除</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//查看点赞列表</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getLikes</span><span class="token punctuation">(</span><span class="token class-name">String</span> postId<span class="token punctuation">,</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">LIKE_PREFIX</span> <span class="token operator">+</span> postId<span class="token punctuation">;</span>
        <span class="token class-name">ZParams</span> zParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> jedis<span class="token punctuation">.</span><span class="token function">zrangeByScoreWithScores</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"+inf"</span><span class="token punctuation">,</span> <span class="token string">"-inf"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> zParams<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>tuple <span class="token operator">-></span> <span class="token punctuation">{</span>
                    <span class="token class-name">String</span> userId <span class="token operator">=</span> tuple<span class="token punctuation">.</span><span class="token function">getElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> userId<span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></pre></div></code-block><div id="x5LPEHtZrQci6XJMTsCr5b" class="wolai-block wolai-text"><div></div></div><div id="8J4yQgwat1j3TEDXTQ3DD2" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kqvg63bX1ZVnsppCsNNpKT" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">Redis<span class="jill"></span>的<span class="jill"></span>zset<span class="jill"></span>实现排行榜，实现分数相同按照时间顺序排序，怎么做？</span></h1><div id="9bNoa7fPWYPFnk5i4BMGeQ" class="wolai-block wolai-text"><div><span class="inline-wrap">要在<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>ZSET（有序集合）中实现分数相同情况下按时间顺序排序，可以借助一些技巧和额外的字段来实现。以下是一种可能的实现方法：</span></div></div><div id="v887sRuRPRZeQJVzpHttWj" class="wolai-block wolai-text"><div><span class="inline-wrap">假设你要存储帖子的排行榜，分数表示点赞数，时间戳表示点赞时间。</span></div></div><ol class="wolai-block"><li id="6kJbzU6FgqacBkeyFz8b3t"><div class="marker"></div><span class="inline-wrap">添加帖子点赞时，使用<span class="jill"></span>ZADD<span class="jill"></span>命令将帖子的<span class="jill"></span>ID<span class="jill"></span>作为成员，点赞时间戳作为分数添加到<span class="jill"></span>ZSET<span class="jill"></span>中。ZADD post_likes:&lt;post_id&gt; &lt;timestamp&gt; &lt;user_id&gt;</span></li><li id="gJzQpSqrKgTRwdAqHddTJG"><div class="marker"></div><span class="inline-wrap">当多个用户点赞同一帖子时，由于分数是点赞时间戳，相同分数的成员会按照字典序排序。</span></li><li id="vDfJTyHt7wR7cLvkt6uV6r"><div class="marker"></div><span class="inline-wrap">查询排行榜时，使用<span class="jill"></span>ZREVRANGE<span class="jill"></span>命令按分数（时间戳）倒序获取排行榜列表。ZREVRANGE post_likes:&lt;post_id&gt; 0 -1</span></li></ol><div id="dTTnVzj2112rkHsq7k4jDa" class="wolai-block wolai-text"><div><span class="inline-wrap">这将返回按时间倒序的点赞列表，如果多个用户的点赞时间戳相同，它们会按照插入顺序排列，符合你的要求。</span></div></div><div id="b9fXPJa4WFXFM6Fodts8Ve" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，由于<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>ZSET<span class="jill"></span>是基于分数排序的，所以我们将时间戳作为分数存储，这样就能够实现相同分数情况下的时间顺序排序。在实际应用中，你可能还需要考虑数据清理、数据同步等问题，以确保系统的稳定性和一致性。</span></div></div><div id="nJsouiMXqmieKVKmk5gsJu" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="2egsoU6ipC4TJ5GGSpsZT7" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">如何实现“查找附近的人”功能？</span></h1><div id="s2Lh7nVvkTiTQyWrUjQAww" class="wolai-block wolai-text"><div><span class="inline-wrap">实现</span><span class="inline-wrap">“查找附近的人”</span><span class="inline-wrap">功能通常涉及到地理位置数据和距离计算。</span></div></div><div id="9zTYQnonnS7FQFCuN7wBnJ" class="wolai-block wolai-text"><div><span class="inline-wrap">在这里，我将为你提供一个基本的思路和步骤，使用<span class="jill"></span>Redis<span class="jill"></span>的地理位置数据结构（Geospatial Indexes）来实现这个功能。</span></div></div><div id="kaSqYwYJfWSKzA3a8jEDoG" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Redis<span class="jill"></span>中，地理位置数据可以使用有序集合（Sorted Set）的功能来存储和查询。</span></div></div><div id="m71Niq3Bf567scSTzrCK3r" class="wolai-block wolai-text"><div><span class="inline-wrap">每个成员都有一个经度（longitude）和纬度（latitude）的坐标，可以通过这些坐标来计算距离并进行查询。</span></div></div><div id="r6SmwZAU68Q3jigTMqQ83z" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个基本的实现步骤：</span></div></div><ol class="wolai-block"><li id="muMLZCUjBKk3CvhHKFGn2N"><div class="marker"></div><span class="inline-wrap"><b>存储用户地理位置信息</b></span><span class="inline-wrap">： 对于每个用户，使用 GEOADD 命令将其地理位置信息存储在一个有序集合中，键可以是类似于 &quot;user_locations&quot; 的标识。</span><code-block id="79k9sTktrzrzU3UQ5Lr6U6" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>GEOADD user_locations <span class="token operator">&lt;</span>longitude<span class="token operator">></span> <span class="token operator">&lt;</span>latitude<span class="token operator">></span> <span class="token operator">&lt;</span>user_id<span class="token operator">></span></pre></div></code-block></li><li id="mnKBNKAqcZLNAEapH5uFto"><div class="marker"></div><span class="inline-wrap"><b>查询附近的人</b></span><span class="inline-wrap">： 使用 GEORADIUS 命令来查询附近的人。你可以指定一个中心点的坐标（比如当前用户的位置），然后指定一个距离范围，命令会返回在这个范围内的用户列表。这将返回一组用户及其与中心点的距离。</span><code-block id="s8xrjtMiipNhMtRi3pn1uv" class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>GEORADIUS user_locations <span class="token operator">&lt;</span>center_longitude<span class="token operator">></span> <span class="token operator">&lt;</span>center_latitude<span class="token operator">></span> <span class="token operator">&lt;</span>radius<span class="token operator">></span> m WITHDIST</pre></div></code-block></li><li id="3ienbXAiXiB8aG3RnKW4z1"><div class="marker"></div><span class="inline-wrap"><b>筛选结果</b></span><span class="inline-wrap">： 你可以根据需要对查询结果进行进一步的筛选和处理，比如根据距离排序、限制结果数量等。</span></li></ol><div id="h6pXBe6Qhz4VmDf464B6Rx" class="wolai-block wolai-text"><div><span class="inline-wrap">请注意，这只是一个简单的实现示例，实际情况可能会更加复杂。在实际应用中，你还需要考虑数据的更新、清理、错误处理以及性能优化等问题。</span></div></div><div id="3rFYQeLpDdEXUSsp6dRK5A" class="wolai-block wolai-text"><div><span class="inline-wrap">另外，随着技术的不断发展，可能会有其他更高级的方法和工具来实现类似的功能，例如使用地理信息数据库或专门的地理位置服务。</span></div></div><div id="4sWa4KqKWFKJwCuJvq35MY" class="wolai-block wolai-text"><div></div></div><div id="rUHmYSXwwCkG6ub5ziHJP2" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ioFsovoGSEFv76e7XwrirB" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">消息队列使用拉模式好还是推模式好？为什么？</span></h1><div id="i33PVD3Eo6aqyPZ6v2ppw1" class="wolai-block wolai-text"><div><span class="inline-wrap">消息队列可以采用拉模式（Pull）或推模式（Push）来处理消息传递。选择哪种模式取决于你的应用场景和需求。</span></div></div><div id="n9CJxDHHE4nkoxr5SA7ZuS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wbnzhVJTmMafiFzcneBdUv" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">概念</span></h2><h3 id="wj36SZthCHnrUmokLWHVbQ" class="wolai-block"><span class="wolai-serial-number">13.1.1</span><span class="inline-wrap">拉模式（Pull）</span></h3><div id="tp41CPSS2K7pwoaanVt6eB" class="wolai-block wolai-text"><div><span class="inline-wrap">在拉模式中，消费者主动从消息队列中拉取消息。消费者决定何时获取消息以及获取多少消息。这种模式的优势在于消费者可以控制消息的处理速率，以适应自己的处理能力。</span></div></div><div id="irrAdyC6cx1uefT7aZRXYy" class="wolai-block wolai-text"><div><span class="inline-wrap">拉模式适用于以下情况：</span></div></div><ol class="wolai-block"><li id="m19CM9oDsC5ZMzWMzynvwZ"><div class="marker"></div><span class="inline-wrap">消费者处理能力不稳定： 如果消费者的处理速度波动较大，拉模式可以避免消息积压问题。</span></li><li id="3zyjKifdSXMgaVZzD6QBy4"><div class="marker"></div><span class="inline-wrap">消费者需要灵活控制： 如果消费者希望在特定时间获取消息，或者根据自身逻辑选择性地获取特定消息，拉模式更适合。</span></li></ol><div id="8o96nRkdrFhEjbKXm7Uxq7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="ug5ByBqW2zeyrAQXobK6Dx" class="wolai-block"><span class="wolai-serial-number">13.1.2</span><span class="inline-wrap">推模式（Push）</span></h3><div id="2ngg4nSZfxvLKfZv5eTfGN" class="wolai-block wolai-text"><div><span class="inline-wrap">在推模式中，消息队列将消息主动推送给消费者。消费者只需提供一个回调函数或处理方法，消息队列会在有消息到达时调用该回调函数。推模式的优势在于即时性，适用于以下情况：</span></div></div><ol class="wolai-block"><li id="ouSGiM3vqM1KzZCUz4LgJq"><div class="marker"></div><span class="inline-wrap">低延迟要求： 如果你需要实现低延迟的消息传递，推模式可以更快地将消息发送给消费者。</span></li><li id="sd2Mq7JarQRVekaB5Evhmx"><div class="marker"></div><span class="inline-wrap">实时通知： 如果你需要及时通知消费者进行某些操作，推模式可以满足这种即时性的需求。</span></li></ol><div id="uPSCQteVWbDjg6KSSSjo61" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="icnZnsQkN2PwchtUH2rYXF" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">选择</span></h2><div id="5s4eRcMNufRBQaq5zgA2oV" class="wolai-block wolai-text"><div><span class="inline-wrap">选择拉模式还是推模式取决于你的应用需求和场景：</span></div></div><ul class="wolai-block"><li id="fBHmxn1SA1M8HTASMg6LR7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">拉模式适用于：</span><ul class="wolai-block"><li id="7Q66LHGco6cYLexfGozkCL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">需要灵活控制消息获取的场景。</span></li><li id="2QzVvhgK3vQwtXkPJtQ6k2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者处理能力波动较大的情况。</span></li><li id="6du7cM2LbARAADqzyYGnJw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对消息处理的顺序有严格要求。</span></li></ul></li><li id="8GHkoT1inV85W97rd5zNds"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">推模式适用于：</span><ul class="wolai-block"><li id="7g5H91o6R8YhoB6Xktb74G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">需要低延迟和实时性的场景。</span></li><li id="uMJ5NAomZtNv1cPZ2PiGqs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">需要及时通知和即时反馈的情况。</span></li><li id="7c6WGhzEfuj92yoeu4KsCw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">消费者处理能力稳定，不容易被消息积压。</span></li></ul></li></ul><div id="fZpjiuX1A3dR5JdfNXGFES" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，有些消息队列系统甚至允许在同一个应用中同时使用拉模式和推模式，以满足不同消息处理需求。在实际应用中，根据业务需求来选择适合的模式是非常重要的。</span></div></div><div id="bfzkSDJ1V2zZWzRyQLv5Dz" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="gWVzkvBZJp828Hu35y2ihe" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">如果让你实现一个<span class="jill"></span>Dubbo，会考虑用哪些技术解决哪些问题？</span></h1><div id="h3Wse33qH45zSMCdaMMpVT" class="wolai-block wolai-text"><div><span class="inline-wrap">要实现类似于<span class="jill"></span>Dubbo<span class="jill"></span>这样的分布式服务框架，需要考虑多个方面的技术和问题。以下是一些可能的考虑和解决方案：</span></div></div><ol class="wolai-block"><li id="kyX9mTaDMTH8KP8UcEQFdj"><div class="marker"></div><span class="inline-wrap"><b>服务注册与发现</b></span><span class="inline-wrap">： 使用类似<span class="jill"></span>Zookeeper、Etcd<span class="jill"></span>或<span class="jill"></span>Consul<span class="jill"></span>等分布式系统作为服务注册中心，用于服务提供者注册自己的服务，并供消费者发现可用的服务。</span></li><li id="pYButwDxR8eihVpUFpBG9F"><div class="marker"></div><span class="inline-wrap"><b>远程通信协议</b></span><span class="inline-wrap">： 选择合适的远程通信协议，如<span class="jill"></span>RPC（Remote Procedure Call）协议，可以使用基于<span class="jill"></span>TCP<span class="jill"></span>的协议，如<span class="jill"></span>Netty，或者<span class="jill"></span>HTTP/2<span class="jill"></span>等。</span></li><li id="8XVQ4wRBqjbXxKEqfiDvnp"><div class="marker"></div><span class="inline-wrap"><b>序列化与反序列化</b></span><span class="inline-wrap">： 选用高效的序列化方式，如<span class="jill"></span>Google Protocol Buffers、Apache Avro<span class="jill"></span>或者<span class="jill"></span>MessagePack，以减少网络传输时的数据体积。</span></li><li id="5FAivr7T1bGbW8xkPKU3b2"><div class="marker"></div><span class="inline-wrap"><b>负载均衡</b></span><span class="inline-wrap">： 实现负载均衡策略，确保服务消费者能够均匀地调用不同的服务提供者，可考虑使用轮询、随机、权重等策略。</span></li><li id="x835CBQvsJ1YDbBAMstJeP"><div class="marker"></div><span class="inline-wrap"><b>容错与熔断</b></span><span class="inline-wrap">： 实现容错机制，处理服务提供者不可用或者网络故障等情况，可以引入熔断器，如<span class="jill"></span>Hystrix，以避免级联故障。</span></li><li id="oE6VgVUXi5hY22CMn8RxPY"><div class="marker"></div><span class="inline-wrap"><b>并发与线程池</b></span><span class="inline-wrap">： 考虑到服务提供者可能会被大量请求同时调用，需要使用线程池等技术来管理并发请求，避免资源耗尽。</span></li><li id="stXeR7jAezDmDRbC4RQC1U"><div class="marker"></div><span class="inline-wrap"><b>超时与重试</b></span><span class="inline-wrap">： 实现超时机制，避免长时间等待，同时可以引入重试机制，确保在某些网络瞬时问题导致的失败情况下，能够进行自动重试。</span></li><li id="ufLUbjyV4t2ZxNM85EJPzq"><div class="marker"></div><span class="inline-wrap"><b>跨语言支持</b></span><span class="inline-wrap">： 如果需要支持不同编程语言间的服务调用，可以使用通用的<span class="jill"></span>IDL（接口定义语言）来定义接口，再根据不同语言生成对应的客户端和服务端代码。9. 监控与治理： 引入监控和管理工具，如<span class="jill"></span>Dubbo-admin、Prometheus<span class="jill"></span>等，用于实时监控服务的调用情况、性能指标等，并能进行故障排查和性能优化。</span></li><li id="8p1Az6FgekfqqyXPcocAod"><div class="marker"></div><span class="inline-wrap"><b>安全与认证</b></span><span class="inline-wrap">： 考虑数据传输的安全性，可以使用<span class="jill"></span>SSL/TLS<span class="jill"></span>加密通信，另外还可以引入认证和授权机制，确保只有合法的服务消费者能够调用服务。</span></li><li id="ib3Hfx79A9M19kNgcqeqso"><div class="marker"></div><span class="inline-wrap"><b>分布式事务</b></span><span class="inline-wrap">： 如果需要支持分布式事务，可以考虑使用分布式事务管理器，如<span class="jill"></span>Seata<span class="jill"></span>或<span class="jill"></span>TCC（Try-Confirm-Cancel）等机制。</span></li><li id="3dE3fx53crLCPsJRWyH4hP"><div class="marker"></div><span class="inline-wrap"><b>扩展性</b></span><span class="inline-wrap">： 构建可扩展的架构，允许根据业务需求动态添加新的服务提供者，同时保持系统的稳定性。</span></li></ol><div id="i5zgTXzuvuZ4uL2bYgsmBi" class="wolai-block wolai-text"><div><span class="inline-wrap">最终的选择会依赖于具体的业务需求、技术栈以及团队的经验和技术偏好。以上列举的技术和问题只是其中的一部分，实际实现时还需要根据具体情况进行详细的设计和调优。</span></div></div><div id="jE8D3XBHL2XUtXpN69R8M" class="wolai-block wolai-text"><div></div></div><div id="rsTiyWhxpA7s2udZKtBaLN" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="e7NdsPShfqrWJGMa4zshyM" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">一个订单在<span class="jill"></span>11:00<span class="jill"></span>超时关闭后发现它支付成功了，如何处理？</span></h1><h2 id="bZ9SjqPsrd15pQVfME2Skp" class="wolai-block"><span class="wolai-serial-number">15.1</span><span class="inline-wrap">已发生问题的善后处理</span></h2><h3 id="2HXZVTEAKMccozDEBzZPXV" class="wolai-block"><span class="wolai-serial-number">15.1.1</span><span class="inline-wrap">用户视角</span></h3><div id="dQgcH9hLvoyqZzGhaMa5g6" class="wolai-block wolai-text"><div><span class="inline-wrap">用户支付金钱，但由于订单被关闭导致无法发货，用户一定会维权，所以这是无法容忍的故障问题</span></div></div><div id="fo961ryE3rGsFRoN5yMq6q" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="8C8yt4QygYAzMBQd7V85HG" class="wolai-block"><span class="wolai-serial-number">15.1.2</span><span class="inline-wrap">解决方式</span></h3><ul class="wolai-block"><li id="a9vDWDZy8rpHHFnC2buf5z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方案一：人工修改订单状态，使其回到正常流程，保证后续可以给用户发货</span></li><li id="8V6vXqntdNxQTtoouJQDuU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方案二：按照原路径给用户退款</span></li></ul><div id="vKMYBtpz2PAo3XYeaXULin" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="xtNnGuvVi5iREQoyKGmhBi" class="wolai-block"><span class="wolai-serial-number">15.2</span><span class="inline-wrap">代码逻辑修正</span></h2><h3 id="8X8ZAPcyVXFNCn8VjkoLWm" class="wolai-block"><span class="wolai-serial-number">15.2.1</span><span class="inline-wrap">目前的逻辑</span></h3><div id="83aEhGrNjQwfFv5sAX3dLF" class="wolai-block"><figure class="wolai-center" style="width: 747px; flex-direction: column"><img src="media/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6(7).png" style="width: 100%"/></figure></div><div id="pmk6RrPxGQphgKPBj63UXR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="h5nEmkrWEDfMmJKRdErSnU" class="wolai-block wolai-text"><div><span class="inline-wrap">问题就在于“延迟关单”和“用户支付”是两个彼此独立的流程，二者不存在调用等待关系，所以即使后端程序关闭了订单，仍然无法阻止用户支付。</span></div></div><div id="hXGNkbenoeviveUdGL3rQe" class="wolai-block wolai-text"><div><span class="inline-wrap">所以核心问题是：采用『先生成订单，然后再等待用户支付』的模式，用户在本系统之外做支付操作不受控制</span></div></div><div id="bHVz9Jibf5rTTmbYdcptwP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="aZaxvNvNzFW68B44WcWFDE" class="wolai-block"><span class="wolai-serial-number">15.2.2</span><span class="inline-wrap">改进的逻辑</span></h3><div id="uiFcKNPiarV2oVdMtWYvhM" class="wolai-block wolai-text"><div><span class="inline-wrap">核心思想：调整流程顺序，用户在购物车点击结算时先支付总计的金额然后再生成订单。</span></div></div><div id="rUz15FqyKjWJHxa7ZEdp13" class="wolai-block wolai-text"><div><span class="inline-wrap">反过来说就是：用户不支付，就不生成订单，自然不存在前述问题</span></div></div><div id="bS4eVNXm4j1XFsx79BCeN5" class="wolai-block wolai-text"><div><span class="inline-wrap">当然在这种模式下也就不需要设置延迟关单的操作了</span></div></div><div id="mzZQ1JQz9VKcvE3sZZzFQS" class="wolai-block wolai-text"><div><span class="inline-wrap">事实上现在很多平台都是这么处理的</span></div></div><div id="4ZG5xsfb3Q55X4DZDQFzyS" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="bQQS3KtZuQhHwFKEQ4WigV" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">一个支付单，多个渠道同时支付成功了怎么办？</span></h1><h2 id="cD43B64D6NT6zL5PpbQMb8" class="wolai-block"><span class="wolai-serial-number">16.1</span><span class="inline-wrap">已发生问题的善后处理</span></h2><h3 id="xuHE938m18TNFQsfiVK3ET" class="wolai-block"><span class="wolai-serial-number">16.1.1</span><span class="inline-wrap">问题发现</span></h3><ul class="wolai-block"><li id="cLsDyrXRn5qVMSERT8qH6A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户投诉，通过客服系统发现问题</span></li><li id="c21ieHVhss3B9P8MjhooJM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">系统自查，通过财务对账系统发现问题</span></li></ul><div id="nVyUknQpU4UXDfGhSVstQi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="6ryhkFMfc7g13CQScVsQqT" class="wolai-block"><span class="wolai-serial-number">16.1.2</span><span class="inline-wrap">善后处理</span></h3><ol class="wolai-block"><li id="xdpPZ8hrEdHiKsWwBR1Bgm"><div class="marker"></div><span class="inline-wrap">定位故障订单</span></li><li id="7u3M4HW3L8xG4QvaaByPPU"><div class="marker"></div><span class="inline-wrap">判断订单是否已发货</span><ol class="wolai-block"><li id="4Q954PNTXunERPKscBq1PN"><div class="marker"></div><span class="inline-wrap">未发货（此时我们认为订单仍在交易系统）</span><ol class="wolai-block"><li id="sqsnLSabWojBDMbUgir2Fo"><div class="marker"></div><span class="inline-wrap">把当前订单标记为故障单并关闭，不会发货</span></li><li id="bSYCKDWPD6v57DHX43Gscj"><div class="marker"></div><span class="inline-wrap">用户所有渠道支付全部退款，用户需重新下单</span></li></ol></li><li id="fmCtxG9a9Cf1zCFxsubo2V"><div class="marker"></div><span class="inline-wrap">已发货（此时我们认为订单已经完成，用户争议进入售后服务阶段处理）</span><ol class="wolai-block"><li id="dYpfPd2B7PNwJLRkv2X9kj"><div class="marker"></div><span class="inline-wrap">基于当前故障订单新建售后服务单，原订单仍保持已发货状态并在用户收货后正常关闭</span></li><li id="oH241ycD1hfYW5zMe2byTB"><div class="marker"></div><span class="inline-wrap">售后服务单创建后，售后服务流程开始</span></li><li id="8cUCEaut5zV9ZY7NQY7vxa"><div class="marker"></div><span class="inline-wrap">售后服务人员负责和用户对接，核算需退款金额（总支付金额-商品应支付金额）</span></li><li id="aJgCiQF6euXHAhMPjSZfaq"><div class="marker"></div><span class="inline-wrap">用户确认退款金额</span></li><li id="44fJKe6RJdBtddZs34Da5j"><div class="marker"></div><span class="inline-wrap">系统调用支付接口发起退款</span></li></ol></li></ol></li></ol><div id="sZVTfjhfWFzQLApo3BhxEp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="t5Zo7PND1J1sBDTwG5jQZH" class="wolai-block"><span class="wolai-serial-number">16.2</span><span class="inline-wrap">系统逻辑修正</span></h2><div id="rcPaW8VrzoeNymnXmrcRHA" class="wolai-block wolai-text"><div><span class="inline-wrap">用户多渠道支付成功的核心问题在于：用户</span><span class="indigo inline-wrap"><b>多终端登录</b></span><span class="inline-wrap">，然后在不同终端使用不同渠道进行了支付。</span></div></div><div id="8yeZ2EsBHSyCmxG7aKnBbU" class="wolai-block wolai-text"><div><span class="inline-wrap">所以解决问题的思路就是：分布式锁</span></div></div><div id="uJWiWZKEBCwkDjcAqaH7b4" class="wolai-block wolai-text"><div><span class="inline-wrap">用户可以在任何一个终端上支付订单，但是只有一个终端可以操作成功，底层代码执行时需要先申请分布式锁，获得锁的请求才能执行支付流程</span></div></div><div id="uGutUZrDXZRunGU66K3Pn7" class="wolai-block wolai-text"><div></div></div><div id="6Um4JB9wixEE6KHvP2LrN1" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cJdUd2v51F1jpqteA5KaJP" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">如何解决消息重复消费、重复下单等问题？</span></h1><div id="urjkSvFxWoptRFaw6LD8zF" class="wolai-block wolai-text"><div><span class="inline-wrap">要解决消息重复消费、重复下单等问题，通常可以采取以下一些方法：</span></div></div><ol class="wolai-block"><li id="dyDYQKFCLqy68KJmDnDo5T"><div class="marker"></div><span class="inline-wrap"><b>消息去重</b></span><span class="inline-wrap">： 在消息队列中，你可以实现消息的唯一标识。当消费者从队列中获取消息时，首先检查该消息的唯一标识是否已经被处理过。如果已经处理过，就可以跳过该消息，避免重复消费。</span></li><li id="2fy913yAsrnja4Npk8Hbdf"><div class="marker"></div><span class="inline-wrap"><b>幂等性设计</b></span><span class="inline-wrap">： 在系统中引入幂等性概念，即使同一个操作被多次执行，结果也保持一致。对于下单操作，可以设计成幂等操作，确保多次重复请求只会产生一次订单。可以通过为每个订单生成一个唯一的订单号，使用订单号来识别订单的唯一性。</span></li><li id="n8Pxi8tDHCk766XUqHWWWN"><div class="marker"></div><span class="inline-wrap"><b>事务控制</b></span><span class="inline-wrap">： 在涉及到多个操作的情况下，使用事务来确保操作的原子性。例如，在创建订单的同时扣减库存，可以将这两个操作放在同一个事务中，如果其中一个操作失败，整个事务会回滚，保证数据的一致性。</span></li><li id="4Z5jubNmCR8mGDfuoRWnDP"><div class="marker"></div><span class="inline-wrap"><b>幂等性校验</b></span><span class="inline-wrap">： 在处理请求之前，可以先查询系统的状态，判断该请求是否已经被处理过。如果已经处理过，可以直接返回之前的结果，避免重复操作。</span></li><li id="tH4is9gHYwsoz9jxhw3etw"><div class="marker"></div><span class="inline-wrap"><b>定时任务清理</b></span><span class="inline-wrap">： 可以设置定时任务来清理过期的数据，如未支付的订单或已经处理过的消息。这样可以确保系统中不会长期存在无效数据。</span></li><li id="qaufLMfmwQTMsmpWqC9Ydc"><div class="marker"></div><span class="inline-wrap"><b>消息确认机制</b></span><span class="inline-wrap">： 在消息队列中，可以使用消息确认机制来确保消息被成功消费。只有在消费者确认后，消息才会被标记为已消费，避免消息在处理失败时被重复消费。</span></li><li id="qS75ctSQjDyuEefBiFTgwc"><div class="marker"></div><span class="inline-wrap"><b>日志记录与审计</b></span><span class="inline-wrap">： 记录每个操作的日志，并建立审计机制。这样可以追踪操作的历史，及时发现异常情况并进行处理。</span></li></ol><div id="f2JpjRdvSKvSAFSYkEjUcT" class="wolai-block wolai-text"><div><span class="inline-wrap">综合使用上述方法，可以有效地解决消息重复消费、重复下单等问题，保证系统的稳定性和数据的一致性。</span></div></div><div id="g4XQVCVjfRQP2ySPNDwEHo" class="wolai-block wolai-text"><div></div></div><div id="x96d6LcWnzEtyaJQk7QCxh" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="kvm6FQDa9DsVLRnW5kxHVj" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">不使用<span class="jill"></span>synchronized<span class="jill"></span>和<span class="jill"></span>Lock<span class="jill"></span>如何设计一个线程安全的单例？</span></h1><div id="pZnN6432nd6K4Pxc9ksXyH" class="wolai-block wolai-text"><div><span class="inline-wrap">不使用 synchronized 和 Lock 来设计一个线程安全的单例可以考虑使用一些其他方式，例如基于静态内部类的单例模式，或者使用双重检查锁定（Double-Checked Locking）等技术来实现。以下是两种常见的线程安全单例实现方法：</span></div></div><div id="5sEczaSS7QBBabwr42Hzzg" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="m7oECo9wUybTQD3aFiMgpc" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">静态内部类单例模式</span></h2><div id="xpiMaM7y896st8m1uGk3Pz" class="wolai-block wolai-text"><div><span class="inline-wrap">这种方法利用了类加载的特性，保证了只有在第一次使用单例的时候才会加载内部类，从而实现懒加载，同时又保证线程安全。</span></div></div><code-block id="wWRKrHynPAgCTgXqHu8mwR" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 私有构造方法 */</span> <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></div></code-block><div id="kCsiQTiTRNAV6jC5ws4ebX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kLzjjJgcMSCUZaA9jktEce" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">CAS</span></h2><div id="rUbvRKD4uag7jFhPTRjKQa" class="wolai-block wolai-text"><div><span class="inline-wrap">CAS<span class="jill"></span>是项乐观锁技术，当多个线程尝试使用<span class="jill"></span>CAS<span class="jill"></span>同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</span></div></div><div id="e2DWkgu9ozsNBG3gz9QFSb" class="wolai-block wolai-text"><div><span class="inline-wrap">实现单例的方式如下：</span></div></div><code-block id="4ru2ngXdySub9XXpmVNnjK" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">></span></span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span>
            <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> singleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="2QBjLnSNTaq74JVeedpTFt" class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>CAS<span class="jill"></span>的好处在于不需要使用传统的锁机制来保证线程安全,CAS<span class="jill"></span>是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。</span></div></div><div id="aovSxfbTDkmkosLQf7Ysan" class="wolai-block wolai-text"><div><span class="inline-wrap">CAS<span class="jill"></span>的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对<span class="jill"></span>CPU<span class="jill"></span>造成较大的执行开销。</span></div></div><div id="tvvQeKXHFfdBj5h9NQLtZm" class="wolai-block wolai-text"><div><span class="inline-wrap">另外，如果<span class="jill"></span>N<span class="jill"></span>个线程同时执行到<span class="jill"></span>singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。</span></div></div><div id="vQWAXA8cLX5j7ic3qvz5fd" class="wolai-block wolai-text"><div></div></div><div id="nARETAosdPTeJ8T91UrgeN" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="aXAoCDWZpgrc1r5Rh5gHwm" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">索引失效的问题是如何排查的，有那些种情况？</span></h1><div id="aYak1Q7o2YLUvsCt6wVSGy" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MySQL<span class="jill"></span>中，索引是提高查询性能的重要手段。然而，在某些情况下，索引可能会失效，导致查询性能下降。以下是一些常见导致<span class="jill"></span>MySQL<span class="jill"></span>索引失效的情况：</span></div></div><ol class="wolai-block"><li id="bpzAr2QpUjTXKA4oeVUjso"><div class="marker"></div><span class="inline-wrap"><b>函数的使用</b></span><span class="inline-wrap">：当查询条件中的列被函数包裹时，MySQL<span class="jill"></span>无法利用索引。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE YEAR(created_at) = 2024;</code></span><span class="inline-wrap"> 这里的 </span><span class="inline-wrap"><code>YEAR(created_at)</code></span><span class="inline-wrap"> 会导致索引失效。</span></li><li id="bdzEJeBvrQJdtnyZSScWrz"><div class="marker"></div><span class="inline-wrap"><b>隐式类型转换</b></span><span class="inline-wrap">：如果查询条件中的列类型与表中列的类型不一致，MySQL<span class="jill"></span>会进行隐式类型转换，从而导致索引失效。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE phone_number = 1234567890;</code></span><span class="inline-wrap"> 如果 </span><span class="inline-wrap"><code>phone_number</code></span><span class="inline-wrap"> 是字符串类型，这将导致索引失效。</span></li><li id="nsGUykA6wWs3UDRURm7tDk"><div class="marker"></div><span class="inline-wrap"><b>使用不等于操作符</b></span><span class="inline-wrap">：查询中使用 </span><span class="inline-wrap"><code>!=</code></span><span class="inline-wrap"> 或 </span><span class="inline-wrap"><code>&lt;&gt;</code></span><span class="inline-wrap"> 操作符时，MySQL<span class="jill"></span>通常无法利用索引。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE age != 30;</code></span></li><li id="mnEJMFN1pq5tu5Sjw5VAix"><div class="marker"></div><span class="inline-wrap"><b>LIKE<span class="jill"></span>查询以 % 开头</b></span><span class="inline-wrap">：如果 </span><span class="inline-wrap"><code>LIKE</code></span><span class="inline-wrap"> 查询的模式以 </span><span class="inline-wrap"><code>%</code></span><span class="inline-wrap"> 开头，MySQL<span class="jill"></span>无法使用索引。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE name LIKE &#39;%Alice&#39;;</code></span></li><li id="pMYWB421qq4FVN1V16vpmo"><div class="marker"></div><span class="inline-wrap"><b>最左前缀原则未遵循</b></span><span class="inline-wrap">：MySQL<span class="jill"></span>的联合索引遵循最左前缀匹配原则。如果查询未使用索引的前缀部分，索引会失效。例如：</span><span class="inline-wrap"><code>CREATE INDEX idx_name_age ON users (name, age); SELECT * FROM users WHERE age =30;</code></span></li><li id="33mpkYYoFvK6aSZnEseqCU"><div class="marker"></div><span class="inline-wrap"><b>OR<span class="jill"></span>条件未优化</b></span><span class="inline-wrap">：如果查询条件中包含 </span><span class="inline-wrap"><code>OR</code></span><span class="inline-wrap">，并且 </span><span class="inline-wrap"><code>OR</code></span><span class="inline-wrap"> 两侧的列未同时加索引，MySQL<span class="jill"></span>无法使用索引。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE name = &#39;Alice&#39; OR age = 30;</code></span></li><li id="coW2nwR9D94biADNjj94BB"><div class="marker"></div><span class="inline-wrap"><b>索引列参与计算或表达式</b></span><span class="inline-wrap">：如果查询条件中的索引列被用作计算或表达式的一部分，索引失效。例如：</span><span class="inline-wrap"><code>SELECT * FROM users WHERE age + 1 = 30;</code></span></li><li id="aGPXYbx56KRZNPiYrZGjZp"><div class="marker"></div><span class="inline-wrap"><b>数据分布特性</b></span><span class="inline-wrap">：当查询的条件匹配大部分数据时，MySQL<span class="jill"></span>可能会放弃使用索引，转而选择全表扫描。</span></li><li id="vkbFjMsAxksd53acBcpwyv"><div class="marker"></div><span class="inline-wrap"><b>统计信息不准确</b></span><span class="inline-wrap">：如果表的数据变化频繁，索引的统计信息可能不准确，MySQL<span class="jill"></span>会错误选择不使用索引。</span></li><li id="5U2JcwYPCKARQtbf4AZVKz"><div class="marker"></div><span class="inline-wrap"><b>小表扫描优先</b></span><span class="inline-wrap">：如果表数据量较小，MySQL<span class="jill"></span>优化器可能会选择全表扫描，而不是使用索引。</span></li><li id="dXb15LJsegePwWTW2fgktK"><div class="marker"></div><span class="inline-wrap"><b>范围条件的限制</b></span><span class="inline-wrap">：当组合索引中包含范围条件（如 </span><span class="inline-wrap"><code>&gt;</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>&lt;</code></span><span class="inline-wrap">, </span><span class="inline-wrap"><code>BETWEEN</code></span><span class="inline-wrap">），后续的列索引无法被使用。例如：</span><span class="inline-wrap"><code>CREATE INDEX idx_name_age_salary ON users (name, age, salary); SELECT * FROM users WHERE name = &#39;Alice&#39; AND age &gt; 30 AND salary = 5000;</code></span></li><li id="phWf6C6Ygo4EYc3bkYCep8"><div class="marker"></div><span class="inline-wrap"><b>IS NULL<span class="jill"></span>或<span class="jill"></span>IS NOT NULL<span class="jill"></span>查询</b></span><span class="inline-wrap">：某些版本的<span class="jill"></span>MySQL<span class="jill"></span>中，IS NULL<span class="jill"></span>或<span class="jill"></span>IS NOT NULL<span class="jill"></span>查询可能无法使用索引。</span></li><li id="4i2hVETMNR8PTHFedpWsfu"><div class="marker"></div><span class="inline-wrap"><b>不支持索引的存储引擎</b></span><span class="inline-wrap">：例如，MySQL<span class="jill"></span>的<span class="jill"></span>MEMORY<span class="jill"></span>引擎不支持<span class="jill"></span>TEXT<span class="jill"></span>或<span class="jill"></span>BLOB<span class="jill"></span>字段上的索引。</span></li></ol><div id="iqxx4iAcqyHGmZX1ZmZwFW" class="wolai-block wolai-text"><div><span class="inline-wrap">总结来说，了解这些导致索引失效的情况对于优化<span class="jill"></span>MySQL<span class="jill"></span>查询性能至关重要。开发者应避免这些常见的陷阱，合理设计索引和查询语句，以提高数据库的性能。</span></div></div><div id="eE5sHKHgCP6W2gYWzrJD7n" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="oT3buz7yPmEFt3JsnxyVAn" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">40<span class="jill"></span>亿个<span class="jill"></span>QQ<span class="jill"></span>号，限制<span class="jill"></span>1G<span class="jill"></span>内存，如何去重？</span></h1><div id="VEod3nfkZuBTv7kku7HPu" class="wolai-block wolai-text"><div><span class="inline-wrap">在面对<span class="jill"></span>40<span class="jill"></span>亿个<span class="jill"></span>QQ<span class="jill"></span>号的去重问题时，考虑到内存限制为<span class="jill"></span>1G，传统的数据结构如数组或集合显然无法满足需求。以下是几种可能的解决方案：</span></div></div><ol class="wolai-block"><li id="uoSQxHGn2HzH5BmpwngySU"><div class="marker"></div><span class="inline-wrap"><b>使用位图（BitMap）</b></span><ol class="wolai-block"><li id="eAcncHDVD5GgZHScxk46Gv"><div class="marker"></div><span class="inline-wrap"><b>确定位图的大小</b></span><span class="inline-wrap">：首先，需要确定位图的大小。由于<span class="jill"></span>QQ<span class="jill"></span>号是无符号整数，其范围从<span class="jill"></span>0<span class="jill"></span>到<span class="jill"></span>2^32-1，因此理论上需要<span class="jill"></span>2^32<span class="jill"></span>个<span class="jill"></span>bit<span class="jill"></span>来表示所有可能的<span class="jill"></span>QQ<span class="jill"></span>号。然而，由于实际只有<span class="jill"></span>40<span class="jill"></span>亿个<span class="jill"></span>QQ<span class="jill"></span>号，所以只需要<span class="jill"></span>40<span class="jill"></span>亿个<span class="jill"></span>bit<span class="jill"></span>即可。每个<span class="jill"></span>byte<span class="jill"></span>包含<span class="jill"></span>8<span class="jill"></span>个<span class="jill"></span>bit，因此所需的总内存空间为<span class="jill"></span>40<span class="jill"></span>亿/8/1024/1024 ≈ 476MB，远小于<span class="jill"></span>1G<span class="jill"></span>的限制。</span></li><li id="kpaSpkFqjPDPkYyHpRoQ2p"><div class="marker"></div><span class="inline-wrap"><b>初始化位图</b></span><span class="inline-wrap">：创建一个足够大的位图数组，初始时所有<span class="jill"></span>bit<span class="jill"></span>都设置为<span class="jill"></span>0。这个位图将用于记录每个<span class="jill"></span>QQ<span class="jill"></span>号是否已经出现过。</span></li><li id="edVGG27zhjk6htoU5cKDxg"><div class="marker"></div><span class="inline-wrap"><b>计算<span class="jill"></span>QQ<span class="jill"></span>号对应的<span class="jill"></span>bit<span class="jill"></span>位置</b></span><span class="inline-wrap">：对于每个<span class="jill"></span>QQ<span class="jill"></span>号，通过取模运算计算出它在位图中的位置。例如，如果<span class="jill"></span>QQ<span class="jill"></span>号是<span class="jill"></span>12345678，那么它在位图中的位置可以通过<span class="jill"></span>12345678 % 位图大小来计算。</span></li><li id="5gNfgBbPAk8T8fteUNM21r"><div class="marker"></div><span class="inline-wrap"><b>设置<span class="jill"></span>bit<span class="jill"></span>值</b></span><span class="inline-wrap">：根据计算出的位置，将对应的<span class="jill"></span>bit<span class="jill"></span>设置为<span class="jill"></span>1。如果该位置的<span class="jill"></span>bit<span class="jill"></span>已经是<span class="jill"></span>1，则表示该<span class="jill"></span>QQ<span class="jill"></span>号已经存在，无需重复添加。</span></li><li id="BysaSyE9AEnkq6dgtjDL1"><div class="marker"></div><span class="inline-wrap"><b>查询和去重</b></span><span class="inline-wrap">：在查询或去重时，只需检查位图中相应位置的<span class="jill"></span>bit<span class="jill"></span>是否为<span class="jill"></span>1。如果为<span class="jill"></span>1，则表示该<span class="jill"></span>QQ<span class="jill"></span>号已经存在；如果为<span class="jill"></span>0，则表示该<span class="jill"></span>QQ<span class="jill"></span>号不存在。</span></li></ol></li><li id="8XVmRE2vUX4iz5w1JKdRt9"><div class="marker"></div><span class="inline-wrap"><b>使用布隆过滤器（Bloom Filter）</b></span><ul class="wolai-block"><li id="Rrcaos1B9kdRwaLiihQBb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">布隆过滤器是一种基于多个哈希函数的概率型数据结构，用于快速判断一个元素是否可能存在于集合中。它通过将元素映射到位数组中的多个位置来实现。</span></li><li id="s8rx3rxMuCCRvUqt9No7Xz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">布隆过滤器的优点是可以快速插入和查询，且占用的空间相对较小。然而，它有一定的误判率，即可能会错误地认为某个不存在的元素存在。</span></li></ul></li></ol><div id="qpFoewo7torrHWjVbtQPkj" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，针对<span class="jill"></span>40<span class="jill"></span>亿个<span class="jill"></span>QQ<span class="jill"></span>号的去重问题，在<span class="jill"></span>1G<span class="jill"></span>内存的限制下，位图是一个更为合适的选择。它能够提供精确的去重结果，并且相对于直接存储所有<span class="jill"></span>QQ<span class="jill"></span>号来说，大大节省了内存空间。而布隆过滤器虽然也能在一定程度上解决问题，但其误判率可能会影响结果的准确性。</span></div></div><div id="pD8ZnxTgo24CPuPL6YufxM" class="wolai-block wolai-text"><div></div></div><div id="weJL8aJZuqCbCXEdRLwwwQ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6rWvHmYr4hmSWbhavZMpxD" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">说一说多级缓存是如何应用的？</span></h1><div id="u9noq95GwUjSXmizHQYofa" class="wolai-block wolai-text"><div><span class="inline-wrap">多级缓存是计算机体系结构中常用的一种优化技术，旨在加速数据访问并提高系统性能。</span></div></div><div id="r8cuwnsAuLJkq1W8BwVdyP" class="wolai-block wolai-text"><div><span class="inline-wrap">它利用不同容量和速度的存储设备来缓存数据，以降低<span class="jill"></span>CPU<span class="jill"></span>访问主存储器的频率，从而减少访问延迟。</span></div></div><div id="j6Ci9ei16m4jZGW1WAY5tN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hGN5Xw6aeXqhVAVX1iWgg7" class="wolai-block wolai-text"><div><span class="inline-wrap">多级缓存通常分为三级，分别是<span class="jill"></span>L1、L2<span class="jill"></span>和<span class="jill"></span>L3<span class="jill"></span>缓存，它们按照从最近到最远的访问距离进行层次划分。以下是多级缓存的应用方式：</span></div></div><ol class="wolai-block"><li id="8LD6n48y6S8BTFUveqMXYr"><div class="marker"></div><span class="inline-wrap"><b>Level1<span class="jill"></span>缓存</b></span><span class="inline-wrap">：位于<span class="jill"></span>CPU<span class="jill"></span>内部，速度最快但容量最小。通常用于存储当前正在执行的指令和相关数据。由于其位置接近<span class="jill"></span>CPU<span class="jill"></span>核心，可以迅速提供数据，适用于对访问延迟敏感的任务。</span></li><li id="cCg3LxrSYmjyGHqr4MC3oh"><div class="marker"></div><span class="inline-wrap"><b>Level2<span class="jill"></span>缓存</b></span><span class="inline-wrap">：位于<span class="jill"></span>CPU<span class="jill"></span>核心外部，容量较大，速度较快。它承担了<span class="jill"></span>L1<span class="jill"></span>缓存无法容纳的数据，并提供更大的缓存空间。L2<span class="jill"></span>缓存可以通过一些高效的算法来预测数据的使用模式，从而更好地满足<span class="jill"></span>CPU<span class="jill"></span>的数据需求。</span></li><li id="hfLqXoaRk4qou3nKSwtWKg"><div class="marker"></div><span class="inline-wrap"><b>Level3<span class="jill"></span>缓存</b></span><span class="inline-wrap">：位于<span class="jill"></span>CPU<span class="jill"></span>芯片上但多个核心共享，容量更大，速度相对较慢。L3<span class="jill"></span>缓存通常用于存储多个核心之间共享的数据，以及更大规模的工作负载。它有助于降低多核处理器之间的数据传输延迟。</span></li></ol><div id="6pDDRK7YjMu3i16vrowod3" class="wolai-block wolai-text"><div><span class="inline-wrap">多级缓存的应用方式包括以下几个方面：缓存命中和缓存失效：当<span class="jill"></span>CPU<span class="jill"></span>需要访问数据时，会首先在最小的<span class="jill"></span>L1<span class="jill"></span>缓存中查找，如果找到则为缓存命中，否则会在更大的<span class="jill"></span>L2<span class="jill"></span>或<span class="jill"></span>L3<span class="jill"></span>缓存中查找。如果所有缓存层都没有找到需要的数据，就会发生缓存失效，需要从主存储器中加载数据。</span></div></div><div id="iBNa8cfH4FjqHJLuucAMf4" class="wolai-block wolai-text"><div><span class="inline-wrap">缓存替换算法：当缓存空间不足时，会采用一些算法来决定替换哪些数据。常见的替换算法包括<span class="jill"></span>LRU（最近最少使用）、LFU（最不常用）等，以及一些变种。</span></div></div><div id="5xfqjLjCsccMHduN7LaZdh" class="wolai-block wolai-text"><div><span class="inline-wrap">数据预取：缓存控制器可能会根据访问模式预测未来可能需要的数据，并提前将其加载到缓存中，以提高命中率。</span></div></div><div id="e5VkoZZa6FnE7uva9ATKce" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，多级缓存通过提供不同层次的缓存存储，有效地提高了计算机系统的数据访问速度和整体性能。在设计中，需要权衡容量、速度和成本等因素，以达到最佳的性能提升效果。</span></div></div><div id="mSH3tvXMxfjKfmDiH8eJbu" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jiMcmhjohFpfzFCEn8fCgY" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">从<span class="jill"></span>B+<span class="jill"></span>树的角度分析为什么单表<span class="jill"></span>2000<span class="jill"></span>万要考虑分表？</span></h1><h2 id="6YxF3bZBPbgzopGbhUt1wd" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">估算<span class="jill"></span>B+<span class="jill"></span>树的数据容量</span></h2><div id="AoyJavMqmqKRqCZ5g8zQ" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_12.png" style="width: 100%"/></figure></div><div id="5YrrzWd4kHy2rWnEdnWoAp" class="wolai-block wolai-text"><div><span class="inline-wrap">结论：根据下面的推算使用 B+Tree 的形式来组织数据库表中数据的存储方式，只需要 2~4 层就足够了。</span></div></div><ul class="wolai-block"><li id="bT7ycyhFPU5SaHkbTy69C6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一层：只有一个根节点</span><ul class="wolai-block"><li id="rFPC8LNhZNSBPQUbt1kDTp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这个根节点只能是数据页节点</span></li><li id="mG3PBhAaiFrJ7QYJBzruoS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一个数据页默认大小是：16KB</span></li><li id="55wfNAHp29sC8zm6JaXwEV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">假设一条记录占空间：1KB</span></li><li id="iVXBHNREfMKZg8C1E1zDbh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">能够存储的是数据数量：16 条</span></li></ul></li><li id="byfBhRExyv4hYzweTRPbvj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">两层：</span><ul class="wolai-block"><li id="a6AV1TWUAWKZKDnfq1Nxpm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根节点：目录页</span><ul class="wolai-block"><li id="x7QF1Sc7ToQgq3LhUhngkP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">主键：8 B</span></li><li id="rMbVvomxDqxkEe7xGhATqx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">页码：8 B</span></li><li id="3ScAjy1tPdd9PjisinUNSv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">目录页的每一条记录：16 B</span></li><li id="cWwRKLxQRJBgLahvYUAueh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">目录页能够存储的记录数量：16 KB / 16 B = 1024</span></li><li id="4FJkMfYbGtzf56an7SmiWk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对目录页来说：内部存储了多少条记录，就会指向多少个子节点</span></li></ul></li><li id="mFgJWBYuN9pjmWgvHB6EbN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">叶子节点：数据页</span><ul class="wolai-block"><li id="bpdpnsmGm3npiAu1oCiCiD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">能够存储的是数据数量：16 条</span></li></ul></li><li id="dvN8SmEFNU44uyHotbUa9T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">总和：目录页容量 × 数据页容量 = 1024 × 16 = 16384 条记录</span></li></ul></li><li id="kgs1jBvYmNfZc2EPSYQt7s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">三层：</span><ul class="wolai-block"><li id="nwUMSizDdacEXQ5f1zrLDb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根节点：1 个目录页</span></li><li id="5VoK36LoqF4KP8XGCqHtqH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第二层：1024 个目录页</span></li><li id="iDRdEfsPsDx8xKvq2ZSvBD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第三层：目录页的个数 × 目录页的容量 = 1024 × 1024 = 1048576 个数据页</span></li><li id="qnXxyYyDWphfsB6o7zydzW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">总和：数据页的个数 × 数据页的容量= 1048576 × 16 = 16,777,216 条记录</span></li></ul></li><li id="8pGP4riDoqcJr6Hmw674Xr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">四层：</span><ul class="wolai-block"><li id="toYd4NVNJ28F6zcHzy2Hn1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根节点：1 个目录页</span></li><li id="k1GQhdtdRmw4PezvobEqUf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第二层：1024 个目录页</span></li><li id="42cJFRHKA1nSu6vHSmttNS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第三层：目录页的个数 × 目录页的容量 = 1024 × 1024 = 1048576 个目录页</span></li><li id="qVYJo5yq7Sw8kPx1PM3aDx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">第四层：目录页的个数 × 目录页的容量 = 1048576 × 1024 = 1,073,741,824 个数据页</span></li><li id="mKkHfhYrP2UVMUEmwC9XFY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">总和：数据页的个数 × 数据页的容量= 1,073,741,824 × 16 = 17,179,869,184 条记录</span></li></ul></li></ul><div id="3dJ2BtBshygZKSqBrxapky" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3kEV5h6g5GPgwLQvwnvCvq" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">B+Tree 层次对性能的影响</span></h2><ul class="wolai-block"><li id="mrxWEcF4aFso65BAbdLwod"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">根节点常驻内存。</span></li><li id="5HRAypFJBMnJ8JNUGHRHNe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">访问下一层的节点会导致一次 I/O，访问硬盘。</span></li><li id="gsZ2Gm3zDuwSYWtXgcPR6F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所以层数越少，I/O 的次数就越少，性能就越好。</span></li></ul><div id="wZ8qhwrMjnLYtSwyAEnYiZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="f3s8DyFnjScyZBm8cBWxuU" class="wolai-block"><span class="wolai-serial-number">22.3</span><span class="inline-wrap">结论</span></h2><div id="mtoTQ2UeQKKWvijJ7mBunc" class="wolai-block wolai-text"><div><span class="inline-wrap">如果单张数据库表存储数据达到<span class="jill"></span>2000<span class="jill"></span>万条，那么<span class="jill"></span>B+<span class="jill"></span>树将会扩展为<span class="jill"></span>4<span class="jill"></span>层甚至更多，进而导致如下问题：</span></div></div><ol class="wolai-block"><li id="9RJdrxWFuc6rKY8DewQSHK"><div class="marker"></div><span class="inline-wrap"><b>查询性能下降</b></span><span class="inline-wrap">：随着数据量的增加，B+<span class="jill"></span>树的高度可能会增加，导致查询操作的时间复杂度增加。较深的<span class="jill"></span>B+<span class="jill"></span>树意味着需要更多的磁盘<span class="jill"></span>I/O<span class="jill"></span>操作，从而影响查询的效率。</span></li><li id="ufymykRYygaKXdQPSY1rCX"><div class="marker"></div><span class="inline-wrap"><b>索引维护成本增加</b></span><span class="inline-wrap">：当数据量大时，B+<span class="jill"></span>树的维护成本也会增加。插入、更新和删除操作可能需要频繁地调整<span class="jill"></span>B+<span class="jill"></span>树结构，这可能导致性能下降。</span></li><li id="bemKwXQUxaQ9ujj9yxfgs3"><div class="marker"></div><span class="inline-wrap"><b>内存压力增大</b></span><span class="inline-wrap">：单表数据量增加会增加<span class="jill"></span>B+<span class="jill"></span>树节点的数量，从而需要更多的内存来存储索引。如果内存无法容纳足够多的索引节点，就可能导致频繁的磁盘访问，进而影响查询性能。</span></li><li id="phJEvmVLVykZFLZDTrXVJi"><div class="marker"></div><span class="inline-wrap"><b>数据备份和恢复困难</b></span><span class="inline-wrap">：单表数据量庞大时，数据备份和恢复变得更加复杂和耗时。分表可以使数据管理和维护变得更加灵活，有助于更好地进行备份和恢复操作。</span></li></ol><div id="bjypCxtY8nb9m5mQZee6do" class="wolai-block wolai-text"><div></div></div><div id="kMYpka5Amachnj92sKnCfQ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dcFGhCUPWB8wd8FZjPauLV" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">InnoDB<span class="jill"></span>为什么不用跳表，Redis<span class="jill"></span>为什么不用<span class="jill"></span>B+<span class="jill"></span>树？</span></h1><h2 id="8eQRAuAfmj5NsPBwb9zzFU" class="wolai-block"><span class="wolai-serial-number">23.1</span><span class="inline-wrap">相关概念</span></h2><h3 id="vHFKPXSKWz3WdKyG9pk5gC" class="wolai-block"><span class="wolai-serial-number">23.1.1</span><span class="inline-wrap">跳表</span></h3><div id="n9NunDCjcKBPSvF18d9vDt" class="wolai-block wolai-text"><div><span class="inline-wrap">跳表是一种</span><span class="inline-wrap"><b>基于链表的多层索引结构</b></span><span class="inline-wrap">，它通过在有序链表中增加多级索引来提高数据检索、插入和删除操作的效率。以下是对跳表相关信息的具体介绍：</span></div></div><ol class="wolai-block"><li id="tbsbc6d4KLgqegq5BzEnbV"><div class="marker"></div><span class="inline-wrap"><b>基本概念</b></span><ul class="wolai-block"><li id="wz7Tj6X7M3syc8AhKSNH9f"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>定义</b></span><span class="inline-wrap">：跳表是一种随机化的数据结构，实质就是一种可以进行二分查找的有序链表[^2^]。</span></li><li id="fU3nabK8BbpLb9X5QFhmR1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>特点</b></span><span class="inline-wrap">：跳表通过“空间换时间”的方式，将查询、插入和删除操作的时间复杂度降至<span class="jill"></span>O(logn)，其中<span class="jill"></span>n<span class="jill"></span>为元素数量[^1^]。</span></li></ul></li><li id="nba7wCXNMaX6Cp2DDYhA5U"><div class="marker"></div><span class="inline-wrap"><b>结构组成</b></span><ul class="wolai-block"><li id="usn9U38h5PiTirNuDuuTFa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>多层次链表</b></span><span class="inline-wrap">：跳表由多个层次的链表构成，每一层链表的元素数量大约是下一层的一半[^3^]。</span></li><li id="k9qmsQx7Ue9vQtPKi28RPz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>头节点</b></span><span class="inline-wrap">：头节点包含多个指针域，用于指向不同层次链表的起始位置[^4^]。</span></li><li id="hMey6QM6UuA54ZVHMRS721"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>索引节点</b></span><span class="inline-wrap">：每层链表中的节点称为索引节点，每个索引节点包含数据节点、下层索引节点的指针以及同层下一个索引节点的指针[^5^]。</span></li></ul></li><li id="qHQXKSGB72BE1EScN1kCJc"><div class="marker"></div><span class="inline-wrap"><b>操作原理</b></span><ul class="wolai-block"><li id="gF39D86jJ4t4E1VfECquyQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>查询操作</b></span><span class="inline-wrap">：从顶层索引开始，逐层向下查找，每次比较都跳过一定数量的元素，直到找到目标元素或确定其不存在[^2^][^4^]。</span></li><li id="wtmecpDVsXmwgZ1ofoVw2A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>插入操作</b></span><span class="inline-wrap">：首先找到插入位置，然后根据概率决定新节点在各层索引中的位置，并更新相应指针[^5^]。</span></li><li id="kHJSrnGMXryXmFeNuVLoEh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>删除操作</b></span><span class="inline-wrap">：找到待删除节点后，更新相关索引层的指针，移除节点[^5^]。</span></li></ul></li><li id="ukJcALVMUMmfqTc8SoG6TT"><div class="marker"></div><span class="inline-wrap"><b>性能分析</b></span><ul class="wolai-block"><li id="txyQzPqBib8pors1M2EgHf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>时间复杂度</b></span><span class="inline-wrap">：跳表的查询、插入和删除操作的平均时间复杂度均为<span class="jill"></span>O(logn)[^1^]。</span></li><li id="jMNnVPTKjj6ViFe1c7tceq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>空间复杂度</b></span><span class="inline-wrap">：跳表的空间复杂度为<span class="jill"></span>O(n)，因为除了存储<span class="jill"></span>n<span class="jill"></span>个元素外，还需要存储额外的索引指针[^5^]。</span></li></ul></li><li id="37ue1LoovkVzEcJDLuEvQL"><div class="marker"></div><span class="inline-wrap"><b>应用场景</b></span><ul class="wolai-block"><li id="maXfbzUCvEx2WyD9VFGBBc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>有序集合实现</b></span><span class="inline-wrap">：如<span class="jill"></span>Redis<span class="jill"></span>中的有序集合<span class="jill"></span>zset<span class="jill"></span>就是使用跳表实现的[^3^]。</span></li><li id="fjTgG7Vv1bnibA7UXVGqWV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>内存数据库</b></span><span class="inline-wrap">：LevelDB、RocksDB<span class="jill"></span>等内存数据库中使用跳表来优化数据访问速度[^3^]。</span></li></ul></li></ol><div id="i5FQR1Ejq8H6MD2zJugG1Y" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，跳表作为一种高效的数据结构，在需要快速检索、插入和删除操作的场景中表现出色。它的设计思想是通过增加空间成本来换取时间效率的提升，这在处理大规模数据集时尤为重要。</span></div></div><h3 id="ckg98mnCbivgUqFBTPBiZ2" class="wolai-block"><span class="wolai-serial-number">23.1.2</span><span class="inline-wrap">B+<span class="jill"></span>树</span></h3><div id="5Z3SUmX1ytih7XBUzBSvAJ" class="wolai-block wolai-text"><div><span class="inline-wrap">B+<span class="jill"></span>树是一种</span><span class="inline-wrap"><b>自平衡的搜索树</b></span><span class="inline-wrap">，广泛应用于数据库和文件系统的索引结构。以下是对<span class="jill"></span>B+<span class="jill"></span>树相关信息的具体介绍：</span></div></div><ol class="wolai-block"><li id="xjLZdwSNgNBCQyHiuXcbuH"><div class="marker"></div><span class="inline-wrap"><b>基本概念</b></span><ul class="wolai-block"><li id="eQodbqjiUEMi42xhBHQhDF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B+<span class="jill"></span>树是<span class="jill"></span>B<span class="jill"></span>树的一种变体，它将所有的数据记录都保存在叶子节点中，而内部节点仅存储关键字信息[^1^]。这种设计使得<span class="jill"></span>B+<span class="jill"></span>树非常适合于外部存储，如磁盘或<span class="jill"></span>SSD，因为它减少了读取数据时所需的<span class="jill"></span>I/O<span class="jill"></span>操作次数。</span></li></ul></li><li id="pahAQ14DZgWAoHFmfTRqZT"><div class="marker"></div><span class="inline-wrap"><b>结构特点</b></span><ul class="wolai-block"><li id="nQUJqZGoPTokF3kJST5C9V"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">每个节点可以有多个子节点，非根节点至少有<span class="jill"></span>m/2<span class="jill"></span>个子节点，至多有<span class="jill"></span>m<span class="jill"></span>个子节点（m<span class="jill"></span>为树的阶数）[^3^]。</span></li><li id="aBZfKa2daUZz9GJWSKPTgD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所有叶子节点位于同一层，且包含指向下一个叶子节点的指针，形成了一个链表结构[^1^][^3^]。</span></li><li id="k6Wbv2CGzd8RbqWG9M8GWM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内部节点只存储键值，用于引导查找路径，不存储实际数据[^3^]。</span></li><li id="tdRhCS3JsKwZMhaS1jESyW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所有实际数据都存储在叶子节点中，并且叶子节点之间通过链表相连[^2^]。</span></li></ul></li><li id="u4Ea8NoxhTfKCixL1iyZGX"><div class="marker"></div><span class="inline-wrap"><b>查找算法</b></span><ul class="wolai-block"><li id="bHHNybVChXYidHnakcaR2z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">查找操作从根节点开始，根据键值的大小选择相应的子节点继续查找，直到到达叶子节点[^3^]。</span></li><li id="fEPjq6eVvj76rh5Ugi4YfF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在叶子节点中进行线性或二分查找，找到对应的数据[^3^]。</span></li></ul></li><li id="bbCX6JhVrwwLjToiDTMAib"><div class="marker"></div><span class="inline-wrap"><b>插入算法</b></span><ul class="wolai-block"><li id="phURwH65G18JtsHUVNCV94"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">插入操作首先找到适当的叶子节点，然后在叶子节点中插入键值[^3^]。</span></li><li id="dpZLjC5zaKVpqyjqmV9BYY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果叶子节点已满，则将其分裂为两个节点，并将中间键值上移到父节点[^3^]。</span></li><li id="s4B68tRJbyai9t3vf65KeK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">若父节点也满了，继续向上分裂，直到根节点。如果根节点也满了，则树的高度增加[^3^]。</span></li></ul></li><li id="wG4PhJUgAp1Tj11xHUQK82"><div class="marker"></div><span class="inline-wrap"><b>删除算法</b></span><ul class="wolai-block"><li id="3kJPahCuYLTJF9PaSzUZKZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">删除操作首先找到包含目标键值的叶子节点[^3^]。</span></li><li id="7sfKyAd7b4phNXpuW3wapP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">从叶子节点中删除键值，并检查节点的键值数量。如果删除后叶子节点的键值数量小于最小容量，则需要从兄弟节点借位或将其与兄弟节点合并[^3^]。</span></li><li id="h1UAtYpmZmAJz1fhrYhmhu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">若父节点也受到影响，则继续向上调整[^3^]。</span></li></ul></li></ol><div id="wcff1oJyFkaDXBrKjodrRv" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，B+<span class="jill"></span>树是一种高效的树形数据结构，特别适合于需要频繁读取和写入大量数据的应用场景。它的设计优化了磁盘<span class="jill"></span>I/O<span class="jill"></span>性能，提高了范围查询的效率，因此在数据库和文件系统中得到了广泛的应用。</span></div></div><h2 id="pgZctrSuP5Lu5F6mEnQqui" class="wolai-block"><span class="wolai-serial-number">23.2</span><span class="inline-wrap">题目答案</span></h2><div id="e6LbxDuCAGN5bqxRmN54d6" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>InnoDB 不使用跳表的原因</b></span><span class="inline-wrap">： InnoDB 是 MySQL 数据库的默认存储引擎，它采用了 B+ 树作为主要的索引数据结构。B+ 树在数据库领域广泛应用，因为它对范围查询、排序等操作有着良好的支持，适合于数据库的多样化查询需求。相比之下，跳表在某些方面可能表现出色，但在数据库场景下，它的性能和特点可能不如 B+ 树。</span></div></div><div id="uZeJDNcbuSkLBWDnWfSYT8" class="wolai-block wolai-text"><div><span class="inline-wrap">跳表适用于有序数据的搜索，它可以在某些情况下实现快速查找，但相对于 B+ 树，跳表的实现和维护可能更为复杂，而且跳表对于范围查询的性能可能不如 B+ 树。此外，B+ 树在磁盘存储和内存管理方面也有优势，这在数据库中尤为重要。</span></div></div><div id="nwMUy2tvitc7QypfuYtSAt" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Redis 不使用 B+ 树的原因</b></span><span class="inline-wrap">： Redis 是一个内存存储数据库，它主要用于缓存和快速数据存取。在这样的场景下，B+ 树不一定是最优选择。B+ 树的设计和优势更多地与磁盘存储相关，而 Redis 的数据通常完全存储在内存中，磁盘访问并不是主要瓶颈。</span></div></div><div id="ocMhGPLrSYbUTqBxgRpGmg" class="wolai-block wolai-text"><div><span class="inline-wrap">Redis 使用了一种称为「跳跃表」（Skip List）的数据结构来实现有序集合。跳跃表在内存中的实现相对简单，适用于 Redis 的高速内存存储和快速读写操作。它在某些情况下可以提供良好的性能，尤其是在不需要像 B+ 树那样复杂的平衡和维护操作时。</span></div></div><div id="iZfJACo62Xo8Q6qH1SAezL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="mDTPty5tCNtRpmiKBgP7xz" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，InnoDB 和 Redis 在选择数据结构上考虑了各自的使用场景、性能需求以及存储特点。虽然跳表在某些情况下可能表现得很好，但在数据库和内存存储引擎的背景下，B+ 树和跳跃表分别被选择以满足不同的性能和设计要求。</span></div></div><div id="67qRUBsj1kuuh3QqF9gYbX" class="wolai-block wolai-text"><div></div></div><div id="pSnDNjAVRoDHhHBFmEf52E" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="edM7EZ3w8EckqkJKEE7mSu" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">怎么做数据对账？</span></h1><div id="4Mv9c9i1P9azacVkPhTQyP" class="wolai-block wolai-text"><div><span class="inline-wrap">当需要进行数据对账时，通常涉及比较两个或多个数据源之间的差异，以确保数据的一致性和准确性。</span></div></div><div id="bXyxvRkaJTk9Sxh5Wt6PHx" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一般的数据对账步骤：</span></div></div><ol class="wolai-block"><li id="bVVksmvpxwu6hRY1smvptu"><div class="marker"></div><span class="inline-wrap"><b>确定对账目标</b></span><span class="inline-wrap">： 确定要对账的数据源和目标，例如两个不同系统之间的数据、两个时间点的数据等。</span></li><li id="tzp9uwCH9LM5zSfhJuVMmJ"><div class="marker"></div><span class="inline-wrap"><b>数据提取</b></span><span class="inline-wrap">： 从每个数据源中提取需要对账的数据。这可能涉及数据库查询、API<span class="jill"></span>调用、文件导出等。</span></li><li id="sbQKzEZmKjjZw7DeHmVUBG"><div class="marker"></div><span class="inline-wrap"><b>数据转换</b></span><span class="inline-wrap">： 将提取的数据转换成统一的格式，以便于后续比较。确保数据字段名、数据类型等匹配。</span></li><li id="Q6ReTa7RB11Qv4thhUpxc"><div class="marker"></div><span class="inline-wrap"><b>数据比较</b></span><span class="inline-wrap">： 对转换后的数据进行比较。比较的方法可以包括逐行比对、使用哈希函数生成数据指纹后进行比对等。</span></li><li id="tzWPoBQsuPJheoHhmH8ydB"><div class="marker"></div><span class="inline-wrap"><b>差异分析</b></span><span class="inline-wrap">： 如果数据源之间存在差异，进行详细的差异分析。确定哪些数据不一致，并找出造成差异的原因。</span></li><li id="ciTxR1eeGTdiNbiuuLbRzm"><div class="marker"></div><span class="inline-wrap"><b>差异解决</b></span><span class="inline-wrap">： 根据差异分析结果，采取适当的措施来解决数据差异。可能需要更新数据、纠正错误等。</span></li><li id="3VyHgfeETXnvUhp47CsYKG"><div class="marker"></div><span class="inline-wrap"><b>记录和报告</b></span><span class="inline-wrap">： 记录对账过程的结果，包括哪些数据一致，哪些数据不一致，以及差异的原因和解决方案。这可以作为后续审计和改进的依据。</span></li><li id="uhntp6RGDkCztc7BQUse1W"><div class="marker"></div><span class="inline-wrap"><b>自动化对账（可选）</b></span><span class="inline-wrap">： 对于频繁进行的对账任务，可以考虑建立自动化对账流程。这可以减少人工错误和时间成本。</span></li><li id="nRHgFfJmrbryUdbHVNibQb"><div class="marker"></div><span class="inline-wrap"><b>定期重复对账</b></span><span class="inline-wrap">： 数据对账不是一次性任务，应该定期重复执行，以确保数据一致性的持续性。</span></li></ol><div id="nhbh7Ph1f4XnGJXKAtEoGM" class="wolai-block wolai-text"><div><span class="inline-wrap">值得注意的是，数据对账可能会因应用场景和数据的不同而有所不同，上述步骤提供了一个通用的框架，可以根据实际情况进行调整和扩展。此外，对于大规模数据，可能需要考虑性能和效率问题，选择合适的工具和算法来进行对账操作。</span></div></div><div id="q5qxvmJdw5KRtZBGbYb9vo" class="wolai-block wolai-text"><div></div></div><div id="p1cJvKX7UzR5k4cLC4HemN" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="sqSCiN59U3PqFC1qDoD8EJ" class="wolai-block"><span class="wolai-serial-number">25</span><span class="inline-wrap">MySQL<span class="jill"></span>千万级大表如何做数据清理？</span></h1><div id="6CtFrv3MAKCqkHfoDLKyPo" class="wolai-block wolai-text"><div><span class="inline-wrap">清理<span class="jill"></span>MySQL<span class="jill"></span>千万级大表的数据可以采取以下几种方法：</span></div></div><ol class="wolai-block"><li id="2XRuifr8V5aQAie9v3KhB6"><div class="marker"></div><span class="inline-wrap"><b>分区表</b></span><span class="inline-wrap">：如果你的表支持分区，可以根据时间范围将数据分散到不同的分区中。这样，当需要清理数据时，只需删除相应的分区即可，而不需要扫描整个表。这种方法可以提高清理数据的效率。</span></li><li id="3CKAVaUFouF4XkzjgNvLYW"><div class="marker"></div><span class="inline-wrap"><b>分批删除</b></span><span class="inline-wrap">：将要删除的数据分成多个较小的批次进行删除，而不是一次性删除整个表的数据。可以使用<span class="jill"></span>LIMIT<span class="jill"></span>和<span class="jill"></span>OFFSET<span class="jill"></span>子句来限制每个批次的删除数量，并使用循环或脚本来逐批删除数据。这样可以减少对数据库的负载，避免一次性删除大量数据时的性能问题。</span></li><li id="u2e3z1AKWs5ZN7h7tVcdvf"><div class="marker"></div><span class="inline-wrap"><b>使用索引</b></span><span class="inline-wrap">：确保表中的字段上有适当的索引。索引可以加快删除操作的速度，特别是在大表中。根据删除条件创建适当的索引，这样数据库可以更快地定位到要删除的数据。</span></li><li id="g9MFP7ndKPG1PZnwFLEbhQ"><div class="marker"></div><span class="inline-wrap"><b>优化删除语句</b></span><span class="inline-wrap">：使用<span class="jill"></span>DELETE<span class="jill"></span>语句删除数据时，可以优化语句的性能。避免在删除操作中使用不必要的子查询或复杂的条件，这可能会导致查询执行时间过长。确保删除语句的<span class="jill"></span>WHERE<span class="jill"></span>条件能够充分利用索引，以提高删除操作的效率。</span></li><li id="udgU3Mqvd1hUVNE8FBson8"><div class="marker"></div><span class="inline-wrap"><b>数据归档</b></span><span class="inline-wrap">：如果你需要保留历史数据但不经常查询，可以考虑将旧数据归档到其他表或存储介质中，例如归档表、归档文件或其他数据库。这样可以减小主表的大小，提高查询性能。</span></li><li id="26Sd5u9yCHwAmuw7TeqLWP"><div class="marker"></div><span class="inline-wrap"><b>定期维护</b></span><span class="inline-wrap">：定期进行数据库维护操作，例如优化表结构、重建索引、收集统计信息等。这些操作可以提高数据库的性能，并减少数据清理的需要。</span></li></ol><div id="vYNXzg2FYtTXJKMWmb3mZu" class="wolai-block wolai-text"><div><span class="inline-wrap">在进行数据清理操作之前，请务必备份数据库以防止意外数据丢失。此外，根据你的具体情况，可能需要结合其他方法或工具来进行数据清理，例如使用分布式数据库、数据分片或数据迁移等。最好在测试环境中进行测试和验证，以确保清理操作的安全性和效果。</span></div></div><div id="uz3HgSL4YBYf8QMhaVKmqC" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="xeqBbkbtwPr1yPKjPGDqEZ" class="wolai-block"><span class="wolai-serial-number">26</span><span class="inline-wrap">高并发的积分系统，在数据库增加积分，怎么实现？</span></h1><h2 id="6wxpwBiv87PkN2RaJ7auZT" class="wolai-block"><span class="wolai-serial-number">26.1</span><span class="inline-wrap">场景细化：用户个人积分</span></h2><h3 id="pZGjGbuHjdnrAGyu2w6zrJ" class="wolai-block"><span class="wolai-serial-number">26.1.1</span><span class="inline-wrap">特点</span></h3><div id="sayKoacQqVAgrPAJGkzCKa" class="wolai-block wolai-text"><div><span class="inline-wrap">具体到某一个用户的积分修改，在限定用户<span class="jill"></span>ID<span class="jill"></span>的情况下不会出现并发写的情况，所以宏观上不需要加锁</span></div></div><div id="cd89UQd4RSEDfvHDH4L3rr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="egjPkGRH7pDL1G6pNjLQfu" class="wolai-block"><span class="wolai-serial-number">26.1.2</span><span class="inline-wrap">并发性能保障</span></h3><div id="jmXMtaurKW9WhcjE5uotfG" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Redis<span class="jill"></span>中建立缓存，数据结构选择<span class="jill"></span>Hash<span class="jill"></span>类型</span></div></div><ul class="wolai-block"><li id="c3LPUiS7Dqn6HGjL56HYqx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">key：user_score:[userId]</span></li><li id="i33Etsvxwu5VTqvEX3Ftwn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">value：用户积分的具体数值</span></li></ul><div id="tMEiXfBCQLGcnLQuJfYTgR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6BKQSh5jGNefZxp5QkodFo" class="wolai-block wolai-text"><div><span class="inline-wrap">每一次接收到修改用户积分的请求则执行两方面操作：</span></div></div><ul class="wolai-block"><li id="gC5VNwfrpVhUMhbCb2n2ve"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修改<span class="jill"></span>Redis<span class="jill"></span>中的数据</span></li><li id="seoKBm9vEZPQ6qR6q32wDz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">把『用户积分修改操作』存入消息队列，由消息队列的消费端负责更新数据库</span></li></ul><div id="pPNymDu8vjpvWNMx2JV9HV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7j59UZxFr8Fhox2Q8qMHeY" class="wolai-block"><span class="wolai-serial-number">26.1.3</span><span class="inline-wrap">数据一致性保障</span></h3><div id="mHWixWxfSMUo4218F5hfri" class="wolai-block wolai-text"><div><span class="inline-wrap">按照用户<span class="jill"></span>ID<span class="jill"></span>执行更新即可，如果希望加强保障则可以考虑在修改数据时加行锁</span></div></div><div id="mt8uHGZPPTR2N4WVRfK9tT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aiLT1m7SPZdRPdZusd4TPt" class="wolai-block"><span class="wolai-serial-number">26.2</span><span class="inline-wrap">场景细化：团队积分</span></h2><h3 id="q4t31Z5CvmbhNPxyp5xFsN" class="wolai-block"><span class="wolai-serial-number">26.2.1</span><span class="inline-wrap">特点</span></h3><div id="63nnB8ySP9nAvLnmXpbSFP" class="wolai-block wolai-text"><div><span class="inline-wrap">团队中的每一个个体行为都会导致团队积分改变，那这样就会造成宏观上出现并发写操作，所以需要加分布式锁</span></div></div><div id="k5nsWpc338MLZkwKa2qXUx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5DqyksBpVrR6JFVyJ3UrBY" class="wolai-block"><span class="wolai-serial-number">26.2.2</span><span class="inline-wrap">并发性能保障</span></h3><div id="fT5QCYMkvPR6G2DejokFU7" class="wolai-block wolai-text"><div><span class="inline-wrap">每个用户信息中都需要包含团队<span class="jill"></span>ID</span></div></div><div id="h3pjzLZuL6VQHLinD2vpSN" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Redis<span class="jill"></span>中建立缓存，数据结构选择<span class="jill"></span>Hash<span class="jill"></span>类型</span></div></div><ul class="wolai-block"><li id="iM2yNkvrV1VtENxaP7U5t2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">key：team_score:[teamId]</span></li><li id="fXGSweYxhCR3pBYbHUkM9s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">value：团队积分的具体数值</span></li></ul><div id="pmC3zKzmN5pCxsrp7pXKgi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="416wgr9gmDr68M1QKsEJUF" class="wolai-block wolai-text"><div><span class="inline-wrap">每一次接收到修改用户积分的请求则执行如下操作：</span></div></div><ul class="wolai-block"><li id="3wDrndtoMfCxpyt1W9AoHM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于团队<span class="jill"></span>ID<span class="jill"></span>获取分布式锁</span><ul class="wolai-block"><li id="5o2KAxbjemWBmZPT7uGNbS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">获取成功</span><ul class="wolai-block"><li id="syvx969JZYwQ5RTL1DVHuz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修改<span class="jill"></span>Redis<span class="jill"></span>中的数据</span></li><li id="dCF8DkvR18BQMZH2cya9i3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">把『团队积分修改操作』存入消息队列，由消息队列的消费端负责更新数据库</span></li></ul></li><li id="eeUWHXUCqQU6VHcvX9A4g1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">获取失败：等待并重试</span></li></ul></li></ul><div id="fZwggpzyoQ4LGY14o18kbS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7bA5tvYvXJetLB5BQPtiMC" class="wolai-block"><span class="wolai-serial-number">26.2.3</span><span class="inline-wrap">数据一致性保障</span></h3><div id="gJfWZXRA2xqMR1wYLfTRBo" class="wolai-block wolai-text"><div><span class="inline-wrap">按照团队<span class="jill"></span>ID<span class="jill"></span>执行更新即可，如果希望加强保障则可以考虑在修改数据时加行锁</span></div></div><div id="rS5i4on7czCugHsXQ4aRvp" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cETqdFj5GbBXZY8znh1HDE" class="wolai-block"><span class="wolai-serial-number">27</span><span class="inline-wrap">MySQL<span class="jill"></span>热点数据更新会带来哪些问题？</span></h1><div id="rMSYsG2Ssk7MQfmRPt24JM" class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>MySQL<span class="jill"></span>中的热点数据频繁更新时，可能会导致以下问题：</span></div></div><ol class="wolai-block"><li id="kaxoMorJfG4AaL2eBak3Ey"><div class="marker"></div><span class="inline-wrap"><b>锁竞争</b></span><span class="inline-wrap">：多个并发事务同时更新同一行或同一组数据时，会引发锁竞争。如果没有合适的锁策略和并发控制机制，可能会导致事务等待和阻塞，降低系统的并发性能。</span></li><li id="3jxTWKjQpz8dHCWntbLr33"><div class="marker"></div><span class="inline-wrap"><b>死锁</b></span><span class="inline-wrap">：如果多个事务之间存在循环依赖的更新操作，并且没有正确处理锁的顺序，可能会导致死锁的发生。死锁会导致事务无法继续执行，需要通过超时或者手动干预来解决。</span></li><li id="4zs53cmHZY86L1ucaJVd3U"><div class="marker"></div><span class="inline-wrap"><b>数据不一致</b></span><span class="inline-wrap">：当热点数据频繁更新时，如果没有正确的事务隔离级别和并发控制策略，可能会导致数据不一致的问题。例如，读取到未提交的数据或者读取到部分更新的数据。</span></li><li id="599bW6ZRieSKMz4X1gXyn8"><div class="marker"></div><span class="inline-wrap"><b>性能瓶颈</b></span><span class="inline-wrap">：频繁的热点数据更新可能会导致数据库性能瓶颈，特别是在高并发的情况下。数据库需要处理大量的更新操作，可能会增加<span class="jill"></span>CPU<span class="jill"></span>和磁盘的负载，导致响应时间延长和吞吐量下降。</span></li><li id="x8daMuKKwzNXjz9kjwWf3q"><div class="marker"></div><span class="inline-wrap"><b>数据库压力</b></span><span class="inline-wrap">：热点数据更新可能会导致数据库的存储空间增加和磁盘<span class="jill"></span>IO<span class="jill"></span>的负载增加。如果没有及时的数据库优化和调整，可能会导致数据库性能下降和存储资源的消耗。</span></li></ol><div id="dc2KJrzLkPnteBZV4nCHmZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fiX39NgW1tzrYnmjm5WHnJ" class="wolai-block wolai-text"><div><span class="inline-wrap">为了解决这些问题，可以采取以下措施：</span></div></div><ol class="wolai-block"><li id="c51YMi99kfwuaLURprziti"><div class="marker"></div><span class="inline-wrap"><b>优化查询和更新语句</b></span><span class="inline-wrap">：通过合理的索引设计、查询优化和更新批量处理等方式，减少对热点数据的频繁更新操作，降低锁竞争和数据库负载。</span></li><li id="gJn3P1w3c3WSLMS7tYyHub"><div class="marker"></div><span class="inline-wrap"><b>选择合适的事务隔离级别</b></span><span class="inline-wrap">：根据业务需求和数据一致性要求，选择合适的事务隔离级别，避免读取到脏数据或不可重复读的问题。</span></li><li id="ggNQtbFrfL8P48CQe5TyXa"><div class="marker"></div><span class="inline-wrap"><b>使用合理的并发控制策略</b></span><span class="inline-wrap">：通过锁机制、乐观锁或悲观锁等方式，控制并发事务对热点数据的访问和更新，避免锁竞争和死锁的发生。</span></li><li id="eXNk2oCv6s8hdzaPWE8Su1"><div class="marker"></div><span class="inline-wrap"><b>数据库优化和扩展</b></span><span class="inline-wrap">：通过合理的数据库配置、硬件升级、分库分表、读写分离等方式，提升数据库的性能和扩展性，以应对高并发的热点数据更新。</span></li><li id="s9ygkRqFfo7SNFYMHNAXES"><div class="marker"></div><span class="red inline-wrap"><b>借助外部资源</b></span><span class="inline-wrap">：借助消息队列或缓存空间，先把需要修改的的数据缓存起来，等到项目访问高峰期过去再集中执行更新</span></li></ol><div id="2wkUtjLiLifQptC7ryXAbW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="qVNti4ozES7mJriKRBjKRQ" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，热点数据的频繁更新可能会带来锁竞争、死锁、数据不一致、性能瓶颈和数据库压力等问题。通过合理的数据库设计、并发控制和优化策略，可以有效地解决这些问题，并提升系统的性能和可靠性。</span></div></div><div id="aAbL5XzhJHf4fKRdMQmsgS" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="7aVoydm73QQQXdbPCwtvoN" class="wolai-block"><span class="wolai-serial-number">28</span><span class="inline-wrap">和外部机构交互如何防止被外部服务不可用而拖垮</span></h1><div id="i42FqpYY9vQoQ7oTjthowc" class="wolai-block wolai-text"><div><span class="inline-wrap">与外部机构交互时，为了防止外部服务不可用导致自身服务受到影响，可以采取以下一些策略：</span></div></div><ol class="wolai-block"><li id="v8ZfhS43cMPq7uAWN7H7Zz"><div class="marker"></div><span class="inline-wrap"><b>超时设置和重试机制</b></span><span class="inline-wrap">：在与外部服务进行交互时，设置合适的超时时间。如果在预定时间内未收到响应，可以触发重试机制，多次尝试与外部服务建立连接。但是要注意避免无限制的重试，以免对自身系统造成过多负担。</span></li><li id="4cTKFQLnvpBVodHUdZ4fWZ"><div class="marker"></div><span class="inline-wrap"><b>限流和熔断</b></span><span class="inline-wrap">：使用限流和熔断机制来控制与外部服务的交互频率。当外部服务不可用或响应时间过长时，可以暂时停止或降低对该服务的请求，防止过多的请求集中到不可用的服务上，从而拖垮自身服务。</span></li><li id="tumq4r4C6FgecML4KzELuN"><div class="marker"></div><span class="inline-wrap"><b>服务降级</b></span><span class="inline-wrap">：在外部服务不可用的情况下，可以采取服务降级策略，提供一个备用的功能或响应， 确保自身系统的基本功能仍然可用。例如，展示缓存数据、提供默认值等。</span></li><li id="hVJvcKC8rW7nwTcrb4nU1g"><div class="marker"></div><span class="inline-wrap"><b>异步处理</b></span><span class="inline-wrap">：将与外部服务的交互设计为异步操作，不会直接阻塞主要流程。将请求放入消息队列或异步任务中，从而减少直接依赖外部服务的耦合。</span></li><li id="rowcL6KPzfiYRsF1TwG8mj"><div class="marker"></div><span class="inline-wrap"><b>多地域部署</b></span><span class="inline-wrap">：如果外部服务支持多地域部署，可以选择将自身服务部署在多个地理位置，以减少单一地区外部服务不可用对整体系统的影响。</span></li><li id="wnVdU4SgKZf47oset1Pp7k"><div class="marker"></div><span class="inline-wrap"><b>监控和报警</b></span><span class="inline-wrap">：实施有效的监控和报警系统，及时检测外部服务的可用性和性能。一旦发现问题，可以迅速采取措施，如切换到备用服务、通知相关人员等。7. 合理的容错策略： 在代码中实施合理的容错策略，例如处理异常情况、优雅降级和自动恢复机制，确保系统在外部服务不稳定时也能正常运行。</span></li><li id="hn9TGa1rsahrJWf8Sxd1Gz"><div class="marker"></div><span class="inline-wrap"><b>预案和应急准备</b></span><span class="inline-wrap">：制定与外部服务不可用时的应急预案，明确责任人员和处理流程，以便在发生问题时能够迅速应对。</span></li><li id="cNPiXedBgP7ZFv8mcXaH7W"><div class="marker"></div><span class="inline-wrap"><b>合作伙伴选择</b></span><span class="inline-wrap">：在选择外部服务供应商时，要考虑其稳定性和可靠性。选择有良好服务记录和强大基础设施的供应商，减少不可用风险。</span></li></ol><div id="tcoxhPMw87sGD6XBFCirfT" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，通过合理的设计和应对策略，可以最大程度地降低外部服务不可用对自身服务造成的影响，保障系统的稳定性和可用性。</span></div></div><div id="cnZYoD1NdgkFgvM35bo9ZL" class="wolai-block wolai-text"><div></div></div><div id="3suuCxFi9oFXEkLDSMZ9aQ" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="KDKMMrTF8WkZRbF5xGxtb" class="wolai-block"><span class="wolai-serial-number">29</span><span class="inline-wrap">MySQL 里有 2000W 数据，Redis 中只存 20W 的数据，如何保证 Redis<span class="jill"></span>中的数据都是热点数据?</span></h1><div id="henAPTmL1MPtzsVE4D1CKV" class="wolai-block wolai-text"><div><span class="inline-wrap">要确保<span class="jill"></span>Redis<span class="jill"></span>中存储的数据都是热点数据，可以考虑以下策略：  </span></div></div><ol class="wolai-block"><li id="L56AS8A4tBuNqsVTJf79v"><div class="marker"></div><span class="inline-wrap"><b>缓存策略选择</b></span><span class="inline-wrap">： 选择合适的缓存策略，如<span class="jill"></span>LRU（最近最少使用）、LFU（最不经常使用）或基于时间过期等。这些策略可以根据数据的访问频率和使用情况来淘汰冷数据，确保<span class="jill"></span>Redis<span class="jill"></span>中存储的数据都是热点数据。</span></li><li id="dqwSjFxbf4q1wikUX3so1F"><div class="marker"></div><span class="inline-wrap"><b>数据预热</b></span><span class="inline-wrap">： 在系统启动或负载低峰期，可以通过预热的方式将热点数据加载到<span class="jill"></span>Redis<span class="jill"></span>中。预热可以通过批量读取数据库中的热点数据，并将其存储到<span class="jill"></span>Redis<span class="jill"></span>中，以提前缓存热点数据，减少后续访问时的延迟。</span></li><li id="odAoduu3HedGeiQ5BZVyAR"><div class="marker"></div><span class="inline-wrap"><b>数据更新时同步更新<span class="jill"></span>Redis</b></span><span class="inline-wrap">： 当<span class="jill"></span>MySQL<span class="jill"></span>中的数据发生更新时，及时将更新的数据同步到<span class="jill"></span>Redis<span class="jill"></span>中。可以通过在应用程序中实现数据更新的逻辑，保持<span class="jill"></span>MySQL<span class="jill"></span>和<span class="jill"></span>Redis<span class="jill"></span>中数据的一致性。这样可以确保<span class="jill"></span>Redis<span class="jill"></span>中存储的数据是最新的热点数据。</span></li><li id="mYj6CJz6dYaxGiPUjfNhBT"><div class="marker"></div><span class="inline-wrap"><b>定期更新数据</b></span><span class="inline-wrap">： 定期更新<span class="jill"></span>Redis<span class="jill"></span>中的数据，将最新的热点数据加载到<span class="jill"></span>Redis<span class="jill"></span>中。可以通过定时任务或者触发器来实现定期更新，以保证<span class="jill"></span>Redis<span class="jill"></span>中的数据与<span class="jill"></span>MySQL<span class="jill"></span>中的热点数据保持同步。</span></li><li id="wqBbkD22vuTpkBTzJakVmo"><div class="marker"></div><span class="inline-wrap"><b>监控和自动清理</b></span><span class="inline-wrap">： 监控<span class="jill"></span>Redis<span class="jill"></span>中的数据访问情况和存储空间占用情况。根据实际情况，自动清理不再是热点数据的缓存，以释放存储空间并保持<span class="jill"></span>Redis<span class="jill"></span>中存储的数据都是热点数据。</span></li><li id="R4BXPEb91fjzh8KDy9uYG"><div class="marker"></div><span class="inline-wrap"><b>合理设置过期时间</b></span><span class="inline-wrap">： 对于不再频繁访问的数据，可以设置较短的过期时间，以便在一段时间内没有被访问时自动从<span class="jill"></span>Redis<span class="jill"></span>中淘汰。这样可以确保<span class="jill"></span>Redis<span class="jill"></span>中存储的数据都是当前较为活跃的热点数据。</span></li></ol><div id="uhpDH9HsrLZaHkvGeCxGvo" class="wolai-block wolai-text"><div><span class="inline-wrap">通过以上策略，可以有效地保证<span class="jill"></span>Redis<span class="jill"></span>中存储的数据都是热点数据，提高数据访问的性能和响应速度。但需要根据具体业务场景和数据访问模式来选择和调整策略，以达到最佳效果。</span></div></div><div id="etZQWfTMXLUPazXkoWQFTN" class="wolai-block wolai-text"><div></div></div><div id="6ycYJkuMJgmHVpCkqHjvKE" class="bg-fluorescent_green wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="bDqbbXjRhg8ytZveNcc4zL" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>