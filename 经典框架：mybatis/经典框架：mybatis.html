<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>经典框架：Mybatis - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="经典框架：Mybatis" class="main-title"></div></div></header><article><h1 id="6Ezgx4VmCuxwh2WjMCoj5j" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">Mybatis<span class="jill"></span>中#和<span class="jill"></span>$<span class="jill"></span>的区别？</span></h1><h2 id="7HH6gqMHeFyUqU7uL8w451" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">背记</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="dVE4pDUK2rFApy8XAnQsyG" class="wolai-block wolai-text"><div><span class="inline-wrap">符号</span></div></div><span class="inline-wrap"></span><br/><div id="hnFjEvr5iAbT51RfX9c8ba" class="wolai-block wolai-text"><div><span class="inline-wrap">#</span></div></div><span class="inline-wrap"></span><br/><div id="5duEfqZXc1AyXj9fTmBGa8" class="wolai-block wolai-text"><div><span class="inline-wrap">$</span></div></div><span class="inline-wrap"></span><br/><div id="knUMtKDBtQ6ZBBXHYH6wY3" class="wolai-block wolai-text"><div><span class="inline-wrap">说明</span></div></div><span class="inline-wrap"></span><br/><div id="pAnzRvWvfszrCJKeYA8jcX" class="wolai-block wolai-text"><div><span class="inline-wrap"># 占位符是使用预编译的方式进行参数传递，并自动进行参数类型转换和防止<span class="jill"></span>SQL<span class="jill"></span>注入攻击</span></div></div><span class="inline-wrap"></span><br/><div id="qdPy3UjfxeDZTiixK7wkEP" class="wolai-block wolai-text"><div><span class="inline-wrap">$ 占位符是使用字符串拼接的方式进行参数传递， ${} 用于必须构建动态<span class="jill"></span>SQL<span class="jill"></span>语句的情况</span></div></div><h2 id="rHhq4hHWt3AifWYTqGTsR2" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">理解</span></h2><div id="cZF33wK5t4cvCy8nL9eL99" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MyBatis<span class="jill"></span>中， 井号（#）和美元符号（$）是两种不同的参数占位符使用方式。</span></div></div><h3 id="9Zmu6WA2Uobxk7bugp4gTD" class="wolai-block"><span class="wolai-serial-number">1.2.1</span><span class="inline-wrap">井号（#）</span></h3><div id="uU645krHhBtu81GFv3BFF8" class="wolai-block wolai-text"><div><span class="inline-wrap">使用预编译的方式进行参数传递。在<span class="jill"></span>SQL<span class="jill"></span>语句中，使用 # 可以将参数值安全地替换到<span class="jill"></span>SQL<span class="jill"></span>语句中，并自动进行参数类型转换和防止<span class="jill"></span>SQL<span class="jill"></span>注入攻击。使用 # 占位符时，MyBatis<span class="jill"></span>会将参数值作为一个整体传递给数据库，因此可以有效地防止<span class="jill"></span>SQL<span class="jill"></span>注入问题。</span></div></div><code-block id="vfLq9jWQR8C1uEUY4hwBqy" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token comment">#{userId} 示例SQL：</span></pre></div></code-block><div id="ozmnmB1VTa4J2BCmRQouaH" class="wolai-block wolai-text"><div><span class="inline-wrap">在上述示例中，#{userId}<span class="jill"></span>会被替换为具体的参数值，并且会根据参数类型进行合适的转换。</span></div></div><div id="mfp53g69i1LjSnb9fN5bNe" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="oFQP5RsjdUgAGHPKK6NW55" class="wolai-block"><span class="wolai-serial-number">1.2.2</span><span class="inline-wrap">美元符号（$）</span></h3><div id="tuWGkpCcgNPUww7SQcjC2p" class="wolai-block wolai-text"><div><span class="inline-wrap">使用字符串拼接的方式进行参数传递。在<span class="jill"></span>SQL<span class="jill"></span>语句中，使用<span class="jill"></span>$<span class="jill"></span>可以将参数值直接拼接到<span class="jill"></span>SQL<span class="jill"></span>语句中，不进行预编译和参数类型转换。使用<span class="jill"></span>$<span class="jill"></span>占位符时，需要注意潜在的安全风险，因为参数值直接拼接到<span class="jill"></span>SQL<span class="jill"></span>语句中，可能会导致<span class="jill"></span>SQL<span class="jill"></span>注入攻击。</span></div></div><code-block id="jaaWM8bmobom3htu2BbRyi" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> id <span class="token operator">=</span> ${userId} 示例<span class="token keyword">SQL</span>：</pre></div></code-block><div id="dMezyX6g5q9DMjV5ozPz1P" class="wolai-block wolai-text"><div><span class="inline-wrap">在上述示例中， ${userId} 会被替换为具体的参数值，但不会进行参数类型转换和安全检查。</span></div></div><div id="hzPyxgUnU4p3bffSA3hpHH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qftXXaLQnVK2j4BZ8axFwp" class="wolai-block"><span class="wolai-serial-number">1.3</span><span class="inline-wrap">总结</span></h2><div id="rSwukfApjdfevZpagkTkph" class="wolai-block wolai-text"><div><span class="inline-wrap">使用井号（#）占位符可以提供更安全和可靠的参数传递方式，适用于大多数情况。</span></div></div><div id="9DvzXTy9gDybRBhh6JTGZj" class="wolai-block wolai-text"><div><span class="inline-wrap">使用美元符号（$）占位符可以提供更灵活的参数传递方式，但需要注意安全性和潜在的<span class="jill"></span>SQL<span class="jill"></span>注入问题。</span></div></div><div id="pLZWoBTDvUzV18AFU8sYaM" class="wolai-block wolai-text"><div><span class="inline-wrap">在选择使用</span><span class="inline-wrap">井号（#）</span><span class="inline-wrap">还是</span><span class="inline-wrap">美元符号（$）</span><span class="inline-wrap">时，需要根据具体的需求和安全考虑来决定。</span></div></div><div id="zbMmDPxdoagvBt5zhXXjZ" class="wolai-block wolai-text"><div><span class="inline-wrap">一般来说，推荐使用 # 占位符，除非有特殊的需求需要使用 $ 占位符。</span></div></div><div id="ignf8h2CprLJGr9FA4iGL6" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="9czw661d5cPh4Cn9nZdVrF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="73L31oLayd3iwVixrv77rK" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">Mybatis<span class="jill"></span>的编程步骤是什么样的？</span></h1><div id="mqJ61XFWgK3dCjMivpTWfB" class="wolai-block wolai-text"><div><span class="inline-wrap">MyBatis<span class="jill"></span>的编程步骤主要包括以下几个环节：</span></div></div><ol class="wolai-block"><li id="h9XogvTowKfxVw8eNSrucj"><div class="marker"></div><span class="inline-wrap"><b>配置数据库连接</b></span><span class="inline-wrap">：需要配置数据库连接信息，这通常在<span class="jill"></span>MyBatis<span class="jill"></span>的全局配置文件 mybatis-config.xml 中完成。这个配置文件包含了数据库连接、事务管理、别名等重要信息。</span></li><li id="wrNt3CKCzf5goTMMu7J95D"><div class="marker"></div><span class="inline-wrap"><b>创建映射文件</b></span><span class="inline-wrap">：映射文件（mapper.xml）是<span class="jill"></span>MyBatis<span class="jill"></span>的核心部分，它定义了<span class="jill"></span>SQL<span class="jill"></span>语句和<span class="jill"></span>Java<span class="jill"></span>对象之间的映射关系。在这一步中，你需要编写<span class="jill"></span>SQL<span class="jill"></span>语句，并通过映射文件将这些语句与<span class="jill"></span>Java<span class="jill"></span>对象关联起来。</span></li><li id="gjY9quZurM3FzfyhoUPbTh"><div class="marker"></div><span class="inline-wrap"><b>编写接口</b></span><span class="inline-wrap">：在<span class="jill"></span>MyBatis<span class="jill"></span>中，需要创建一个接口，该接口将定义与数据库交互的方法。这些方法不需要实现，因为<span class="jill"></span>MyBatis<span class="jill"></span>会在运行时动态生成它们的实现。</span></li><li id="deW9TWAkJTu5nRyvGi1ZPW"><div class="marker"></div><span class="inline-wrap"><b>编写实体类</b></span><span class="inline-wrap">：实体类用于表示数据库中的表，它们通常与数据库表一一对应，包含表中字段对应的属性。</span></li><li id="wfC8TSgXAXTo2vhTvzRn1E"><div class="marker"></div><span class="inline-wrap"><b>执行<span class="jill"></span>SQL<span class="jill"></span>操作</b></span><span class="inline-wrap">：通过调用在第一步中创建的接口方法，可以执行<span class="jill"></span>SQL<span class="jill"></span>操作，如查询、插入、更新或删除数据。MyBatis<span class="jill"></span>会处理这些方法调用，将其转换为实际的<span class="jill"></span>SQL<span class="jill"></span>语句执行。</span></li><li id="rvSQiEzgftALoA5hwg8pS"><div class="marker"></div><span class="inline-wrap"><b>结果映射</b></span><span class="inline-wrap">：MyBatis<span class="jill"></span>会自动将<span class="jill"></span>SQL<span class="jill"></span>查询的结果映射到<span class="jill"></span>Java<span class="jill"></span>对象中，这个过程可以通过配置映射文件中的结果映射来完成。</span></li><li id="hvghDcXfsDgZSh8esyDiLD"><div class="marker"></div><span class="inline-wrap"><b>释放资源</b></span><span class="inline-wrap">：在使用完数据库连接后，需要关闭连接和释放其他相关资源，以确保系统的稳定性和性能。</span></li></ol><div id="57WF651WHNiL5Gqbcxoh7v" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，MyBatis<span class="jill"></span>通过提供一种半自动化的<span class="jill"></span>ORM<span class="jill"></span>实现，简化了<span class="jill"></span>JDBC<span class="jill"></span>的繁琐过程，使得开发者可以更加专注于<span class="jill"></span>SQL<span class="jill"></span>语句的编写和优化。</span></div></div><div id="eabysGo9PDBLnKPPvqfpKM" class="wolai-block wolai-text"><div></div></div><div id="6dud1e1QHnfdbtDh1YJ5WN" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cSaLmF8Kvfjz6NicoF2P5D" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">JDBC<span class="jill"></span>编程有哪些不足之处，MyBatis<span class="jill"></span>是如何解决这些问题的？</span></h1><div id="woNAVpEnCx22kt5nPNR8Kn" class="wolai-block wolai-text"><div><span class="inline-wrap">MyBatis<span class="jill"></span>作为一个优秀的持久层框架，它简化了<span class="jill"></span>JDBC<span class="jill"></span>操作数据库的过程。MyBatis<span class="jill"></span>通过提供<span class="jill"></span>XML<span class="jill"></span>映射文件或者注解的方式，让开发者只需要关注<span class="jill"></span>SQL<span class="jill"></span>本身，而无需处理诸如注册驱动、创建连接、创建<span class="jill"></span>statement、设置参数、结果集检索等<span class="jill"></span>JDBC<span class="jill"></span>中的繁杂过程代码。以下是<span class="jill"></span>JDBC<span class="jill"></span>编程的一些不足之处以及<span class="jill"></span>MyBatis<span class="jill"></span>是如何解决这些问题的：</span></div></div><ol class="wolai-block"><li id="TL6dFo8rXcHefuX1NbaoK"><div class="marker"></div><span class="inline-wrap"><b>繁琐的代码</b></span><span class="inline-wrap">：JDBC<span class="jill"></span>编程需要编写大量的重复代码，包括连接数据库、创建和释放资源、处理结果集等。这使得代码冗长、难以维护和理解。MyBatis<span class="jill"></span>通过提供一个简洁的配置文件和映射文件，将数据库操作的细节抽象出来，使得开发者只需关注<span class="jill"></span>SQL<span class="jill"></span>语句和参数映射，大大减少了繁琐的代码量。</span></li><li id="tPfxxu1mrVZxdgXw6iU42a"><div class="marker"></div><span class="inline-wrap"><b>SQL<span class="jill"></span>与<span class="jill"></span>Java<span class="jill"></span>代码的耦合</b></span><span class="inline-wrap">：在<span class="jill"></span>JDBC<span class="jill"></span>编程中，SQL<span class="jill"></span>语句通常直接嵌入在<span class="jill"></span>Java<span class="jill"></span>代码中，导致<span class="jill"></span>SQL<span class="jill"></span>与<span class="jill"></span>Java<span class="jill"></span>代码紧密耦合，不易于维护和修改。MyBatis<span class="jill"></span>使用了面向<span class="jill"></span>SQL<span class="jill"></span>的思想，将<span class="jill"></span>SQL<span class="jill"></span>语句与<span class="jill"></span>Java<span class="jill"></span>代码分离，通过映射文件将<span class="jill"></span>SQL<span class="jill"></span>语句与<span class="jill"></span>Java<span class="jill"></span>对象进行映射，使得<span class="jill"></span>SQL<span class="jill"></span>与<span class="jill"></span>Java<span class="jill"></span>代码解耦，提高了代码的可维护性和可读性。</span></li><li id="qjK8YByfjEMDQwRVbNu8Mv"><div class="marker"></div><span class="inline-wrap"><b>手动参数设置和结果集处理</b></span><span class="inline-wrap">：在<span class="jill"></span>JDBC<span class="jill"></span>编程中，需要手动设置参数并处理结果集，包括类型转换、结果集遍历等，增加了开发的工作量和出错的可能性。MyBatis<span class="jill"></span>通过提供参数映射和结果集映射的功能，自动处理参数设置和结果集转换，开发者只需定义映射关系，MyBatis<span class="jill"></span>会自动完成参数设置和结果集处理，简化了开发过程。</span></li><li id="cQpDheC1XvsbDmMHH7vd2G"><div class="marker"></div><span class="inline-wrap"><b>缺乏对象关系映射（ORM）支持</b></span><span class="inline-wrap">：JDBC<span class="jill"></span>编程需要手动将数据库查询结果映射到<span class="jill"></span>Java<span class="jill"></span>对象中，缺乏对对象关系映射的支持，增加了开发的复杂性。MyBatis<span class="jill"></span>提供了强大的对象关系映射（ORM）功能，可以将查询结果自动映射到<span class="jill"></span>Java<span class="jill"></span>对象中，支持一对一、一对多、多对一等复杂的关系映射，简化了数据操作的过程。5. 缺乏缓存支持：JDBC<span class="jill"></span>编程没有内置的缓存机制，每次查询都需要访问数据库，降低了性能。MyBatis<span class="jill"></span>提供了一级缓存和二级缓存的支持。一级缓存是在同一个会话中的缓存，可以减少对数据库的访问；二级缓存是在多个会话中的缓存，可以共享缓存结果，提高了查询性能。</span></li></ol><div id="rMLBKb5pZrr76NDdYebhaG" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，MyBatis<span class="jill"></span>通过提供简洁的配置和映射文件、解耦<span class="jill"></span>SQL<span class="jill"></span>与<span class="jill"></span>Java<span class="jill"></span>代码、自动处理参数和结果集、支持对象关系映射和缓存等功能，弥补了<span class="jill"></span>JDBC<span class="jill"></span>编程的不足之处，提供了更便捷、高效和可维护的数据库访问解决方案。</span></div></div><div id="jeR2Jqa1N2bpRk6HTgaTNB" class="wolai-block wolai-text"><div></div></div><div id="or7Bi28TtAZSoZLhN2Sft" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ortKC3VNxvoRNACGoPkNVX" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">使用<span class="jill"></span>MyBatis<span class="jill"></span>的<span class="jill"></span>Mapper<span class="jill"></span>接口调用时有哪些要求？</span></h1><div id="uai6phNifoB4V4N4hQ6Pbo" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>MyBatis<span class="jill"></span>的<span class="jill"></span>mapper<span class="jill"></span>接口调用时，需要满足以下几个要求：</span></div></div><ol class="wolai-block"><li id="jDiWAqP1AL3jiWmpY91MHy"><div class="marker"></div><span class="inline-wrap">方法名匹配：Mapper<span class="jill"></span>接口中的方法名需要与<span class="jill"></span>mapper.xml<span class="jill"></span>文件中定义的<span class="jill"></span>SQL<span class="jill"></span>语句的<span class="jill"></span>id<span class="jill"></span>相同。</span></li><li id="i9ME8wTYJ78CQ6rqdb3fX1"><div class="marker"></div><span class="inline-wrap">输入参数类型匹配：Mapper<span class="jill"></span>接口方法的输入参数类型应与<span class="jill"></span>mapper.xml<span class="jill"></span>中定义的<span class="jill"></span>SQL<span class="jill"></span>语句的<span class="jill"></span>parameterType<span class="jill"></span>类型一致。</span></li><li id="rEB7pyvbBtkBu5aTet8eQ6"><div class="marker"></div><span class="inline-wrap">输出参数类型匹配：Mapper<span class="jill"></span>接口方法的返回类型应与<span class="jill"></span>mapper.xml<span class="jill"></span>中定义的<span class="jill"></span>SQL<span class="jill"></span>语句的<span class="jill"></span>resultType<span class="jill"></span>类型相匹配。</span></li><li id="7LcebJrNyySkdKhidnj8Wm"><div class="marker"></div><span class="inline-wrap">正确配置<span class="jill"></span>namespace：Mapper.xml<span class="jill"></span>文件中的<span class="jill"></span>namespace<span class="jill"></span>应与<span class="jill"></span>mapper<span class="jill"></span>接口的全限定类名（类路径）相对应。</span></li></ol><div id="dPriSNu7c8fgBQtWz8L2sK" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cTGbCGCr2zwrA7UhxdUDkw" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">Mybatis<span class="jill"></span>中一级缓存与二级缓存？</span></h1><h2 id="jhoEmhjeSMS6WcQszuTH9D" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">背记</span></h2><div id="jnHSStw96sWjST552c45PM" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MyBatis<span class="jill"></span>中，存在一级缓存和二级缓存两种缓存机制</span></div></div><h3 id="iDWZyDQvpmHNnUkH5F5qe2" class="wolai-block"><span class="wolai-serial-number">5.1.1</span><span class="inline-wrap">一级缓存是<span class="jill"></span>SqlSession<span class="jill"></span>级别的缓存</span></h3><div id="mpTWmAVBWznBJXGXjLkC8D" class="wolai-block wolai-text"><div><span class="inline-wrap">一级缓存在<span class="jill"></span>MyBatis<span class="jill"></span>中发挥着减少数据库访问次数和提高数据访问效率的作用。它是默认开启且无法关闭的，作用于单个<span class="jill"></span>SqlSession<span class="jill"></span>内部</span></div></div><div id="2VeUuCmdLEUYWYw2TQFZhQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="cNqotcrAvnsBDJxfduhbjd" class="wolai-block"><span class="wolai-serial-number">5.1.2</span><span class="inline-wrap">二级缓存是<span class="jill"></span>mapper<span class="jill"></span>级别的缓存</span></h3><div id="k7mFYH4Q395ynZcSQwSw51" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存的作用域是<span class="jill"></span>mapper<span class="jill"></span>的同一个<span class="jill"></span>namespace，需要手动开启的，它不依赖于单个<span class="jill"></span>SqlSession，而是跨<span class="jill"></span>SqlSession<span class="jill"></span>的。这意味着不同的<span class="jill"></span>SqlSession<span class="jill"></span>如果执行相同的<span class="jill"></span>namespace<span class="jill"></span>下的<span class="jill"></span>SQL<span class="jill"></span>语句，且传递的参数也相同，那么第一次执行完毕后，数据会被写入缓存，第二次查询时会直接从缓存中获取数据，而不再访问底层数据库。这样可以显著提高数据查询的效率，减少数据库的压力。</span></div></div><div id="jPYMrQAxiRTb3wKUzrj5ZA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="vXtJbUbjuCQiW8DCH5ggzg" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">理解</span></h2><div id="uHe22qAAeBGMVicDgcdmLc" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MyBatis 中，存在一级缓存和二级缓存两种缓存机制。</span></div></div><div id="2h3LYCz9tJQemofGBkLhTV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wDpzny1mxLHxtRBYHq9qQ3" class="wolai-block"><span class="wolai-serial-number">5.2.1</span><span class="inline-wrap">一级缓存</span></h3><div id="teY6z8ohaLJqzmCJwe1X7n" class="wolai-block wolai-text"><div><span class="inline-wrap">一级缓存是 MyBatis 默认开启的缓存机制，也被称为本地缓存。一级缓存的作用范围是在同一个 SqlSession 内部，即在同一个会话期间，多次执行相同的查询语句，第一次查询结果会被缓存到一级缓存中，后续的查询会直接从缓存中获取结果，而不再去查询数据库。一级缓存是基于对象引用的方式实现的，因此在同一个会话期间，如果对查询结果进行了修改（例如更新、插入、删除等操作），则会清空一级缓存，以保证数据的一致性。</span></div></div><div id="v7urr8fYhvkLKypmUQx7bi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2hF4kutSW5rWntW9Y5sCRK" class="wolai-block"><span class="wolai-serial-number">5.2.2</span><span class="inline-wrap">二级缓存</span></h3><div id="3Ps7NWcuC8iZTJSwqHjbi6" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存是 MyBatis 的全局缓存机制，作用范围是在同一个 Mapper 的 namespace<span class="jill"></span>中，即多个 SqlSession 共享同一个 Mapper 的缓存。</span></div></div><div id="6nSRhcwKsq7oD5Cf4tHimT" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存可以跨越多个会话，当多个会话执行相同的查询语句时，第一个会话的查询结果会被缓存到二级缓存中，后续的会话可以直接从缓存中获取结果，而不再去查询数据库。</span></div></div><div id="p9MxsEPGYNcvXsGCEcnnJj" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存是基于序列化的方式实现的，因此要求缓存的对象必须是可序列化的。</span></div></div><div id="h6aYQS4FwruVwp3P9o3zUQ" class="wolai-block wolai-text"><div><span class="inline-wrap">默认情况下，二级缓存是关闭的，需要在 Mapper 的配置文件中显式配置开启。</span></div></div><div id="vvoBe6uYYpH6atZ6sd526D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="6BcaXS6fBDKD1kotrdW5dN" class="wolai-block"><span class="wolai-serial-number">5.2.3</span><span class="inline-wrap">需要注意的是</span></h3><div id="v1woR1TUZinMwDBMyHfhFn" class="wolai-block wolai-text"><div><span class="inline-wrap">一级缓存和二级缓存是独立的，互不影响。</span></div></div><div id="twrhK1sRUL3rbJfd8WsnqK" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存是可选的，可以根据需要选择是否开启。</span></div></div><div id="3NaRTGzq6vRuEzm1yLQt6B" class="wolai-block wolai-text"><div><span class="inline-wrap">二级缓存的使用需要注意数据的一致性和并发访问的问题，特别是在多线程环境下。</span></div></div><div id="4KEooPSMFLSiEdA5cHn3GR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5yTtAZvCCdQijSxVvVsrMR" class="wolai-block"><span class="wolai-serial-number">5.3</span><span class="inline-wrap">总结</span></h2><div id="h8dUoHHVN2vBHq5Ygjcb1h" class="wolai-block wolai-text"><div><span class="inline-wrap">一级缓存是在同一个会话期间的缓存，而二级缓存是在同一个 Mapper 的命名空间中的缓存。一级缓存是默认开启的，二级缓存是可选的。在实际应用中，可以根据需求选择合适的缓存机制来提高查询性能。</span></div></div><div id="qR7Mxvj6nayXSuXKEHYFiP" class="wolai-block wolai-text"><div></div></div><div id="pfDqZQk4YK7PNbVujPVRdn" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="xs3AqmEuv1Kv7LwWBND5tG" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">MyBatis<span class="jill"></span>在<span class="jill"></span>insert<span class="jill"></span>插入操作时如何返回主键<span class="jill"></span>ID？</span></h1><h2 id="vDDamGjh93ASzCCPYDBGFp" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">背记</span></h2><div id="tRDm8j9LWqoFTt2j8MGJwm" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>MyBatis<span class="jill"></span>中，要使<span class="jill"></span>insert<span class="jill"></span>插入操作返回主键<span class="jill"></span>ID，可以通过以下两种方式实现：</span></div></div><ol class="wolai-block"><li id="qh6dxV3e1EVvE5M6qV9sYW"><div class="marker"></div><span class="inline-wrap"><b>使用 </b></span><span class="indigo inline-wrap"><b>useGeneratedKeys </b></span><span class="inline-wrap"><b>和 </b></span><span class="blue inline-wrap"><b>keyProperty </b></span><span class="inline-wrap"><b>属性</b></span><span class="inline-wrap">：在映射文件中的 &lt;insert&gt; 标签中，添加 useGeneratedKeys=&quot;true&quot; 和 keyProperty=&quot;id&quot; 属性。这样，当执行插入操作时，数据库生成的主键值会被自动赋值给传入参数对象的 id 属性。</span></li><li id="sLoi8tZaCfbzpx24PXMgKA"><div class="marker"></div><span class="inline-wrap"><b>使用 </b></span><span class="blue inline-wrap"><b>selectKey </b></span><span class="inline-wrap"><b>标签</b></span><span class="inline-wrap">：在映射文件中的 &lt;insert&gt; 标签内部，添加 &lt;selectKey&gt; 标签来设置主键生成策略。 &lt;selectKey&gt; 标签有两个重要属性： resultType 指定主键的类型，keyProperty 指定将主键赋值给哪个属性。此外，还可以通过 before 或 after 属性来设置是在插入前还是插入后获取主键值。</span></li></ol><div id="fUqYsP9Zvff2mSZDG9GqBb" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，通过这些配置，MyBatis<span class="jill"></span>可以在执行插入操作后返回主键<span class="jill"></span>ID，并将其赋值给对应的<span class="jill"></span>Java<span class="jill"></span>对象</span></div></div><div id="3sjR4g8nS7oWWLidqjZsFW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="w6sNBzCQsGgZu46PzSQoAY" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">理解</span></h2><div id="3SGmoFjGUXourb9NMy3DLh" class="wolai-block wolai-text"><div><span class="inline-wrap">在 MyBatis 中，可以通过以下几种方式来获取插入操作后生成的主键 ID：</span></div></div><ol class="wolai-block"><li id="2xhBiwcj72nS5JvGVnyvQK"><div class="marker"></div><span class="inline-wrap">使用数据库的自增主键：</span><ol class="wolai-block"><li id="jVzYptbSfLZJZxZ2e7CS2q"><div class="marker"></div><span class="inline-wrap">如果你的表使用了数据库的自增主键（如 MySQL 的 AUTO_INCREMENT），则在执行插入操作后，可以通过 SELECT LAST_INSERT_ID() 来获取最后插入的主键 ID。</span></li><li id="joFRddzkipii4LhTGJMp1p"><div class="marker"></div><span class="inline-wrap">在 MyBatis 的映射文件（Mapper XML）中，可以使用 &lt;selectKey&gt; 元素来配置获取主键的语句，例如：</span></li></ol><code-block id="sx3sqrv2AxMCFVw6MtU11p" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Long<span class="token punctuation">"</span></span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>AFTER<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    SELECT LAST_INSERT_ID()
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>
  INSERT INTO user (username, password) VALUES (#{username}, #{password})
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></pre></div></code-block><ol class="wolai-block"><li id="ur8jswsNwuo25nTiwLouC9"><div class="marker"></div><span class="inline-wrap">在执行插入操作后，MyBatis 会自动执行 &lt;selectKey&gt; 中配置的语句，并将获取到的主键值设置到对应的属性（ keyProperty ）中。</span></li></ol></li><li id="e2j9DpU9KaAjfiRtEZ3mZV"><div class="marker"></div><span class="inline-wrap">使用数据库的序列（Sequence）：</span><ol class="wolai-block"><li id="tCghyaTcYDneEY3ToVPbp3"><div class="marker"></div><span class="inline-wrap">如果你的表使用了数据库的序列（如 Oracle 的序列），则可以通过调用序列的<span class="jill"></span>NEXTVAL 函数来获取下一个序列值作为主键 ID。</span></li><li id="ttfbr3udJt2ahqfqnq36AF"><div class="marker"></div><span class="inline-wrap">在 MyBatis 的映射文件中，可以使用 &lt;selectKey&gt; 元素来配置获取序列值的语句，例如：</span></li></ol><code-block id="sfScPLrCrbetwfqREN7mGZ" class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Long<span class="token punctuation">"</span></span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BEFORE<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    SELECT user_seq.NEXTVAL FROM DUAL
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>
  INSERT INTO user (id, username, password) VALUES (#{id}, #{username}, #
  {password})
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></pre></div></code-block><ol class="wolai-block"><li id="cDLroG8LXHT5Z6mxbG5EhL"><div class="marker"></div><span class="inline-wrap">在执行插入操作前，MyBatis 会先执行 &lt;selectKey&gt; 中配置的语句，并将获取到的序列值设置到对应的属性（ keyProperty ）中。</span></li></ol></li><li id="rdaB8de3CRuCB3iMLAZAiS"><div class="marker"></div><span class="inline-wrap">使用数据库的触发器（Trigger）：</span><ol class="wolai-block"><li id="3ogi3T5QSn5nmh1gMgemxr"><div class="marker"></div><span class="inline-wrap">如果你的表使用了数据库的触发器，在触发器中可以获取插入操作后生成的主键 ID，并将其设置到对应的列中。</span></li><li id="8Ydg7aLdR9WCWawur56dXt"><div class="marker"></div><span class="inline-wrap">在 MyBatis 中，执行插入操作后，可以通过查询插入的记录来获取主键 ID，例如：</span></li></ol><code-block id="3J5TwdtLTqSzQpisSw6pAo" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token comment">// 执行插入操作</span>
sqlSession<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"insertUser"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取插入后的主键 ID</span>
<span class="token class-name">Long</span> id <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><ol class="wolai-block"><li id="3HodehDxX8X3eUjRmbUBGp"><div class="marker"></div><span class="inline-wrap">根据你所使用的数据库和表的配置，选择适合的方式来获取插入操作后的主键 ID。</span></li></ol></li></ol><div id="rzhj4kTg1RysYaBCchd91x" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="dPhCHMMm3Hj3TBsGoWoaas" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">简述 Mybatis 的插件运行原理，如何编写一个插件</span></h1><h2 id="hD7dWNcxYF7zyyMLUZ7YtZ" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">背记</span></h2><div id="kguBktiYKseW9jqAyUjbmA" class="wolai-block wolai-text"><div><span class="inline-wrap">MyBatis 插件的运行原理基于<span class="jill"></span>Java<span class="jill"></span>的动态代理机制。Mybatis 只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这<span class="jill"></span>4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的<span class="jill"></span>invoke() 方法， 拦截那些你指定需要拦截的方法。</span></div></div><div id="q9Gy7vuCmu9Ds2eMPf9C87" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bJekFff4WWTLX1N57Dk6AJ" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">理解</span></h2><div id="aRP5DR99ga2dr3CHSPqgQB" class="wolai-block wolai-text"><div><span class="inline-wrap">MyBatis<span class="jill"></span>自定义插件的实现方式主要包括以下几个步骤：</span></div></div><ol class="wolai-block"><li id="cTyjdVo7onbnVg7SreDMdx"><div class="marker"></div><span class="inline-wrap">创建插件类：首先，需要创建一个<span class="jill"></span>Java<span class="jill"></span>类来表示自定义插件。这个类需要实现<span class="jill"></span>MyBatis<span class="jill"></span>提供的 Interceptor 接口，并重写其中的 intercept() 方法。在这个方法中，可以编写自定义的拦截逻辑。</span></li><li id="AAejWGdmdXgjxrmTzkzLv"><div class="marker"></div><span class="inline-wrap">配置插件：在<span class="jill"></span>MyBatis<span class="jill"></span>的全局配置文件（mybatis-config.xml）中，通过 &lt;plugins&gt; 标签定义和加载插件。在 &lt;plugins&gt; 标签内部，使用 &lt;plugin&gt; 标签指定自定义插件的全限定类名。</span></li><li id="gPRTbJwxXU9TpQRxGx6qmL"><div class="marker"></div><span class="inline-wrap">注册插件：在<span class="jill"></span>MyBatis<span class="jill"></span>的 Configuration 配置对象中，将实现了 Interceptor 接口的插件进行注册。这样<span class="jill"></span>MyBatis<span class="jill"></span>就能够识别并使用这些插件。</span></li><li id="fZf6JCf2mok8GmxCFpMQtW"><div class="marker"></div><span class="inline-wrap">构建拦截器链：MyBatis<span class="jill"></span>基于责任链设计模式，将多个拦截器串联起来，形成一个拦截器链。当核心组件的方法被调用时，会依次经过每个拦截器的处理。</span></li><li id="rhx91Q1X5MwBrJFEM1CD9V"><div class="marker"></div><span class="inline-wrap">动态代理机制：MyBatis<span class="jill"></span>利用<span class="jill"></span>Java<span class="jill"></span>的动态代理技术，对 ParameterHandler 、ResultSetHandler 、 StatementHandler 和 Executor 这四种核心接口创建代理对象。当这些组件的方法被调用时，会先执行拦截器链中的代码，再执行原始方法。</span></li><li id="ot9favAhTtHDUxK8egG76y"><div class="marker"></div><span class="inline-wrap">插件执行：当<span class="jill"></span>MyBatis<span class="jill"></span>的核心组件执行方法时，会触发拦截器的 intercept() 方法。在这个方法中，可以实现对<span class="jill"></span>SQL<span class="jill"></span>语句的修改、日志打印、性能监控等功能。执行完拦截逻辑后，可以选择是否继续执行原始方法。</span></li><li id="cwafGiixsqgTJLZ6ip4kwd"><div class="marker"></div><span class="inline-wrap">完成插件功能：通过上述步骤，自定义插件完成了对<span class="jill"></span>MyBatis<span class="jill"></span>功能的增强或修改。开发者可以根据需要调整插件的行为，以实现特定的业务需求。</span></li></ol><div id="iTAEeXTaTueMLKfmv794vN" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div></article><footer></footer></body></html>