<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>Java并发编程（多线程） - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="Java并发编程（多线程）" class="main-title"></div></div></header><article><h1 id="ohDdVXYHQopz8sHzhJP5e5" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">创建多线程的四种方式</span></h1><div id="2y3m3PCL9vBwa8fULyP4b6" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中使用<span class="jill"></span>Thread<span class="jill"></span>类代表线程，所以不管使用什么方式创建多线程</span><span class="blue inline-wrap"><u><b>本质</b></u></span><span class="inline-wrap">上都是创建新的</span><span class="blue inline-wrap"><u><b>Thread<span class="jill"></span>对象</b></u></span><span class="inline-wrap">，然后再调用<span class="jill"></span>start()方法启动线程</span></div></div><div id="byM98MTEpw4x8qTm9Q52LC" class="wolai-block wolai-text"><div><span class="inline-wrap">所不同的是：打算放在新线程中要执行的</span><span class="blue inline-wrap"><u><b>任务</b></u></span><span class="inline-wrap">如何</span><span class="blue inline-wrap"><u><b>封装</b></u></span></div></div><h2 id="gFWDEeTofxA89N4kKMABch" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">继承<span class="jill"></span>Thread<span class="jill"></span>类</span></h2><ul class="wolai-block"><li id="6QKR9mLz3aqox6H5UzjGCb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义一个类继承自 Thread 类，并重写 run() 方法。</span></li><li id="oPFviYxEGoAh1AbS1cyT7W"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建该类的对象，并调用其 start() 方法启动新线程。</span></li></ul><div id="uHqzGeF4oASS7tuYnUMNj5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="iXifTDJhf3Euw1HG3jG5uW" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">实现<span class="jill"></span>Runnable<span class="jill"></span>接口</span></h2><ul class="wolai-block"><li id="wZZ8Pft1kvNfGauG3NZmsE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义一个类并实现 Runnable 接口的 run() 方法。</span></li><li id="9NBCp8KobJNX4agySPrZ6P"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建该类的对象，并将其作为目标传递给一个 Thread 类的实例。</span></li><li id="d4jcHShuSqFtqheLqMUsGx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用 Thread 实例的 start() 方法启动新线程。</span></li></ul><div id="cDSXugDgqUxRpYkZL83w7B" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fs44gB77zTkMz5TKzvJd19" class="wolai-block"><span class="wolai-serial-number">1.3</span><span class="inline-wrap">实现<span class="jill"></span>Callable<span class="jill"></span>接口（需借助<span class="jill"></span>FutureTask）</span></h2><ul class="wolai-block"><li id="xkJGapvfcMfWzsyu8mnbAx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定义一个类并实现 Callable 接口的 call() 方法。</span></li><li id="8hgcDAsFPTxMQvEN7NBKD8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建一个 FutureTask 对象，将 Callable 实例作为参数传入。</span></li><li id="64yVbWRgv6ZVZuuhZGRUfy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">将 FutureTask 对象作为目标传递给一个 Thread 类的实例，并启动线程。</span></li><li id="9qyS6ncD8yrne67mqagkbc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过 FutureTask 对象的 get() 方法获取异步计算的结果。</span></li></ul><div id="3sfTrUmTqtdQtCh1NbkM2w" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="6uYh8qLXjXMYyUMmaxPtqa" class="wolai-block"><span class="wolai-serial-number">1.4</span><span class="inline-wrap">使用线程池</span></h2><ul class="wolai-block"><li id="83N6jcCUfmv1bxp84S9ECS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建一个执行器服务，例如 Executors.newFixedThreadPool(int nThreads) 。</span></li><li id="ubLm2G29vfJaDiPLXL1puE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">提交实现了 Runnable 或 Callable 接口的任务到执行器服务。</span></li><li id="nduNtUT8cUrUaMNmhtHNSd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">执行器服务会自动分配线程来执行这些任务。</span></li></ul><div id="dy1anPEUfUXMs77uMMdWon" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="Pzf7ABYmHiPCLMv4X363D" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">多线程生命周期</span></h1><h2 id="fRSaU3PEHKg92J7SUHDRuw" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="uzXGPqDp3BzWniTw2YN64A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新建（New）：线程被创建后，尚未启动（未调用<span class="jill"></span>start()方法）的状态。</span></li><li id="esp8YWe5uqCWpVg1thUzqV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">就绪（Runnable）：当线程对象的<span class="jill"></span>start()方法被调用后，线程进入就绪状态，此时线程已经准备好执行，等待<span class="jill"></span>CPU<span class="jill"></span>调度。</span></li><li id="bjzddNPkuBszFUEcra4n1m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行（Running）：当<span class="jill"></span>CPU<span class="jill"></span>开始调度处于就绪状态的线程时，线程进入运行状态，开始执行其任务。</span></li><li id="5zV1SujiE46PoUhg4NSYtA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">阻塞（Blocked）：线程在运行过程中遇到同步锁但申请锁失败，会进入阻塞状态，此时需要获取到锁之后才会继续执行。</span></li><li id="rrLn5FcpCrUKscaWHo4fKh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">等待（Waiting）：线程在执行过程中可能会进入等待状态，例如调用了<span class="jill"></span>wait()方法，等待其他线程的通知、唤醒，才能继续执行。</span></li><li id="atdYZfRxsHEiX9LYLGCRDQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">计时等待（Timed Waiting）：与等待状态类似，但在此状态下的线程有一个预定的等待时间，超时后自动返回到就绪状态。</span></li><li id="eVRFFnaW3nZ8cfaYAP2rbT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">终止（Terminated）：线程完成任务或者因为异常而结束执行，进入终止状态。</span></li></ul><div id="7fnMGSbGAY3GCydegLNbBg" class="wolai-block wolai-text"><div><span class="inline-wrap">线程状态的管理通常是由操作系统和编程语言的运行时环境共同完成的。</span></div></div><div id="5p2AcGPh2qvnRJYFHP1eYC" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，可以通过<span class="jill"></span>Thread<span class="jill"></span>类提供的方法来控制和管理线程的状态，例如使用<span class="jill"></span>interrupt()方法来中断线程的阻塞状态，或者使用<span class="jill"></span>join()方法等待线程终止等</span></div></div><div id="oAYRYtzLceooxbazUuQqf" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2sKe9exLVDJf91bq82h1RR" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">理解</span></h2><h3 id="9QxJWoVrBSMH7WkUtDZyiT" class="wolai-block"><span class="wolai-serial-number">2.2.1</span><span class="inline-wrap">源码中定义的线程状态</span></h3><div id="bxaDQpBvoQ3uK7qNPVUrsZ" class="wolai-block"><figure class="wolai-center" style="width: 306.6666666666667px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="47rPhkntQcCcHvVqo8LfXY" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="hFaHEx5QqtmSoNqVfqrdS7" class="wolai-block"><span class="wolai-serial-number">2.2.2</span><span class="inline-wrap">新建（NEW ）</span></h3><div id="mccMXt6SFD1TPf978yYeKL" class="wolai-block wolai-text"><div><span class="inline-wrap">线程对象刚刚创建，但未启动（start）</span></div></div><code-block id="u3YFzjHByuW3wW9Z3MtyyL" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 只要线程new出来</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程的名字"</span><span class="token operator">+</span>thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程的状态:"</span><span class="token operator">+</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="shdcbb9D9DrEGETiKFab7b" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3JyZGAFfFbzthfMVGVJiwH" class="wolai-block"><span class="wolai-serial-number">2.2.3</span><span class="inline-wrap">可运行（RUNNABLE ）</span></h3><div id="gDwhQEuWmBqLCtFF6dPQbo" class="wolai-block wolai-text"><div><span class="inline-wrap">线程已被启动，可以被调度或正在被调度；也可以说此时线程在等待<span class="jill"></span>CPU<span class="jill"></span>时间片</span></div></div><code-block id="xcxaU8K3zfmsLjZ1BnP2Wf" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程的状态"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程的状态"</span><span class="token operator">+</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="isXGFd9V37xToTPDpFq6kb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7jnhHUCimjcUcejSQgQrTe" class="wolai-block"><span class="wolai-serial-number">2.2.4</span><span class="inline-wrap">锁阻塞（BLOCKED ）</span></h3><div id="iahFmtGPk39EsY4ECroZ96" class="wolai-block wolai-text"><div><span class="inline-wrap">当前线程要获取的锁对象正在被其他线程占用，此时该线程处于<span class="jill"></span>Blocked<span class="jill"></span>状态</span></div></div><code-block id="tfA3JwcxAzgtAkb3LLcgSN" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"11111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Thread</span> threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> threadB<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"状态"</span> <span class="token operator">+</span> threadB<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="g5uo37FBciVSXrB8htQFMn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3YB7WzHeer8gFV7MRsGjPU" class="wolai-block"><span class="wolai-serial-number">2.2.5</span><span class="inline-wrap">等待阻塞（WAITING ）</span></h3><div id="sTogVGHw6zr6MeSVqVmyNw" class="wolai-block wolai-text"><div><span class="inline-wrap">当前线程遇到了<span class="jill"></span>wait()，join()等方法</span></div></div><code-block id="tTokVQpC5mX75i2ehXudHy" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i---"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    o<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 使用对象的wait方法时 必要要有一个对象和synchronized</span>
                    <span class="token comment">// 如若不结合synchronized 那么就会出现一个监视器对象状态异常 IllegalMonitorStateException。</span>
                    <span class="token comment">// 任何一个对象中都有一个ObjectMonitor对象。监视器锁。管程技术。</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token comment">// o.notify();//使用notify或者notifyAll()都要结合synchronized使用，不然就会出现监视器异常IllegalMonitorStateException</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do some thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        o<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="be92cJgzXgr5tBUtr8UKFq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fuPKKHByVoKn3eCN88MQsR" class="wolai-block"><span class="wolai-serial-number">2.2.6</span><span class="inline-wrap">限时等待（TIMED_WAITING ）</span></h3><div id="oGqRh3ovBeSPRutzeKXiBo" class="wolai-block wolai-text"><div><span class="inline-wrap">当前线程调用了<span class="jill"></span>sleep(时间)，wait(时间)，join(时间)等方法</span></div></div><code-block id="6vwLvvggZ4MouEhkzGJTmr" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 线程调用wait(5000)方法</span>
            o<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程调用sleep(5000)方法</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程调用join(5000)方法</span>
thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="eX525QeUywyumZj7VhKHUQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5c5KhZjWxqBsebekwMibXY" class="wolai-block"><span class="wolai-serial-number">2.2.7</span><span class="inline-wrap">终止（TERMINATED ）</span></h3><div id="4qCKX52CvBSm52ezsgykha" class="wolai-block wolai-text"><div><span class="inline-wrap">线程正常结束或异常提前退出</span></div></div><code-block id="jAcxRcVqJUnDEDHP1fQ6T6" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="bbWXrvpvKu8v3EDDu3BGHF" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cNr45745KhUdbVY2QrXN6A" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">什么是线程池，线程池有哪些？</span></h1><div id="3DCDvUHeWHr8bXPinBdmpb" class="wolai-block wolai-text"><div><span class="inline-wrap">线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间、实现了线程对象的复用，提高的代码执行效率</span></div></div><div id="g2ekK5S8Q5zuGMSFGDdMMX" class="wolai-block wolai-text"><div><span class="inline-wrap">在 JDK 的 java.util.concurrent.Executors 中提供了多种</span><span class="inline-wrap">生成</span><span class="inline-wrap">线程池的静态方法。</span></div></div><ul class="wolai-block"><li id="sRfn8pUqQqNp143WfF34Mf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span></li><li id="aAq6gYvpiWV7hB3wf7DHMe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);</span></li><li id="hymL1s8nv5DHC4833ryBxb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);</span></li><li id="n7R32GjQghVU2j9mQtumJ2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span></li></ul><div id="i1EeVmb5a42Dh5EghSUWEk" class="wolai-block wolai-text"><div><span class="inline-wrap">需要由线程对象执行特定任务时，调用他们的 execute 方法即可。</span></div></div><div id="kGJ5pZivjXDTNX5BESf8jn" class="wolai-block wolai-text"><div><span class="red inline-wrap"><u><b>注意</b></u></span><span class="inline-wrap">：实际开发时严格</span><span class="red inline-wrap"><u><b>禁止使用</b></u></span><span class="inline-wrap">上述方法创建线程池！！！因为它们内部设置的各项参数非常不合理，存在<span class="jill"></span>OOM<span class="jill"></span>等重大风险</span></div></div><h2 id="nJgU2fxPjTxhveAoAM1TJh" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">newCachedThreadPool()</span></h2><div id="ntPoaxmyMoyjLNphHX17ui" class="wolai-block wolai-text"><div><span class="inline-wrap">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span></div></div><div id="9SFYQ2Wkvy1YLj5YTPq1kj" class="wolai-block wolai-text"><div><span class="inline-wrap">这种类型的线程池特点是：</span></div></div><ul class="wolai-block"><li id="45mvk2Gfmzv3WuhdB5rve5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">工作线程的创建数量几乎没有限制(其实也有限制的，数目为<span class="jill"></span>Interger. MAX_VALUE)，这样可灵活的往线程池中添加线程。</span></li><li id="khFsnmV6P6X1awqzcpX7Up"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为<span class="jill"></span>1<span class="jill"></span>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</span></li><li id="uEApNfSgVx6WB3PUzhUmTD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在使用<span class="jill"></span>CachedThreadPool<span class="jill"></span>时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</span></li></ul><div id="7FGq2qnFjrQM3zA53J27cv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="Z1L64fj8hCMSAnqjruoec" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">newFixedThreadPool()</span></h2><div id="oxRwXo9ReE5FieBYp5SxNe" class="wolai-block wolai-text"><div><span class="inline-wrap">创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool<span class="jill"></span>是一个典型的线程池。在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</span></div></div><div id="kuH1Uip35dUvgNoxVH2o3P" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="nwsoExGCzCZVTg6B6S6s8p" class="wolai-block"><span class="wolai-serial-number">3.3</span><span class="inline-wrap">newScheduleThreadPool()</span></h2><div id="aV5Y5JabL5NYWa2rojCyLb" class="wolai-block wolai-text"><div><span class="inline-wrap">创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟<span class="jill"></span>3<span class="jill"></span>秒执行。</span></div></div><div id="qAfYKvPKyitrHeKp7kkn9N" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="rqS3WYycj9FTsmuabt6rcS" class="wolai-block wolai-text"><div><span class="inline-wrap">这<span class="jill"></span>4<span class="jill"></span>种线程池底层全部是<span class="jill"></span>ThreadPoolExecutor<span class="jill"></span>对象的实现，阿里规范手册中规定线程池采用<span class="jill"></span>ThreadPoolExecutor<span class="jill"></span>自定义的，实际开发也是。</span></div></div><div id="8biBZ7cZi4aspAarBfyD17" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="oPxN3Z2246Zphs1vtUeCnZ" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">ThreadPoolExecutor<span class="jill"></span>对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点]</span></h1><h2 id="uQzMWx9VVo2ra7ApYPdirK" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">7<span class="jill"></span>个参数的作用</span></h2><h3 id="bUQYeShj6di4D2VHStWSyV" class="wolai-block"><span class="wolai-serial-number">4.1.1</span><span class="inline-wrap">corePoolSize</span></h3><div id="r1RYq1Z6CVJHjuWosxV2Gg" class="wolai-block wolai-text"><div><span class="inline-wrap">核心线程数，在<span class="jill"></span>ThreadPoolExecutor<span class="jill"></span>中有一个与它相关的配置：allowCoreThreadTimeOut（默认为<span class="jill"></span>false）</span></div></div><ul class="wolai-block"><li id="5MT6VK5GmqQeQmaPd6o8XW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">allowCoreThreadTimeOut<span class="jill"></span>为<span class="jill"></span>false：核心线程会一直存活，哪怕是一直空闲着</span></li><li id="57M4tXk1xcGCKohX83ZzbY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">allowCoreThreadTimeOut<span class="jill"></span>为<span class="jill"></span>true：核心线程空闲时间超过<span class="jill"></span>keepAliveTime<span class="jill"></span>时会被回收</span></li></ul><div id="pSeMfF9J8SukRfXaPXhq6k" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="ak88rxQcci9G9kgTvZh7eH" class="wolai-block"><span class="wolai-serial-number">4.1.2</span><span class="inline-wrap">maximumPoolSize</span></h3><div id="3EABqB4yxwPDQceEtvTsN7" class="wolai-block wolai-text"><div><span class="inline-wrap">最大线程数，线程池能容纳的最大线程数，当线程池中的线程达到最大且等待队列已满时，添加新任务将会触发拒绝策略</span></div></div><div id="2JXpReihsV9amWbrgmBVcd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3hZERo53D7P1TgdJzfwPbE" class="wolai-block"><span class="wolai-serial-number">4.1.3</span><span class="inline-wrap">keepAliveTime</span></h3><div id="dZSaVQBWZKSkriEyerWMLh" class="wolai-block wolai-text"><div><span class="inline-wrap">线程的最大空闲时间</span></div></div><ul class="wolai-block"><li id="fwmVVRKnusFfVDqQ5LDhHd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非核心空闲超过这个时间将被回收</span></li><li id="vqjEg9Ry7frBsng4YV7nRZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">核心线程</span><span class="inline-wrap">超过这个时间</span><span class="inline-wrap">是否回收受<span class="jill"></span>allowCoreThreadTimeOut<span class="jill"></span>影响</span></li></ul><div id="53SSrRisASsrFPgdnAS5Jj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fsVsAHvQ5eiHw4ddQTBGCA" class="wolai-block"><span class="wolai-serial-number">4.1.4</span><span class="inline-wrap">unit</span></h3><div id="i5F2uwFDZug1xMsi96dVkw" class="wolai-block wolai-text"><div><span class="inline-wrap">keepAliveTime<span class="jill"></span>的时间单位</span></div></div><div id="oQAXRQrbMgCoQCrCK61g4x" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="koSWRgFdRh2yeQ91QygmRy" class="wolai-block"><span class="wolai-serial-number">4.1.5</span><span class="inline-wrap">workQueue</span></h3><div id="iEBYjXsnQQXWwPVhgUGwMc" class="wolai-block wolai-text"><div><span class="inline-wrap">任务队列，常用有三种队列，即<span class="jill"></span>SynchronousQueue、LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。</span></div></div><div id="qjbAUzVeGr713hviw5TsDe" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="u3LeUS2j1GTBBCJkRw87xQ" class="wolai-block"><span class="wolai-serial-number">4.1.6</span><span class="inline-wrap">threadFactory</span></h3><div id="hmnrEkXUe6cHThyKDMbovF" class="wolai-block wolai-text"><div><span class="inline-wrap">线程工厂，ThreadFactory<span class="jill"></span>是一个接口，用来创建<span class="jill"></span>worker。通过线程工厂可以对线程的一些属性进行定制，默认直接新建线程。</span></div></div><div id="jHTPDwi4ytQFD5K3JZRbet" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pYA7D7aQVEu1EqkdA7kz6s" class="wolai-block"><span class="wolai-serial-number">4.1.7</span><span class="inline-wrap">RejectedExecutionHandler</span></h3><div id="5D4CymQdAm884gcBogmTSg" class="wolai-block wolai-text"><div><span class="inline-wrap">也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用<span class="jill"></span>RejectedExecutionHandler<span class="jill"></span>的<span class="jill"></span>rejectedExecution<span class="jill"></span>法。默认是抛出一个运行时异常。</span></div></div><div id="k9FP4K6MYRxxF4s3HHdf5t" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="53vf73uxyEXCSJmBBpw5QS" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">线程池大小设置</span></h2><h3 id="gda2rmhUBvdDiGBGsLfy4u" class="wolai-block"><span class="wolai-serial-number">4.2.1</span><span class="inline-wrap">最佳实践</span></h3><div id="e1znvweHMRn9THrdqiwK72" class="wolai-block wolai-text"><div><span class="inline-wrap">把<span class="jill"></span>corePoolSize<span class="jill"></span>和<span class="jill"></span>maximumPoolSize<span class="jill"></span>设置成相同的数值，避免非核心线程创建又销毁，销毁又创建</span></div></div><div id="3Fvbrkxt4joN4rfVdbEAn8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="8VHznkzwQLmDqmnTuR8ktY" class="wolai-block"><span class="wolai-serial-number">4.2.2</span><span class="inline-wrap">具体数值设置</span></h3><div id="peVy9kDjQZoBE2HcZdyEYL" class="wolai-block wolai-text"><div><span class="inline-wrap">首先需要分析项目中线程池负责的任务是哪种类型</span></div></div><h4 id="nGgjUVXxcKS7UN3Zww6J73" class="wolai-block"><span class="wolai-serial-number">4.2.2.1</span><span class="inline-wrap">CPU<span class="jill"></span>密集型</span></h4><div id="hD4azoWmakvnfd8Um4rimA" class="wolai-block wolai-text"><div><span class="inline-wrap">主要执行计算任务，响应时间很快，CPU<span class="jill"></span>一直在运行。这种任务的<span class="jill"></span>CPU<span class="jill"></span>利用率很高，那么线程数的配置应该根据<span class="jill"></span>CPU<span class="jill"></span>核心数来决定。</span></div></div><div id="fRmgJSF2TBxnbfSz3CX9Dk" class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>核心数等于最大同时执行线程数</span></div></div><div id="8zkdv3mEHJCM63DAkLUbsS" class="wolai-block wolai-text"><div><span class="inline-wrap">假如<span class="jill"></span>CPU<span class="jill"></span>核心数为<span class="jill"></span>4，那么服务器最多能同时执行<span class="jill"></span>4<span class="jill"></span>个线程，过多的线程会导致上下文切换反而使得效率降低</span></div></div><div id="sHq1GGodY23QViPMbRidue" class="wolai-block wolai-text"><div><span class="inline-wrap">此时线程池的最大线程数可以配置为<span class="jill"></span>CPU<span class="jill"></span>核心数<span class="jill"></span>+1</span></div></div><div id="ovjThsC7nSjWfwt7Mn8H5o" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="dYcYUWvWdBQT5D8oByUaHi" class="wolai-block"><span class="wolai-serial-number">4.2.2.2</span><span class="inline-wrap">I/O<span class="jill"></span>密集型</span></h4><div id="cPZ2umo9X1StxcJL21ehM4" class="wolai-block wolai-text"><div><span class="inline-wrap">主要进行<span class="jill"></span>I/O<span class="jill"></span>操作，执行<span class="jill"></span>I/O<span class="jill"></span>操作时间长，在<span class="jill"></span>I/O<span class="jill"></span>过程中<span class="jill"></span>CPU<span class="jill"></span>处于空闲状态导致<span class="jill"></span>CPU<span class="jill"></span>利用率不高</span></div></div><div id="twvaH8DuFXAXDL3SQ2tR94" class="wolai-block wolai-text"><div><span class="inline-wrap">这种情况可以增加线程池中线程数量的大小，具体增加多少可以结合线程的等待时长来判断，等待时间越长，线程数可以相对越多</span></div></div><div id="3Mn7oLqPBLhXUZS5ydSuE4" class="wolai-block wolai-text"><div><span class="inline-wrap">一般可以配置<span class="jill"></span>CPU<span class="jill"></span>核心数的两倍</span></div></div><blockquote id="5mSqY9TeX1rgg8d8FpSmuh" class="wolai-block"><span class="inline-wrap">补充：其实我们平时写的常规业务都是<span class="jill"></span>I/O<span class="jill"></span>密集型。前端发送过来一个请求，Java<span class="jill"></span>代码需要计算的不多，大部分时间是在等待<span class="jill"></span>Redis、MySQL、ElasticSearch<span class="jill"></span>通过网络传输返回结果</span></blockquote><div id="mcFV6T1AXU6aDPjLGVBVMx" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jikAZdBxHXTc7Q6ieoJ95s" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">常见线程安全的并发容器有哪些？</span></h1><ul class="wolai-block"><li id="q9L1FUYiYWB6xjmop1ZBPr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Set<span class="jill"></span>集合：CopyOnWriteArraySet（写时复制技术）</span></li><li id="2XNPyQzia78tdBbekEdshc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">List<span class="jill"></span>集合：CopyOnWriteArrayList（写时复制技术）</span></li><li id="3et4FeJBG2Vhzsrfr1a7oP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Map<span class="jill"></span>集合：ConcurrentHashMap</span><ul class="wolai-block"><li id="oss4AHDfT2yk2MsQsF1Gj2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK1.7：采用了锁分段（Segment）技术来提高并发性能，每个段（Segment）相当于一个独立的哈希表，并且每个段都有自己的锁，这样可以减少锁的竞争</span></li><li id="5V5hyk4RcxWWtViLbntzUe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK1.8：设计进行了优化，不再使用分段锁（Segment），而是采用了<span class="jill"></span>CAS（Compare and Swap）操作和<span class="jill"></span>synchronized<span class="jill"></span>关键字相结合的方式来实现线程安全，它使用了更细粒度的锁机制，即在链表或红黑树的节点上使用<span class="jill"></span>synchronized<span class="jill"></span>锁，同时对于一些非竞争性的操作则采用<span class="jill"></span>CAS<span class="jill"></span>来保证原子性，从而进一步提高了并发性能</span></li></ul></li></ul><div id="iQBbUngN4QY4SJaCwutDGm" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="9bNKriKjs6ds2svswD26E6" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">Atomic<span class="jill"></span>原子类了解多少？原理是什么？</span></h1><h2 id="4eXvnmnja2e8sgExi77Gjh" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">概述</span></h2><div id="oc9QK5AwWK3whKxs8YGAJy" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的<span class="jill"></span>java.util.concurrent.atomic<span class="jill"></span>包提供了一组原子类，用于在多线程环境中执行原子操作，而无需使用显式的锁。</span></div></div><div id="bfsi7qGyzv6AdGQRdJeR4s" class="wolai-block wolai-text"><div><span class="inline-wrap">这些原子类使用特殊的<span class="jill"></span>CPU<span class="jill"></span>指令来确保操作的原子性，从而避免了使用锁带来的性能开销。</span></div></div><div id="uexYhV858gvw5JdvHXRRvm" class="wolai-block wolai-text"><div><span class="inline-wrap">这些原子类的实现依赖于底层硬件架构提供的原子操作指令。</span></div></div><div id="9rszFjxXKVWPizuX7baUFo" class="wolai-block wolai-text"><div><span class="inline-wrap">通常，这些指令在现代处理器上是硬件级别的支持，确保对内存的读写是原子的。</span></div></div><div id="q6txVwGyhVinh3iaKCVaRm" class="wolai-block wolai-text"><div><span class="inline-wrap">这使得在不使用锁的情况下，可以在多线程环境中执行某些操作，而不会导致竞态条件（race conditions）。</span></div></div><div id="hmES3bYF19v9euah5Pcb1e" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3Uzzrcf8WjifGqyyXEazdf" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">分别说明</span></h2><div id="wDBY2hAEv8epXgm3zN5Tkx" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一些常见的<span class="jill"></span>java.util.concurrent.atomic<span class="jill"></span>包中的原子类以及它们的一些实现原理：</span></div></div><div id="UJzcFqms5FXoMs26Uddxs" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9d3gx5WvJdW2UzdNLvoX76" class="wolai-block"><span class="wolai-serial-number">6.2.1</span><span class="inline-wrap">AtomicInteger、AtomicLong、AtomicReference</span></h3><div id="bTC5demmV5fAWsdQuyTn7z" class="wolai-block wolai-text"><div><span class="inline-wrap">这些类使用<span class="jill"></span>compareAndSet（CAS）操作实现原子性。</span></div></div><div id="arDdePvLqrF7BHcPEWDk1P" class="wolai-block wolai-text"><div><span class="inline-wrap">CAS<span class="jill"></span>是一种乐观锁定机制，它尝试原子地将一个值更新为新值，但只有在当前值等于预期值时才成功；否则，它会重新尝试。</span></div></div><div id="3tnUSSZUNkohoEL1RuiYWf" class="wolai-block wolai-text"><div><span class="inline-wrap">CAS<span class="jill"></span>操作是由处理器提供的原子性操作指令支持的。</span></div></div><div id="8e9K3Jd8aoozPNdaCWNwYq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="d87Nf4zM2DX8aTzS56G11Z" class="wolai-block"><span class="wolai-serial-number">6.2.2</span><span class="inline-wrap">AtomicBoolean</span></h3><div id="9FSm6NVqPSqMLw4sPWRx1K" class="wolai-block wolai-text"><div><span class="inline-wrap">AtomicBoolean<span class="jill"></span>类使用<span class="jill"></span>compareAndSet<span class="jill"></span>实现。</span></div></div><div id="7SfLE1rE56R5R77yWbcdXB" class="wolai-block wolai-text"><div><span class="inline-wrap">compareAndSet<span class="jill"></span>的实现通常依赖于底层处理器的<span class="jill"></span>CAS<span class="jill"></span>指令。</span></div></div><div id="is5sQhGsYxGHDfxqvdzhQu" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="hN2on3QPy8Cn1Hjs9Px3pf" class="wolai-block"><span class="wolai-serial-number">6.2.3</span><span class="inline-wrap">AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</span></h3><div id="i64H9i5PMWR6LgpuZiopGT" class="wolai-block wolai-text"><div><span class="inline-wrap">这些类提供了对数组元素的原子性访问。</span></div></div><div id="xtDpway2BYJURxXC2NFn2o" class="wolai-block wolai-text"><div><span class="inline-wrap">它们也使用<span class="jill"></span>CAS<span class="jill"></span>操作，但应用于数组的特定位置。</span></div></div><div id="7NcB8q1s5gUTCtrpNqfCB9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9pKCmzWJoQyv1V1Uhfn6n3" class="wolai-block"><span class="wolai-serial-number">6.2.4</span><span class="inline-wrap">AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</span></h3><div id="wZu3P8MqLxRWbDNsuT4117" class="wolai-block wolai-text"><div><span class="inline-wrap">这些类提供了对对象字段的原子性更新。</span></div></div><div id="bMz6zLoPQeosuVZPTtZ3gB" class="wolai-block wolai-text"><div><span class="inline-wrap">它们使用了反射和<span class="jill"></span>CAS<span class="jill"></span>操作来实现。</span></div></div><div id="9uuKpcbRd7yqTF54yR488S" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="aCTWs13ihm29fbXiPZbA8Y" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">synchronized<span class="jill"></span>底层实现是什么？Lock<span class="jill"></span>底层是什么？有什么区别？</span></h1><h2 id="4Vh4ogkr7N2A4FbSmCerBM" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">synchronized<span class="jill"></span>原理</span></h2><h3 id="qLdxabB5Vo2c8iW5vXMQZa" class="wolai-block"><span class="wolai-serial-number">7.1.1</span><span class="inline-wrap">同步方法</span></h3><div id="up3bJfEh78so18CDtdwzne" class="wolai-block wolai-text"><div><span class="inline-wrap">方法级的同步是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。</span></div></div><div id="dZbMsJFiVkfgYkpY1rwq8U" class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>可以从方法常量池中的方法表结构（</span><span class="inline-wrap">method_info Structure</span><span class="inline-wrap">）中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</span></div></div><div id="tpzFoXDpKRdmrCBaJpMbMD" class="wolai-block wolai-text"><div><span class="inline-wrap">当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有<span class="jill"></span>monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成（</span><span class="inline-wrap">无论是正常完成还是非正常完成</span><span class="inline-wrap">）时释放<span class="jill"></span>monitor。</span></div></div><div id="nu6yLuKXviLZ8y2dHsdShJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="idTqWaeA7A9RRCv4WAbovs" class="wolai-block"><span class="wolai-serial-number">7.1.2</span><span class="inline-wrap">同步代码块</span></h3><div id="goDRDtqziobHo4JdudXncW" class="wolai-block wolai-text"><div><span class="inline-wrap">代码块的同步是利用<span class="jill"></span>monitorenter<span class="jill"></span>和<span class="jill"></span>monitorexit<span class="jill"></span>这两个字节码指令。它们分别位于同步代码块的开始和结束位置。</span></div></div><div id="7nbTRjqf3PawL2LEN5e3br" class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>JVM<span class="jill"></span>执行到<span class="jill"></span>monitorenter<span class="jill"></span>指令时，当前线程试图获取<span class="jill"></span>monitor<span class="jill"></span>对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器<span class="jill"></span>+1；</span></div></div><div id="bMe2VN3qsqfYL9H6yaF8hg" class="wolai-block wolai-text"><div><span class="inline-wrap">当执行<span class="jill"></span>monitorexit<span class="jill"></span>指令时，锁计数器-1；</span></div></div><div id="ksBNTRPAxjxAme7g1uet2f" class="wolai-block wolai-text"><div><span class="inline-wrap">当锁计数器为<span class="jill"></span>0<span class="jill"></span>时，该锁就被释放了。</span></div></div><div id="jaNbQpFFga2D5be7XDDW2o" class="wolai-block wolai-text"><div><span class="inline-wrap">如果获取<span class="jill"></span>monitor<span class="jill"></span>对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</span></div></div><div id="hTiybK2cmQoqRH5pY6tgdb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bcDNhFvL216EJg5KQ6h5Nt" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">Lock<span class="jill"></span>原理</span></h2><div id="vZ4EQFT11sNRwMPkJrgKjF" class="wolai-block wolai-text"><div><span class="inline-wrap">Lock<span class="jill"></span>的存储结构：一个<span class="jill"></span>int<span class="jill"></span>类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</span></div></div><div id="mf54KdTW8VxLpotpQ1Psbf" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="p3j6EryvQtfntsCx7baeyG" class="wolai-block"><span class="wolai-serial-number">7.2.1</span><span class="inline-wrap">Lock<span class="jill"></span>获取锁的过程</span></h3><div id="do5MeJgJ4i4zs5wiALb2GR" class="wolai-block wolai-text"><div><span class="inline-wrap">本质上是通过<span class="jill"></span>CAS<span class="jill"></span>来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</span></div></div><div id="eW8st4nPY4ojaQ96f1SroF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="gQWrBHdJ4nGutYzPWNFUt1" class="wolai-block"><span class="wolai-serial-number">7.2.2</span><span class="inline-wrap">Lock<span class="jill"></span>释放锁的过程</span></h3><div id="64mziUMMrEBa52RHKWu2tU" class="wolai-block wolai-text"><div><span class="inline-wrap">修改状态值，调整等待链表。Lock<span class="jill"></span>大量使用<span class="jill"></span>CAS+<span class="jill"></span>自旋。因此根据<span class="jill"></span>CAS<span class="jill"></span>特性，Lock<span class="jill"></span>建议使用在低锁冲突的情况下。</span></div></div><div id="nYzTBSU3759ecHn2LtvcuK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hDZRtzyQZybEURUsFNTU6f" class="wolai-block"><span class="wolai-serial-number">7.3</span><span class="inline-wrap">Lock<span class="jill"></span>与<span class="jill"></span>synchronized<span class="jill"></span>的区别</span></h2><div id="uHyiheWHo2HDGaDqeEXB5Z" class="wolai-block wolai-text"><div><span class="inline-wrap">Lock<span class="jill"></span>的加锁和解锁都是由<span class="jill"></span>Java<span class="jill"></span>代码配合<span class="jill"></span>native<span class="jill"></span>方法（调用操作系统的相关方法）实现的，而<span class="jill"></span>synchronized<span class="jill"></span>的加锁和解锁的过程是由<span class="jill"></span>JVM<span class="jill"></span>管理的。</span></div></div><h3 id="kLAnSbgU1WBAHvunPjy1yR" class="wolai-block"><span class="wolai-serial-number">7.3.1</span><span class="inline-wrap">阻塞机制</span></h3><ul class="wolai-block"><li id="hpWC4CxuwDKChqrwau1d7Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当一个线程使用<span class="jill"></span>synchronized<span class="jill"></span>获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。</span></li><li id="ufhFbZbbXtm2AiUkfiCU2d"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Lock<span class="jill"></span>则提供超时锁和可中断等更加灵活的方式，在未能获取锁的条件下提供一种退出的机制。</span></li></ul><div id="xqfEKXzWdYgTtgdj4LaPHG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="emkzer6N1Pdw68zv32pGtg" class="wolai-block"><span class="wolai-serial-number">7.3.2</span><span class="inline-wrap">锁占有模式</span></h3><ul class="wolai-block"><li id="8w1aJyt53Y9x7fUB9o6Df1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">synchronized<span class="jill"></span>对线程的同步仅提供独占模式，</span></li><li id="mXy6oMZYsNVh1FEYos6VtJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Lock<span class="jill"></span>既可以提供独占模式，也可以提供共享模式</span></li></ul><div id="onXRbfhF51cuNQ6kd131wN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2iCLM6sttR56NQA3UJcF1S" class="wolai-block"><span class="wolai-serial-number">7.3.3</span><span class="inline-wrap">条件队列</span></h3><div id="jeZLkMq6JDpCSKhPZcJGjw" class="wolai-block wolai-text"><div><span class="inline-wrap">一个锁内部可以有多个<span class="jill"></span>Condition<span class="jill"></span>实例，即有多路条件队列，而<span class="jill"></span>synchronized<span class="jill"></span>只有一路条件队列</span></div></div><div id="9oxT7AH79vhxj7aXULLW1B" class="wolai-block wolai-text"><div><span class="inline-wrap">同样<span class="jill"></span>Condition<span class="jill"></span>也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以及设置等待时限等方式退出条件队列。</span></div></div><div id="T838dr4yzd7LLnfpzbcJn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="47xKWyPz4RcZRyeuR8wSmt" class="wolai-block"><span class="wolai-serial-number">7.3.4</span><span class="inline-wrap">总结</span></h3><span class="inline-wrap"></span><br/><div id="iDATj6AiG3L67hvs4Udw2Z" class="wolai-block wolai-text"><div><span class="inline-wrap">synchronized</span></div></div><span class="inline-wrap"></span><br/><div id="ww88enjV1UvtLdi4d8tSF" class="wolai-block wolai-text"><div><span class="inline-wrap">Lock</span></div></div><span class="inline-wrap"></span><br/><div id="6z2Eo4NDJvQemUxhrjApbF" class="wolai-block wolai-text"><div><span class="inline-wrap">关键字</span></div></div><span class="inline-wrap"></span><br/><div id="rG7fFz5b2epjFMV9pcaQbZ" class="wolai-block wolai-text"><div><span class="inline-wrap">接口/类</span></div></div><span class="inline-wrap"></span><br/><div id="31AdgEwVMAV9KoB1WZyyvh" class="wolai-block wolai-text"><div><span class="inline-wrap">自动加锁和释放锁</span></div></div><span class="inline-wrap"></span><br/><div id="7eJ9hbLnGYKiqo9Vg8RVZh" class="wolai-block wolai-text"><div><span class="inline-wrap">需要手动调用<span class="jill"></span>unlock()方法释放锁</span></div></div><span class="inline-wrap"></span><br/><div id="aB1nJa6G8ALUme4uAz9YJ" class="wolai-block wolai-text"><div><span class="inline-wrap">JVM<span class="jill"></span>层面的锁</span></div></div><span class="inline-wrap"></span><br/><div id="m16r2SxcKzoGzhy42rjkbY" class="wolai-block wolai-text"><div><span class="inline-wrap">API<span class="jill"></span>层面的锁</span></div></div><span class="inline-wrap"></span><br/><div id="6j7AhVoGEm1QNixDsJLXys" class="wolai-block wolai-text"><div><span class="inline-wrap">非公平锁</span></div></div><span class="inline-wrap"></span><br/><div id="mgMzQdQSzgEeSsUBG6cBdE" class="wolai-block wolai-text"><div><span class="inline-wrap">可以选择公平或者非公平锁</span></div></div><span class="inline-wrap"></span><br/><div id="j7o7giLSdshpQUVk26Pb5C" class="wolai-block wolai-text"><div><span class="inline-wrap">锁是一个对象，并且锁的信息保存在了对象中</span></div></div><span class="inline-wrap"></span><br/><div id="iV8Erqm2w9b3z7xVe5aj6J" class="wolai-block wolai-text"><div><span class="inline-wrap">代码中通过<span class="jill"></span>int<span class="jill"></span>类型的<span class="jill"></span>state<span class="jill"></span>标识</span></div></div><span class="inline-wrap"></span><br/><div id="by2RqqGnSt4ydisAjcE17D" class="wolai-block wolai-text"><div><span class="inline-wrap">有一个锁升级的过程</span></div></div><span class="inline-wrap"></span><br/><div id="7webgPYLB78hrG6E9vuRRU" class="wolai-block wolai-text"><div><span class="inline-wrap">无</span></div></div><div id="vTNZduxKQyKgq9hYxDFydm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="pcAFtXyz8ZzZteuWh6eZha" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><div id="9EY61yTgSiNqiYA4osj8aE" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>