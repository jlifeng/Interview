<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>Java核心语法（底线必会） - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="Java核心语法（底线必会）" class="main-title"></div></div></header><article><h1 id="pbgsJYgEVgavBKqEDWQKJ1" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">写出<span class="jill"></span>Java<span class="jill"></span>的四类八种基本数据类型</span></h1><h2 id="qDTvQi482iUdZw9ZKvcchM" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">背会：</span></h2><div id="hJtEpRDofprmA6CmqqqF2b" class="wolai-block wolai-text"><div><span class="inline-wrap">四类：整数型、浮点型、字符型和布尔型</span></div></div><div id="uFZpEXoMJcYqP4WawfAa4z" class="wolai-block wolai-text"><div><span class="inline-wrap">八种：byte、short、int、long、float、double、char、boolean</span></div></div><div id="uQWG6PyMHc6PdEZU5toTsL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mPS1jWPRnZUEbLJihW9ZaP" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">理解：</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="eyd8DBFPZHTDQKzzcoVSGe" class="wolai-block wolai-text"><div><span class="inline-wrap">类别</span></div></div><span class="inline-wrap"></span><br/><div id="vmGnt7wg4L7PjvAPjF8UQP" class="wolai-block wolai-text"><div><span class="inline-wrap">整数型</span></div></div><span class="inline-wrap"></span><br/><div id="4SmQKjarCD19gnNfMgLpFF" class="wolai-block wolai-text"><div><span class="inline-wrap">整数型</span></div></div><span class="inline-wrap"></span><br/><div id="d53aL3hnr4B5aGKDcG8Pb7" class="wolai-block wolai-text"><div><span class="inline-wrap">整数型</span></div></div><span class="inline-wrap"></span><br/><div id="jx8GyeUGh6ubAmMneKLv5P" class="wolai-block wolai-text"><div><span class="inline-wrap">数据类型</span></div></div><span class="inline-wrap"></span><br/><div id="219SuoHQkFXTsD1hefkygN" class="wolai-block wolai-text"><div><span class="inline-wrap">byte</span></div></div><span class="inline-wrap"></span><br/><div id="hLpjef7j9pEoacyFM2AKSN" class="wolai-block wolai-text"><div><span class="inline-wrap">short</span></div></div><span class="inline-wrap"></span><br/><div id="tZoXLpZTydwL4fm9UvPJ5X" class="wolai-block wolai-text"><div><span class="inline-wrap">int</span></div></div><span class="inline-wrap"></span><br/><div id="fiXrpWaXoexHzZJnMyJvvY" class="wolai-block wolai-text"><div><span class="inline-wrap">占用字节</span></div></div><span class="inline-wrap"></span><br/><div id="mK9cPao4HjaaGXzDQ2RcN9" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="tJdj1ZeH2ep7BaLDSvGyFd" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="pELZNSyjcZGuoXAMU4oyMQ" class="wolai-block wolai-text"><div><span class="inline-wrap">4</span></div></div><span class="inline-wrap"></span><br/><div id="3DxdA2DXdjLdpu1C4fCj3e" class="wolai-block wolai-text"><div><span class="inline-wrap">取值范围</span></div></div><span class="inline-wrap"></span><br/><div id="oDN1axPCNECXPT6RHedD1Y" class="wolai-block wolai-text"><div><span class="inline-wrap">-128 到 127</span></div></div><span class="inline-wrap"></span><br/><div id="3CQXBVjBzPderRh1qDUZaV" class="wolai-block wolai-text"><div><span class="inline-wrap">-32,768 到 32,767</span></div></div><span class="inline-wrap"></span><br/><div id="jbs4xZpsg5t5Fu56mEYNgb" class="wolai-block wolai-text"><div><span class="inline-wrap">-2^31 到 2^31-1</span></div></div><span class="inline-wrap"></span><br/><div id="x6zxYUJiQRM7vaeqoU2tB3" class="wolai-block wolai-text"><div><span class="inline-wrap">整数型</span></div></div><span class="inline-wrap"></span><br/><div id="5SnLe6NbZnxvPBtDVvTzM" class="wolai-block wolai-text"><div><span class="inline-wrap">long</span></div></div><span class="inline-wrap"></span><br/><div id="5YLjjZ6XHCycChbMWYTTEN" class="wolai-block wolai-text"><div><span class="inline-wrap">8</span></div></div><span class="inline-wrap"></span><br/><div id="jy6uzCk31rn6gQW3xFeQUK" class="wolai-block wolai-text"><div><span class="inline-wrap">-2^63 到 2^63-1</span></div></div><span class="inline-wrap"></span><br/><div id="d92zF2r6mBJ1hmbPnTf55b" class="wolai-block wolai-text"><div><span class="inline-wrap">浮点型</span></div></div><span class="inline-wrap"></span><br/><div id="w269esYRE3LeespEP3BtCg" class="wolai-block wolai-text"><div><span class="inline-wrap">float</span></div></div><span class="inline-wrap"></span><br/><div id="7bBq5oJJpKh7nQnauWoiS1" class="wolai-block wolai-text"><div><span class="inline-wrap">4</span></div></div><span class="inline-wrap"></span><br/><div id="sEUo1SYmCuwMLjEGcGkiFU" class="wolai-block wolai-text"><div><span class="inline-wrap">1.4E-45 到 3.4028235E38</span></div></div><span class="inline-wrap"></span><br/><div id="9jsyUaFhctjE5j4FvXoMfJ" class="wolai-block wolai-text"><div><span class="inline-wrap">浮点型</span></div></div><span class="inline-wrap"></span><br/><div id="3E1ttxBUXeo1Crgh7Xi9nH" class="wolai-block wolai-text"><div><span class="inline-wrap">double</span></div></div><span class="inline-wrap"></span><br/><div id="9Y7fnx53Vy6w4zvY4xk27y" class="wolai-block wolai-text"><div><span class="inline-wrap">8</span></div></div><span class="inline-wrap"></span><br/><div id="mp73hDzzGmmyH5Dj8M6Ta4" class="wolai-block wolai-text"><div><span class="inline-wrap">4.9E-324 到 1.7976931348623157E308</span></div></div><span class="inline-wrap"></span><br/><div id="rLT63vFAZubyDqzF2DoKn2" class="wolai-block wolai-text"><div><span class="inline-wrap">字符型</span></div></div><span class="inline-wrap"></span><br/><div id="gEPwAbPmMj1k1tSNAapazJ" class="wolai-block wolai-text"><div><span class="inline-wrap">char</span></div></div><span class="inline-wrap"></span><br/><div id="b5xUPzYPKERndVargCbqge" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="jrbWzuhXSxG5VfFp5toTPT" class="wolai-block wolai-text"><div><span class="inline-wrap"> &#39;u0000&#39;（0）到 &#39;\uffff&#39;（65,535）</span></div></div><span class="inline-wrap"></span><br/><div id="dMjjGfni4bD4eEmt59h43S" class="wolai-block wolai-text"><div><span class="inline-wrap">布尔型</span></div></div><span class="inline-wrap"></span><br/><div id="ws6SAQJsvVq5hhEsdeBNb4" class="wolai-block wolai-text"><div><span class="inline-wrap">boolean</span></div></div><span class="inline-wrap"></span><br/><div id="wSLfAqiLNhctCi49q2pSfw" class="wolai-block wolai-text"><div><span class="inline-wrap">特殊</span></div></div><span class="inline-wrap"></span><br/><div id="vgbw12FFbYyywJeEyTx74e" class="wolai-block wolai-text"><div><span class="inline-wrap">true<span class="jill"></span>和<span class="jill"></span>false</span></div></div><div id="gt5htBydEMLbnwoxp1YvnX" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，上述表格中的取值范围指的是数据类型的默认取值范围。</span></div></div><div id="6KuobudowhNTpaC4FGVNP6" class="wolai-block wolai-text"><div><span class="inline-wrap">对于整数型和浮点型，Java<span class="jill"></span>使用补码形式表示负数，而对于布尔型，它只有两个可能的值：true<span class="jill"></span>和<span class="jill"></span>false。</span></div></div><div id="iGBaTeVyeMWN8cJu9AymmN" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，char<span class="jill"></span>类型用于表示单个的<span class="jill"></span>Unicode<span class="jill"></span>字符，它的实际存储大小是<span class="jill"></span>16<span class="jill"></span>位，即<span class="jill"></span>2<span class="jill"></span>个字节，能够表示的字符范围从&#39;\u0000&#39;到&#39;\uffff&#39;。</span></div></div><div id="i5agurFA6btkzQsFKTEvzf" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oJYXCBdXe2ssYz1Eyo2VBU" class="wolai-block"><span class="wolai-serial-number">1.3</span><span class="inline-wrap">boolean<span class="jill"></span>类型的特殊说明</span></h2><h3 id="6AqZMbubuLt885n29Smqhx" class="wolai-block"><span class="wolai-serial-number">1.3.1</span><span class="inline-wrap">单独使用时</span></h3><div id="mCTg7B4y57UFFRxvCefM1M" class="wolai-block wolai-text"><div><span class="inline-wrap">boolean 类型数据在内存中占用<span class="jill"></span>4<span class="jill"></span>个字节。这是因为<span class="jill"></span>Java<span class="jill"></span>虚拟机（JVM）将单独的 boolean 值当作 int 类型来处理，而 int 类型在<span class="jill"></span>Java<span class="jill"></span>中占用<span class="jill"></span>4<span class="jill"></span>个字节。</span></div></div><div id="bL5iAxYtxeHN8mm255vtU7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3LPsb8kmP3NswWuxvFsPKe" class="wolai-block"><span class="wolai-serial-number">1.3.2</span><span class="inline-wrap">放在数组中</span></h3><div id="f6hVqx35stM9StYQNLJMD5" class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>boolean<span class="jill"></span>类型以数组的形式出现时，每个<span class="jill"></span>boolean<span class="jill"></span>元素在内存中占用<span class="jill"></span>1<span class="jill"></span>个字节。</span></div></div><div id="gDinmUuo9MPL5V9AoZPc82" class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为在<span class="jill"></span>JVM<span class="jill"></span>规范中，boolean<span class="jill"></span>数组被编码为字节数组，每个元素使用<span class="jill"></span>8<span class="jill"></span>位即<span class="jill"></span>1<span class="jill"></span>个字节来表示，其中使用<span class="jill"></span>1<span class="jill"></span>代表 true ，0<span class="jill"></span>代表 false 。</span></div></div><div id="9NXty1pMWEekWdcD4QZpX3" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="jVNJ94k8ZaqwMrWXEC5GJf" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">&amp; 和 &amp;&amp; 的区别</span></h1><h2 id="nUUbv6cCvURxBmzXffwKCJ" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">背会</span></h2><div id="tZNE8FJTvGgFbPacZh49FU" class="wolai-block wolai-text"><div><span class="inline-wrap">在进行逻辑运算时，&amp;没有短路效果，&amp;&amp;有短路效果</span></div></div><ul class="wolai-block"><li id="sPjzjdQ3hJ3LdwkWMmHHAk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">左边表达式 &amp; 右边表达式：即使左边表达式计算结果为<span class="jill"></span>false<span class="jill"></span>可以推断出整体结果，但仍然会执行右边表达式</span></li><li id="cicuv4koexuphgq8muJP8L"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">左边表达式 &amp;&amp; 右边表达式：如果左边表达式计算结果为<span class="jill"></span>false<span class="jill"></span>可以推断出整体结果，所以右边表达式将不再执行，提高代码执行效率</span></li></ul><div id="Zh1NUN9idikxtwZnRqLXT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="iPwZ4VywTsbMDyhYQ55S35" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">&amp;运算符可以计算的数据类型</span></h2><h3 id="o5xutDo5ij55LyThwgkknd" class="wolai-block"><span class="wolai-serial-number">2.2.1</span><span class="inline-wrap">整数类型</span></h3><ul class="wolai-block"><li id="pumEZJnP18Kf6wy3EzKY4Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">byte
</span></li><li id="xBug2ekevZ3ayFWiaw8TNE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">short
</span></li><li id="hzkN2cmYiPyCFzbNfahXvF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">int
</span></li><li id="ubSpAegEN2cWK2jgY2wbsX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">long
</span></li></ul><div id="qKN9qwmGaLWUoxomAP5K2q" class="wolai-block wolai-text"><div><span class="inline-wrap">对于这些类型，&amp;执行按位与操作，即对两个操作数的二进制位逐位进行逻辑与运算。</span></div></div><div id="ubgJcrQ5tRNMLvjYJx6KDB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="crJoVkD7xTXthR2PbVmCA" class="wolai-block"><span class="wolai-serial-number">2.2.2</span><span class="inline-wrap">布尔类型</span></h3><div id="xdPfsay6kX3rAbY8DUSbpQ" class="wolai-block wolai-text"><div><span class="inline-wrap">当用于布尔表达式时，&amp;操作符执行逻辑与操作，只有当两边的操作数都为<span class="jill"></span>true<span class="jill"></span>时结果才为<span class="jill"></span>true。注意，这里的&amp;通常用在表达式中而不是直接对<span class="jill"></span>boolean<span class="jill"></span>变量操作。</span></div></div><div id="6KS2iC5X6BVdB4y4AQoWBF" class="wolai-block wolai-text"><div><span class="inline-wrap">此时整个表达式没有短路效果，即使&amp;号左边是<span class="jill"></span>false<span class="jill"></span>已经能够推断出整体结果，但还是会对后续表达式进行计算</span></div></div><div id="338QStW9vWcoJWc9oQKqr6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="gGpkJ8XdmJj8A1eqorCnjt" class="wolai-block"><span class="wolai-serial-number">2.2.3</span><span class="inline-wrap">字符类型</span></h3><div id="evWr2hf6tSBV4NEv2v7kPv" class="wolai-block wolai-text"><div><span class="inline-wrap">虽然<span class="jill"></span>char<span class="jill"></span>本质上是一个整数类型（Unicode<span class="jill"></span>值），但是直接对<span class="jill"></span>char<span class="jill"></span>类型使用按位与操作并不常见，除非特别需要处理字符的二进制位。</span></div></div><div id="h6DYaAxrNxXd1GF7hUzkPa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="uZhvpE6td7ADhxuMzog6qD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qNKaruR9Tcb1Acv9CX7ogi" class="wolai-block"><span class="wolai-serial-number">2.3</span><span class="inline-wrap">应用场景</span></h2><div id="f8dkkwQmcYo2T3TdSTkkXu" class="wolai-block wolai-text"><div><span class="inline-wrap">位运算时使用&amp;这不必多说什么，逻辑运算符通常肯定是使用&amp;&amp;，除非右边表达式必须执行：</span></div></div><code-block id="wKw12V5kDLLVw87gK6yRhW" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> number <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 假设这里必须给b变量赋值，那么右边表达式就一定要执行</pre></div></code-block><div id="7EaKVkUExqbeiLKkdMduVP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="jptyvXBCrDXwjYkf9Tb6KR" class="wolai-block"><span class="wolai-serial-number">2.4</span><span class="inline-wrap">优先级</span></h2><div id="t85wFRPnebo76w3Zvb945M" class="wolai-block wolai-text"><div><span class="inline-wrap">&amp;&amp;比&amp;优先级高，如果出现在同一个表达式中，先执行&amp;&amp;的计算</span></div></div><code-block id="gvEUhFUjSJX84hgBYaxsQk" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
 参照如下代码示例，证明二者优先级：</pre></div></code-block><div id="tGD3jezXdTtfB5vXcUPwxx" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="gUmEUhjueeJXrWnd7NuvT2" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">switch<span class="jill"></span>的参数可以是什么类型</span></h1><h2 id="3RwGjzy4zyjN2LARjqccGc" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背会</span></h2><div id="6oqCyaxoGUgCcAM6qop9Gk" class="wolai-block wolai-text"><div><span class="inline-wrap">byte，short，int，char，String，枚举</span></div></div><div id="pdG5zHrNR6TK94umAhNVB7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hq3eR9MYJGgjJzQxk6XEHT" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">理解</span></h2><div id="3a5dJeKMTP8r6ay8yuPNw7" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中<span class="jill"></span>switch<span class="jill"></span>语句的参数类型取决于你使用的<span class="jill"></span>JDK<span class="jill"></span>版本。具体如下：</span></div></div><h3 id="35ZMzWcHULE2VGVoDgLvGJ" class="wolai-block"><span class="wolai-serial-number">3.2.1</span><span class="inline-wrap">JDK1.6<span class="jill"></span>及以前版本</span></h3><div id="oMAyqodKXPogsBbdaw1JT" class="wolai-block wolai-text"><div><span class="inline-wrap">在这些版本中，switch<span class="jill"></span>语句的参数可以是基本数据类型<span class="jill"></span>int、byte、short<span class="jill"></span>和<span class="jill"></span>char，以及它们的包装类<span class="jill"></span>Integer、Byte、Short<span class="jill"></span>和<span class="jill"></span>Character 。由于<span class="jill"></span>byte、short<span class="jill"></span>和<span class="jill"></span>char<span class="jill"></span>可以自动转换为<span class="jill"></span>int，因此它们也可以作为<span class="jill"></span>switch<span class="jill"></span>的参数。此外从<span class="jill"></span>JDK1.5<span class="jill"></span>开始，switch<span class="jill"></span>还支持枚举类型<span class="jill"></span>enum。</span></div></div><div id="9M9tjiXf2YKQzRd3DBYVnW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="q3GZpBxySnhS6aerygopxb" class="wolai-block"><span class="wolai-serial-number">3.2.2</span><span class="inline-wrap">JDK 1.7<span class="jill"></span>及以后版本</span></h3><div id="5dAvMXd2s74zL5sYXkp6vZ" class="wolai-block wolai-text"><div><span class="inline-wrap">从<span class="jill"></span>JDK 1.7<span class="jill"></span>开始，switch<span class="jill"></span>语句新增了对<span class="jill"></span>String<span class="jill"></span>类型的支持。</span></div></div><div id="5yxDwTM9hW7oMQgcZAzvXQ" class="wolai-block wolai-text"><div><span class="inline-wrap">这意味着你可以使用字符串作为<span class="jill"></span>switch<span class="jill"></span>的参数，这在之前的版本中是不允许的。</span></div></div><div id="um6m241qByEq76iUoVQoUj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2Bk3jfL9NCRuSojauMUZpm" class="wolai-block"><span class="wolai-serial-number">3.2.3</span><span class="inline-wrap">JDK21<span class="jill"></span>版本</span></h3><div id="7Qrc7Yhj6BZfQ9ycMEaQdC" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK21<span class="jill"></span>中可以使用<span class="jill"></span>Object<span class="jill"></span>类型，然后在各个分支中匹配具体类型</span></div></div><code-block id="98c3CfAyU1TJWnKskhPUoe" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">formatterSwitch</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-></span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"int %d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Long</span> l  <span class="token operator">-></span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"long %d"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Double</span> d <span class="token operator">-></span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"double %f"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s <span class="token operator">-></span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"String %s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span>    <span class="token operator">-></span> o<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="jeZMtCChxMUCXUrwwczbo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4CPHvzsSUoGUXVNLXVUPun" class="wolai-block"><span class="wolai-serial-number">3.2.4</span><span class="inline-wrap">所有版本</span></h3><div id="aAB44aMu9wgpG4oNV24p87" class="wolai-block wolai-text"><div><span class="inline-wrap">在所有版本的<span class="jill"></span>Java<span class="jill"></span>中，switch<span class="jill"></span>语句都不支持<span class="jill"></span>long<span class="jill"></span>类型作为参数。</span></div></div><div id="9TVNyFe3jA2gthJQw15UJb" class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为<span class="jill"></span>long<span class="jill"></span>类型的范围比<span class="jill"></span>int<span class="jill"></span>大，不能自动转换为<span class="jill"></span>int<span class="jill"></span>类型。</span></div></div><div id="24M1ofzkrx56TKsBzw23BU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="hCqUtW3XYeBCCJNbhcGP5u" class="wolai-block"><span class="wolai-serial-number">3.2.5</span><span class="inline-wrap">特殊注意</span></h3><div id="juHUwrPwyow8EcYumatVfz" class="wolai-block wolai-text"><div><span class="inline-wrap">虽然<span class="jill"></span>switch<span class="jill"></span>语句在某些版本中支持<span class="jill"></span>String<span class="jill"></span>和枚举类型，但它本质上仍然只接受<span class="jill"></span>int<span class="jill"></span>类型的参数。</span></div></div><div id="vEC6N6nE7sCBAEAoAz8JYM" class="wolai-block wolai-text"><div><span class="inline-wrap">对于<span class="jill"></span>String<span class="jill"></span>类型，底层实现实际上是使用了字符串的<span class="jill"></span>hashCode()方法，该方法返回一个整数值。</span></div></div><div id="oKKb3d1CWjJSphy4uY18E3" class="wolai-block wolai-text"><div><span class="inline-wrap">对于枚举类型，使用的是<span class="jill"></span>ordinal()方法，该方法返回枚举常量的序号，也是一个整数值。</span></div></div><div id="3AGmWTJ4HmKWbVGyPdKvbo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="akohWVZykJWk7vqkHKj28r" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="wM3VXS2Xj8KC6QgiNMja5M" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">实例变量和局部变量的区别是什么？</span></h1><h2 id="rkyiAKinVKxzpvGRj6ECEN" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">背记</span></h2><h3 id="8Whay1eCrAcRDH8Eh6XDhx" class="wolai-block"><span class="wolai-serial-number">4.1.1</span><span class="inline-wrap">代码位置</span></h3><ul class="wolai-block"><li id="nHZfj2xyDy57RtRN1sH2pR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量：类中方法外</span></li><li id="dPJQuuM8FzFc3N8L3wETRY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">局部变量：方法中或方法定义的小括号里面</span></li></ul><div id="wgTmhRUKcbA5Z1upqghSHb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3qiKUsHsd3geRaMan1zUeH" class="wolai-block"><span class="wolai-serial-number">4.1.2</span><span class="inline-wrap">内存位置</span></h3><ul class="wolai-block"><li id="vSapxu8xehfX9Gkmx67skH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量：作为对象的组成部分，成员变量在堆内存中</span></li><li id="r2i729nY78zr6HKQAPxS51"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">局部变量：作为方法执行过程中的临时数据，通常在栈内存中（栈帧）</span></li></ul><div id="73o4TjSDdRVrhsbteTVkvn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="c2pUJ3Yj1Q2zLyz1ZjVg6L" class="wolai-block"><span class="wolai-serial-number">4.1.3</span><span class="inline-wrap">生命周期</span></h3><ul class="wolai-block"><li id="63EmXzHGESzeh14VdEdYTp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量：作为对象的组成部分，随着对象创建而产生，随着对象的消失而消失</span></li><li id="mZ5tvAuHx896cCtTb3hbLV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">局部变量：作为方法执行过程中的临时数据，随着方法的调用而产生，随着方法调用结束而消失</span></li></ul><div id="r7cfxg7Jwunyy4iAiGMqbC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="aJLmS3drtY6dcNbAWsNJtL" class="wolai-block"><span class="wolai-serial-number">4.1.4</span><span class="inline-wrap">有无默认值</span></h3><ul class="wolai-block"><li id="kd9eLYetzmScqiWPj4msmS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量：有默认值</span></li></ul><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="gXpWhGfXoBGRj2sivnimX6" class="wolai-block wolai-text"><div><span class="inline-wrap">类型</span></div></div><span class="inline-wrap"></span><br/><div id="e6yvFEu9HK9Mbf73eD1AS8" class="wolai-block wolai-text"><div><span class="inline-wrap">基本数据类型中的整数</span></div></div><span class="inline-wrap"></span><br/><div id="fuoaqUaMAZNki4uFkHPEhZ" class="wolai-block wolai-text"><div><span class="inline-wrap">基本数据类型中的</span><span class="inline-wrap">小数</span></div></div><span class="inline-wrap"></span><br/><div id="7PB5U6QvshWdnpuXtPFq3R" class="wolai-block wolai-text"><div><span class="inline-wrap">基本数据类型中的</span><span class="inline-wrap">字符</span></div></div><span class="inline-wrap"></span><br/><div id="myZYuwe5pMhqdtDW3S7cEm" class="wolai-block wolai-text"><div><span class="inline-wrap">默认值</span></div></div><span class="inline-wrap"></span><br/><div id="2482v7QeRENqtM9wKv1sBr" class="wolai-block wolai-text"><div><span class="inline-wrap">0</span></div></div><span class="inline-wrap"></span><br/><div id="dGBXaCjDCsjL9C8dqYvBEi" class="wolai-block wolai-text"><div><span class="inline-wrap">0.0</span></div></div><span class="inline-wrap"></span><br/><div id="dP6KmQ1MDmDxrfrcXUFkFX" class="wolai-block wolai-text"><div><span class="inline-wrap">&#39;\u0000&#39;</span></div></div><span class="inline-wrap"></span><br/><div id="vLS725FYzHuyG6WVzwdrXH" class="wolai-block wolai-text"><div><span class="inline-wrap">基本数据类型中的</span><span class="inline-wrap">布尔</span></div></div><span class="inline-wrap"></span><br/><div id="daBEttvAjimaJPRC6ygzZe" class="wolai-block wolai-text"><div><span class="inline-wrap">false</span></div></div><span class="inline-wrap"></span><br/><div id="bUzwHjb3MgyzK7BaquyvMH" class="wolai-block wolai-text"><div><span class="inline-wrap">引用数据类型</span></div></div><span class="inline-wrap"></span><br/><div id="nrEtMPixS1fwq6P11Bh2sN" class="wolai-block wolai-text"><div><span class="inline-wrap">null</span></div></div><ul class="wolai-block"><li id="7rDygwe5oiccCF7wVPHwwL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">局部变量：没有默认值，使用的时候必须先赋值</span></li></ul><div id="3BUGdAPX37bCLooA8sEwEF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="bDuSEAkB7KkZcYPaHCwTEG" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">理解</span></h2><div id="5xgPiSG2VzbnS1s2gqZnA5" class="wolai-block wolai-text"><div><span class="inline-wrap">实例变量和局部变量是<span class="jill"></span>Java<span class="jill"></span>中两种主要的变量类型，它们在作用范围、生命周期和初始化方面存在显著差异。</span></div></div><h3 id="64NXVjtReZVypouVwLcf51" class="wolai-block"><span class="wolai-serial-number">4.2.1</span><span class="inline-wrap">作用范围</span></h3><div id="kGSTL2ovwgsKMa444gPwYq" class="wolai-block wolai-text"><div><span class="inline-wrap">实例变量是定义在类中，且不在任何方法体内的变量。</span></div></div><div id="6C2yzj77Dj8N7ESsxHwzv1" class="wolai-block wolai-text"><div><span class="inline-wrap">实例变量在对象创建过程中被初始化，在对象使用过程中被读写，它的作用范围在对象内部。</span></div></div><div id="trZAUwCu2q77BgX7mWbFX2" class="wolai-block wolai-text"><div><span class="inline-wrap">基于封装性考虑，实例变量通常不会被对象外部直接读写，规范的做法是通过<span class="jill"></span>getXxx()、setXxx()方法操作。</span></div></div><div id="drWtzWQ5nsMK5ySShXaz9S" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="aGT8E57rrzfWEkiRyv7svL" class="wolai-block wolai-text"><div><span class="inline-wrap">而局部变量是定义在方法体或代码块内的变量，其作用范围仅限于该方法或代码块内部。</span></div></div><div id="3curwtMihZcvj4hDr6DPG7" class="wolai-block wolai-text"><div><span class="inline-wrap">这意味着，一旦方法执行完毕，局部变量就会从内存中消失。</span></div></div><div id="6mcg5kmBAHd5V9x4XKXGhd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iGKfWRRozXGkSPcuDcRtWE" class="wolai-block"><span class="wolai-serial-number">4.2.2</span><span class="inline-wrap">生命周期</span></h3><div id="v9yjGXhVzE282Su618hCfQ" class="wolai-block wolai-text"><div><span class="inline-wrap">实例变量的生命周期与类的实例对象相同，即从对象被创建到被销毁的整个过</span><span class="inline-wrap">程。</span></div></div><div id="28h5pDmxWvAfCtmFbWNC7e" class="wolai-block wolai-text"><div><span class="inline-wrap">局部变量的生命周期则局限于方法的调用过程，即从方法被执行到方法执行完毕的整个过程。</span></div></div><div id="jCBGuQjcmuNZoD8dtXGfi3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="tbhoydw2eVB2dYQCJ2mp1t" class="wolai-block"><span class="wolai-serial-number">4.2.3</span><span class="inline-wrap">初始化</span></h3><div id="jxMpB73uvYNzs5P9QZjZLK" class="wolai-block wolai-text"><div><span class="inline-wrap">实例变量会自动初始化为其对应类型的默认值（如<span class="jill"></span>int<span class="jill"></span>类型为<span class="jill"></span>0），即使没有显式赋</span><span class="inline-wrap">值也是如此。</span></div></div><div id="iMMuMPEXeBFLBUPGruE2WN" class="wolai-block wolai-text"><div><span class="inline-wrap">而局部变量必须经过显式初始化才能使用，否则编译器会报错。</span></div></div><div id="rqEzCQ5w5wjePdLYmmm2QB" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，理解实例变量和局部变量的区别对于编写正确的<span class="jill"></span>Java<span class="jill"></span>代码至关重要。</span></div></div><div id="tNHMPGXKTwGG5oVX84PLrV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="ecgwBE4vLH9GHgvRa9bH8k" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="5fyZoKTaQ9Hf6uP1ff5ykL" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">static<span class="jill"></span>关键字都能修饰什么？ 都有什么特点</span></h1><h2 id="pp1BFDV7Y7nNj1fqLj78uF" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="98YGkrnstTVsT4UJr8LswK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修饰成员变量，使成员变量变成静态的类变量；</span><ul class="wolai-block"><li id="iQiGhCmYZp7f9eg4su9uZd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于类只加载一份，所以静态变量（也叫类变量）也只有一份</span></li><li id="SKJgJPAHVeRbdLaZHeDUd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量可以在一定范围内共享，但具体范围需要参照权限修饰符</span></li></ul></li><li id="pFR4Lcmd31T7RrhuGjo9zC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修饰方法，方法就成了静态方法: 可以直接使用类名.方法名进行调用；</span></li><li id="uytCTWidHfNDjakT24BG1Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修饰代码块，就得到了静态代码块，在类加载过程中执行；</span></li><li id="mgFo4ptYVnKF5gkkaGqgNm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修饰类，只有内部类可以使用<span class="jill"></span>static<span class="jill"></span>修饰，此时内部类变成了静态内部类；</span></li></ul><div id="6bmf3hkdNfGWAu1mwfLdAu" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7CdLYuh2oSSagC4bMoZd34" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">理解</span></h2><div id="9SpFL2LeZryyphRCJaWNMP" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中<span class="jill"></span>static 关键字是一个非常重要的概念，它用于表示一个成员（变量或方法）属于类本身，而不是类的实例对象。</span></div></div><div id="62r12nZmrchawTs2FwNovb" class="wolai-block wolai-text"><div><span class="inline-wrap">具体来说<span class="jill"></span>static<span class="jill"></span>关键字具有以下特点：</span></div></div><h3 id="gcV6pgXnXkwJHaBm2q9E3L" class="wolai-block"><span class="wolai-serial-number">5.2.1</span><span class="inline-wrap">类级属性</span></h3><div id="dpHZ4A2Hv1zBdQsypCqVrw" class="wolai-block wolai-text"><div><span class="inline-wrap">被<span class="jill"></span>static<span class="jill"></span>修饰的成员变量被视为类的属性，它们在类加载时被初始化，并且在整个程序运行期间只占用一块内存空间。</span></div></div><div id="dsPyp4x1RqYTYQW9tqbNfp" class="wolai-block wolai-text"><div><span class="inline-wrap">这意味着，无论你创建多少个类的实例对象，static<span class="jill"></span>成员只有一份拷贝，被所有实例共享。</span></div></div><div id="4unuRmRyKhbfejy3n9GwJe" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="gV8q3oiYb7trywi4rog67Z" class="wolai-block"><span class="wolai-serial-number">5.2.2</span><span class="inline-wrap">无需实例化</span></h3><div id="7ypPaKk61NkTe5MdyPgLb5" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>static<span class="jill"></span>成员属于类，因此你无需创建类的实例对象就可以直接访问它们。</span></div></div><div id="dWJXR3rtzMkXnTYMQj4ENi" class="wolai-block wolai-text"><div><span class="inline-wrap">你可以通过类名直接访问<span class="jill"></span>static<span class="jill"></span>成员，例如<span class="jill"></span>ClassName.staticMethod()或<span class="jill"></span>ClassName.staticVariable。</span></div></div><div id="2aKTLZf1VxCZrgE3zLaCvx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="eFjtCHpjmG1kyuVdZFCzGy" class="wolai-block"><span class="wolai-serial-number">5.2.3</span><span class="inline-wrap">限制访问非静态成员</span></h3><div id="7veoWJv89izcbuUTghP6aJ" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>static<span class="jill"></span>方法在类加载时就存在，因此它们不能访问非静态成员（即实例成员），因为此时实例对象可能尚未创建。</span></div></div><div id="h2X2p7WqdrrTwKzMDe6JHx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5BEo6wbo2tMcaTDt4BYVNz" class="wolai-block"><span class="wolai-serial-number">5.2.4</span><span class="inline-wrap">继承特性</span></h3><div id="qaCxkhLt8xUScMrQtJU2FU" class="wolai-block wolai-text"><div><span class="inline-wrap">与非静态成员不同，子类不会继承父类的<span class="jill"></span>static<span class="jill"></span>成员。如果需要访问父类的<span class="jill"></span>static<span class="jill"></span>成员，可以通过父类的类名直接访问。</span></div></div><div id="cFsVmhCevv95ivFch8qche" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="43nVc6K2KB6RHjdmt9z2S3" class="wolai-block"><span class="wolai-serial-number">5.2.5</span><span class="inline-wrap">默认值</span></h3><div id="cWzMgmQC8wvR6C7RNdFR5Y" class="wolai-block wolai-text"><div><span class="inline-wrap">static<span class="jill"></span>变量有默认值，与实例变量的默认值相同。</span></div></div><div id="oXeDvybsowAftetdEXGNom" class="wolai-block wolai-text"><div><span class="inline-wrap">例如， static int<span class="jill"></span>类型的默认值为<span class="jill"></span>0，static boolean<span class="jill"></span>类型的默认值为 false。</span></div></div><div id="2hocYfsqzoeNi2vVf5c3sd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="siRjD1RDvFGRmwG2UNeBe3" class="wolai-block"><span class="wolai-serial-number">5.2.6</span><span class="inline-wrap">静态代码块</span></h3><div id="9ffUzEiny5ogJyUL3YXz74" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中还支持静态代码块，它仅在类加载时执行一次。</span></div></div><div id="2TnCFcNmpbbqezEgnNb832" class="wolai-block wolai-text"><div><span class="inline-wrap">静态代码块通常用于对静态成员进行初始化操作。</span></div></div><div id="bsQJ7YAVtuFEGhq7Mu6R1N" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，理解<span class="jill"></span>static<span class="jill"></span>关键字是理解<span class="jill"></span>Java<span class="jill"></span>面向对象编程的关键之一。</span></div></div><div id="hLKyQPeP98GL78Qu6eup8" class="wolai-block wolai-text"><div><span class="inline-wrap">通过合理使用<span class="jill"></span>static<span class="jill"></span>关键字，可以更好地组织代码，实现类与实例之间的资源共享和交互。</span></div></div><div id="7DAqCaHxY2ATPMdV4y7sjJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="8SALCpVGmZiNx9FCiwKA8E" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="qck1NVEyLFMyajpTBud9nE" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">overload<span class="jill"></span>和<span class="jill"></span>override<span class="jill"></span>的区别</span></h1><h2 id="g5aQwL2yXb5WFCg1o3yMXk" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">背记</span></h2><div id="3dRakxv9Qg9epMfCnaGBfB" class="wolai-block wolai-text"><div><span class="inline-wrap">在面向对象编程中，“override”和“overload”是两个重要的概念，它们用于描述方法或函数的行为。</span></div></div><div id="rWhLJgknqCFFmqdzohP4xc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="312kdituJNqmHjcR6DJbty" class="wolai-block"><span class="wolai-serial-number">6.1.1</span><span class="inline-wrap">定义</span></h3><div id="hUpehsijXgFs3jdfcttbWf" class="wolai-block wolai-text"><div><span class="inline-wrap">Override：指子类重写（覆盖）了父类中的方法。子类中的方法名、参数列表与父类中的方法完全相同，返回值类型不超过父类方法返回值类型的范围。</span></div></div><div id="jZk7e93EY5tkN3gR9nqCQX" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload：指在同一个类中或者子类中定义多个具有相同名称但参数列表不同的方法。这些方法可以有不同的参数个数、类型或顺序。</span></div></div><div id="jTrCGh6LYe9ZMfazPEPLXW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="v43o6fPCVaPstRsNeZrFnR" class="wolai-block"><span class="wolai-serial-number">6.1.2</span><span class="inline-wrap">参数列表</span></h3><div id="5sjfS4Ri33TSfPFANAu4iE" class="wolai-block wolai-text"><div><span class="inline-wrap">Override：参数列表必须与父类中被重写的方法完全一致。</span></div></div><div id="ujyeDLzoJnzWNEZcjbyTJ5" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload：参数列表必须不同，可以是参数个数、类型或顺序的差异。</span></div></div><div id="qKp5wfW3yf6NR2LaePrY2d" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vQSC7PKFhs8uZZGcA9e2fG" class="wolai-block"><span class="wolai-serial-number">6.1.3</span><span class="inline-wrap">返回类型</span></h3><div id="tFabpx1njsVcVZkdr2Bbvs" class="wolai-block wolai-text"><div><span class="inline-wrap">Override：返回类型必须与父类中被重写的方法相同，或者是其子类。</span></div></div><div id="3dMuNg8ijU43JCafvkWWHt" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload：返回类型可以相同也可以不同。</span></div></div><div id="x37ipCSUs6g2EvnkcJ2Vkf" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bvmunLjS5om4jFjK6ASAja" class="wolai-block"><span class="wolai-serial-number">6.1.4</span><span class="inline-wrap">作用域</span></h3><div id="uC9uzFkws1SZJVngtW2eox" class="wolai-block wolai-text"><div><span class="inline-wrap">Override：通常发生在继承关系中，子类重写父类的方法。</span></div></div><div id="6hDQWDS9J8tLZLzXdMp7z6" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload：可以在同一个类中或者子类中进行方法的重载。</span></div></div><div id="mxjNLZZQrG7Bh3peY8Lfq8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2WFte6TpLZJn1kcoAgqjnM" class="wolai-block"><span class="wolai-serial-number">6.1.5</span><span class="inline-wrap">编译时决定</span></h3><div id="zhqrAK6NT518oDD2cDVLk" class="wolai-block wolai-text"><div><span class="inline-wrap">Override：动态绑定，即在运行时根据对象的实际类型决定调用哪个版本的方法。</span></div></div><div id="u7VyAjMb7nzYSpxEDMUf14" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload：静态绑定，即根据方法名和参数列表的静态类型在编译期间决定调用哪个方法。</span></div></div><blockquote id="8jJGKdFou16yvq4fenPaeW" class="wolai-block"><span class="inline-wrap">为什么『重写』是动态绑定？
答：有的时候确实要在运行的时候才知道对象的具体类型是什么。比如：
walk(Animal animal)这个方法接收<span class="jill"></span>Animal<span class="jill"></span>类型的参数，这就需要运行时才知道具体传入的是<span class="jill"></span>Cat<span class="jill"></span>还是<span class="jill"></span>Dog</span></blockquote><div id="vK4fmMF3NwwCiaqAZWFC56" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="rPSikGXidsiNReysxUyU8C" class="wolai-block"><span class="wolai-serial-number">6.1.6</span><span class="inline-wrap">口诀</span></h3><ul class="wolai-block"><li id="rAWkDyf6yDUvvmJPC9yJt1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重载：方法名相同，参数列表不同，其它不要求</span></li><li id="hGKdjL3pK948hfzVdf1mrg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重写：两同两小一大</span><ul class="wolai-block"><li id="ioJ5jjkzUSvfVzr1osg93i"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">两同：方法名相同、形参列表相同</span></li><li id="htekJ4UkZXkC4UJtrgaZMo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">两小：</span><ul class="wolai-block"><li id="qVPiRL4H9TCFHVYBvpVM12"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">子类方法返回值类型小于等于父类方法返回值类型</span></li><li id="xnEDaoA5KVXN3NqQDxgLGf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">子类方法<span class="jill"></span>throws<span class="jill"></span>异常类型小于等于父类方法返回值类型</span></li></ul></li><li id="5ngpSP1hwGde5tugb1oT4R"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一大：子类方法权限修饰符大于等于父类方法权限修饰符</span></li></ul></li></ul><div id="gF54bs5MihSZmXfH9vFsKx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rbkCSZhubXsndSvX2baPry" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">理解</span></h2><div id="jWNrtkSYKRexybXdMVdmt4" class="wolai-block wolai-text"><div><span class="inline-wrap">Overload（重载）和<span class="jill"></span>Override（重写）是<span class="jill"></span>Java<span class="jill"></span>中两个基本的概念，它们都是方法多态性的表现，但有一些关键的区别。具体分析如下：</span></div></div><h3 id="cZ8R9vuf4ghCqcdkLF8CDX" class="wolai-block"><span class="wolai-serial-number">6.2.1</span><span class="inline-wrap">Overload（重载）</span></h3><div id="dyVfav3thNWTaebGyZSWAr" class="wolai-block wolai-text"><div><span class="inline-wrap">作用于同一个类中。方法名相同且参数列表不同（参数类型、个数或顺序至少有一项不同）。</span></div></div><div id="aBFL368f5RW1XqFGyLS85X" class="wolai-block wolai-text"><div><span class="inline-wrap">不是基于继承的。在编译时根据参数签名确定调用哪个方法。可以改变返回类型（非必需，但改变了参数必须改变返回类型）。</span></div></div><div id="qxaUug69GuSZvmkC82wtud" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="uWavcx1MZMhWHwy4dgeKcx" class="wolai-block"><span class="wolai-serial-number">6.2.2</span><span class="inline-wrap">Override（重写）</span></h3><div id="2UMnb4kCrGB7soj7wRtbZ5" class="wolai-block wolai-text"><div><span class="inline-wrap">基于继承，子类覆盖父类的方法。方法名及参数列表必须完全相同。访问权限不能比被覆盖的方法更严格。</span></div></div><div id="bycvcMS1fy4n6956asKHik" class="wolai-block wolai-text"><div><span class="inline-wrap">返回类型必须是相同的或者是协变的。</span></div></div><div id="jjnji5f9S3xrX6uSXizUjN" class="wolai-block wolai-text"><div><span class="inline-wrap">抛出的异常必须是相同的或者是其子异常。</span></div></div><div id="6wBWNatbaPEjkvzAfjoDRh" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Overload（重载）提供了一种机制，使得同一个方法名可以用于执行不同的功能，只要它们的参数不同即可。</span></div></div><div id="8uGdUWJGdP1y8QpZ4vYJtq" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>Override（重写）则允许子类提供特定于子类的实现，同时保持与父类相同的方法签名。</span></div></div><div id="h4ogs5sq5LfDLS7wUNbpUp" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><div id="5ee9mk2ToVEXTSGMPYpg5G" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="uLna3RzgvibGHUDmwtyxew" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">final<span class="jill"></span>和<span class="jill"></span>finally<span class="jill"></span>的区别</span></h1><h2 id="38WpsXBdhArL1wDKTp2aNw" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">背记</span></h2><h3 id="mgcWoHZA5LLLinU4GWkaaj" class="wolai-block"><span class="wolai-serial-number">7.1.1</span><span class="inline-wrap">总体对比</span></h3><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="4dr1L1zinmjdf7HDHYrrjk" class="wolai-block wolai-text"><div><span class="inline-wrap">关键词</span></div></div><span class="inline-wrap"></span><br/><div id="irJbQA2Ryu5ywQFcbCNcnT" class="wolai-block wolai-text"><div><span class="inline-wrap">final</span></div></div><span class="inline-wrap"></span><br/><div id="8atsCvP5vRoy8qhEx9vvJS" class="wolai-block wolai-text"><div><span class="inline-wrap">finally</span></div></div><span class="inline-wrap"></span><br/><div id="92bp4KvbWCe3L54zgE5Je9" class="wolai-block wolai-text"><div><span class="inline-wrap">用法</span></div></div><span class="inline-wrap"></span><br/><div id="5Njjq2zxrNTGv4fN1CFQHn" class="wolai-block wolai-text"><div><span class="inline-wrap">作为修饰符来使用</span></div></div><span class="inline-wrap"></span><br/><div id="sCGP2BRXhJQTuaQu64dYuS" class="wolai-block wolai-text"><div><span class="inline-wrap">后面跟一个代码块</span></div></div><span class="inline-wrap"></span><br/><div id="whTgTJ8wJFGThKV8qhfdoe" class="wolai-block wolai-text"><div><span class="inline-wrap">功能</span></div></div><span class="inline-wrap"></span><br/><div id="2wQRbE6Rb8TKtPR8KdBfjW" class="wolai-block wolai-text"><div><span class="inline-wrap">修饰类型、方法或变量</span></div></div><span class="inline-wrap"></span><br/><div id="wHAtzpfePcjerrzJT6Hby5" class="wolai-block wolai-text"><div><span class="inline-wrap">配合<span class="jill"></span>try、catch<span class="jill"></span>块使用</span></div></div><div id="uqUJAaWGa69csjdh3XhHUn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="ooKoxqjyqGwtL7RFhUHb6M" class="wolai-block"><span class="wolai-serial-number">7.1.2</span><span class="inline-wrap">细节：final</span></h3><div id="5CmQ8s1T3wWQj5MG3iguiC" class="wolai-block wolai-text"><div><span class="inline-wrap">final<span class="jill"></span>是一个修饰符，可以修饰如下三种语法结构：</span></div></div><ul class="wolai-block"><li id="jj7h2Z4Si7F3TpdyUZE5VE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类：被<span class="jill"></span>final<span class="jill"></span>修饰的类不能被继承（可以正常创建对象）</span></li><li id="fY44WWu2aTdwNRGDzjPzFW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法：被<span class="jill"></span>final<span class="jill"></span>修饰的类不能被重写（可以正常调用）</span></li><li id="3Ryke6npBT3678ZWTSHzgZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">变量：被<span class="jill"></span>final<span class="jill"></span>修饰的变量只能被赋值一次，于是这个变量也就成了常量</span></li></ul><div id="dfwTwCw3dP1bLha2DoaAqr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pih548oEFhckFqKPAdDFPQ" class="wolai-block"><span class="wolai-serial-number">7.1.3</span><span class="inline-wrap">细节：finally</span></h3><div id="gLM9bRYaWyqj9C728SiwYJ" class="wolai-block wolai-text"><div><span class="inline-wrap">finally<span class="jill"></span>是一个代码块，配合<span class="jill"></span>try、catch<span class="jill"></span>一起使用，效果是不论前面执行<span class="jill"></span>try<span class="jill"></span>块成功还是失败，finally<span class="jill"></span>块中的代码都必定会执行</span></div></div><div id="xg6fkhnLaD4bmQPGLoVy2Y" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2Vnjy2hHP4k5rEyAmnTrUs" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">理解</span></h2><ul class="wolai-block"><li id="kNLs1A4my7DnKuBE83cjgV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">final<span class="jill"></span>关键字提供了不可变性的特性，用于确保特定的类、方法或变量的不可更改性，从而保护数据的一致性和安全性。</span></li><li id="oEWpTgNtqivW2g4kMK9AQs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">finally 是异常处理机制的一部分，它与 try 和 catch 一起使用，形成 try-catch-finally 块。 finally 块中的代码无论异常是否发生，都会被执行。这通常用于放置一些必须执行的清理代码，如关闭文件、释放资源等，以确保资源的正确释放和程序的稳定性。</span></li></ul><div id="qZNFaVtRYKPJSiBMin7m9A" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="pG26JfQVJvBavbDsyrrJhA" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><div id="5ei1Sofz4QGWxgoy5J6joz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="3BcMRsGLgq6BPn55KQisFv" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">this<span class="jill"></span>和<span class="jill"></span>super<span class="jill"></span>都能用到哪些地方？</span></h1><h2 id="p5RunZ2hJ9tRUFXbe2tGC1" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">背记：</span></h2><h3 id="ovPYbmzQYo2PDnFMcYu2wK" class="wolai-block"><span class="wolai-serial-number">8.1.1</span><span class="inline-wrap">访问成员变量</span></h3><ul class="wolai-block"><li id="eVbG15DwC2Cbxsdt2z3pxG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">this：可以用于区分成员变量与局部变量重名的情况，如果本类没有这个成员变量，也可以调用父类的成员变量。</span></li><li id="95p57W9NkVtDpYu1odVqYi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">super：可以用于区分本类成员变量与父类成员变量重名的情况，只能调用父类的成员变量。</span></li></ul><div id="9fx9AYP7UZpPKEAFJeiofr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pD6PX5Vu4ccVMbcpBNbCzV" class="wolai-block"><span class="wolai-serial-number">8.1.2</span><span class="inline-wrap">访问成员方法</span></h3><ul class="wolai-block"><li id="eRNLkJegwtWFhzYoK3Kpt3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">this：可以调用本类的成员方法，如果本类没有这个成员方法，也可以调用父类的成员方法。</span></li><li id="iKSi6jhqJ98TY2TbWfjMcP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">super：只能调用父类的成员方法。</span></li></ul><div id="i25Ca5vyJ9qA5d3qStDz2Q" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2YdGEit2sDGuwKX3CR94Y2" class="wolai-block"><span class="wolai-serial-number">8.1.3</span><span class="inline-wrap">访问构造器</span></h3><ul class="wolai-block"><li id="tWK4s2BrRVZnSu6vS1bnLA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">this：可以通过<span class="jill"></span>this()或<span class="jill"></span>this(参数)在当前构造器中调用其它构造器</span></li><li id="aWkRUZdvttYU7BqfkeiZen"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">super：子类通过<span class="jill"></span>super()或<span class="jill"></span>super(参数)调用父类构造器</span></li></ul><div id="fqiX5ZQvQxuTSM1JpZzCau" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="repK8B1HevGWUUE6GmgZNP" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">理解：</span></h2><h3 id="gL5U3HWkyzZwnwrorcE98N" class="wolai-block"><span class="wolai-serial-number">8.2.1</span><span class="inline-wrap">this</span></h3><div id="gVthdK37iNUyPz1STYKqWu" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个方法需要明确指出它正在操作当前对象时，就会用到<span class="jill"></span>this<span class="jill"></span>关键字。</span></div></div><div id="5uZB3ubZHp5d7oMPXLieRs" class="wolai-block wolai-text"><div><span class="inline-wrap">this<span class="jill"></span>可以用来区分局部变量和类的字段之间的名称冲突，也可以用来调用同一个类中的其他构造器。</span></div></div><div id="79vnQuEavpfibBbh4ZF5fw" class="wolai-block wolai-text"><div><span class="inline-wrap">在构造器中，this<span class="jill"></span>通常用于调用同一类中的另一个构造器，这通常发生在构造器的第一行。</span></div></div><div id="irF9Sx7VozATtHJNQGK4dz" class="wolai-block wolai-text"><div><span class="inline-wrap">这样做的目的是为了代码重用和提高可维护性。</span></div></div><div id="ehGo2GKj4f1RCJrf9Husx2" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，如果一个类有多个构造器，它们可能需要执行一些共同的初始化步骤，那么可以使用<span class="jill"></span>this<span class="jill"></span>来调用一个共有的构造器，以避免代码重复。</span></div></div><div id="fZHhkEL3uwgeThT7L89DWv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7tRs3ktzka7AApSvBQaJh4" class="wolai-block"><span class="wolai-serial-number">8.2.2</span><span class="inline-wrap">super</span></h3><div id="VHTejnQpRk1tQNoencEm7" class="wolai-block wolai-text"><div><span class="inline-wrap">super<span class="jill"></span>关键字用于引用当前对象的父类。</span></div></div><div id="cp1ma3qnTKhi9a4NYwMk8p" class="wolai-block wolai-text"><div><span class="inline-wrap">它主要用于在子类的构造器中调用父类的构造器，这是因为子类构造时，需要先初始化从父类继承的成员。</span></div></div><div id="iWRbkFKqiTcM5ZroDSnYzd" class="wolai-block wolai-text"><div><span class="inline-wrap">super<span class="jill"></span>也可以用来调用父类的方法或访问父类的字段。</span></div></div><div id="rEjshdevZCuLGuvgQz2QMF" class="wolai-block wolai-text"><div><span class="inline-wrap">如果父类的构造器需要参数，则子类的构造器中必须通过<span class="jill"></span>super(参数名)显式调用父类中的某一个构造器。</span></div></div><div id="sMvF85wnNLY75fkwbrB1xh" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，在同一个构造器中，this()和<span class="jill"></span>super()不能同时出现，因为<span class="jill"></span>this()必须放在构造器的第一行，而<span class="jill"></span>super() 也是放在第一行，所以它们不能共存。</span></div></div><div id="vmHoChV2ki5nawGL9NiBFG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fAUYpfBVpyMebuwMUbZPGj" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="81r2bB2EgwvQydLLWY6jiX" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">接口与抽象类的区别</span></h1><h2 id="uTKs2nipBBsFm9yYNmEV4r" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">背记</span></h2><h3 id="gnEEN7WxJM5XNzeqEVfdp5" class="wolai-block"><span class="wolai-serial-number">9.1.1</span><span class="inline-wrap">关键字</span></h3><ul class="wolai-block"><li id="gJVTi2rV9SmKe1kcHPkYBQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：使用<span class="jill"></span>abstract<span class="jill"></span>关键字定义</span></li><li id="4bgbNk8j1jeC5SiPyHrHFV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：使用<span class="jill"></span>interface<span class="jill"></span>关键字定义</span></li></ul><div id="iiX5wyDYMirK2xfeXCj4tp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="gCAyuAAV18BWa7CNgpEZsG" class="wolai-block"><span class="wolai-serial-number">9.1.2</span><span class="inline-wrap">设计</span></h3><ul class="wolai-block"><li id="78nxdfbGcX7zt2Eq97B9pR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：代表对事物通用特性的抽象，可以包含属性和方法</span></li><li id="pK5xfHB7PmJ4YyCT8MJj6H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：主要关注事物的行为，所以它是方法的集合</span></li></ul><div id="g5R5RK1xLbcuK5X1DCFPVv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9cTZMg2cmj8rbz2foSsA4t" class="wolai-block"><span class="wolai-serial-number">9.1.3</span><span class="inline-wrap">构造器和成员变量</span></h3><ul class="wolai-block"><li id="o1BwJuxwUbJyBxbc86uihW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：有构造器，有普通成员变量</span></li><li id="obNmt8W9SDHwS1Qi8a8rnK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：没有构造器和普通成员变量，其内部变量默认为<span class="jill"></span>public static final<span class="jill"></span>类型</span></li></ul><div id="eUM2t1g93K8arrt9hoaAHW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="29mxXC6W48freYixvHBhfz" class="wolai-block"><span class="wolai-serial-number">9.1.4</span><span class="inline-wrap">方法实现</span></h3><ul class="wolai-block"><li id="ayUEqpztM2bNe2naDzrC7M"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：可以包含抽象方法和非抽象方法</span></li><li id="auQGxX9LvMmxspiWD2JAm3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：只能声明抽象方法，但在<span class="jill"></span>Java 8<span class="jill"></span>起可以有默认方法和静态方法</span></li></ul><div id="bWXa2sy5cuKLZZicNQH5ZL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="56UKS5JAiehc8K8CTdQQwo" class="wolai-block"><span class="wolai-serial-number">9.1.5</span><span class="inline-wrap">继承与实现</span></h3><div id="bp5rn3XZdqP8jPiNsCSmVn" class="wolai-block wolai-text"><div><span class="inline-wrap">一个类只能继承一个抽象类，但可以实现多个接口，这是<span class="jill"></span>Java<span class="jill"></span>支持多态性的重要方式</span></div></div><div id="ihoDH12u49hxs9hEqzFv5U" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4Hzdo3cGxfFwV2gn3u39zK" class="wolai-block"><span class="wolai-serial-number">9.1.6</span><span class="inline-wrap">访问修饰符</span></h3><ul class="wolai-block"><li id="aSNPX7BtEDPETgcn9DHukZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：抽象方法可以有修饰符</span></li><li id="sRair7KzwtELnTdczMMSux"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：抽象方法只能是<span class="jill"></span>public<span class="jill"></span>类型</span></li></ul><div id="dxxebpdnd1GyDsiD6gVLfE" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kNHQebqsjUnvkBvfhVXEKC" class="wolai-block"><span class="wolai-serial-number">9.1.7</span><span class="inline-wrap">实例化</span></h3><div id="b5eriDt3EoBR9yVzLrUzCD" class="wolai-block wolai-text"><div><span class="inline-wrap">抽象类和接口因为包含抽象方法，所以都不能直接用于创建对象，实例化之前都必须给出抽象方法的具体实现</span></div></div><div id="uYRpdRrJB8YCX4SX15xpiG" class="wolai-block wolai-text"><div><span class="inline-wrap">通过匿名内部类方式创建对象时，其实抽象方法在匿名内部类中实现了</span></div></div><div id="9F4357WvF2VkWkfDbJsivR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qt4aHsaASNiGzuqfhjfuj8" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">理解</span></h2><div id="fAbBS3bL4FwC4vjUvQaeHx" class="wolai-block wolai-text"><div><span class="inline-wrap">抽象类和接口各有其适合使用的应用场景：</span></div></div><h3 id="e4CCizmFFKTQXinTogHVGR" class="wolai-block"><span class="wolai-serial-number">9.2.1</span><span class="inline-wrap">设计层面</span></h3><ul class="wolai-block"><li id="sakbAaL55MerhTVghFWyue"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：</span><span class="inline-wrap">定义一个基础的对象类型，让其他类继承这些基本特征</span><ul class="wolai-block"><li id="wbD2BHZ5Eeo2jh72szyena"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">例如：有一个系统需要处理不同类型的图形，可以定义一个抽象类<span class="jill"></span>Shape ，它包含一些如<span class="jill"></span>getArea()的抽象方法，然后让<span class="jill"></span>Circle、 Rectangle<span class="jill"></span>等具体形状类继承<span class="jill"></span>Shape<span class="jill"></span>并实现这些方法。</span></li></ul></li><li id="fyjhKaCBRJ3LCHxNFzQk5y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：</span><span class="inline-wrap">定义一组不相关类的共同行为</span><ul class="wolai-block"><li id="dLXpRzfXhE1HwARwgkvuSt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">例如：系统中有多种类型的对象需要进行比较，可以实现一个<span class="jill"></span>Comparable<span class="jill"></span>接口，该接口中定义了<span class="jill"></span>compareTo()方法，然后让需要比较的类实现这个接口。</span></li></ul></li></ul><div id="gAzrMoHZLCN7WmYm97F5GU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="uZKCtAmZFtME9ScnNM53Z8" class="wolai-block"><span class="wolai-serial-number">9.2.2</span><span class="inline-wrap">功能实现</span></h3><ul class="wolai-block"><li id="se52jLXYwkKZAahoevJr7n"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">抽象类：表达类型上的从属关系，比如</span><span class="inline-wrap">“鸽子是鸟的一种”</span><span class="inline-wrap">则更适合使用抽象类来表示这种层次关系，因为抽象类可以包含具体的方法实现。</span></li><li id="4T3MthCKzdcqZgnihXpTxZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">接口：</span><span class="inline-wrap">对于需要多个不相关类共有的行为，比如“飞”这个动作，无论是鸟还是飞机都可以飞，这时可以使用接口来定义“飞”的行为，不同的类实现该接口并提供具体的飞行方式。</span></li></ul><div id="d2wRSVQ5xNfrcqQWvBDocj" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="641D52WUiaouV32L86JFeA" class="wolai-block"><span class="wolai-serial-number">9.2.3</span><span class="inline-wrap">实际应用中的选择</span></h3><div id="itoDSuNMyp9r3TyxacdoQd" class="wolai-block wolai-text"><div><span class="inline-wrap">在实际应用中，如果遇到需要同时使用抽象类和接口的情况，一般建议先继承抽象类再实现接口，因为<span class="jill"></span>Java<span class="jill"></span>不支持多重继承。</span></div></div><div id="3J33uhKtsqPy43LS6hHngZ" class="wolai-block wolai-text"><div><span class="inline-wrap">抽象类可以定义各种类型的成员变量，而接口中只能有 public static final 修饰的静态常量。</span></div></div><div id="iKZ8SQXcrpcDtwewfswCcT" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，在实际开发中选择使用接口还是抽象类取决于你的设计需求和所面临的具体问题。</span></div></div><div id="2eGgSej12zV1abFHJRYhPo" class="wolai-block wolai-text"><div><span class="inline-wrap">如果你的设计更侧重于对象的层次结构和它们之间的共性，那么抽象类可能是更好的选择。</span></div></div><div id="rEPgR8jSfx9nucFtd3cJNA" class="wolai-block wolai-text"><div><span class="inline-wrap">如果你的设计需要灵活地为不同类添加或修改行为，而不关心它们的具体类型，那么接口可能更加合适。</span></div></div><div id="hHVhJ8UAXqCpsVDKHt5kUG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="ezW7FzdvBPfeVKjWT6Z2EE" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="7bNw4GqFMEKcyF8f8SnNUr" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">静态变量与实例变量的区别</span></h1><h2 id="sVuceJjjNY1XhaoYcuvaFs" class="wolai-block"><span class="wolai-serial-number">10.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="ca1BoFhZjyGigvQ7Ye2HfV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量是类级别的，是类信息的一部分</span></li><li id="fWu5aR9yfyBHqWpqPFPZS3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量是对象级别的，是对象数据的一部分</span></li></ul><div id="oFuFoEUYGt6Knms9WbhXwH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oFtjH4wZigFpZeQQNZ4hyX" class="wolai-block"><span class="wolai-serial-number">10.2</span><span class="inline-wrap">理解</span></h2><div id="pS1tsYruoRti4JPzoqbSxZ" class="wolai-block wolai-text"><div><span class="inline-wrap">静态变量和实例变量是<span class="jill"></span>Java<span class="jill"></span>中的两种不同类型的变量，它们在定义、存储位置和使用方式上都存在差异。具体分析如下：</span></div></div><h3 id="ney94fwZCLW9gRKnbNhZyY" class="wolai-block"><span class="wolai-serial-number">10.2.1</span><span class="inline-wrap">声明</span></h3><div id="wSXZjkqBTsQ3bKD44kHnM8" class="wolai-block wolai-text"><div><span class="inline-wrap">静态变量在声明时需要使用 static 关键字，而实例变量则不需要。</span></div></div><div id="mSU9v5rdffDSfhvy9csnWU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="tA1f3DJzvFgWbdNbiJ7bvZ" class="wolai-block"><span class="wolai-serial-number">10.2.2</span><span class="inline-wrap">存储位置</span></h3><ul class="wolai-block"><li id="ddBkxvJzUdBLYCM9TwVxhq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量属于类级别，不依赖于任何对象实例，即使没有创建类的实例，静态变量也存在。</span></li><li id="9dWWYQmNVwkxTnWrKPkxTc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量存在于对象实例中，每个对象实例都有自己的实例变量副本。</span></li></ul><div id="ahzcBpsSFVGUHrgg6Z2cea" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2o6t71gbznzS3JBPTKxikP" class="wolai-block"><span class="wolai-serial-number">10.2.3</span><span class="inline-wrap">使用方式</span></h3><ul class="wolai-block"><li id="oZxU2xUQjrimQBiBjsn9ia"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量可以通过类名直接访问，无需创建类的实例。</span></li><li id="mWbLzCeMdZ1tH8Zvcvrzwj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量必须通过对象实例来访问。</span></li></ul><div id="3fwFCKPyoGjSLfpxU77c25" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="51c3zKknVjqjM872DenbjP" class="wolai-block"><span class="wolai-serial-number">10.2.4</span><span class="inline-wrap">内存位置</span></h3><ul class="wolai-block"><li id="wUU2jiZ6mYkJ3qthhtvhAS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量在方法区中（方法区存放类的信息）</span></li><li id="83uRfzg6VPuBTTwxT2XxvX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量在堆内存中（堆内存存放对象数据）</span></li></ul><div id="tuRq1txUxhtsEgZd7enYjz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4LHHrnnJjAw3GyX6A3R6q2" class="wolai-block"><span class="wolai-serial-number">10.2.5</span><span class="inline-wrap">生命周期</span></h3><ul class="wolai-block"><li id="Yge4j4gXoB1DPap2eyYBy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量随着.class<span class="jill"></span>文件加载而产生,随着.class<span class="jill"></span>文件结束而结束</span></li><li id="decaomTiVpYugG8HiGwtMb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量随着对象的创建而产生,随着对象的结束而结束</span></li></ul><div id="sXK6n7mhRTPxZokBFxFNLa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="xzRtp7XafSu2xw19E8rHUU" class="wolai-block"><span class="wolai-serial-number">10.2.6</span><span class="inline-wrap">调用方式</span></h3><ul class="wolai-block"><li id="mLLbTgk9UDRTpZpvh4Gbx8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">静态变量既可以通过『类名.变量名』方式直接进行调用，也可以通过『对象.变量名』方式进行调用（当然本质上都是先找到类，然后在找类变量）</span></li><li id="m3K4cTVXHkjSUodxAKCyeU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实例变量只能通过『对象.变量名』方式进行访问</span></li></ul><div id="738s6te7VER4d1yJHjtcj3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kF7xPEBS4vfCb8rHqk2SQv" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="cfUpyr97ZNssKhyKTvVYCu" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">throw<span class="jill"></span>和<span class="jill"></span>throws 的区别</span></h1><h2 id="7xPWrTpMqcHZTxkTY4VfrP" class="wolai-block"><span class="wolai-serial-number">11.1</span><span class="inline-wrap">关键要点</span></h2><ul class="wolai-block"><li id="KpsfxxKK5igfi6LLoi9RX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throw<span class="jill"></span>动真格</span></li><li id="boucGkGYJ5JsnqyzTydCr4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throws<span class="jill"></span>吓唬人</span></li></ul><div id="qAEi72H9tVNjfYaF1tug1z" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ado65QnBLkBerogN3YSZSf" class="wolai-block"><span class="wolai-serial-number">11.2</span><span class="inline-wrap">具体细节</span></h2><h3 id="ofP9gukb6Yc3Vfeh1trvSX" class="wolai-block"><span class="wolai-serial-number">11.2.1</span><span class="inline-wrap">使用位置</span></h3><ul class="wolai-block"><li id="vpjJMBRFN6gzAbmeDQixEd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throw：在方法体内使用，用来真实抛出一个异常对象</span></li><li id="xCtC8bLMxBWnUE9T7Sz6v"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throws：在方法声明位置使用，用来告诉方法的调用者，这个方法有抛出这些异常的风险，仅仅只是风险，不代表调用时一定会抛出</span></li></ul><div id="nZqhuKoS4KQoQ2ypYzvqva" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iquzGVWcBer9tD5aaAJCJf" class="wolai-block"><span class="wolai-serial-number">11.2.2</span><span class="inline-wrap">使用效果</span></h3><ul class="wolai-block"><li id="mV1EUipQDHhCdfHiMSwLPw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throw：真实抛出异常</span></li><li id="ewV8BVei54sz7DnsZc3P2i"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throws：声明方法运行中有可能发生的风险</span></li></ul><div id="tBT6tRCxPtFhjmwqez7k4L" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wKGotxNPCjcFfQnXkGXTz" class="wolai-block"><span class="wolai-serial-number">11.2.3</span><span class="inline-wrap">后跟类型</span></h3><ul class="wolai-block"><li id="wFn2TSYggC4ZpriqKNsaEh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throw：后跟具体的异常对象，只能是一个</span></li><li id="fuLpnbx7nZ6Kmx3DuzkhuN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">throws：后跟异常类型，可以多个</span></li></ul><div id="5DoqHbbw7nngMmcYAKzoP5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="tpTGGHbrGAN8Vgy9dZpQGR" class="wolai-block"><span class="wolai-serial-number">11.3</span><span class="inline-wrap">有趣发现：throws<span class="jill"></span>为什么加“s”？</span></h2><div id="jkaUwpwLhVsMqdAmB9XAtB" class="wolai-block wolai-text"><div><span class="inline-wrap">并不是因为它后面跟多个异常类型，这不是名词复数形式；</span></div></div><div id="ikhPFiPaaSeHg6v9METAWQ" class="wolai-block wolai-text"><div><span class="inline-wrap">而是因为<span class="jill"></span>throws<span class="jill"></span>前面是方法名，方法名是主语，throws<span class="jill"></span>是谓语动词，那么一般现在时中，主语是第三人称单数时谓语动词加“s”</span></div></div><div id="cYeFre2t2T218ybDDMhLVf" class="wolai-block wolai-text"><div><span class="inline-wrap">编程语言语法也是遵循自然语言语法的</span></div></div><div id="twbADYMXffn1mC9wvZBZ2z" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><div id="c7YhWZaTBEnVyqNMwBkFp5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="v1976RCaihLRnsePTHw85V" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">String、StringBuilder 与 StringBuffer 的区别</span></h1><h2 id="7LrCzjqsnpQgPvQcDCP9wJ" class="wolai-block"><span class="wolai-serial-number">12.1</span><span class="inline-wrap">背记</span></h2><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="c6xtyfSrVdnqSdNWJbk95D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><span class="inline-wrap"></span><br/><div id="6LXeKNjSdtZCXgsnm3CaFb" class="wolai-block wolai-text"><div><span class="inline-wrap">String</span></div></div><span class="inline-wrap"></span><br/><div id="bVVNoDXvx5auAhk8DmU35j" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuilder</span></div></div><span class="inline-wrap"></span><br/><div id="q5f6KREJNGHnZ4SRUQKkRQ" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuffer</span></div></div><span class="inline-wrap"></span><br/><div id="vFk29eT31RKQ7ZvS8rHZ7g" class="wolai-block wolai-text"><div><span class="inline-wrap">可变性</span></div></div><span class="inline-wrap"></span><br/><div id="8wwYUi2Fm1CYrDj7YzL7qT" class="wolai-block wolai-text"><div><span class="inline-wrap">不可变</span></div></div><span class="inline-wrap"></span><br/><div id="qHjREUnt2qKcb4UHEdTyoD" class="wolai-block wolai-text"><div><span class="inline-wrap">可变</span></div></div><span class="inline-wrap"></span><br/><div id="fFLyDV1xkP4sTGrVK81Q3N" class="wolai-block wolai-text"><div><span class="inline-wrap">可变</span></div></div><span class="inline-wrap"></span><br/><div id="nSvKS344Y8YgkbmRXHkY4X" class="wolai-block wolai-text"><div><span class="inline-wrap">频繁修改时性能</span></div></div><span class="inline-wrap"></span><br/><div id="bZmtYjMbQ2gSD22MKxYTXQ" class="wolai-block wolai-text"><div><span class="inline-wrap">差（第三名）</span></div></div><span class="inline-wrap"></span><br/><div id="C5jxAtNCZ3X7CwdGKEPLZ" class="wolai-block wolai-text"><div><span class="inline-wrap">较好（第一名）</span></div></div><span class="inline-wrap"></span><br/><div id="oSJidvARw8U5p11o7wXaXe" class="wolai-block wolai-text"><div><span class="inline-wrap">较好（第二名）</span></div></div><span class="inline-wrap"></span><br/><div id="mFGyQX1uDGGmR7nPbxs9Zs" class="wolai-block wolai-text"><div><span class="inline-wrap">线程安全性</span></div></div><span class="inline-wrap"></span><br/><div id="xifqc3mwHCThTnpirB1q3D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><span class="inline-wrap"></span><br/><div id="jGA2m78bpcDmBNvth2PWaG" class="wolai-block wolai-text"><div><span class="inline-wrap">不加锁，线程不安全</span></div></div><span class="inline-wrap"></span><br/><div id="biKneTrQpCDFjfKXYMM4F9" class="wolai-block wolai-text"><div><span class="inline-wrap">加锁，线程安全</span></div></div><div id="bEhw4qkqUosRu12MjM1Fsb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3aJ5nNyGXFLBFHycsK3388" class="wolai-block"><span class="wolai-serial-number">12.2</span><span class="inline-wrap">细节</span></h2><h3 id="s1cjkDonMP5MWRFANcqDeJ" class="wolai-block"><span class="wolai-serial-number">12.2.1</span><span class="inline-wrap">可变性</span></h3><ul class="wolai-block"><li id="rKKQob4BHKhLeF6rSs8QWX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Java<span class="jill"></span>中<span class="jill"></span>String<span class="jill"></span>类型的字符串是不可改变的字符序列</span></li><li id="wxJwpHMTiyRXf9yzkuDJ8g"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">String<span class="jill"></span>类型的对象一旦创建，其内容就不可改变</span></li><li id="6mV7XazDiFRwrEKhyJQR6z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对<span class="jill"></span>String<span class="jill"></span>进行任何修改操作，都是创建一个新的<span class="jill"></span>String<span class="jill"></span>对象</span></li><li id="hsgYDR2Aitr9jHP9jLYHq9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">StringBuilder<span class="jill"></span>和<span class="jill"></span>StringBuffer<span class="jill"></span>是可变的，可以在原有对象的基础上进行修改，不会导致新对象的创建。这使得它们在频繁修改字符串时比 String<span class="jill"></span>更加高效。</span></li></ul><div id="hLf938wa75zcwf9yiojwkR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="m5XEqZBfjb4d1wx2NN8QeP" class="wolai-block"><span class="wolai-serial-number">12.2.2</span><span class="inline-wrap">性能</span></h3><div id="j1XyjFdM9UYNaPRRNH4Gdq" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>String<span class="jill"></span>的不可变性，每次修改都会生成新的对象，这可能会导致性能问题，尤其是在大量修改操作的场景下。</span></div></div><div id="bFqpPU6AQNqg1KsGJjZpaq" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuilder<span class="jill"></span>和<span class="jill"></span>StringBuffer<span class="jill"></span>的性能通常比<span class="jill"></span>String<span class="jill"></span>要好，因为它们避免了频繁的对象创建。</span></div></div><div id="4wbJ6XAaxgWnzLipUtqYif" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuilder<span class="jill"></span>的性能略优于<span class="jill"></span>StringBuffer，因为它不是线程安全的，不需要同步操作，所以在单线程环境下速度更快。</span></div></div><div id="2nTTvnDSidaU9W2NbTwVMk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fkFsLHnqiBCpybGkg9ktz8" class="wolai-block"><span class="wolai-serial-number">12.2.3</span><span class="inline-wrap">线程安全</span></h3><div id="3L9Uw5LK3uL3tmmjdAXVhm" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuffer<span class="jill"></span>是线程安全的，因为它的关键方法是同步的。这意味着在多线程环境下，使用<span class="jill"></span>StringBuffer<span class="jill"></span>可以避免并发问题。</span></div></div><div id="pRKjY51e4RrJvtjJcRfGWF" class="wolai-block wolai-text"><div><span class="inline-wrap">StringBuilder<span class="jill"></span>不是线程安全的，它的方法没有同步，因此在多线程环境下可能会出现数据不一致的问题，但它在单线程环境下的性能更优。</span></div></div><div id="rb5LkcRB6FDyHUuSdWjHt8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="cAXPDSKgDs3dnLJo4JTkDZ" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="coNP8bheGrFqBJmkEDi1xS" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">==和<span class="jill"></span>equals()的区别</span></h1><h2 id="g8MfLp7sLpuHvcet4UShBC" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="pdKwJE3VUmv5vTqaheW4aG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">双等号：</span><ul class="wolai-block"><li id="ff3oprw1n1c5jJBoNWiizq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基本数据类型：比较数据本身</span></li><li id="dDiYm1nyhofg4xXiHxPQ4A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">引用类型：比较引用地址</span></li></ul></li><li id="hnyn5vvUh9vT4jLUSBrkUm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">equals()：仅限于引用类型之间比较</span><ul class="wolai-block"><li id="9id9isRn9ub8NW3zPPNe5G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Object<span class="jill"></span>类中未被重写的<span class="jill"></span>equals()：使用双等号比较引用地址</span></li><li id="m7RaJCQA6vLYY4cG7HNMoV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">官方代码重写<span class="jill"></span>equals()之后：比较内容，例如<span class="jill"></span>String、Integer<span class="jill"></span>等</span></li><li id="8CE3wLXM4pzAwSnEY3cwzd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自定义重写<span class="jill"></span>equals()之后：根据重写后的代码逻辑决定</span></li></ul></li></ul><div id="2SLXvmtWAawXSnKTpFepZ8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="hWZR5SfCCPUEAzb4q8T3yh" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">使用建议</span></h2><div id="seXrJF5d1cRWqz2TuwKBro" class="wolai-block wolai-text"><div><span class="inline-wrap">通常来说：</span></div></div><ul class="wolai-block"><li id="9Crgi2Ne4uA7s8suJtP6LD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基本数据类型使用双等号比较</span></li><li id="aNuMmTLfaXQvrUXJ2sQpkV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">引用类型使用<span class="jill"></span>equals()比较，如有需要，由开发人员重写<span class="jill"></span>equals()方法</span></li></ul><div id="bGhaprFUv8WM2UeocGQw4v" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fmH7y1oTWiebeYGheB7AUp" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="dJ5MhpyFRgzyGCp1BZmMJA" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">包装类拆箱装箱</span></h1><h2 id="3bZGLEmx8zL96h9XJjZQLp" class="wolai-block"><span class="wolai-serial-number">14.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="wX1tXhXKYnejNHfFPABa2Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">装箱：将基本数据类型数据转换为包装类型对象</span></li><li id="e7SBsagMvxdgDSKUxKJceb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">拆箱：将包装类型对象转换为基本数据类型数据</span></li></ul><div id="5YaPzZH1h1iqeGHJ9ZRCNK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="57GoQBj6PKi6EipPXXQzmW" class="wolai-block"><span class="wolai-serial-number">14.2</span><span class="inline-wrap">理解</span></h2><h3 id="qcQDaBjBbY8BUNawkvCdfy" class="wolai-block"><span class="wolai-serial-number">14.2.1</span><span class="inline-wrap">装箱</span></h3><ul class="wolai-block"><li id="wiN7yCijQYFMK5PzGLTRTV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">概念：是指将基本数据类型的值转换成对应包装类的实例对象的过程。</span></li><li id="srn26Wvwsyjipyx17XR4EJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法：可以通过调用包装类的构造器或<span class="jill"></span>valueOf()方法来实现手动装箱。</span></li><li id="sydsoRWxEicgz3ybnEHF58"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自动装箱：从<span class="jill"></span>Java 5<span class="jill"></span>开始，编译器会自动将基本类型转换为包装类，这称为自动装箱。</span></li></ul><div id="kMvYAjAZ8QzqqWnbzjR7rv" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，将<span class="jill"></span>int<span class="jill"></span>类型的变量赋值给<span class="jill"></span>Integer<span class="jill"></span>对象时，会自动调用<span class="jill"></span>Integer.valueOf()方法。</span></div></div><h3 id="NaWtyjqEwQVMdyqAhbJMx" class="wolai-block"><span class="wolai-serial-number">14.2.2</span><span class="inline-wrap">拆箱</span></h3><ul class="wolai-block"><li id="5V5a5ns4ofEoSvYd69jjR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">概念：是指将包装类对象转换回其对应的基本数据类型的过程。</span></li><li id="3Ms2yydQGy6YpZFBSCHFVo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法：可以通过调用包装类的<span class="jill"></span>xxxValue()方法（如 intValue() 、 doubleValue() 等）来实现手动拆箱。</span></li><li id="mZx9vZX2HapoondLyhiLh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自动拆箱：与自动装箱类似，当需要基本数据类型的值时，如果操作的对象是包装类类型，编译器会自动将其转换为基本类型，这称为自动拆箱。</span></li></ul><h3 id="e46azaBFRCnxxhYgBFi8Tk" class="wolai-block"><span class="wolai-serial-number">14.2.3</span><span class="inline-wrap">注意事项</span></h3><div id="5ChbGVXxegUxs8174vtB3a" class="wolai-block wolai-text"><div><span class="inline-wrap">自动拆装箱虽然方便，但也可能导致不必要的性能开销，尤其是在大量数据处理时。</span></div></div><div id="rR3rTjhAZPFqKRwzNaEnK" class="wolai-block wolai-text"><div><span class="inline-wrap">频繁的拆装箱操作可能会导致内存占用增加，因为每次装箱都会创建新的包装类对象。</span></div></div><div id="eJvykReLApMcsMPdFYU3T3" class="wolai-block wolai-text"><div><span class="inline-wrap">在编写代码时，应当注意不要过度依赖自动拆装箱，以免影响程序的性能和可读性。</span></div></div><div id="gU4s6BA8mhmNjLcrM4mFmX" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，理解拆箱和装箱的概念对于<span class="jill"></span>Java<span class="jill"></span>编程是非常重要的，因为它们涉及到<span class="jill"></span>Java<span class="jill"></span>中基本类型与对象类型之间的转换机制，这对于编写高效且健壮的<span class="jill"></span>Java<span class="jill"></span>代码至关重要。</span></div></div><div id="joim33GGF5BBUQzYAVTzP6" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><div id="iKxyFTLj1PcvNq7jNPofBF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="wGDZfThAwYNfgweXPajy9H" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">异常结构图</span></h1><div id="rVEboCkx3VMHdxqRikkaJp" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/%E5%9B%BE%E7%89%871.png" alt="  " style="width: 100%"/><figcaption>  </figcaption></figure></div><div id="qzn51eYrk5NA74tv4fEwWk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="5Vm2mivAfTa67aij3ABXBK" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="kdBdaNGZT3r1dmLCRMssmo" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">请谈一下<span class="jill"></span>Java<span class="jill"></span>中<span class="jill"></span>I/O<span class="jill"></span>技术体系中包含哪些种类的流？</span></h1><h2 id="oTD3tk5FnKobtXT1c645zx" class="wolai-block"><span class="wolai-serial-number">16.1</span><span class="inline-wrap">背记</span></h2><div id="qwvXKMs2xERZpTzX6avQ81" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的<span class="jill"></span>I/O<span class="jill"></span>流可以从不同角度来分类：</span></div></div><ul class="wolai-block"><li id="kPbevRcxstfYiwyYtUVhgB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">按照数据内容分类：</span><ul class="wolai-block"><li id="tgxc6v9LHv4aYRnakgRa47"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字节流：万能流，可以处理任意类型的文件，主要用于处理二进制数据，如图片、视频等</span></li><li id="hZ7NGFpdgi2gsgSgFKFg8s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符流：非万能，主要用来处理文本文件，提供了对字符数据的高效读写</span></li></ul></li><li id="oK146ukwibR8P7wLgrDZ6a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">按照数据流动方向分类：</span><ul class="wolai-block"><li id="nWmFXY2kb9UsoNFTmSSj2n"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">输入流：从源头读取数据，比如从文件中读取</span></li><li id="442icAtNuApygYXtXFv7yb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">输出流：向目标写入数据，比如写入到文件中</span></li></ul></li><li id="ct2h1zPGqnzbmLH2taAY9H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">按照功能分类：</span><ul class="wolai-block"><li id="u2uaiLwE56Aa9YqhcQut2Q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">节点流：直接与数据源相连，比如<span class="jill"></span>FileInputStream</span></li><li id="6fzY9QyDmegmCA4fi7zqX3" class="bg-default"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">处理流：在节点流的基础上提供了额外的功能，比如<span class="jill"></span>BufferedInputStream<span class="jill"></span>通过缓冲区提高<span class="jill"></span>I/O<span class="jill"></span>效率，处理流都是对节点流的包装</span></li></ul></li></ul><h2 id="x44TUqYZkENo8zzx9NEDP4" class="wolai-block"><span class="wolai-serial-number">16.2</span><span class="inline-wrap">参考</span></h2><div id="ijFCQUwLsvdBCmpU29Z7nh" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的<span class="jill"></span>IO<span class="jill"></span>流是用于数据输入和输出的抽象概念，它代表了输入源和输出目标。</span></div></div><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="iYV7itLidh9R7fiUK1tfUu" class="wolai-block wolai-text"><div><span class="inline-wrap">I/O<span class="jill"></span>流类型</span></div></div><span class="inline-wrap"></span><br/><div id="khRTdSJStCgLG2wD8Fi9ZY" class="wolai-block wolai-text"><div><span class="inline-wrap">FileInputStream</span></div></div><span class="inline-wrap"></span><br/><div id="6N2kicafVEdsTn18FFUVtF" class="wolai-block wolai-text"><div><span class="inline-wrap">FileOutputStream</span></div></div><span class="inline-wrap"></span><br/><div id="jpWhiQHpKShYZ2AqEgRLtP" class="wolai-block wolai-text"><div><span class="inline-wrap">ObjectInputStream</span></div></div><span class="inline-wrap"></span><br/><div id="cAkxxjb8h4zeUYjjvjp6mN" class="wolai-block wolai-text"><div><span class="inline-wrap">功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="v34rDwSkgZDM69ai4JCQu2" class="wolai-block wolai-text"><div><span class="inline-wrap">用于从文件中读取字节数据</span></div></div><span class="inline-wrap"></span><br/><div id="hez1PzwcMGDsfMT47nCi2N" class="wolai-block wolai-text"><div><span class="inline-wrap">用于向文件中写入字节数据</span></div></div><span class="inline-wrap"></span><br/><div id="6NAQe4r9kG6jmvBqydJt47" class="wolai-block wolai-text"><div><span class="inline-wrap">用于从输入流中读取对象：对象的反序列化</span></div></div><span class="inline-wrap"></span><br/><div id="bJKLNrXkHL2hixJkV7J4wF" class="wolai-block wolai-text"><div><span class="inline-wrap">ObjectOutputStream</span></div></div><span class="inline-wrap"></span><br/><div id="aHQJcrchQbipEKnCszC2au" class="wolai-block wolai-text"><div><span class="inline-wrap">用于向输出流中写入对象：对象的序列化</span></div></div><span class="inline-wrap"></span><br/><div id="mE95qi2bjf86xd2TEHaDps" class="wolai-block wolai-text"><div><span class="inline-wrap">OutputStreamWriter</span></div></div><span class="inline-wrap"></span><br/><div id="dZbtXh2UYi8zFE2cjc4Ut2" class="wolai-block wolai-text"><div><span class="inline-wrap">将字符流转为字节流，用于写入文本数据</span></div></div><span class="inline-wrap"></span><br/><div id="5pWcy4oSjMee5ytGNcy7S3" class="wolai-block wolai-text"><div><span class="inline-wrap">BufferedReader</span></div></div><span class="inline-wrap"></span><br/><div id="duGd8sWFkgrHQDW1D6RSzH" class="wolai-block wolai-text"><div><span class="inline-wrap">包装其他读取字符的输入流，提供缓冲功能，提高读取效率</span></div></div><span class="inline-wrap"></span><br/><div id="mTdi84bs9Ayw8zbZ27kXFD" class="wolai-block wolai-text"><div><span class="inline-wrap">InputStreamReader</span></div></div><span class="inline-wrap"></span><br/><div id="jhHjcNoEb8BSHjhC7oJRTP" class="wolai-block wolai-text"><div><span class="inline-wrap">将字节流转为字符流，用于读取文本数据</span></div></div><span class="inline-wrap"></span><br/><div id="ibDSCXxHGfSWoqsnwwfwuv" class="wolai-block wolai-text"><div><span class="inline-wrap">BufferedWriter</span></div></div><span class="inline-wrap"></span><br/><div id="7Esc9rzsWLwCEbGoX3qHuW" class="wolai-block wolai-text"><div><span class="inline-wrap">包装其他写入字符的输出流，提供缓冲功能，提高写入效率</span></div></div><span class="inline-wrap"></span><br/><div id="rg7xjr9knG6Ew97T1TqcTQ" class="wolai-block wolai-text"><div><span class="inline-wrap">PrintWriter</span></div></div><span class="inline-wrap"></span><br/><div id="5Tp3P7L9kYu1unzHwBdefL" class="wolai-block wolai-text"><div><span class="inline-wrap">提供了打印各种数据的便利方法</span></div></div><span class="inline-wrap"></span><br/><div id="8iaexS7rBvz7T3HbjW3xfQ" class="wolai-block wolai-text"><div><span class="inline-wrap">Scanner</span></div></div><span class="inline-wrap"></span><br/><div id="8D3KKuBembR8WMXsz5RgmX" class="wolai-block wolai-text"><div><span class="inline-wrap">用于解析原始类型和字符串的正则表达式</span></div></div><div id="ggisQWk3SjMbvNwo5Cc1oH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="awj3vfbkV3rPKvLJivkGBt" class="wolai-block"><span class="wolai-serial-number">16.3</span><span class="inline-wrap">理解</span></h2><div id="wBoEiFEQzmfe4sS8ybEfnk" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的输入流和输出流是<span class="jill"></span>I/O<span class="jill"></span>流体系的核心部分，它们分别负责数据的读取和写入。</span></div></div><h3 id="brq1273qrHt13ru4GWuujN" class="wolai-block"><span class="wolai-serial-number">16.3.1</span><span class="inline-wrap">输入流</span></h3><div id="7H1wwQ4c7PKgKroaJBUn8j" class="wolai-block wolai-text"><div><span class="inline-wrap">输入流主要用于从数据源（如文件、网络连接等）读取数据到程序中。</span></div></div><div id="9Kk482JtpF2KhyFjSB8Eir" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，输入流主要由<span class="jill"></span>InputStream<span class="jill"></span>和<span class="jill"></span>Reader<span class="jill"></span>作为基类。</span></div></div><ul class="wolai-block"><li id="g8bxNCJu9V4tSQua9SfeYX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">InputStream：基于字节的输入流接口，它是最底层的流，能处理任何类型的数据传输，包括文字、图片、视频等</span></li><li id="aciQYq86QxnHQiCNUpJg1R"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Reader：基于字符的输入操作接口，用于更高效地处理文本数据。</span></li></ul><h3 id="iaG6Pt8282CCGs4Ric8Mh7" class="wolai-block"><span class="wolai-serial-number">16.3.2</span><span class="inline-wrap">输出流</span></h3><div id="vRvsBYbHSFhfiN5KEXu5R9" class="wolai-block wolai-text"><div><span class="inline-wrap">输出流主要用于将程序中的数据写入到目标（如文件、网络连接等）。</span></div></div><div id="dJqUR3rvre3tHXAmyRLWgV" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，输出流主要由<span class="jill"></span>OutputStream<span class="jill"></span>和<span class="jill"></span>Writer<span class="jill"></span>作为基类。</span></div></div><ul class="wolai-block"><li id="vNmRCW6LQyt96B7z6NieLs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">OutputStream：基于字节的输出流接口，它同样可以处理各种类型的数据。</span></li><li id="mawYcSLPcHdcX8xbXYf7qP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Writer：基于字符的输出操作接口，专门用于文本数据的输出。</span></li></ul><div id="jXDGX4dfvp1kg9W5UCcQ4E" class="wolai-block wolai-text"><div><span class="inline-wrap">输出流也可以分为节点流和处理流，节点流直接与数据目标相连，而处理流提供了额外的功能，如压缩、序列化等。</span></div></div><div id="cNbN8z4Vz4Lmb2sc1iwgWG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7DHHvBMun2LCtc45cDC8ZE" class="wolai-block"><span class="wolai-serial-number">16.4</span><span class="inline-wrap">思维导图</span></h2><ul class="wolai-block"><li id="xbAu9fU4AAzUghBw3p8txW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">I/O<span class="jill"></span>流</span><ul class="wolai-block"><li id="9ed5YAkPzU6rk94TCZYmvk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字节流</span><ul class="wolai-block"><li id="ssxkDQ9EqUh7E8GXCQQFCz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">InputStream<span class="jill"></span>输入流</span><ul class="wolai-block"><li id="7auV8fbvAGZ6SBPaGz51y9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">FileInputStream</span><ul class="wolai-block"><li id="bcGNaZKMdQNBiR3GP2Mw1k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">从文件系统的某个文件中获得输入字节用于读取诸如图像数据之类的原始字节流</span></li></ul></li><li id="b9tn2mtQyf2hwA8NFKtovL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BufferedInputStream</span><ul class="wolai-block"><li id="6e9UZqepHdWpQCKtASa48t"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">缓冲流，InputStream<span class="jill"></span>的间接子类</span></li></ul></li></ul></li><li id="twoZKDWnDNMjkWnnMkycTE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">OutputStream<span class="jill"></span>输出流</span><ul class="wolai-block"><li id="mdwRi3HM1GGPdfKTbn4x2p"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">FileOutputStream</span><ul class="wolai-block"><li id="nENiCigRFbeiZiomdXSFWw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用于写入诸如图像数据之类的原始字节流</span></li></ul></li><li id="g7u7gSAiaCAbkBbJ2ZrDkp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BufferedOutputStream</span><ul class="wolai-block"><li id="sJ6UEX6ZnDy5sASaMLFXNU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">缓冲流，OutputStream<span class="jill"></span>的间接子类</span></li></ul></li></ul></li></ul></li><li id="bz22qTSciCHwNcFhLqYZn5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符流</span><ul class="wolai-block"><li id="uKSNswyd2fL1JFk8dgEDit"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Reader</span><ul class="wolai-block"><li id="hDU5PBuFPJJFzEiJyFkffg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">InputStreamReader</span><ul class="wolai-block"><li id="n4nNcmv8svEEhp1iq2JMXU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">转换流，字节流通向字符流的桥梁</span></li><li id="2NajWeDqpVbyG22CxYqJjT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">FileReader</span><ul class="wolai-block"><li id="q6mT1ZdpuCjHgxp2dz9TC6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读取字符文件的便捷类</span></li></ul></li></ul></li><li id="aZFMTFAxRD6gFUAd94uTMB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BufferedReader</span><ul class="wolai-block"><li id="sBEXjKPPzte67A8gctYrzz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">缓冲流，特有方法：readLine()</span></li></ul></li></ul></li><li id="23UGMXaN5S6EkM4fDLandt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Writer</span><ul class="wolai-block"><li id="gDALX1mzxHDShrm4N2p2Fi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">OutputStreamWriter</span><ul class="wolai-block"><li id="t7rJSRus7AscHdyea2bg8H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">转换流：字符流通向字节流的桥梁</span></li><li id="6TFmkHFYCkiEycSUZWoEqr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">FileWriter</span><ul class="wolai-block"><li id="69A3HMbzfz6dkCHbmzPNVa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">写入字符文件的便捷类</span></li></ul></li></ul></li><li id="hKigFq4VJHyzFf8GUQ1fcG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BufferedWriter</span><ul class="wolai-block"><li id="aQ31Q719cFbaucub2okYhR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">缓冲流，特有方法：newLine()、write(String str)</span></li></ul></li></ul></li></ul></li></ul></li></ul><div id="984e19QdAWxaYVGmUDZe31" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="jJcq6D6sooa6RiR5FN3w9V" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="p2Y5uBA3PGL42ELfn5k5xS" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">请谈谈你对反射的理解</span></h1><h2 id="bSm76TY1KDrW1mBsj4f1tT" class="wolai-block"><span class="wolai-serial-number">17.1</span><span class="inline-wrap">反射要解决的问题</span></h2><ul class="wolai-block"><li id="GCnRtgmhNiLXejCVR3uGp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">编写代码时：无法确定对象的类型</span></li><li id="jD8RUHJn9dAGvnYXXSBmzQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运行时：动态判定对象的类型</span></li></ul><div id="s6Xbq274PgTbrLsmeVtS24" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="aW7epe1JGAqPCHLx9ZmnkP" class="wolai-block"><span class="wolai-serial-number">17.2</span><span class="inline-wrap">反射的原理</span></h2><div id="qofmQ1VDKPAhtqQiHMYQMH" class="wolai-block wolai-text"><div><span class="inline-wrap">核心就一句话：类的所有信息都在它编译出的*.class<span class="jill"></span>字节码文件中，所以反射操作的起点就是读取*.class<span class="jill"></span>字节码文件</span></div></div><h3 id="4XMR4tzE66wQ2uyz8kbsj5" class="wolai-block"><span class="wolai-serial-number">17.2.1</span><span class="inline-wrap">光学中的反射</span></h3><div id="6PZCKkvJor4zEszyT4TJZ4" class="wolai-block"><figure class="wolai-center" style="width: 493px; flex-direction: column"><img src="media/image-20240328205722252.png" alt="  " style="width: 100%"/><figcaption>  </figcaption></figure></div><div id="tweSLDsLQcmM4obM8kCbyF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pcLUmqAiTiVUyNToBw5Fao" class="wolai-block"><span class="wolai-serial-number">17.2.2</span><span class="inline-wrap">Java 中的反射</span></h3><div id="saZiXLFjogUS4xqP7N5d2x" class="wolai-block"><figure class="wolai-center" style="width: 668px; flex-direction: column"><img src="media/image-20240328210252811.png" alt="  " style="width: 100%"/><figcaption>  </figcaption></figure></div><div id="h1wFctL5roCiwDHSMFuU6r" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="f8BMtvRGCDDBnfTBekFc2C" class="wolai-block"><span class="wolai-serial-number">17.3</span><span class="inline-wrap">反射的具体实现</span></h2><div id="f6qmJkZbvxwdFKnhrNQsLL" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>的反射机制实现思路主要包括以下几个关键步骤</span></div></div><h3 id="qwxR9GQkbbeBSxjVyb1GyA" class="wolai-block"><span class="wolai-serial-number">17.3.1</span><span class="inline-wrap">获取<span class="jill"></span>Class<span class="jill"></span>对象</span></h3><div id="ohtBRMwSXZENDqsNMcAVCt" class="wolai-block wolai-text"><div><span class="inline-wrap">首先，需要获取目标类的<span class="jill"></span>Class<span class="jill"></span>对象，方式很多：</span></div></div><ul class="wolai-block"><li id="2LSthG7WsTzGkvBWPmJr5K"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Class.forName(&quot;全类名&quot;)</span></li><li id="mJ2ZMph65mJDT4HGGJ3Rcq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类名.class</span></li><li id="2MKzD1xsb9iTJaMqgbbLY1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象.getClass()</span></li><li id="cWPorbNw1bPtoQTkXhZBHW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类加载器对象.loadClass(&quot;全类名&quot;)</span></li></ul><div id="dSARD3WhX5HdWQLWbVWkSi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="nfAWPHQkqL5nugX7Wpdd26" class="wolai-block"><span class="wolai-serial-number">17.3.2</span><span class="inline-wrap">分析类信息</span></h3><div id="rnoEPcMKLb436tUws98maA" class="wolai-block wolai-text"><div><span class="inline-wrap">有了<span class="jill"></span>Class<span class="jill"></span>对象后，可以对类进行深入的分析，包括获取构造器、字段（属性）和
方法等信息。这些信息可以通过<span class="jill"></span>Class<span class="jill"></span>对象提供的一组反射方法来获取。</span></div></div><div id="aXrwayCXdofV6prrcWYhHt" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iXYSQcedULvc7759xkjnGC" class="wolai-block"><span class="wolai-serial-number">17.3.3</span><span class="inline-wrap">动态操作类</span></h3><div id="ixZn1HX5SafmvrXqxZ94Kj" class="wolai-block wolai-text"><div><span class="inline-wrap">根据获取到的类信息，可以进行动态的操作，如创建对象实例、访问和修改字段值、调用方法等。</span></div></div><div id="uUdYwmp5Qy5qsgVFwFPgAj" class="wolai-block wolai-text"><div><span class="inline-wrap">这些操作可以通过反射<span class="jill"></span>API<span class="jill"></span>提供的方法来实现。</span></div></div><div id="mobA7qgVLvnoUM9gDuukwY" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="a5R7GgRD74DygDiHfV5oKC" class="wolai-block"><span class="wolai-serial-number">17.3.4</span><span class="inline-wrap">异常处理</span></h3><div id="h2VpsejLhz2FqKMyWe5NXQ" class="wolai-block wolai-text"><div><span class="inline-wrap">在反射操作过程中，可能会遇到各种异常情况，如类未找到、方法不存在、访问权限不足等。</span></div></div><div id="39sg7Jwajq5R1Hd9cZJCpx" class="wolai-block wolai-text"><div><span class="inline-wrap">因此，需要对异常情况进行捕获和处理。</span></div></div><div id="2c5D8eGzcSYjhx99EGVRdx" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bL2d9ACjHpbAFF6P7rNwzd" class="wolai-block"><span class="wolai-serial-number">17.3.5</span><span class="inline-wrap">性能优化（可选）</span></h3><div id="6BLLjLaGb23Bv93oSNGi4Z" class="wolai-block wolai-text"><div><span class="inline-wrap">反射操作相比直接调用方法通常会有一定的性能开销。</span></div></div><div id="4MFhvCn6exacrvu1gKxKXg" class="wolai-block wolai-text"><div><span class="inline-wrap">如果性能是一个关键因素，可以考虑使用缓存或其他优化技术来提高反射操作的性能。
</span></div></div><div id="bQxYDhE1n3xwN278jYSLAF" class="wolai-block wolai-text"><div><span class="inline-wrap">总之<span class="jill"></span>Java<span class="jill"></span>的反射机制实现思路是通过获取目标类的 Class 对象，然后利用反射<span class="jill"></span>API<span class="jill"></span>提供的方法来分析和操作类及其成员。</span></div></div><div id="np8LNVrA4zFb6jKVutKiQP" class="wolai-block wolai-text"><div><span class="inline-wrap">这种机制使得<span class="jill"></span>Java<span class="jill"></span>程序可以在运行时具有更高的灵活性和动态性。</span></div></div><div id="seyz5vdoDcsUSMUGiGPd5d" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="q8Y6o71PE1aZeLwhfmd6RT" class="wolai-block"><span class="wolai-serial-number">17.4</span><span class="inline-wrap">示例</span></h2><code-block id="8xM3XcVhd3DKwuMBx7L97c" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>reflective</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Constructor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * @Author huzhongkui
 * @Date 2023--09--19:10:30
 * 聪明出于勤奋,天才在于积累
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectiveDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1.获取任意一个对象所属的类</span>
            <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token punctuation">></span></span> aClass1 <span class="token operator">=</span> student<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 2.构造任意一个类对象</span>
            <span class="token class-name">Student</span> student1 <span class="token operator">=</span> aClass1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 3.获取任意一个类中的构造方法</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> aClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"se.reflective.Student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> declaredConstructor <span class="token operator">:</span>
                    aClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Object</span> instance <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            <span class="token comment">// 4. 获取任意一个类中的方法</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> declaredMethod <span class="token operator">:</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Student类中的方法:"</span> <span class="token operator">+</span> declaredMethod<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            <span class="token comment">// 5. 获取任意一个类中的成员变量</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> declaredField <span class="token operator">:</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Student类中的成员变量"</span> <span class="token operator">+</span> declaredField<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            <span class="token comment">// 6.调用任意一个对象的方法</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><div id="wFC2aS8qNRfSeoEMkGJYpZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="4bsx3ibTT2qVeq61gFMz4x" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div><h1 id="upRYau9Z4d3Jn5fqi9VMSx" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">深拷贝和浅拷贝</span></h1><h2 id="jD5n5FnMJtTwtsFDMx345x" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">背记</span></h2><ul class="wolai-block"><li id="uTAFDm4UZ5AYdzpQUECLXm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">相同点：</span><ul class="wolai-block"><li id="dwrSuqnm8iqfWn9Ckjx8Hg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">都需要创建新对象</span></li><li id="q1XbimG4k3DBiFc1KpDjb5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原对象的基本数据类型属性都是复制值本身</span></li></ul></li><li id="5aaKbUrqGJ9N6yzS9poyM9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不同点：对象的引用类型属性不一样</span><ul class="wolai-block"><li id="97Mi8ABHjm669Ss9HBjodS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">浅拷贝：复制对象地址</span></li><li id="bEaC7sjXg1HGDucphkKTLW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">深拷贝：创建新对象，给每个属性复制内容，其内容如果还是引用类型则递归操作</span></li></ul></li></ul><div id="be2JUnXpTHnRuDzPuP7Bxw" class="wolai-block"><figure class="wolai-center" style="width: 959.3333333333334px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="j8Ddc5HJs9PtzFsMy8f15E" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kojTZx94bZbrGd9bb3Z8tu" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">注意</span></h2><div id="2eKK6xT4TNtJFxDKbiM5Xe" class="wolai-block wolai-text"><div><span class="inline-wrap">深拷贝涉及到引用类型时，会创建新对象，所以复制之后会得到多个副本，修改任何一个副本都不影响其它副本</span></div></div><div id="9jS41RZYPU2kWHeaWJDbHJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oH2efQ8NVskAgUmv4K5Qoj" class="wolai-block"><span class="wolai-serial-number">18.3</span><span class="inline-wrap">应用场景</span></h2><ul class="wolai-block"><li id="hhxZN97BYcrFB59pjPcYfe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">浅拷贝：可以共享内部引用时使用</span></li><li id="ormitPQkGCH2eJ5N1mX9h3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">深拷贝：不能共享内部引用时使用</span></li></ul><div id="hHRFt7oJ3cXp7sqXNpxRpB" class="wolai-block wolai-text"><div></div></div><div id="vksHNHdRY8Nwn6ei78EshP" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">                   </span><br/></div></div></article><footer></footer></body></html>