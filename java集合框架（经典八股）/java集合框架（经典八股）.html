<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>Java集合框架（经典八股） - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="Java集合框架（经典八股）" class="main-title"></div></div></header><article><h1 id="aEvjfHzy2k6QrE4X3uB7PH" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">Java<span class="jill"></span>集合框架是什么?说出集合框架的一些优点?</span></h1><div id="5iabAjezp2NP6Fo3ycPooz" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>集合框架（Collection Framework）是一组用于存储和操作对象的类和接口的集合</span></div></div><div id="JEqg5q9ur6WT6qqVXe4Yb" class="wolai-block wolai-text"><div><span class="inline-wrap">集合框架的应用场景非常广泛，具体有<span class="jill"></span>List、Set、Map<span class="jill"></span>接口及其实现类：</span></div></div><h2 id="iYswJzogBPwgug5DxyaPDk" class="wolai-block"><span class="wolai-serial-number">1.1</span><span class="inline-wrap">List<span class="jill"></span>集合</span></h2><div id="qH5gzud1wV4KBsTihgkkTf" class="wolai-block wolai-text"><div><span class="inline-wrap">适用于需要保持元素插入顺序的场景，如学生的成绩列表，或者任何需要有序且允许重复元素的集合。</span></div></div><h2 id="6EQyFAWGp1SK56E11iY1Uf" class="wolai-block"><span class="wolai-serial-number">1.2</span><span class="inline-wrap">Set<span class="jill"></span>集合</span></h2><div id="o4QjYAE2JpPZJAKtnnoqLH" class="wolai-block wolai-text"><div><span class="inline-wrap">适用于需要存储唯一元素的场景，如学生学号的集合，确保每个学生都有一个唯一的标识。</span></div></div><h2 id="7inqvN5EwT4gtDMJ2Kei1z" class="wolai-block"><span class="wolai-serial-number">1.3</span><span class="inline-wrap">Map<span class="jill"></span>集合</span></h2><div id="qEg6SJFkNVBpHbJ56rp9su" class="wolai-block wolai-text"><div><span class="inline-wrap">适用于需要通过键快速查找值的场景，如学生名册，其中学号作为键，姓名作为值，可以快速检索每个学生的信息。</span></div></div><h2 id="G5voKnTY8NXHd3FETsFc2" class="wolai-block"><span class="wolai-serial-number">1.4</span><span class="inline-wrap">优点：</span></h2><ul class="wolai-block"><li id="hVXdWVcE7EJcj3fP4iYtPJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用核心集合类降低开发成本，而非实现我们自己的集合类。</span></li><li id="3wEiWPfod5mnrRofjCLQi6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用经过严格测试的集合框架类，代码质量会得到提高。</span></li><li id="feY7fZJpDk1NKSeEk23XHg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">通过使用<span class="jill"></span>JDK<span class="jill"></span>附带的集合类，可以降低代码维护成本。</span></li><li id="cbLaVaqLviSWcE2tgyLgEs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">复用性和可操作性。</span></li></ul><div id="ouXe87cMwozS2fyowLEAZm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6vJdRQ4YXnHuTNoSg7fGdK" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/20200423210229.png" alt="  " style="width: 100%"/><figcaption>  </figcaption></figure></div><div id="2nA5pKWpdPMW5QHk9Swjtd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="8cu2cgqAvDwuopPHmNZ5Yk" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="f2tZd4fDHzcaNqu1QDSDEs" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">集合接口的常见实现类</span></h1><h2 id="dLEBmdFxJ3Ppa1NNt3Upn5" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">List<span class="jill"></span>接口的实现类</span></h2><h3 id="ta3WApBPPjJbAw6PJm7p8n" class="wolai-block"><span class="wolai-serial-number">2.1.1</span><span class="inline-wrap">背记</span></h3><div id="34achSynkiB3KhyRqbLsXR" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>接口的实现类有以下几个：</span></div></div><ul class="wolai-block"><li id="6NJ133Ba7nkb24yqcsCywQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ArrayList：基于动态数组实现，支持随机访问和快速插入、删除操作。</span></li><li id="tQjWggQBAwzWTgRhmy3mcG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedList：基于双向链表实现，支持快速插入、删除操作，但不支持高效的随机访问。</span></li><li id="3q3YZaziVBcQ5XSQpvoewR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Vector：基于数组实现，与<span class="jill"></span>ArrayList<span class="jill"></span>类似，但线程安全。</span></li><li id="nvkyYcqZL6fFAhoveB2C9r"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Stack：继承自<span class="jill"></span>Vector，表示一个后进先出（LIFO）的栈。</span></li></ul><div id="bq1XefjTb9mHYkrwue9SSP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="xeSszNeEoQKYgtyQPRWfVh" class="wolai-block"><span class="wolai-serial-number">2.1.2</span><span class="inline-wrap">理解</span></h3><h4 id="iXMmqHjEQvZXp2G9wZjixh" class="wolai-block"><span class="wolai-serial-number">2.1.2.1</span><span class="inline-wrap">ArrayList：</span></h4><div id="kEL59TSHACHanUBWxR5MuH" class="wolai-block wolai-text"><div><span class="inline-wrap">底层实现：基于动态数组实现。</span></div></div><div id="sEwFwyeua41a3NeaMkfVTb" class="wolai-block wolai-text"><div><span class="inline-wrap">特点：查询效率高，因为支持快速随机访问；增删效率相对较低，尤其是在列表中间插入或删除元素时，因为需要移动大量元素。</span></div></div><div id="9nCJ4wYcmoGjVCGHyFSxy5" class="wolai-block wolai-text"><div><span class="inline-wrap">适用场景：适合随机访问元素较多的场景。</span></div></div><div id="hxSKF6kkCcMMwzPW8nZthi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="4djX9LnhgsjcH8d3E9ude9" class="wolai-block"><span class="wolai-serial-number">2.1.2.2</span><span class="inline-wrap">LinkedList：</span></h4><div id="9unoCgTyFKH29kLH9imuyb" class="wolai-block wolai-text"><div><span class="inline-wrap">底层实现：基于双向链表实现。</span></div></div><div id="wpXFRT6X4JpAL8NoxwbL47" class="wolai-block wolai-text"><div><span class="inline-wrap">特点：在列表的两端添加或删除元素的效率高，因为只需要改变链接；查询效率较低，因为需要从头或尾遍历链表。</span></div></div><div id="nWgxCcq2A5Ndhr7p19mccb" class="wolai-block wolai-text"><div><span class="inline-wrap">适用场景：适合频繁在列表两端进行插入和删除操作的场景。</span></div></div><div id="cwHazbsxsvTEuhzoLHswPK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="c3QjD57cR3YbGA4aGq2STe" class="wolai-block"><span class="wolai-serial-number">2.1.2.3</span><span class="inline-wrap">Vector：</span></h4><div id="agVWptM27sK6YkQfeoo3Nm" class="wolai-block wolai-text"><div><span class="inline-wrap">底层实现：基于数组实现，与<span class="jill"></span>ArrayList<span class="jill"></span>类似，但<span class="jill"></span>Vector<span class="jill"></span>是线程安全的。</span></div></div><div id="jvwVJB6Tj4bSXiNq8ukBvC" class="wolai-block wolai-text"><div><span class="inline-wrap">特点：由于同步开销，性能比<span class="jill"></span>ArrayList<span class="jill"></span>低；提供了线程安全的列表操作。</span></div></div><div id="fy4K3BNqHzWeShkge9tW6d" class="wolai-block wolai-text"><div><span class="inline-wrap">适用场景：在多线程环境中需要保证线程安全的场景。</span></div></div><div id="e7UkdN3KGCaaKnKYzHUaNC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="2tx6prwqKec3BtBT73W9vx" class="wolai-block"><span class="wolai-serial-number">2.1.2.4</span><span class="inline-wrap">选择</span></h4><div id="wSmaVhk3oCEQHBvtbuQiRY" class="wolai-block wolai-text"><div><span class="inline-wrap">如果需要频繁访问列表中的某个元素，那么<span class="jill"></span>ArrayList<span class="jill"></span>可能是最佳选择；</span></div></div><div id="u2Wv9hdpbLtdhRJxa3K9vk" class="wolai-block wolai-text"><div><span class="inline-wrap">如果需要在列表的两端频繁添加或删除元素，那么<span class="jill"></span>LinkedList<span class="jill"></span>可能更合适。</span></div></div><div id="aPsAWr42sMpJBxbRn8Cwmu" class="wolai-block wolai-text"><div><span class="inline-wrap">如果需要在多线程环境中使用<span class="jill"></span>List，可以考虑使用<span class="jill"></span>Vector，因为它线程安全，尽管它的性能可能不如其他实现类。</span></div></div><div id="eiW2auvDorRXrb9kA3j4yQ" class="wolai-block wolai-text"><div><span class="inline-wrap">如果在多线程环境中需要兼顾性能和安全，那么就需要使用<span class="jill"></span>CopyOnWriteArrayList</span></div></div><div id="pbcW3g3GZkHByj4kVweyyJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="cNEEsZksXTxYvpUu5rWgHo" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">Set<span class="jill"></span>接口的实现类</span></h2><h3 id="5aYww7eXeBmQgNA4iqktCi" class="wolai-block"><span class="wolai-serial-number">2.2.1</span><span class="inline-wrap">背记</span></h3><div id="fRViVTBsEj5aMp2Mb9rQSX" class="wolai-block wolai-text"><div><span class="inline-wrap">Set<span class="jill"></span>接口的实现类有以下几个：</span></div></div><ul class="wolai-block"><li id="uTQE8WnsXfHMEGLPMY64z5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashSet：基于哈希表实现，元素无序，不允许重复。</span></li><li id="j1s9VXQX5q6yc8QFJr87nB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedHashSet：基于哈希表和链表实现，元素有序，不允许重复。</span></li><li id="fgCtjnjfZZdwvk4rkmZXtD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TreeSet：基于红黑树实现，元素有序，不允许重复。</span></li></ul><div id="2CPYze9qzCJFjtMjzr2rj5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vXsR6gcawCeSNN4tSib7pn" class="wolai-block"><span class="wolai-serial-number">2.2.2</span><span class="inline-wrap">理解</span></h3><div id="igpgRZ9DxMqfrBNqjPhE6m" class="wolai-block wolai-text"><div><span class="inline-wrap">Set<span class="jill"></span>接口的实现类及其特点具体如下：</span></div></div><h4 id="oCQGgYzdRA7hruGkPVn8Fq" class="wolai-block"><span class="wolai-serial-number">2.2.2.1</span><span class="inline-wrap">HashSet</span></h4><div id="dEb1H24tQhB86HbRQRJpES" class="wolai-block wolai-text"><div><span class="inline-wrap">基于<span class="jill"></span>HashMap<span class="jill"></span>实现，由哈希表支持。</span></div></div><div id="i8AFDVyAAK7rbrJ7HgRQKo" class="wolai-block wolai-text"><div><span class="inline-wrap">无序性：不保证集合的迭代顺序，特别是它不保证该顺序恒久不变。</span></div></div><div id="9ipRbJcwLzn1XPmzep5ioW" class="wolai-block wolai-text"><div><span class="inline-wrap">不允许重复元素：利用<span class="jill"></span>hashCode()方法和<span class="jill"></span>equals()方法来确保集合中不会有重复元素。</span></div></div><div id="gaovLwd9xnsgYLMa7nUpcs" class="wolai-block wolai-text"><div><span class="inline-wrap">性能优异：因为基于哈希表，所以具有很快的添加、删除和查找速度。</span></div></div><div id="kudxcR48mhBfnJ84gfPgsT" class="wolai-block wolai-text"><div><span class="inline-wrap">使用示例：当需要创建一个不含重复元素的集合时，通常会选择<span class="jill"></span>HashSet。</span></div></div><div id="8NPZTWnyy78dZUvvnc5R5P" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="vwmtBPn4ZGDe5Dubi29814" class="wolai-block"><span class="wolai-serial-number">2.2.2.2</span><span class="inline-wrap">LinkedHashSet</span></h4><div id="dQuMYvd44FiVK9BX7tQXJU" class="wolai-block wolai-text"><div><span class="inline-wrap">继承自<span class="jill"></span>HashSet，内部使用链表维护插入顺序。</span></div></div><div id="gXTzuLzJzTashKsLPE4pED" class="wolai-block wolai-text"><div><span class="inline-wrap">有序性：元素迭代顺序为它们被插入的顺序，或者它们最后一次被访问的顺序。</span></div></div><div id="rewKHcAEYBfLe1fF1HjR2e" class="wolai-block wolai-text"><div><span class="inline-wrap">不允许重复：与<span class="jill"></span>HashSet<span class="jill"></span>类似，通过<span class="jill"></span>hashCode()和<span class="jill"></span>equals()方法确保元素唯一性。</span></div></div><div id="epFfv6wDqbh8Qny4y7hVs9" class="wolai-block wolai-text"><div><span class="inline-wrap">适用场景：在需要保持插入顺序的场景下使用。</span></div></div><div id="wyjM3Ca9aDQWrFPB4eXbn3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="gXsnxhWjmEKEDReX6GKpXB" class="wolai-block"><span class="wolai-serial-number">2.2.2.3</span><span class="inline-wrap">TreeSet</span></h4><div id="5J74sgcPB1RHLDf3Vkz171" class="wolai-block wolai-text"><div><span class="inline-wrap">基于红黑树数据结构实现。</span></div></div><div id="92SN9uXTmdvhj4AtriduzN" class="wolai-block wolai-text"><div><span class="inline-wrap">有序性：可以确保集合元素处于排序状态，它实现了<span class="jill"></span>SortedSet<span class="jill"></span>接口。</span></div></div><div id="fWQsNTHAGmH9VgaouRXDT7" class="wolai-block wolai-text"><div><span class="inline-wrap">不允许重复：同样利用<span class="jill"></span>hashCode()方法和<span class="jill"></span>equals()方法确保无重复元素。</span></div></div><div id="49XTNijaeAhFGdaD5aFU2g" class="wolai-block wolai-text"><div><span class="inline-wrap">可自定义排序规则：允许用户自定义排序规则，或要求集合内的元素类型实现<span class="jill"></span>Comparable<span class="jill"></span>接口。</span></div></div><div id="5MubESBkuYCBqDgeLcYo6d" class="wolai-block wolai-text"><div><span class="inline-wrap">使用示例：当需要对集合元素进行排序时，或需要有序且不重复的元素集合时，应使用<span class="jill"></span>TreeSet。</span></div></div><div id="r1wdZixSygeammASTtCMqz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="c1drhUTNdPWc3sM8dL9yzU" class="wolai-block wolai-text"><div><span class="inline-wrap">以上是<span class="jill"></span>Set<span class="jill"></span>接口的三个主要实现类及其特点。</span></div></div><div id="3twAHHpLQH4jtHkNfKhksD" class="wolai-block wolai-text"><div><span class="inline-wrap">在实际开发中，根据需要选择最适合的实现类非常重要。</span></div></div><div id="vJ946QmDDvaRUwtrxk2hNj" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，如果需要一个能够快速访问的无序集合，则<span class="jill"></span>HashSet<span class="jill"></span>是一个不错的选择；</span></div></div><div id="svK8GVovuKh9pGn3vgQrbg" class="wolai-block wolai-text"><div><span class="inline-wrap">如果还需要保留插入顺序，则应该考虑使用<span class="jill"></span>LinkedHashSet；</span></div></div><div id="7nTuzgLCCkSy369ZwDU2Ro" class="wolai-block wolai-text"><div><span class="inline-wrap">而如果需要集合中的元素始终保持排序状态，则<span class="jill"></span>TreeSet<span class="jill"></span>是正确的选择。</span></div></div><div id="mf3ruJPzG6RuL5fK1rQxqB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="gPhbKBndBFp1xhWXtMh6pm" class="wolai-block"><span class="wolai-serial-number">2.3</span><span class="inline-wrap">Map<span class="jill"></span>接口的实现类</span></h2><h3 id="6D12cCGE9KEZ5x7FJKiwZQ" class="wolai-block"><span class="wolai-serial-number">2.3.1</span><span class="inline-wrap">背记</span></h3><div id="a5hpWhqbSMkNasChyUJD8J" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>接口的实现类主要有以下几个：</span></div></div><ul class="wolai-block"><li id="pvqLP8rg95zZ4jTvVW5s2F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashMap：基于哈希表实现，支持快速的查找和插入操作。</span></li><li id="a8ScRXxjtHn27MwT3c7KKP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedHashMap：继承自<span class="jill"></span>HashMap，维护了元素插入的顺序。</span></li><li id="qjccLyWTR8CRUzCVJ1wvKP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TreeMap：基于红黑树实现，可以按照键的自然顺序或自定义比较器进行排序。</span></li><li id="b1gjLpcENZzPNazHzprdQ3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Hashtable：与<span class="jill"></span>HashMap<span class="jill"></span>类似，但线程安全，使用<span class="jill"></span>synchronized<span class="jill"></span>关键字保证同步。</span></li><li id="mRnNWfRnyLTUTsNCbCsPu9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ConcurrentHashMap：是线程安全的<span class="jill"></span>HashMap<span class="jill"></span>实现，支持高并发访问。</span></li></ul><div id="rMmF9nGJg6yKjoXNvLw17Z" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5sYg2u7MgPHEN1Dt59cr6r" class="wolai-block"><span class="wolai-serial-number">2.3.2</span><span class="inline-wrap">理解</span></h3><div id="41R5LM31kBMuXtGWWXJSXt" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>接口的各个实现类在不同维度上的特点如下：</span></div></div><h4 id="sN5Zwsp8Sf5gnRZYebnTzB" class="wolai-block"><span class="wolai-serial-number">2.3.2.1</span><span class="inline-wrap">HashMap</span></h4><div id="4C152me4zuti7svhr5yuzi" class="wolai-block wolai-text"><div><span class="inline-wrap">存储结构：基于散列表（哈希表）实现。</span></div></div><div id="gA75QBi1ye3LWeJGfgQ5Hp" class="wolai-block wolai-text"><div><span class="inline-wrap">排序：无序，不保证映射的迭代顺序。</span></div></div><div id="69T2vTM4aPxrRDNWcCzKgy" class="wolai-block wolai-text"><div><span class="inline-wrap">同步：非线程安全，高效的单线程访问。</span></div></div><div id="hjPq1r5PAPXoBo8k1T9vRz" class="wolai-block wolai-text"><div><span class="inline-wrap">性能：通常具有较高的存取效率，但在大量元素时可能出现哈希冲突。</span></div></div><div id="wx6J2p9w6vuVBtuYBw7bpc" class="wolai-block wolai-text"><div><span class="inline-wrap">允许空值：允许一个键对应<span class="jill"></span>null<span class="jill"></span>值，但不允许多个键相同。</span></div></div><div id="p7eBU4J78VVaQ6eHbSjFNY" class="wolai-block wolai-text"><div><span class="inline-wrap">典型用途：在没有特殊排序或同步需求时使用。</span></div></div><div id="jfYy2KKPYSK5bEyJYkbNQh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="cN441BnwLqwYFCotj1fbWN" class="wolai-block"><span class="wolai-serial-number">2.3.2.2</span><span class="inline-wrap">LinkedHashMap</span></h4><div id="7oZGvPXQ8o8XUAk7RmJibo" class="wolai-block wolai-text"><div><span class="inline-wrap">存储结构：基于哈希表和双向链表实现。</span></div></div><div id="gDFLxKFiGiCapunfXQdNDY" class="wolai-block wolai-text"><div><span class="inline-wrap">排序：保持插入顺序或访问顺序（取决于构造参数）。</span></div></div><div id="8cSgqKFyRXqtBmC26SuPi2" class="wolai-block wolai-text"><div><span class="inline-wrap">同步：非线程安全。</span></div></div><div id="68tAvNJT8X5j9x3SVBM235" class="wolai-block wolai-text"><div><span class="inline-wrap">性能：相对于<span class="jill"></span>HashMap，插入和迭代速度略慢，但仍具有较好的存取效率。</span></div></div><div id="u1F44QFi6DpGqN4pWSwFkA" class="wolai-block wolai-text"><div><span class="inline-wrap">允许空值：允许一个键对应<span class="jill"></span>null<span class="jill"></span>值，但不允许多个键相同。</span></div></div><div id="g6dDDpTKxeWGQVAqP9HgXo" class="wolai-block wolai-text"><div><span class="inline-wrap">典型用途：需要保持元素插入顺序的场景。</span></div></div><div id="tksjawRCjQfSbL1EFBd5we" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="nFqaLzs85D25AFmXMUQvaX" class="wolai-block"><span class="wolai-serial-number">2.3.2.3</span><span class="inline-wrap">TreeMap</span></h4><div id="cJR5KH4DYKbmqX5X9Fy2xw" class="wolai-block wolai-text"><div><span class="inline-wrap">存储结构：基于红黑树（一种自平衡二叉搜索树）实现。</span></div></div><div id="oqDfbcbagmUJHj3USNSDYj" class="wolai-block wolai-text"><div><span class="inline-wrap">排序：根据键的自然顺序或者自定义比较器进行排序。</span></div></div><div id="j18xrw5dHnrDBiZvgsjNXS" class="wolai-block wolai-text"><div><span class="inline-wrap">同步：非线程安全。</span></div></div><div id="4MAwQNTyuV1boqvdWwQ8x5" class="wolai-block wolai-text"><div><span class="inline-wrap">性能：插入、删除和查找操作的时间复杂度为<span class="jill"></span>O(log n)。</span></div></div><div id="bNY6APuvEefCtdCw3dMus9" class="wolai-block wolai-text"><div><span class="inline-wrap">允许空值：允许一个键对应<span class="jill"></span>null<span class="jill"></span>值，但不允许多个键相同。</span></div></div><div id="6BSqJBX5sXF6pdbUB5ZyWK" class="wolai-block wolai-text"><div><span class="inline-wrap">典型用途：需要对键进行排序或有序遍历的场景。</span></div></div><div id="5wr3bmww3H7QcXD6sx6zkM" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="auuPPYBfeQ1c72ARVXUokN" class="wolai-block"><span class="wolai-serial-number">2.3.2.4</span><span class="inline-wrap">Hashtable</span></h4><div id="7TuE3nRJCka8kMpMRar4q5" class="wolai-block wolai-text"><div><span class="inline-wrap">存储结构：基于散列表实现。</span></div></div><div id="seHwwXz64iSHH8t6Cm1RYj" class="wolai-block wolai-text"><div><span class="inline-wrap">排序：无序，不保证映射的迭代顺序。</span></div></div><div id="mEcwSau3aaJDUqsMg1g2m1" class="wolai-block wolai-text"><div><span class="inline-wrap">同步：线程安全，所有公共操作都是同步的。</span></div></div><div id="kL3jANf3Zu3oiT2jJsGsY6" class="wolai-block wolai-text"><div><span class="inline-wrap">性能：由于同步，多线程环境下表现良好，但单线程效率较低。</span></div></div><div id="ahEo4W8Mgaxdk8J4SBWq73" class="wolai-block wolai-text"><div><span class="inline-wrap">允许空值：不允许键和值为<span class="jill"></span>null。</span></div></div><div id="tkchhtZhSvZ12mMAWGYDPy" class="wolai-block wolai-text"><div><span class="inline-wrap">典型用途：需要线程安全的<span class="jill"></span>Map<span class="jill"></span>实现。</span></div></div><div id="mY9h6yyMkt9wUcztgunKRQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="tLb4xCuatPDKDjpzGtTDXL" class="wolai-block"><span class="wolai-serial-number">2.3.2.5</span><span class="inline-wrap">ConcurrentHashMap</span></h4><div id="hijt7HV8u7KHHnZRPV42ow" class="wolai-block wolai-text"><div><span class="inline-wrap">存储结构：基于分段锁的散列表实现。</span></div></div><div id="6BZ4CFVXS4FQavQSuBHi6E" class="wolai-block wolai-text"><div><span class="inline-wrap">排序：无序，不保证映射的迭代顺序。</span></div></div><div id="4zP6PWTxsZFBKzmaFkyAhS" class="wolai-block wolai-text"><div><span class="inline-wrap">同步：线程安全，高效并发访问。</span></div></div><div id="wpWrJLAQmrJdjcRerFm15T" class="wolai-block wolai-text"><div><span class="inline-wrap">性能：在高并发环境下提供比<span class="jill"></span>Hashtable<span class="jill"></span>更好的性能。</span></div></div><div id="9M7Huvqts47chMAY491va" class="wolai-block wolai-text"><div><span class="inline-wrap">允许空值：允许一个键对应<span class="jill"></span>null<span class="jill"></span>值，但不允许多个键相同。</span></div></div><div id="5AWX87jyAKRdkQwHJCxcvD" class="wolai-block wolai-text"><div><span class="inline-wrap">典型用途：高并发环境下需要高性能的场景。</span></div></div><div id="mHDCKRPQn4nnfC8X1KYok4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="eoXZHhQSUZAAtEmSpC7zn3" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="oY4uGWQVQUeyq9LK3sewQm" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">List<span class="jill"></span>和<span class="jill"></span>Map<span class="jill"></span>区别?</span></h1><h2 id="8fgSDGST9PVXdaUN1q9bwA" class="wolai-block"><span class="wolai-serial-number">3.1</span><span class="inline-wrap">背记</span></h2><h3 id="8mGsMqxGtAVVobAA2diCyn" class="wolai-block"><span class="wolai-serial-number">3.1.1</span><span class="inline-wrap">存储结构</span></h3><div id="dpVPrDSXbBvkyFtqciD3qi" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>是单列数据集合，用于存储一系列有序的对象，而<span class="jill"></span>Map<span class="jill"></span>是双列数据集合，通过键值对（Key-Value）来存储数据。</span></div></div><div id="a6426RjXo4yaBe3QiN8Xna" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="2SRGzsynpwRSR5z56X5vFD" class="wolai-block"><span class="wolai-serial-number">3.1.2</span><span class="inline-wrap">元素唯一性</span></h3><div id="mDP4D7PwCu9yghKtECPw2Q" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>允许元素重复，即可以有多个相同的元素存在于列表中。</span></div></div><div id="PaNwDtRV5vPimU7VDowZw" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>中的键（Key）必须是唯一的，不允许有重复的键存在，但值（Value）可以重复。</span></div></div><div id="2r5kRpu3qSDD3kvhMa6aoa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iR2rHJC85BLHL427YPWnEE" class="wolai-block"><span class="wolai-serial-number">3.1.3</span><span class="inline-wrap">顺序性</span></h3><div id="3AndqNss1bV1W7RzaoUppc" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>中的元素是有序的，元素的插入顺序会被保留。</span></div></div><div id="5CMdnrDdyHtJDB9RbyPn4c" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>中的元素是无序的，它不保证键值对的存储顺序</span></div></div><div id="fmqcYjrR818FyuCYHPScEH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dnWbzPPUnNqnodXhNebR9c" class="wolai-block"><span class="wolai-serial-number">3.2</span><span class="inline-wrap">理解</span></h2><div id="wzrhNBGU9SNs3dBJkqJi8T" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>和<span class="jill"></span>Map<span class="jill"></span>在<span class="jill"></span>Java<span class="jill"></span>集合框架中是两种非常常用的数据结构，它们在存储结构、元素唯一性、排序特点和使用场景方面存在区别。</span></div></div><div id="c16RDsDEcn2tPorT5C21z3" class="wolai-block wolai-text"><div><span class="inline-wrap">具体分析如下</span></div></div><h3 id="58KDKP2psFUuGaZAAAmgeK" class="wolai-block"><span class="wolai-serial-number">3.2.1</span><span class="inline-wrap">存储结构</span></h3><div id="ag2F3oNCZVBLaiCwGVbiSd" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>是单列数据集合，用于存储一系列有序的对象。它允许存储重复的元素，并且可以通过索引直接访问元素。</span></div></div><div id="bLkGACbFvW3yfHnrvh4jkL" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>Map<span class="jill"></span>是一种关联数组结构，它通过键值对（Key-Value）来存储数据，其中键是唯一的，不能重复，但值可以重复。</span></div></div><div id="5fnzqFc7UYe4AS1uCZop1a" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="a3MyQCv6MZc6XxQF2c7yTJ" class="wolai-block"><span class="wolai-serial-number">3.2.2</span><span class="inline-wrap">元素唯一性</span></h3><div id="wfticNaeknANF29aDTvf7W" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>List<span class="jill"></span>中，元素是可以重复的，即可以有多个相同的元素存在于列表中。</span></div></div><div id="cntrovu8yDvchMdN74GzTZ" class="wolai-block wolai-text"><div><span class="inline-wrap">而在<span class="jill"></span>Map<span class="jill"></span>中，键（Key）必须是唯一的，不允许有重复的键存在。</span></div></div><div id="5p5pFvofs1AELTvFHfaTLa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="99RJ5SZmqhKTKF1WjAPvbp" class="wolai-block"><span class="wolai-serial-number">3.2.3</span><span class="inline-wrap">排序特点</span></h3><div id="7eEyfg7j7tD7aSghA4w5E1" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>中的元素是有序的，元素的插入顺序会被保留。</span></div></div><div id="rxfZDL87LizVG6hKs54KNM" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>中的元素是无序的，它不保证键值对的存储顺序。</span></div></div><div id="2D7kuLBVbsq34YcipgGymS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="cuKN1Ad7V8VTYTw8m8CZNr" class="wolai-block"><span class="wolai-serial-number">3.2.4</span><span class="inline-wrap">使用场景</span></h3><div id="hKvmE7KhT3EicDLvBUivBN" class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>通常用于存储一组相关的对象，如名单、待办事项列表等，需要按照特定的顺序进行访问和处理。</span></div></div><div id="wqsCe8nSYN5i5zWp12DKHS" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>则适用于需要通过一个特定键来快速查找、插入或删除值的场景，如字典、数据库表等。</span></div></div><div id="eJz7VxFxSkMWdZC7C5LQR2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="9kzuq5oPoYGvbKEirKiyRZ" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，List<span class="jill"></span>以线性方式存储数据，强调的是元素的顺序和重复性；</span></div></div><div id="qEvVRDQ3Ge9YqhCi3uA3Wc" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>Map<span class="jill"></span>通过键值对的方式存储数据，强调的是键的唯一性和快速检索。</span></div></div><div id="7Yehu8z6zrGH1vK5b3fJxe" class="wolai-block wolai-text"><div><span class="inline-wrap">在实际开发中，选择<span class="jill"></span>List<span class="jill"></span>还是<span class="jill"></span>Map<span class="jill"></span>取决于具体的数据结构和应用场景。</span></div></div><div id="mQGafXqvR8iffTZZJCLHW6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="vqmXDCBzkdNnJRSWLBYwwW" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="2CPifpBP2cjwxf9yvzTHNK" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">List、Map、Set<span class="jill"></span>三个接口，存取元素时，各有什么特点?</span></h1><h2 id="9KeTtAhWRBTkrC6iUe4PpK" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">背记</span></h2><h3 id="tGJ8CPVpERe7PYXsgVv1dZ" class="wolai-block"><span class="wolai-serial-number">4.1.1</span><span class="inline-wrap">List</span></h3><ul class="wolai-block"><li id="2eKzYbrw4fAUrAuZWJ9TwH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存放：元素是有序的，可以重复。</span></li><li id="oy1yFpqSi2cXnz7HyYwxma"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">取出：可以通过索引直接取出元素，也可以使用<span class="jill"></span>for<span class="jill"></span>循环或<span class="jill"></span>for-each<span class="jill"></span>循环遍历。</span></li></ul><div id="7o7cR89ypcKN1n9P6hokfv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="xdPZWKWCx9wQ2c9mp2MjAb" class="wolai-block"><span class="wolai-serial-number">4.1.2</span><span class="inline-wrap">Map</span></h3><ul class="wolai-block"><li id="c2YUUrGGdvbM4D7HHswit7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存放：以键值对的形式存放，键是唯一的且不可重复，而值可以重复。</span></li><li id="pWd3SVhhNUzctsik23LTB5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">取出：通过键来取出对应的值，键无需按顺序存放。</span></li></ul><div id="o3KTReEYowU4CZdDvTnQ6W" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="iQv3KXV4XkKk2cfJRtqX9N" class="wolai-block"><span class="wolai-serial-number">4.1.3</span><span class="inline-wrap">Set</span></h3><ul class="wolai-block"><li id="jMeun6jWebx571sB2AE1hi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存放：元素无序，不可重复。</span></li><li id="dmotWWDdkTFjuxmDTujnFg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">取出：不能通过索引取出元素，需要通过迭代器或增强<span class="jill"></span>for<span class="jill"></span>循环来遍历取出</span></li></ul><div id="rw9qmuy5y6nSgyK54rXiRr" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ck31kZFHT8WiaE9LSxkt7W" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">理解</span></h2><h3 id="5Wo4Ld3i4tE2GB6ceCQa63" class="wolai-block"><span class="wolai-serial-number">4.2.1</span><span class="inline-wrap">List 接口</span></h3><ul class="wolai-block"><li id="9DwXaTUSUbiYpwZT7VchTi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">特点：List 是一个有序的集合，可以存储重复元素。</span></li><li id="niG3ZpZnJ1cMfDeeenX4qd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实现类：常见的 List 实现类有 ArrayList、LinkedList 和 Vector。</span></li><li id="asftxbtbtNggqY5zvPXDMZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">访问方式：可以通过索引访问元素，支持根据索引进行增删改查操作。</span></li><li id="o2SiruLgakxtdVgfmwvNkn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">迭代方式：可以使用普通 for 循环、Iterator 或 foreach 进行遍历。</span></li><li id="ssXU2A3b5FgdwAg52KvoH5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">常用场景：适合需要按顺序存储元素，并且需要频繁根据索引进行操作的场景。</span></li></ul><div id="tqzHepb5M1M5SvCjR8QZSV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="oV8rE8YzKfGAjEqTe9y2UL" class="wolai-block"><span class="wolai-serial-number">4.2.2</span><span class="inline-wrap">Set 接口</span></h3><ul class="wolai-block"><li id="m72UY2sJGV9EkJoRkkbv7M"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">特点：Set 是一个不允许重复元素的集合，保证集合中的元素是唯一的。</span></li><li id="2eRDLU6DzwAZyUNMSS3y8K"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实现类：常见的 Set 实现类有 HashSet、LinkedHashSet 和 TreeSet。</span></li><li id="uELghtmiV9WYa6hoifzVKs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">无序性：Set 不保证元素的顺序，具体的顺序取决于具体的实现类。</span></li><li id="fXMHnxotGhtPrWYywydBda"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">添加元素：向 Set 添加重复元素时，只会保留一个副本。</span></li><li id="5HSjuYn9376ghq38LeRcou"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">常用场景：适合需要保证元素唯一性的场景，不关心元素的顺序。</span></li></ul><div id="bvwQdj29dpifiTVwxGQ8qC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="mzth34UpKJj1poNS2R7rTY" class="wolai-block"><span class="wolai-serial-number">4.2.3</span><span class="inline-wrap">Map 接口</span></h3><ul class="wolai-block"><li id="e9bPn2UjaHUuPnMpFEmw7B"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">特点：Map 是一种键值对的集合，每个键对应一个值，键是唯一的。</span></li><li id="ikWbybRBsyMXguuwfsn8V4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实现类：常见的 Map 实现类有 HashMap、LinkedHashMap、TreeMap 和 ConcurrentHashMap</span></li><li id="6BM9oVg7UCJCKcB19bsW82"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">访问方式：通过键来访问值，支持根据键进行增删改查操作。</span></li><li id="iA7XM6rnBWfrW8Xxgb3krn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">常用方法：包括 put(key, value)、get(key)、containsKey(key) 等。</span></li><li id="dKddJnt3Dk9LWSzaVCd4S2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">常用场景：适合需要根据键快速查找值的场景，如存储配置信息、缓存等。</span></li></ul><div id="dqQJdzRBQaXwDZUMz1Si6d" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="su2sHcfs5B6GfdYaXMF7nz" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，List 适合有序存储、允许重复元素的场景；Set 适合保证元素唯一性的场景；Map 适合</span></div></div><div id="4je8eMRKcbFfgg2aj96z4u" class="wolai-block wolai-text"><div><span class="inline-wrap">键值对存储、根据键快速查找值的场景。开发人员在选择使用时应根据实际需求和数据特点来灵活</span></div></div><div id="kFyZ3UKTua6x7ZVA5Cg7r2" class="wolai-block wolai-text"><div><span class="inline-wrap">选取适合的集合类型。</span></div></div><div id="6DDp1EqeFEQE5PoD3Np3oH" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><div id="rMxXyzmvW5HJz3w1yQ7UiL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="gk7LjGrz6Jz23xiNKJ2DDr" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">为什么<span class="jill"></span>Map<span class="jill"></span>接口不继承<span class="jill"></span>Collection<span class="jill"></span>接口？</span></h1><h2 id="mN4CqrBci7VcdPvEMB9jwk" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">背记</span></h2><h3 id="jL4FapeP5ta9sVUtzSEkRY" class="wolai-block"><span class="wolai-serial-number">5.1.1</span><span class="inline-wrap">数据结构不同</span></h3><ul class="wolai-block"><li id="2h7x8XbHg9QFPLj4a93F86"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Map<span class="jill"></span>集合：提供的是键值对映射，即每个元素由一个键（Key）和一个值（Value）组成</span></li><li id="hnzYJ9iY8dczrR4dAugLA9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Collection<span class="jill"></span>集合：提供的是一组数据，这些数据没有键值对的结构</span></li></ul><div id="sfDmdZuw2zqYcNDn112mY2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kt33CC6DTBgg3tLwCw8Xc2" class="wolai-block"><span class="wolai-serial-number">5.1.2</span><span class="inline-wrap">操作方式不同</span></h3><ul class="wolai-block"><li id="mivFawB2CnuGJynUJTyCxm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Map<span class="jill"></span>集合：检索元素时，是通过给出键对象来返回对应的值对象</span></li><li id="48y4DAveUPVf9m7rCHATYY"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Collection<span class="jill"></span>集合：直接对元素进行操作</span></li></ul><div id="qgX9ep8NpTgPKgoi2ko2cq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kxR2Ge2MW8qoFz4imWjbb7" class="wolai-block"><span class="wolai-serial-number">5.1.3</span><span class="inline-wrap">违反接口分离原则</span></h3><div id="qT7ZsmMcgzVxaxnDkfoq7C" class="wolai-block wolai-text"><div><span class="inline-wrap">接口的设计应该遵循最小化，不应该把用户不使用的方法塞进同一个接口里，每个接口应该只包含一个职责，即一组相关的操作</span></div></div><div id="mpdbFqCmi5xztRxQ6Rx2YA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mFYjyz4V2ggWL5aHkmsBmf" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">理解</span></h2><h3 id="6kWFezz3s3rie812UxWucX" class="wolai-block"><span class="wolai-serial-number">5.2.1</span><span class="inline-wrap">设计原则</span></h3><div id="q5Mq4rPhz7733BGvCAF9GH" class="wolai-block wolai-text"><div><span class="inline-wrap">根据接口分离原则，接口应该细化并只提供客户端所需的方法</span></div></div><div id="rJi955vskwYfNrudwtVQ7U" class="wolai-block wolai-text"><div><span class="inline-wrap">如果一个接口提供了许多方法，而这些方法对于某些客户端来说是不必要的，那么这些客户端就不得不实现它们不需要的方法</span></div></div><div id="3EsqVqXJR98YMMQu6qHiBa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="254ThKwJfuKV24K7s6JP1H" class="wolai-block"><span class="wolai-serial-number">5.2.2</span><span class="inline-wrap">设计实践</span></h3><div id="2bkH5sRQTCTEfPTfxfWXh2" class="wolai-block wolai-text"><div><span class="inline-wrap">在设计时，采用多个与特定客户类有关的接口比采用一个通用的接口要好</span></div></div><div id="q6N5hDQP7spuxEcoscE8Ef" class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为不同的客户端可能需要不同的方法集合，通过分离接口可以确保每个客户端只依赖于它实际需要的方法</span></div></div><div id="d1VKy2usPNo2xcAfAiztZ4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="nC3hNXZyru6QwNdCAt9AYo" class="wolai-block"><span class="wolai-serial-number">5.2.3</span><span class="inline-wrap">设计问题</span></h3><div id="k4Prz9qXMzzwQNipmfWgP3" class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>Map<span class="jill"></span>继承了<span class="jill"></span>Collection<span class="jill"></span>接口，那么所有实现了<span class="jill"></span>Map<span class="jill"></span>接口的类也将隐式地继承<span class="jill"></span>Collection<span class="jill"></span>接口的所有方法</span></div></div><div id="cQjzgSDAKXnHX4ct8PUHrp" class="wolai-block wolai-text"><div><span class="inline-wrap">这会导致一些问题，比如类的接口定义暴露了过多的行为，内聚程度不够好</span></div></div><div id="aceMEFfCcxP4U5suAidRXz" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><div id="jHC4yRBTRYpJb5gu2KShUD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="cepaVHgBpjX4U6ayVZHM5e" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">Iterator<span class="jill"></span>和<span class="jill"></span>ListIterator<span class="jill"></span>之间有什么区别?</span></h1><h2 id="focaYuDSmnJDb75MtTb5kC" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">背记</span></h2><div id="cMrZXYLZV6LNSimjdjxiog" class="wolai-block wolai-text"><div><span class="inline-wrap">Iterator<span class="jill"></span>和<span class="jill"></span>ListIterator<span class="jill"></span>都是<span class="jill"></span>Java<span class="jill"></span>集合框架中用于遍历集合的接口</span></div></div><div id="gU4Ce8JeGLcHJnJHckZYut" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9xf2h1KTJEXxNG1bhsU4N9" class="wolai-block"><span class="wolai-serial-number">6.1.1</span><span class="inline-wrap">使用范围</span></h3><ul class="wolai-block"><li id="t6kgs2tmyY3UdJmbnF3zCE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Iterator：用于遍历所有<span class="jill"></span>Collection<span class="jill"></span>类型的集合，包括<span class="jill"></span>Set<span class="jill"></span>和<span class="jill"></span>List</span></li><li id="vR3HuAqcVqzNiD7N8PAbtX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator：专门用于遍历<span class="jill"></span>List<span class="jill"></span>类型的集合</span></li></ul><div id="bUUcr33SJcyDMCH1iKPFWi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="nTRwUAkcjD3QoZx8HDrw6q" class="wolai-block"><span class="wolai-serial-number">6.1.2</span><span class="inline-wrap">功能</span></h3><ul class="wolai-block"><li id="qST6Y1JTJh1xt97JCepwCK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator<span class="jill"></span>比<span class="jill"></span>Iterator<span class="jill"></span>拥有更多的功能。</span></li><li id="4ZxqbvxFeV1HRW2xSBvhXn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator<span class="jill"></span>可以双向遍历列表，即可以向前也可以向后移动，而<span class="jill"></span>Iterator<span class="jill"></span>只能单向遍历，即只能向前移动。</span></li></ul><div id="4C48MBR2w6ajX2fTgXvU63" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jcEBBXqvWqgMjsVTLKoj7C" class="wolai-block"><span class="wolai-serial-number">6.1.3</span><span class="inline-wrap">操作</span></h3><div id="mdmPnwbfZyNAMpFj6uLKyP" class="wolai-block wolai-text"><div><span class="inline-wrap">ListIterator<span class="jill"></span>可以在遍历过程中进行安全的修改操作，如添加、设置和获取列表中的元素。Iterator<span class="jill"></span>则没有这些额外的操作。</span></div></div><div id="f1MRAPGGPNsdrrM6CaNghW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="iCBWgo1KbsyGVhwve9VxbQ" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">理解</span></h2><div id="ugKp31rV8vYsNiffVR3sTe" class="wolai-block wolai-text"><div><span class="inline-wrap">Iterator<span class="jill"></span>和<span class="jill"></span>ListIterator<span class="jill"></span>都是用于遍历集合的接口，但它们在遍历方向、修改元素、使用范围以及索引定位方面存在差异。</span></div></div><div id="fHFYowutuCKRVnjCTxo87z" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="fZq22bme6FizChvsMkbnjA" class="wolai-block"><span class="wolai-serial-number">6.2.1</span><span class="inline-wrap">遍历方向</span></h3><ul class="wolai-block"><li id="dMSBNFG5EzSnrHaGutwdcS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Iterator<span class="jill"></span>只能实现向前遍历集合，即从集合的第一个元素到最后一个元素的顺序遍历。</span></li><li id="4RNPsJr1E7RQ7Rz2cYs5oe"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator<span class="jill"></span>不仅可以向前遍历，还可以向后遍历集合，即可以从最后一个元素反向遍历到第一个元素。</span></li></ul><div id="d4DdWcrvXjJ2JgpKft7qEm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="j73na9xnNtbUtDk789A3Xu" class="wolai-block"><span class="wolai-serial-number">6.2.2</span><span class="inline-wrap">修改元素</span></h3><ul class="wolai-block"><li id="dH4ZcyKHmZBqGT37aSBvZ5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Iterator<span class="jill"></span>只能遍历集合，不支持修改和添加元素的操作。</span></li><li id="nfsJEyrmGJNgR6CWqqeJNH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator<span class="jill"></span>可以在遍历过程中进行安全的修改操作，如添加、设置和获取列表中的元素。</span></li></ul><div id="8kr7UCeVDWduaD3PHP5x2T" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9W7AJFVYK3bAippzRAP1LK" class="wolai-block"><span class="wolai-serial-number">6.2.3</span><span class="inline-wrap">使用范围</span></h3><ul class="wolai-block"><li id="uZAvFW2is46KTh8kA7v9Jm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Iterator<span class="jill"></span>可以应用于所有的<span class="jill"></span>Collection<span class="jill"></span>集合，包括<span class="jill"></span>Set、List<span class="jill"></span>和<span class="jill"></span>Map<span class="jill"></span>及其子类型</span></li><li id="dv48NJHRK3pfdZD7LEAmV1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ListIterator<span class="jill"></span>只能用于<span class="jill"></span>List<span class="jill"></span>及其子类型</span></li></ul><div id="bWQ2XNKxMBRF331f17B4qf" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jAXHVCwsfrvVWYmqW31cYY" class="wolai-block"><span class="wolai-serial-number">6.2.4</span><span class="inline-wrap">索引定位</span></h3><div id="poRxJZGz5dfaNR8ymghjPe" class="wolai-block wolai-text"><div><span class="inline-wrap">ListIterator<span class="jill"></span>可以定位当前索引的位置，通过<span class="jill"></span>nextIndex()和<span class="jill"></span>previousIndex()方法可以实现。</span></div></div><div id="b7944hFVVy6d664qxgSkgU" class="wolai-block wolai-text"><div><span class="inline-wrap">Iterator<span class="jill"></span>没有此功能。</span></div></div><div id="x2cDbqfkzERY6Em6KjzUQF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="bXzkPUjyTfjmnT6hDXm9gb" class="wolai-block wolai-text"><div><span class="inline-wrap">总结来说，ListIterator<span class="jill"></span>提供了比<span class="jill"></span>Iterator<span class="jill"></span>更丰富的功能，尤其是在遍历<span class="jill"></span>List<span class="jill"></span>时，它能够提供更多的操作和灵活性。</span></div></div><div id="pgch44GRSLw9UefgEVed3j" class="wolai-block wolai-text"><div><span class="inline-wrap">如果只是需要对集合进行简单的前向遍历，Iterator<span class="jill"></span>就足够了。</span></div></div><div id="jUA6ow2UYjPLuHnvCQjERH" class="wolai-block wolai-text"><div><span class="inline-wrap">而在处理<span class="jill"></span>List<span class="jill"></span>集合且需要更多控制时，应当使用<span class="jill"></span>ListIterator。</span></div></div><code-block id="sfwB2u1R5dKTU7JJL964mY" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正向遍历结果:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反向遍历结果:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIterator<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入元素："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listIterator1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
listIterator1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"7"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator1<span class="token punctuation">.</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listIterator1<span class="token punctuation">.</span><span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listIterator2 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"替换元素:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>listIterator2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> next <span class="token operator">=</span> listIterator2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        listIterator2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"155"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="7bD4weBSMXdxgaLvm8pjnu" class="wolai-block"><figure class="wolai-center" style="width: 226.66666666666666px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="k3fSiuzxtJKo1vRWwouj8b" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="8Hv5isU3TMMCCyapnjvSAW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="n8r7ZmjLKMLZrGQzJMoW2Y" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="hBPbuPCidxv2tkwjt51Yd" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">集合框架中的泛型有什么优点?</span></h1><h2 id="8N1PSU4yLMyBoS6WuwUMwS" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">背记</span></h2><h3 id="oCyQAZdLiLDPSkSirSRN91" class="wolai-block"><span class="wolai-serial-number">7.1.1</span><span class="inline-wrap">类型安全</span></h3><div id="3xnEhmYF66nCwJuPBN6F29" class="wolai-block wolai-text"><div><span class="inline-wrap">通过使用泛型，可以在编译时检查类型，确保只有正确类型的对象被添加到集合中。</span></div></div><div id="d9AVQmoapsqTgA1dKsMniJ" class="wolai-block wolai-text"><div><span class="inline-wrap">这避免了在运行时可能发生的类型转换错误。</span></div></div><div id="9n1aLR5jQkRD9XdVP3Png" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9emnY1KVxcJnRd7MydkZfR" class="wolai-block"><span class="wolai-serial-number">7.1.2</span><span class="inline-wrap">消除类型转换</span></h3><div id="qfAd6oxA5g4FYPrYh2v7Zs" class="wolai-block wolai-text"><div><span class="inline-wrap">在使用泛型之前，从集合中取出的对象需要进行类型转换。</span></div></div><div id="8GwJe7aYpMMnohrn6w6Vjg" class="wolai-block wolai-text"><div><span class="inline-wrap">使用泛型后，由于类型已经在编译时得到了确认，因此不再需要进行类型转换。</span></div></div><div id="shr4sLFXWCareuHPFHNLQi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="32zPLrhYkuuxDUgF8c9GqC" class="wolai-block"><span class="wolai-serial-number">7.1.3</span><span class="inline-wrap">代码重用性</span></h3><div id="jMgQXYHER1NfxswLWaYSJi" class="wolai-block wolai-text"><div><span class="inline-wrap">泛型允许你编写灵活且可重用的代码。你可以创建泛型方法或类，它们可以在不同的数据类型上操作，而不必为每种数据类型都编写一个新的版本。</span></div></div><div id="sKSvrtad8HvMmDu59HNoHd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="cooiZbMLDqoGKQzJ1m45ta" class="wolai-block"><span class="wolai-serial-number">7.1.4</span><span class="inline-wrap">优化设计</span></h3><div id="r9EWcBBQAEBB7EARwQxc6z" class="wolai-block wolai-text"><div><span class="inline-wrap">泛型提供了一种更优雅的方式来处理集合中的元素，使得代码更加清晰和易于理解。</span></div></div><div id="dE6kU1VCiFK1X14Eq4cuVh" class="wolai-block wolai-text"><div><span class="inline-wrap">它们还有助于减少潜在的错误，因为你不能将错误的数据类型添加到集合中。</span></div></div><div id="2bYCBZi13gRD8NRxfdBRfo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pDucxVpyYXzMDbgKSGmF5S" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">理解</span></h2><div id="a15mhrk7a3zmzL2jMjDGxa" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>中的泛型是在<span class="jill"></span>JDK 5<span class="jill"></span>中引入的，它的主要目的是提供编译时类型检查和消除类型转换，使得代码更加安全、清晰和易于维护。</span></div></div><div id="pZdT3jzPpMfR6h4148tsdb" class="wolai-block wolai-text"><div><span class="inline-wrap">在没有泛型之前，Java<span class="jill"></span>程序员使用<span class="jill"></span>Object<span class="jill"></span>类型来处理集合中的元素，这导致了代码中充斥着大量的类型转换操作，而且容易出错。</span></div></div><div id="obadnVd1fxjuAWyQDpPvsN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="fNhZkyW84UXdExtNWCxR4u" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，如果你将一个错误类型的对象添加到集合中，那么在运行时可能会引发<span class="jill"></span>ClassCastException<span class="jill"></span>异常。</span></div></div><div id="3ZkGbCseqtSgCVuXKwYqrr" class="wolai-block wolai-text"><div><span class="inline-wrap">为了解决这个问题，Java<span class="jill"></span>引入了泛型。通过使用泛型，你可以在编译时指定集合中元素的类型，从而避免了类型转换错误。</span></div></div><div id="hxkdvaAZGTzQJ4LDPzgyi2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="FxyaYErVLayaR49gsRQGP" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，泛型还提供了代码重用性和优化设计的好处。</span></div></div><div id="iRV8THhrUYUBQBCNPU1P7L" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，Java<span class="jill"></span>中的泛型是一个重要的特性，它通过提供编译时的类型检查和消除类型转换，使得代码更加安全、清晰和易于维护。</span></div></div><div id="hpYka5KNCoEJxj3s6pPXYh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="jCfV9tPFDw4bMTfVf2kBJd" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="kD2NHsC6QEEhHfsf1oASff" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">Map<span class="jill"></span>接口提供了哪些不同的集合视图?</span></h1><h2 id="qDc9PQMDfQ98bgbhqaptqu" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">背记</span></h2><div id="245XodseFgfec5AfHwNMjw" class="wolai-block wolai-text"><div><span class="inline-wrap">Map 接口提供了三种不同的集合视图</span></div></div><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="kQExzGaWVELvv3nt47tRTL" class="wolai-block wolai-text"><div><span class="inline-wrap">视图名称</span></div></div><span class="inline-wrap"></span><br/><div id="8EAeC2JCt4iC1wyV6CYJXx" class="wolai-block wolai-text"><div><span class="inline-wrap">Set view of keys</span></div></div><span class="inline-wrap"></span><br/><div id="2X2quoZxtVyJozB3eJ9mPy" class="wolai-block wolai-text"><div><span class="inline-wrap">Collection view of values</span></div></div><span class="inline-wrap"></span><br/><div id="jZp7QgFiLUyUSUaPeCEY1g" class="wolai-block wolai-text"><div><span class="inline-wrap">Set view of entries</span></div></div><span class="inline-wrap"></span><br/><div id="vtJuGEfDqZS6K6kDE7wUw8" class="wolai-block wolai-text"><div><span class="inline-wrap">入口方法</span></div></div><span class="inline-wrap"></span><br/><div id="dXX82Ld2XP459ViLZx53JQ" class="wolai-block wolai-text"><div><span class="inline-wrap">keySet()</span></div></div><span class="inline-wrap"></span><br/><div id="ecQvuD2FikYgrmbGLbo1SP" class="wolai-block wolai-text"><div><span class="inline-wrap">values()</span></div></div><span class="inline-wrap"></span><br/><div id="uq8yvtMUxi7CjWKMJGRuGc" class="wolai-block wolai-text"><div><span class="inline-wrap">entrySet()</span></div></div><span class="inline-wrap"></span><br/><div id="hDdoH988RszHNftBCQLgyb" class="wolai-block wolai-text"><div><span class="inline-wrap">方法功能说明</span></div></div><span class="inline-wrap"></span><br/><div id="nj3p7AZnPjcqe4SqP8Vg8u" class="wolai-block wolai-text"><div><span class="inline-wrap">获得一个包含所有键（keys）的<span class="jill"></span>Set<span class="jill"></span>视图</span></div></div><span class="inline-wrap"></span><br/><div id="qWLpskLvkxqNhj5LjFj9mb" class="wolai-block wolai-text"><div><span class="inline-wrap">得到一个包含所有值（values）的 Collection<span class="jill"></span>视图</span></div></div><span class="inline-wrap"></span><br/><div id="mMigFV49uTWoJJYLtw54Tb" class="wolai-block wolai-text"><div><span class="inline-wrap">获取一个包含所有映射（entries）的<span class="jill"></span>Set 视图。每个映射都由一个键和一个值组成</span></div></div><h2 id="wvNQ5it3vYH8Nv5WuL2gFe" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">理解</span></h2><h3 id="nB2RBfPeMRJGqE5E2ZGQZ3" class="wolai-block"><span class="wolai-serial-number">8.2.1</span><span class="inline-wrap">Set keyset()</span></h3><div id="kinqopvwHqCMkg8hKmmNMk" class="wolai-block wolai-text"><div><span class="inline-wrap">返回<span class="jill"></span>Map<span class="jill"></span>中包含的所有<span class="jill"></span>key<span class="jill"></span>的一个<span class="jill"></span>Set<span class="jill"></span>视图。</span></div></div><div id="i8h9bchwjEjS7YxbG6dqUn" class="wolai-block wolai-text"><div><span class="inline-wrap">此<span class="jill"></span>Set<span class="jill"></span>集合是受<span class="jill"></span>Map<span class="jill"></span>支持的，Map<span class="jill"></span>增删改会在该集合中反映出来。</span></div></div><div id="gzC4HpvwysDBNj8Wk5TMaA" class="wolai-block wolai-text"><div><span class="inline-wrap">反过来此<span class="jill"></span>Set<span class="jill"></span>集合的删除操作也会在原<span class="jill"></span>Map<span class="jill"></span>集合中体现出来。</span></div></div><div id="jD2J5CaPShBzC5KnpLtsj" class="wolai-block wolai-text"><div><span class="inline-wrap">当时一个迭代器正在遍历此<span class="jill"></span>Set<span class="jill"></span>集合，若<span class="jill"></span>Map<span class="jill"></span>被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为不确定。</span></div></div><div id="5Gjss9yWn26fMEsFaeop3i" class="wolai-block wolai-text"><div><span class="inline-wrap">此<span class="jill"></span>Set<span class="jill"></span>集合支持元素查找和删除，从此<span class="jill"></span>Set<span class="jill"></span>中删除元素会从<span class="jill"></span>map<span class="jill"></span>中移除对应的映射，它不支持<span class="jill"></span>add()和<span class="jill"></span>addAll()添加操作。</span></div></div><div id="arKKeBtnEDB5xKqtYbWLWp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="sqEHgJnXKx9TA2rBFBatGe" class="wolai-block"><span class="wolai-serial-number">8.2.2</span><span class="inline-wrap">Collection values()</span></h3><div id="o29YcHTNY5wYuyuMhwZzgN" class="wolai-block wolai-text"><div><span class="inline-wrap">返回一个<span class="jill"></span>Map<span class="jill"></span>中包含的所有<span class="jill"></span>value<span class="jill"></span>的一个<span class="jill"></span>Collection<span class="jill"></span>视图。</span></div></div><div id="ssy7HzxHYMWEAK9H8p8kJs" class="wolai-block wolai-text"><div><span class="inline-wrap">这个<span class="jill"></span>Collection<span class="jill"></span>集合受<span class="jill"></span>Map<span class="jill"></span>支持，Map<span class="jill"></span>增删改会在<span class="jill"></span>Collection<span class="jill"></span>中反映出来。</span></div></div><div id="uQsfH6XuXFb58CG4b9Ypd4" class="wolai-block wolai-text"><div><span class="inline-wrap">反过来此<span class="jill"></span>Collection<span class="jill"></span>集合的删除操作也会在原<span class="jill"></span>Map<span class="jill"></span>集合中体现出来。</span></div></div><div id="vHxLVJRmr6g677PuiyAipX" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个迭代器正在遍历此<span class="jill"></span>Collection<span class="jill"></span>时，若<span class="jill"></span>Map<span class="jill"></span>被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为不确定。</span></div></div><div id="a32KZAH5Yd5PnC1b2H5G16" class="wolai-block wolai-text"><div><span class="inline-wrap">此<span class="jill"></span>Collection<span class="jill"></span>集合支持元素查找和删除，从此<span class="jill"></span>Collection<span class="jill"></span>中删除元素会从<span class="jill"></span>Map<span class="jill"></span>中移除对应的映射，它不支持<span class="jill"></span>add()和<span class="jill"></span>addAll()添加操作。</span></div></div><div id="eQrHFE4qKUcvMFBRHgntHF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="d53V6JfqgKxWQiQeJ5qRi" class="wolai-block"><span class="wolai-serial-number">8.2.3</span><span class="inline-wrap">Set entrySet()</span></h3><div id="qHUcCvt1RmB7MB4wWeYsHW" class="wolai-block wolai-text"><div><span class="inline-wrap">返回一个<span class="jill"></span>Map<span class="jill"></span>中包含的所有映射的一个<span class="jill"></span>Set<span class="jill"></span>集合视图。</span></div></div><div id="qskSdUrr9gVYKBcn3sPxQZ" class="wolai-block wolai-text"><div><span class="inline-wrap">这个<span class="jill"></span>Set<span class="jill"></span>集合受<span class="jill"></span>Map<span class="jill"></span>支持的，Map<span class="jill"></span>增删改会在<span class="jill"></span>Collection<span class="jill"></span>中反映出来。</span></div></div><div id="kd3Y1Zk8UnR6wsdmYzFDfF" class="wolai-block wolai-text"><div><span class="inline-wrap">反过来此<span class="jill"></span>Set<span class="jill"></span>集合的删除操作也会在原<span class="jill"></span>Map<span class="jill"></span>集合中体现出来。</span></div></div><div id="64MCeYYZxKELMNzSdtEdK5" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个迭代器正在遍历此<span class="jill"></span>Set<span class="jill"></span>集合时，若<span class="jill"></span>Map<span class="jill"></span>被修改了(除迭代器自身的移除操作，以及对迭代器返回的<span class="jill"></span>entry<span class="jill"></span>进行<span class="jill"></span>setValue()外)，迭代器的结果会变为未定义。</span></div></div><div id="pvshHDfogzMBpN6Z9DyCPC" class="wolai-block wolai-text"><div><span class="inline-wrap">此<span class="jill"></span>Set<span class="jill"></span>集合支持元素查找和删除，从此<span class="jill"></span>Set<span class="jill"></span>中删除元素会从<span class="jill"></span>Map<span class="jill"></span>中移除对应的映射，它不支持<span class="jill"></span>add()和<span class="jill"></span>addAll()添加操作。</span></div></div><div id="71U1feqD9TGccjZTGStTwR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="9whT8T4HKAHuwv5kH8gGUK" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="5XzZARBYRQQbSSQXJJoUGc" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">JDK1.7<span class="jill"></span>版本中<span class="jill"></span>HashMap<span class="jill"></span>的内部结构</span></h1><div id="jqbXrsRDTKj3VcVteF6dCL" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>JDK1.7<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的存储结构是</span><span class="blue inline-wrap"><u><b>数组加链表</b></u></span><span class="inline-wrap">组合而成的。</span></div></div><div id="qN1vRLRJHn9SFWCch7HnGJ" class="wolai-block wolai-text"><div><span class="inline-wrap">每个元素都被存储为一个<span class="jill"></span>Entry<span class="jill"></span>对象，这些<span class="jill"></span>Entry<span class="jill"></span>对象被分布到一个数组中，每个数组的元素都是一个单向链表，链表中的每个节点都包含键值对。</span></div></div><div id="uyBpVwJbpJTVSttAuSsCMQ" class="wolai-block wolai-text"><div><span class="inline-wrap">这种设计允许<span class="jill"></span>HashMap<span class="jill"></span>在解决哈希冲突时通过链表来保存具有相同哈希值的不同键值对。</span></div></div><div id="643FKDaLEypAuMGHaksPZM" class="wolai-block wolai-text"><div><span class="inline-wrap">当链表的长度变得过长时，查询效率会受到影响，因为需要遍历链表来查找对应的键值对。</span></div></div><div id="ie82ZZdDuiDV2w9PexQwDr" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>JDK1.7<span class="jill"></span>中，HashMap<span class="jill"></span>的<span class="jill"></span>put()流程涉及几个关键步骤：</span></div></div><h2 id="oWzYJdwWASKGwK7LrmEAH9" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">计算<span class="jill"></span>Hash<span class="jill"></span>值与数组下标</span></h2><div id="pUN7yJb6N4kfeVhVemSS5" class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>key<span class="jill"></span>的<span class="jill"></span>hashCode<span class="jill"></span>计算出数组的下标，计算过程是先计算<span class="jill"></span>hashCode<span class="jill"></span>值，然后用<span class="jill"></span>hashCode<span class="jill"></span>值对数组长度取模，取模的结果就是数组下标。</span></div></div><h2 id="uCL9BCpbXTb7hvwKHWhxAi" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">判断是否需要扩容</span></h2><div id="jEE4eiaGNYTppo4uivYZZC" class="wolai-block wolai-text"><div><span class="inline-wrap">如果当前<span class="jill"></span>HashMap<span class="jill"></span>的大小已达到阈值（默认容量的<span class="jill"></span>0.75<span class="jill"></span>倍），则需要进行扩容操作，这个过程涉及到<span class="jill"></span>rehash<span class="jill"></span>和数据转移。</span></div></div><h2 id="eBum2MCuvLwHSFpcFdaeXd" class="wolai-block"><span class="wolai-serial-number">9.3</span><span class="inline-wrap">插入新元素</span></h2><div id="ug4eEn8NpxSVy6h4Q9jLxu" class="wolai-block wolai-text"><div><span class="inline-wrap">在不需要扩容的情况下，直接在对应下标处的链表插入新的<span class="jill"></span>Entry<span class="jill"></span>节点。</span></div></div><div id="dfFfAUomn7RmNq9XcuRDFy" class="wolai-block wolai-text"><div><span class="inline-wrap">如果链表长度过长，在<span class="jill"></span>JDK1.8<span class="jill"></span>之后的版本中会将链表转换为红黑树以提高查询效率。</span></div></div><h2 id="8CrHonVyPmo73zfTNmqdwV" class="wolai-block"><span class="wolai-serial-number">9.4</span><span class="inline-wrap">处理哈希冲突</span></h2><div id="qP3Pf9XVejssoS9fctUpwq" class="wolai-block wolai-text"><div><span class="inline-wrap">如果存在相同的<span class="jill"></span>hash<span class="jill"></span>值导致下标冲突，且<span class="jill"></span>key<span class="jill"></span>调用<span class="jill"></span>equals()方法确定不相等，则采用头插法将新元素插入到链表中，确保新加入的元素位于链表的最前端。</span></div></div><div id="tTqjgfJXYjT3qPBner2oxS" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，整个<span class="jill"></span>put()方法的逻辑保证了<span class="jill"></span>HashMap<span class="jill"></span>能够在保证键值对高效存取的同时，通过链表来解决哈希冲突的问题。</span></div></div><div id="sE3Hz1EkraNQTbMHGUQKPN" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，在多线程环境下，HashMap<span class="jill"></span>并不是线程安全的，因此可能会遇到并发问题如链表循环等。</span></div></div><div id="uUey6ZpzR5WSXtJZdCrj74" class="wolai-block"><figure class="wolai-center" style="width: 581.3333333333334px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><h2 id="Z86i5LbhVShxJUoK4Dg3P" class="wolai-block"><span class="wolai-serial-number">9.5</span><span class="inline-wrap">put()方法流程梳理</span></h2><div id="wcZXRtmmaHmfQqxFmcV3wN" class="wolai-block"><figure class="wolai-center" style="width: 664px; flex-direction: column"><img src="media/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6(1).png" style="width: 100%"/></figure></div><div id="e4Gg1CZ4S3SMXxpgucW51n" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="9vSFoor5ZSiqTpVGVpPvju" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">    </span><br/></div></div><h1 id="9kFf5ge3mYTwwABAKeUwh" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">HashMap<span class="jill"></span>中哪些情况会导致哈希冲突？</span></h1><h2 id="oHZn5CrGNqKdCi5UT5vfeN" class="wolai-block"><span class="wolai-serial-number">10.1</span><span class="inline-wrap">哈希冲突</span></h2><div id="iXzaVqfXj1HhN9eS8g7ieA" class="wolai-block wolai-text"><div><span class="inline-wrap">哈希冲突是指：经过一系列计算后，Entry<span class="jill"></span>存入数组的下标相同，所以导致哈希冲突的原因就是看哪些情况会导致计算得到的数组下标相同</span></div></div><div id="6XY9oC8nhz7qWxLBbmK3sF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sx3F9AjCs1UEf7DwzA4nXS" class="wolai-block"><span class="wolai-serial-number">10.2</span><span class="inline-wrap">冲突原因</span></h2><ul class="wolai-block"><li id="vw9pvii5FSpegkgnprSnZx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">hashCode<span class="jill"></span>值相同</span></li><li id="gh7fDkBaLBeTptEt6wgi6Q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">hash()方法执行结果相同</span></li><li id="jnVnUJ1Z5sVp1C98cgeXbF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">hashCode<span class="jill"></span>值对<span class="jill"></span>table.length - 1<span class="jill"></span>执行按位与运算，运算结果相同</span></li></ul><div id="uNDpRYSxkB82xexL4THQ79" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pQFpjdYv669oqyraumi1kV" class="wolai-block"><span class="wolai-serial-number">10.3</span><span class="inline-wrap">hash()方法</span></h2><h3 id="j7eMqvscR6WY73eMGNFaNQ" class="wolai-block"><span class="wolai-serial-number">10.3.1</span><span class="inline-wrap">hash()方法的位置</span></h3><div id="xscut5q9TMferNSVPUm4dr" class="wolai-block"><figure class="wolai-center" style="width: 864px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="bxnTLfdytNv5F3sGyK4L8Y" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="c2nGnYCWKGgNDzoYxjY1uw" class="wolai-block"><span class="wolai-serial-number">10.3.2</span><span class="inline-wrap">hash()方法的作用</span></h3><div id="ujCeaH4qcVP4VfUsJuxgAQ" class="wolai-block wolai-text"><div><span class="inline-wrap">通过对<span class="jill"></span>hashCode<span class="jill"></span>值进行『异或』操作、『位移』操作把原来的<span class="jill"></span>hashCode<span class="jill"></span>值打乱，尽可能降低哈希冲突的概率</span></div></div><div id="i1XdJTrjgd7k6FzX2pLjMd" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">    </span><br/></div></div><h1 id="9uPvDsjvL4p3w5Vak3kmt6" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">JDK1.8<span class="jill"></span>版本中<span class="jill"></span>HashMap<span class="jill"></span>的内部结构</span></h1><div id="eccd6s49EBj4VsTLAzfwhH" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的存储结构是</span><span class="blue inline-wrap"><u><b>数组加链表/红黑树</b></u></span><span class="inline-wrap">。</span></div></div><div id="phErJmu8aqX7u9DwbuCwNp" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>JDK1.8<span class="jill"></span>中，HashMap<span class="jill"></span>的底层实现发生了变化，主要为了解决当链表过长时导致的性能问题。</span></div></div><div id="t4GiAxcek6rn42ztp3WSKU" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个版本中，当一个链表的长度超过一定阈值（默认为<span class="jill"></span>8）且数组已经历过两次扩容，该链表会被转换为红黑树，以提高搜索效率。</span></div></div><div id="7oahvRUiGjxyYn6JaWKoa5" class="wolai-block wolai-text"><div><span class="inline-wrap">具体来说<span class="jill"></span>JDK1.8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>put()流程如下：</span></div></div><h2 id="kvF3t6j41zYkaFkvi6q8o9" class="wolai-block"><span class="wolai-serial-number">11.1</span><span class="inline-wrap">计算<span class="jill"></span>Hash<span class="jill"></span>值与数组下标</span></h2><div id="oMgFBG1gGZsyy8n59xP1iQ" class="wolai-block wolai-text"><div><span class="inline-wrap">首先根据<span class="jill"></span>key<span class="jill"></span>的<span class="jill"></span>hashCode<span class="jill"></span>方法计算出一个<span class="jill"></span>hash<span class="jill"></span>值，然后根据这个<span class="jill"></span>hash<span class="jill"></span>值通过位运算得到数组的下标。</span></div></div><h2 id="vyWqqmwZvp5az9Zwt7Kc7m" class="wolai-block"><span class="wolai-serial-number">11.2</span><span class="inline-wrap">判断是否需要扩容</span></h2><div id="tC6TnbaEPWfT33GEvnbpMc" class="wolai-block wolai-text"><div><span class="inline-wrap">如果当前<span class="jill"></span>HashMap<span class="jill"></span>的大小已达到阈值（默认容量的<span class="jill"></span>0.75<span class="jill"></span>倍），则需要进行扩容操作，这个过程涉及到<span class="jill"></span>rehash<span class="jill"></span>和数据转移。</span></div></div><h2 id="sPjptyZLZxb27vgyEBgWos" class="wolai-block"><span class="wolai-serial-number">11.3</span><span class="inline-wrap">插入新元素</span></h2><div id="hzJjzjSK5rY7MtySGbeSgq" class="wolai-block wolai-text"><div><span class="inline-wrap">在不需要扩容的情况下，根据得到的下标位置，找到对应的节点。如果该位置没有节点，则直接创建一个新的节点并放入。</span></div></div><div id="nUd7DDnnacizaGy2KZAZYP" class="wolai-block wolai-text"><div><span class="inline-wrap">如果有节点，则判断<span class="jill"></span>key<span class="jill"></span>是否相等。</span></div></div><h2 id="to1h1KeszVzZzhUKsXbUkN" class="wolai-block"><span class="wolai-serial-number">11.4</span><span class="inline-wrap">处理哈希冲突</span></h2><div id="9LTjjir6J21z4iU8SBJqK4" class="wolai-block wolai-text"><div><span class="inline-wrap">如果存在相同的<span class="jill"></span>hash<span class="jill"></span>值导致下标冲突，则采用头插法将新元素插入到链表中，确保新加入的元素位于链表的最前端。</span></div></div><div id="rpxikHvVKNcbeEw6dN6mfC" class="wolai-block wolai-text"><div><span class="inline-wrap">如果链表长度超过阈值，将链表转换为红黑树。</span></div></div><div id="67BoiR9NERnrgi2z6giYxm" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，整个<span class="jill"></span>put()方法的逻辑保证了<span class="jill"></span>HashMap<span class="jill"></span>能够在保证键值对高效存取的同时，通过链表或红黑树来解决哈希冲突的问题。</span></div></div><div id="ax7NtbF6ZnAAK1BEDdhQvH" class="wolai-block wolai-text"><div><span class="inline-wrap">需要注意的是，在多线程环境下，HashMap<span class="jill"></span>并不是线程安全的，因此可能会遇到并发问题如链表循环等。</span></div></div><div id="4qfWx8M1cwtzLcWKUacZ4V" class="wolai-block"><figure class="wolai-center" style="width: 530.6666666666666px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><h2 id="r73hT6yTYd28BaLMhLXKwV" class="wolai-block"><span class="wolai-serial-number">11.5</span><span class="inline-wrap">put()方法流程</span></h2><div id="v7EwXNZQx3nRsqHxFeKAAH" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6(2).png" style="width: 100%"/></figure></div><h2 id="8Griap12FCJ9Xc2fy9sdmt" class="wolai-block"><span class="wolai-serial-number">11.6</span><span class="inline-wrap">特点总结</span></h2><ul class="wolai-block"><li id="bRRZ9s2gUfScv7nMTk36RZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashMap<span class="jill"></span>是<span class="jill"></span>Map<span class="jill"></span>接口的一个基于哈希表的实现</span></li><li id="xpMCEBNK4udjoP7Ncxo4sd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashMap<span class="jill"></span>不同步，非线程安全</span></li><li id="qH3mzMM3WnKj43LwcPksrc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashMap<span class="jill"></span>的<span class="jill"></span>key、value<span class="jill"></span>都可以为<span class="jill"></span>null</span></li><li id="mCn6E8nxAHJkVvC5Gw8cgp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashMap<span class="jill"></span>映射无序</span></li><li id="pouFxm2Gzrtm9C51tzGsRR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK1.8<span class="jill"></span>之前<span class="jill"></span>HashMap<span class="jill"></span>由『数组<span class="jill"></span>+<span class="jill"></span>链表』组成（“拉链法”解决哈希冲突）</span><ul class="wolai-block"><li id="kkz8FmSDzZ7sXJFbSwvxn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组：HashMap<span class="jill"></span>的主体</span></li><li id="8aRo75inHVQuiM4t16wkAs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">链表：用于解决哈希冲突（两个对象调用的<span class="jill"></span>hashCode<span class="jill"></span>方法计算的哈希码值一致导致计算的数组索引值相同）</span></li></ul></li><li id="k5Hg5k2UwNMFtyxhsc8sWL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK1.8<span class="jill"></span>以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于<span class="jill"></span>64<span class="jill"></span>时，此时此索引位置上的所有数据改为使用红黑树存储</span></li></ul><div id="mDgmxNjmTG6p3Ttwg6CCfm" class="wolai-block wolai-text"><div><span class="inline-wrap">将链表转换成红黑树前会判断，即使阈值大于<span class="jill"></span>8，但是数组长度小于<span class="jill"></span>64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</span></div></div><div id="x3YFVh4H5HNn2yoJkUTQn2" class="wolai-block wolai-text"><div><span class="inline-wrap">这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于<span class="jill"></span>64<span class="jill"></span>时，搜索时间相对要快些。</span></div></div><div id="91xmR6zfanBFBFBjLtUnNp" class="wolai-block wolai-text"><div><span class="inline-wrap">所以综上所述为了提高性能和减少搜索时间，底层在阈值大于<span class="jill"></span>8<span class="jill"></span>并且数组长度大于<span class="jill"></span>64<span class="jill"></span>时，链表才转换为红黑树。</span></div></div><div id="q7XiFTRENSV3EWwiyCmLN8" class="wolai-block wolai-text"><div><span class="inline-wrap">具体可以参考 treeifyBin<span class="jill"></span>方法。</span></div></div><div id="fajEuoRpWSmCBo7Ls3sTf2" class="wolai-block wolai-text"><div><span class="inline-wrap">当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于<span class="jill"></span>8<span class="jill"></span>并且数组长度大于<span class="jill"></span>64<span class="jill"></span>时，链表转换为红黑树时，效率也变的更高效。</span></div></div><div id="bfqDWMbFwT1eiZW7MzNupo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="4BtVpLyPyZKJRYP8MohvBy" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="rfnFgCQPe8bhyUzJaSbPCM" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">JDK8<span class="jill"></span>中的<span class="jill"></span>HashMap<span class="jill"></span>为什么要使用红黑树？</span></h1><h2 id="476GG2mCBf2Ck2q7q4WbnV" class="wolai-block"><span class="wolai-serial-number">12.1</span><span class="inline-wrap">背记</span></h2><div id="rnMcHtFuqBEGatrWWnPuyr" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK8<span class="jill"></span>中的<span class="jill"></span>HashMap<span class="jill"></span>使用红黑树是为了提高查找效率和维持数据结构的平衡。</span></div></div><div id="gGtrUfqTtToPUiChP8jLa5" class="wolai-block wolai-text"><div><span class="inline-wrap">链表的查找时间复杂度为<span class="jill"></span>O(n)，当链表长度过长时会导致性能下降。</span></div></div><div id="i8UfVpggGV2BcRnKnVWDVq" class="wolai-block wolai-text"><div><span class="inline-wrap">而红黑树作为一种自平衡的二叉查找树，可以在数据量增大过程中保持较好的查找性能，其查找时间复杂度为<span class="jill"></span>O(log n)。</span></div></div><div id="fLeGrD4LfC34GdQqsHpZ5v" class="wolai-block wolai-text"><div><span class="inline-wrap">保证数据结构平衡的同时，提高查找效率，避免因链表过长导致的性能问题，同时也减少了内存开销，并简化了实现的复杂性</span></div></div><div id="nTP2BBxs1ejQCTBJgHWSPh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="f3ZcgE7ziKBNicmXxaptnv" class="wolai-block"><span class="wolai-serial-number">12.2</span><span class="inline-wrap">理解</span></h2><div id="ku2kEbpZ55BZ626RV2JiQY" class="wolai-block wolai-text"><div><span class="inline-wrap">使用红黑树的几个原因：</span></div></div><h3 id="pnQs5xjxAYzPARtEhQDvJZ" class="wolai-block"><span class="wolai-serial-number">12.2.1</span><span class="inline-wrap">提高查找效率</span></h3><div id="jRQxP4UMFawAoQhEy39bA7" class="wolai-block wolai-text"><div><span class="inline-wrap">当<span class="jill"></span>HashMap<span class="jill"></span>中某个桶（bucket）内的元素数量超过一定阈值（默认为<span class="jill"></span>8<span class="jill"></span>个），并且这些元素都位于同一条链表上时，将链表转换为红黑树可以提高查找效率。因为红黑树的查找效率要高于链表。</span></div></div><h3 id="uxHLLhctUiC2Nc85AaCKPH" class="wolai-block"><span class="wolai-serial-number">12.2.2</span><span class="inline-wrap">自平衡性</span></h3><div id="5xYPZ2mvYRJu7YVG4K9TMV" class="wolai-block wolai-text"><div><span class="inline-wrap">红黑树是一种自平衡的二叉查找树，它能够在插入和删除操作后自动调整结构，以保持树的平衡。</span></div></div><div id="c2g2fi4F96R7iuhqiD72jU" class="wolai-block wolai-text"><div><span class="inline-wrap">这样可以确保即使在极端情况下，树的高度也不会过高，从而维持了较好的查找性能。</span></div></div><h3 id="j9v87Tn3dwDKxsWWPDR9oT" class="wolai-block"><span class="wolai-serial-number">12.2.3</span><span class="inline-wrap">避免过度哈希化</span></h3><div id="tLncoZrsZBCuvNrpwFR3Sc" class="wolai-block wolai-text"><div><span class="inline-wrap">在早期版本的<span class="jill"></span>HashMap<span class="jill"></span>中，如果出现大量冲突，链表会变得非常长，导致性能急剧下降。</span></div></div><div id="f12ucQWeKEhwW9nbVcZsZv" class="wolai-block wolai-text"><div><span class="inline-wrap">引入红黑树后，即使有大量冲突，也能通过红黑树的结构来保持较高的查找效率。</span></div></div><h3 id="mGizUR8gWmM4C6TpUzwyNu" class="wolai-block"><span class="wolai-serial-number">12.2.4</span><span class="inline-wrap">减少内存开销</span></h3><div id="rVBAMRxjG6ZGRHDacoKBK8" class="wolai-block wolai-text"><div><span class="inline-wrap">相比于<span class="jill"></span>B<span class="jill"></span>树等其他平衡树结构，红黑树的节点利用率更高，因为它不需要存储额外的信息（如兄弟节点指针），这有助于减少内存开销。</span></div></div><h3 id="sqQ3VHo49ZbqFRJgijhNAQ" class="wolai-block"><span class="wolai-serial-number">12.2.5</span><span class="inline-wrap">实现简单</span></h3><div id="sBN5VxrYJ2xQoZn49sFmmU" class="wolai-block wolai-text"><div><span class="inline-wrap">红黑树的实现相对简单，它只有五种基本的旋转操作来维护平衡，这使得它在<span class="jill"></span>HashMap<span class="jill"></span>中的实现更加高效和可靠。</span></div></div><div id="9QZ9hTe8G1bwB577swpSya" class="wolai-block wolai-text"><div></div></div><div id="7hyAhQgu91Uh9PJ916bcFF" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="ehKo12L6ourU41XGv2pKQQ" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">JDK8<span class="jill"></span>中的<span class="jill"></span>HashMap<span class="jill"></span>什么时候将链表转化为红黑树？</span></h1><h2 id="kazQ1cnzHw31LGbk3YtDHh" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">背记</span></h2><div id="rbH6JgiqnNDckzKbVeuxPj" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>将链表转化为红黑树需要同时满足两个条件：</span></div></div><ul class="wolai-block"><li id="5yww8tnUrFVqyVFY9DaF2c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">条件<span class="jill"></span>1：链表长度大于等于<span class="jill"></span>8</span></li><li id="8rAHzmzz8eNQJnyU2T1EBD"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">条件<span class="jill"></span>2：数组长度大于等于<span class="jill"></span>64</span></li></ul><div id="wKR6tdheBJkqaAGJsmWiYv" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dJF1wFWCjc5nQVPrNwSKXC" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">理解</span></h2><div id="hen4Mn4g6XErNuyYojVZTH" class="wolai-block wolai-text"><div><span class="inline-wrap">之所以需要同时满足这两个条件，是因为<span class="jill"></span>HashMap<span class="jill"></span>的设计者认为：频繁的出现哈希碰撞可能是因为数组长度不够。</span></div></div><div id="kxgzvfc5pUTy3GWroJWcyz" class="wolai-block wolai-text"><div><span class="inline-wrap">如果确实是因为数组长度不够而导致了哈希碰撞，那么此时首先要做的就不是把链表转为红黑树，而是对数组扩容。</span></div></div><div id="5kRAYw59FhU234MUSafDiY" class="wolai-block wolai-text"><div></div></div><div id="2XZdgAKT4AvqjjjZssXNRG" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="6dSMYtRbWnYe2c9AtR4Kbk" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">为什么<span class="jill"></span>HashMap<span class="jill"></span>长度大于等于<span class="jill"></span>8<span class="jill"></span>且容量大于等于<span class="jill"></span>64<span class="jill"></span>才转化为红黑树？</span></h1><h2 id="d4xyQ6PERZ977rXkffBQgD" class="wolai-block"><span class="wolai-serial-number">14.1</span><span class="inline-wrap">背记</span></h2><div id="qe8vnLqWWSvkjx5DNcSxx" class="wolai-block wolai-text"><div><span class="inline-wrap">链表的长度达到一定阈值（默认为<span class="jill"></span>8）时，表明该链表已经足够长，以至于搜索性能可能开始受到影响。</span></div></div><div id="6LPVpvxJGPVPNXjy8i4XUv" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>的容量达到（默认为<span class="jill"></span>64）时，表示<span class="jill"></span>HashMap<span class="jill"></span>已经足够大，足以容纳更多的元素而不需要频繁扩容，在这个时机进行树化主要是保证性能的同时，避免不必要的数据结构转换开销。</span></div></div><h2 id="hv7RPYuofr4crrk542mmqY" class="wolai-block"><span class="wolai-serial-number">14.2</span><span class="inline-wrap">理解</span></h2><div id="b894ekaY8ryGhzDuGBwciM" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>在决定是否将链表转化为红黑树时，考虑了两个条件：链表的长度和<span class="jill"></span>HashMap<span class="jill"></span>的容量。</span></div></div><div id="4tJFmFSfHJv75K9e2YVnT9" class="wolai-block wolai-text"><div><span class="inline-wrap">这两个条件共同确保了转化操作的性能收益大于其带来的开销。</span></div></div><div id="t1xqRhLFPynFKrrs2oqsRM" class="wolai-block wolai-text"><div><span class="inline-wrap">具体来说，以下是为什么<span class="jill"></span>HashMap<span class="jill"></span>会设定这些条件的详细解释：</span></div></div><h3 id="8GQ3PiHgE3nyvH6KjzRWqE" class="wolai-block"><span class="wolai-serial-number">14.2.1</span><span class="inline-wrap">链表长度</span></h3><div id="fihraziFbHBNYvNqEtgUVz" class="wolai-block wolai-text"><div><span class="inline-wrap">链表的长度达到一定阈值（默认为<span class="jill"></span>8）时，表明该链表已经足够长，以至于搜索性能可能开始受到影响。</span></div></div><div id="rEzi8LXquRRPhJ1557fX67" class="wolai-block wolai-text"><div><span class="inline-wrap">这个阈值是基于性能测试和经验得出的，它代表了在一般情况下，链表转化为红黑树的性能收益开始显现的点。</span></div></div><h3 id="bFhjnoKw15CHp3ZxDBZ1Ru" class="wolai-block"><span class="wolai-serial-number">14.2.2</span><span class="inline-wrap">HashMap<span class="jill"></span>容量</span></h3><div id="jaN2RcrYKfRf2sWJXqMyd3" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>的容量达到<span class="jill"></span>MIN_TREEIFY_CAPACITY（默认为<span class="jill"></span>64）时，表示<span class="jill"></span>HashMap<span class="jill"></span>已经足够大，足以容纳更多的元素而不需要频繁扩容。</span></div></div><div id="tbGkCqQccY6394UYcYkYDz" class="wolai-block wolai-text"><div><span class="inline-wrap">此时，将链表转化为红黑树的操作更有可能带来性能上的提升，因为树结构可以提供更好的搜索性能。</span></div></div><div id="uu3rGAL1m8AK6jU8u6FuNE" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，如果<span class="jill"></span>HashMap<span class="jill"></span>的容量小于<span class="jill"></span>64，即使链表长度超过<span class="jill"></span>8，也不会进行树化操作。</span></div></div><div id="s36F97H6yaumV2Zq6haxyk" class="wolai-block wolai-text"><div><span class="inline-wrap">这是为了确保在较小的<span class="jill"></span>HashMap<span class="jill"></span>中，不会因为过早的树化而导致额外的开销。</span></div></div><div id="24c7z1jBA3vv1EkQz1U6VS" class="wolai-block wolai-text"><div><span class="inline-wrap">同时，如果红黑树的节点数量减少到小于或等于<span class="jill"></span>6<span class="jill"></span>个，HashMap<span class="jill"></span>会将其恢复为链表形态，因为在这种情况下，维护树结构的开销不再划</span></div></div><div id="qmTGizZ87y4pYvrVvZQnxJ" class="wolai-block wolai-text"><div><span class="inline-wrap">算。</span></div></div><div id="oQ7FMTEiHLuruY88GgCebx" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，HashMap<span class="jill"></span>中的这一设计是为了在保证性能的同时，避免不必要的数据结构转换开销。</span></div></div><div id="Z8yDpQpfun5YMJuBEacDd" class="wolai-block wolai-text"><div></div></div><div id="5tr3svUVuXzNAVpvEkoeSu" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="dVfEwJq6oEjeuAVoH8itN3" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">JDK7<span class="jill"></span>与<span class="jill"></span>JDK8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的不同点？</span></h1><h2 id="cZvqgRKUKC5GLMeAB2FcZy" class="wolai-block"><span class="wolai-serial-number">15.1</span><span class="inline-wrap">背记</span></h2><div id="rznXT4vNy4onEwBaqkVa3e" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK7<span class="jill"></span>与<span class="jill"></span>JDK8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的不同点主要体现在数据结构和扩容机制上：</span></div></div><h3 id="vyp3nBC6KGByGAAjFy7Bdu" class="wolai-block"><span class="wolai-serial-number">15.1.1</span><span class="inline-wrap">数据结构</span></h3><ul class="wolai-block"><li id="hXG3xU9ooGmuvJG9cvs5wh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK7：HashMap<span class="jill"></span>的底层数据结构是数组<span class="jill"></span>+<span class="jill"></span>链表。</span></li><li id="axaxVs4yDzJTokB5easnqb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8：HashMap<span class="jill"></span>的底层数据结构是数组 + 链表 + 红黑树，链表在条件满足后会被转换成红黑树。</span></li></ul><h3 id="swry6LF1fQ95CkQcWTHeKQ" class="wolai-block"><span class="wolai-serial-number">15.1.2</span><span class="inline-wrap">扩容机制</span></h3><div id="mSTndhoH81Z2rwRtRakipF" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>JDK7<span class="jill"></span>中当<span class="jill"></span>HashMap<span class="jill"></span>中的元素数量达到容量的<span class="jill"></span>0.75<span class="jill"></span>倍时，扩大到原来的两倍，并重新散列所有的元素。</span></div></div><div id="dvvXym9MyQZ9GXBA5VbfNY" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>JDK8<span class="jill"></span>中除了扩大数组大小，还会根据情况将红黑树转换回链表或保持红黑树结构。</span></div></div><h2 id="4CNV2KaijCeZR5uJZwGg67" class="wolai-block"><span class="wolai-serial-number">15.2</span><span class="inline-wrap">理解</span></h2><ul class="wolai-block"><li id="4c5kds77bXpK596pNT9eoo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8<span class="jill"></span>中使用了红黑树</span></li><li id="imLPrMsAebXdKi9NV3SuSo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK7<span class="jill"></span>中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致<span class="jill"></span>CPU<span class="jill"></span>飙升）</span></li><li id="cQ5cMmJuFVLeWbbUP7wXEa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8<span class="jill"></span>中链表使用的尾插法（JDK8<span class="jill"></span>中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）</span></li><li id="8EFhCD9SzbBLdSUVHiSu4y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK7<span class="jill"></span>的<span class="jill"></span>Hash<span class="jill"></span>算法比<span class="jill"></span>JDK8<span class="jill"></span>中的更复杂，Hash<span class="jill"></span>算法越复杂，生成的<span class="jill"></span>hashcode<span class="jill"></span>则更散列，那么<span class="jill"></span>hashmap<span class="jill"></span>中的元素则更散列，更散列则<span class="jill"></span>hashmap<span class="jill"></span>的查询性能更好，JDK7<span class="jill"></span>中没有红黑树，所以只能优化<span class="jill"></span>Hash<span class="jill"></span>算法使得元素更散列，而<span class="jill"></span>JDK8<span class="jill"></span>中增加了红黑树，查询性能得到了保障，所以可以简化一下<span class="jill"></span>Hash<span class="jill"></span>算法，毕竟<span class="jill"></span>Hash<span class="jill"></span>算法越复杂就越消耗<span class="jill"></span>CPU。</span></li><li id="qumhrEDCrjaTMAp4HQKqJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">扩容的过程中<span class="jill"></span>JDK7<span class="jill"></span>中有可能会重新对<span class="jill"></span>key<span class="jill"></span>进行哈希（重新<span class="jill"></span>Hash<span class="jill"></span>跟哈希种子有关系），而<span class="jill"></span>JDK8<span class="jill"></span>中没有这部分逻辑。</span></li><li id="jtBJeM8Ac4kKj7whK2wtDt"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8<span class="jill"></span>中扩容的条件和<span class="jill"></span>JDK7<span class="jill"></span>中不一样，除开判断<span class="jill"></span>size<span class="jill"></span>是否大于阈值之外，JDK7<span class="jill"></span>中还判断了<span class="jill"></span>table[i]是否为空，不为空的时候才会进行扩容，而<span class="jill"></span>JDK8<span class="jill"></span>中则没有该条件了。</span></li><li id="uP3mWG6vRPcif9gXPCMyZw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK8<span class="jill"></span>中还多了一个<span class="jill"></span>API：putIfAbsent(key,value)</span></li><li id="oZP1ioejYRTYB6L4ypHgWo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">JDK7<span class="jill"></span>和<span class="jill"></span>JDK8<span class="jill"></span>扩容过程中转移元素的逻辑不一样，JDK7<span class="jill"></span>是每次转移一个元素，JDK8<span class="jill"></span>是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移。</span></li></ul><div id="gQbuF6n4EeETMgSc5gbT9u" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="pwjNCiksAxAEqMaMaTgrCi" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">JDK 1.7 ConcurrentHashMap</span></h1><h2 id="6WGncPMqiZXzJFjRpC4hMs" class="wolai-block"><span class="wolai-serial-number">16.1</span><span class="inline-wrap">两层嵌套数组</span></h2><div id="6yy8wU5XXw7egSAuaPAnnh" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK 1.7 ConcurrentHashMap<span class="jill"></span>底层是由两层嵌套数组来实现的：</span></div></div><ul class="wolai-block"><li id="bDWcjyYnU6eH9nGf1rWYhb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ConcurrentHashMap<span class="jill"></span>对象中有一个属性<span class="jill"></span>segments，类型为<span class="jill"></span>Segment[];</span></li><li id="pZas1LgddNbSWiqo6hbTVG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Segment<span class="jill"></span>对象中有一个属性<span class="jill"></span>table，类型为<span class="jill"></span>HashEntry[];</span></li></ul><div id="v8GHZo6DNRS9Rvjfxu3VSS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="n8ZBZ9SqkfJ6aJPqtRDNcT" class="wolai-block"><span class="wolai-serial-number">16.2</span><span class="inline-wrap">put<span class="jill"></span>流程</span></h2><h3 id="dHxMJ6wDh1AX2ndGLvvq7A" class="wolai-block"><span class="wolai-serial-number">16.2.1</span><span class="inline-wrap">segments[j]</span></h3><div id="6E8oX7iygwSbzHCMLEzvGX" class="wolai-block wolai-text"><div><span class="inline-wrap">当调用<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的<span class="jill"></span>put()方法时，先根据<span class="jill"></span>key<span class="jill"></span>计算出对应的<span class="jill"></span>Segment[]的数组下标<span class="jill"></span>j，确定好当前<span class="jill"></span>key、value<span class="jill"></span>应该插入到哪个<span class="jill"></span>Segment<span class="jill"></span>对象中，如果<span class="jill"></span>segments[j] 为空，则利用自旋锁的方式在<span class="jill"></span>j<span class="jill"></span>位置生成一个<span class="jill"></span>Segment<span class="jill"></span>对象。</span></div></div><div id="5P9nAHwsvcrBJND9Q2wpR5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="hDutdQHz5r21Ja6ihqnCfF" class="wolai-block"><span class="wolai-serial-number">16.2.2</span><span class="inline-wrap">调用<span class="jill"></span>Segment<span class="jill"></span>对象的<span class="jill"></span>put()方法</span></h3><div id="hwH3pc6KXguMhJerdg4nEG" class="wolai-block wolai-text"><div><span class="inline-wrap">Segment<span class="jill"></span>对象的<span class="jill"></span>put()方法会先加锁，然后根据<span class="jill"></span>key<span class="jill"></span>计算出对应的<span class="jill"></span>HashEntry[]的数组下标<span class="jill"></span>i，然后将<span class="jill"></span>key、value<span class="jill"></span>封装为<span class="jill"></span>HashEntry<span class="jill"></span>对象放入该位置，此过程和<span class="jill"></span>JDK7<span class="jill"></span>的<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>put()方法一样，然后解锁。</span></div></div><div id="tYek6fyRK66GCh3WssK2rY" class="wolai-block wolai-text"><div><span class="inline-wrap">在加锁的过程中逻辑比较复杂，先通过自旋加锁，如果超过一定次数就会直接阻塞</span></div></div><div id="ryEGyzfQrvpvb3pmR8zKfF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="gjAPk7qQh7yn5g3ftfGSoE" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="4LemoovwiQXEYpBoUtUr9T" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">JDK 1.8 ConcurrentHashMap</span></h1><h2 id="5tecVN7KTxWhHUsTAqMmwB" class="wolai-block"><span class="wolai-serial-number">17.1</span><span class="inline-wrap">总体介绍</span></h2><div id="ivjgSeZ9ii9Ut1BvmcH4bZ" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>中的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的底层结构是<span class="jill"></span>Node<span class="jill"></span>数组<span class="jill"></span>+<span class="jill"></span>链表<span class="jill"></span>+<span class="jill"></span>红黑树：</span></div></div><h3 id="vzdzJrioeMpB1Hpy3dt7yZ" class="wolai-block"><span class="wolai-serial-number">17.1.1</span><span class="inline-wrap">Node<span class="jill"></span>数组</span></h3><div id="juCxYfsoS3Xzpk4UBj3WXC" class="wolai-block wolai-text"><div><span class="inline-wrap">这是<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>存储元素的基础数据结构，它类似于<span class="jill"></span>HashMap<span class="jill"></span>中的桶</span></div></div><div id="71pPzhtvToroF9hw1rkiDD" class="wolai-block wolai-text"><div><span class="inline-wrap">（bucket）数组。Node<span class="jill"></span>是一个简单的静态内部类，它包含一个键、一个值以及指向下一个节</span></div></div><div id="nPepvvD7gea1Evp19rdo5s" class="wolai-block wolai-text"><div><span class="inline-wrap">点的指针。</span></div></div><h3 id="a2QLoQBAsYNC2LL4YSVZD9" class="wolai-block"><span class="wolai-serial-number">17.1.2</span><span class="inline-wrap">链表</span></h3><div id="71SLQ4asfNAyahmN4TScNr" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Node<span class="jill"></span>数组的同一索引处，如果发生了哈希冲突，那么新的节点将以链表的形式连接在一起。</span></div></div><h3 id="fLL7U3uvTsrW7HgjZxtz4b" class="wolai-block"><span class="wolai-serial-number">17.1.3</span><span class="inline-wrap">红黑树</span></h3><div id="3WVaBH19afZH6qA4H1Kcpw" class="wolai-block wolai-text"><div><span class="inline-wrap">当链表的长度超过一定阈值时，链表会被转换为红黑树以提高搜索效率。</span></div></div><div id="vHi8wLtnvx5nNnoE71jKdK" class="wolai-block wolai-text"><div><span class="inline-wrap">这是因为红黑树可以提供更好的查找性能，尤其是在大量数据的情况下。</span></div></div><div id="cCa6dgNSMR2Fc9RjVjg2W9" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="hdvGEePEVLCZPLbpH1d31b" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，与<span class="jill"></span>JDK1.7<span class="jill"></span>相比<span class="jill"></span>JDK1.8<span class="jill"></span>的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>不再使用分段锁，而是采用了更细粒度的同步机制，如<span class="jill"></span>synchronized<span class="jill"></span>关键字和<span class="jill"></span>CAS<span class="jill"></span>操作。</span></div></div><div id="nWDL4YhnLinWx6kEkcH3FS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="omG2oeTJzKmJyK73kQPaFj" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，JDK1.8<span class="jill"></span>中<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的底层结构设计旨在提高并发性能，同时保持数据的线程安全性。</span></div></div><div id="kVryZY1fsyoy9f7M5y9anQ" class="wolai-block wolai-text"><div><span class="inline-wrap">它通过结合多种数据结构和同步机制来实现这一目标。</span></div></div><div id="rid48WKjyE7NNxDdEbnL2P" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5fUGvwDxjXNAuVhQWiwNNb" class="wolai-block"><span class="wolai-serial-number">17.2</span><span class="inline-wrap">put<span class="jill"></span>流程</span></h2><div id="mkjsY5q1Dqpnji1Rao59k8" class="wolai-block wolai-text"><div><span class="inline-wrap">当向<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>中<span class="jill"></span>put<span class="jill"></span>一个<span class="jill"></span>key、value<span class="jill"></span>时</span></div></div><ul class="wolai-block"><li id="cGpxKG19trTdgFPQp69VMm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">首先根据<span class="jill"></span>key<span class="jill"></span>计算对应的数组下标<span class="jill"></span>i，</span><ul class="wolai-block"><li id="pHXvB68WPoMaLcHaPAvLFN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果该位置没有元素，则通过自旋的方法去向该位置赋值</span></li><li id="qxnmNw4kAEmJ1YrHrmf5Sx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果该位置有元素，则会加<span class="jill"></span>synchronized<span class="jill"></span>锁</span></li></ul></li><li id="fzSxqYDwCPFy44FVEsFFUE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">加锁成功之后，在判断该元素的类型：</span><ul class="wolai-block"><li id="t9mU7ExApuYZov48cAR6Uo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果是链表节点则进行添加节点到链表中</span></li><li id="sbtGkYGvGUCMM2T7a872C3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果是红黑树则添加节点到红黑树</span></li></ul></li><li id="hm2CVyAz5GSzFPi8Qx1rT1"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">添加成功后，判断是否需要进行树化</span></li><li id="fR1xwoexGs34LfP1ayDqJR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">addCount，这个方法的意思是<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的元素个数加<span class="jill"></span>1，但是这个操作也是需要并发安全的，并且元素个数加<span class="jill"></span>1<span class="jill"></span>成功后，会继续判断是否要进行扩容，如果需要，则会进行扩容，所以这个方法很重要。</span></li><li id="em8UYj1sxKJQcunK52tuB5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">同时一个线程在<span class="jill"></span>put<span class="jill"></span>时如果发现当前<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>正在进行扩容则会去帮助扩容。</span></li></ul><div id="tEnnuZSSBo78D18yieShsp" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="nKJRVJLtmEq9XqN6FzgUNm" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">JDK 1.7 ConcurrentHashMap<span class="jill"></span>如何保证并发</span></h1><h2 id="sgezBBzMTdz1fzbqC6UKm1" class="wolai-block"><span class="wolai-serial-number">18.1</span><span class="inline-wrap">背记</span></h2><div id="fx3b5MwwTttNXBgLH8vCy5" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.7<span class="jill"></span>中的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>通过分段锁机制来保证并发性：</span></div></div><h3 id="eYkzH4B3xoav4JkzsTkzUZ" class="wolai-block"><span class="wolai-serial-number">18.1.1</span><span class="inline-wrap">分段锁技术</span></h3><div id="6B6FWPaCSo6G4aXmUvVu53" class="wolai-block wolai-text"><div><span class="inline-wrap">ConcurrentHashMap<span class="jill"></span>将内部结构分为多个段（Segment），每个段都有自己的锁。</span></div></div><div id="wYLRdqk75qLfpimggg788v" class="wolai-block wolai-text"><div><span class="inline-wrap">这样，当多个线程尝试访问不同的段时，它们可以同时进行，不会被其他线程持有的锁阻塞。</span></div></div><div id="8VtrWPytn6nckvbW5J6Lra" class="wolai-block wolai-text"><div><span class="inline-wrap">这种细粒度的锁定机制提高了并发度。</span></div></div><h3 id="tNrCyxVXcbMxgQCQ2r5gWP" class="wolai-block"><span class="wolai-serial-number">18.1.2</span><span class="inline-wrap">高效的读操作</span></h3><div id="ip8foLo7JNaeG36momimzV" class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span>HashEntry<span class="jill"></span>对象的不变性和<span class="jill"></span>volatile<span class="jill"></span>变量的使用，读操作可以在没有锁的情况下安全地进行。</span></div></div><div id="pjdDVFEprQvf9iJjZCAhDg" class="wolai-block wolai-text"><div><span class="inline-wrap">即使有写操作正在进行，读操作也能够看到最新的内存状态，这是通过内存可见性保证的。</span></div></div><h3 id="j9oULwF68SbNePkF7SQmDC" class="wolai-block"><span class="wolai-serial-number">18.1.3</span><span class="inline-wrap">跨段操作的安全性</span></h3><div id="bjVk1Tv4PvMvmBv18YEmtq" class="wolai-block wolai-text"><div><span class="inline-wrap">对于跨段的读操作<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>提供了两种方案：不加锁和加锁。</span></div></div><div id="jiRFbsUcne1ggYAZ3hHUVp" class="wolai-block wolai-text"><div><span class="inline-wrap">不加锁的方案适用于读多写少的场景，而加锁方案则用于写操作较多的场景，以确保操作的安全性。</span></div></div><div id="n9AHH3SZfDqS7uCjLhfYCN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ag6Zpw3gojeu6uuXqkuAim" class="wolai-block"><span class="wolai-serial-number">18.2</span><span class="inline-wrap">理解</span></h2><div id="cPf1rEBjp3TeCF2yVBCYLN" class="wolai-block wolai-text"><div><span class="inline-wrap">主要利用<span class="jill"></span>Unsafe<span class="jill"></span>操作<span class="jill"></span>+ ReentrantLock +<span class="jill"></span>分段思想。</span></div></div><div id="wkgs3AK9mcVFNGxjjEznZi" class="wolai-block wolai-text"><div><span class="inline-wrap">主要使用了<span class="jill"></span>Unsafe<span class="jill"></span>操作中的：</span></div></div><ul class="wolai-block"><li id="rve2R2KfSCtfVqa8t5uayP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">compareAndSwapObject：通过<span class="jill"></span>CAS<span class="jill"></span>的方式修改对象的属性</span></li><li id="K4Uqa9GVewe67Tqc5Shqo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">putOrderedObject：并发安全的给数组的某个位置赋值</span></li><li id="3bwpeKwPhtxAmuDkbLkyKS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">getObjectVolatile：并发安全的获取数组某个位置的元素</span></li></ul><div id="abEL2bJ4jNLCrwrZ76odiZ" class="wolai-block wolai-text"><div><span class="inline-wrap">分段思想是为了提高<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的并发量，分段数越高则支持的最大并发量越高，程序员可以通过<span class="jill"></span>concurrencyLevel<span class="jill"></span>参数来指定并发量。</span></div></div><div id="tZQGEa54o4XHCyc9noH6RB" class="wolai-block wolai-text"><div><span class="inline-wrap">ConcurrentHashMap<span class="jill"></span>的内部类<span class="jill"></span>Segment<span class="jill"></span>就是用来表示某一个段的。</span></div></div><div id="kzrpTiDGCLydsaKEpyzByv" class="wolai-block wolai-text"><div><span class="inline-wrap">每个<span class="jill"></span>Segment<span class="jill"></span>就是一个小型的<span class="jill"></span>HashMap，当调用<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>的<span class="jill"></span>put()方法时，最终会调用到<span class="jill"></span>Segment<span class="jill"></span>的<span class="jill"></span>put()方法，而<span class="jill"></span>Segment<span class="jill"></span>类继承了<span class="jill"></span>ReentrantLock，所以<span class="jill"></span>Segment<span class="jill"></span>自带可重入锁，当调用到<span class="jill"></span>Segment<span class="jill"></span>的<span class="jill"></span>put<span class="jill"></span>方法时，会先利用可重入锁加锁，加锁成功后再将待插入的<span class="jill"></span>key、value<span class="jill"></span>插入到小型<span class="jill"></span>HashMap<span class="jill"></span>中，插入完成后解锁。</span></div></div><div id="21tq7Tfa2N76iPeyX5DXR8" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="sjiMEPSYTp4TF15mJVn836" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">JDK 1.8 ConcurrentHashMap<span class="jill"></span>如何保证并发</span></h1><div id="6pq29GNzXcdcReTYEnLxg9" class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>中的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>通过以下几个方面的细节来保证并发性：</span></div></div><h2 id="yZvfuPcjPR3yjhXXf4Qf" class="wolai-block"><span class="wolai-serial-number">19.1</span><span class="inline-wrap">数据结构</span></h2><div id="fZ31H4RPGjj4ugYgXhboHx" class="wolai-block wolai-text"><div><span class="inline-wrap">使用数组<span class="jill"></span>+<span class="jill"></span>链表<span class="jill"></span>+<span class="jill"></span>红黑树的混合结构，其中数组用于存储桶（bucket），链表用于解决哈希冲突，当链表长度超过一定阈值时会转化为红黑树以提升性能。</span></div></div><h2 id="wj6zRKdUszvD2QNK8Nkmva" class="wolai-block"><span class="wolai-serial-number">19.2</span><span class="inline-wrap">无锁操作</span></h2><div id="7PoHzrKnvLQZqE57w59Sh6" class="wolai-block wolai-text"><div><span class="inline-wrap">ConcurrentHashMap<span class="jill"></span>在大部分读操作中不需要加锁，而是采用无锁的方式来进行。</span></div></div><div id="axFDEdRXEgAxEZxRaubo7h" class="wolai-block wolai-text"><div><span class="inline-wrap">这是通过使用 volatile 关键字和<span class="jill"></span>CAS（Compare And Swap）操作来实现的。</span></div></div><h2 id="5JQ6imP6YFfKaF8RU8uq2K" class="wolai-block"><span class="wolai-serial-number">19.3</span><span class="inline-wrap">CAS<span class="jill"></span>操作</span></h2><div id="gVbEVGsk7W4xaLb7YfFw3w" class="wolai-block wolai-text"><div><span class="inline-wrap">在更新操作中<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>使用了<span class="jill"></span>CAS<span class="jill"></span>操作来减少同步的开销，并确保原子性操作。</span></div></div><h2 id="8G3tnixqLntbmx1i2rE8tt" class="wolai-block"><span class="wolai-serial-number">19.4</span><span class="inline-wrap">扩容机制</span></h2><div id="pGscFjKSEe9c65d9zDyqLx" class="wolai-block wolai-text"><div><span class="inline-wrap">当元素数量达到阈值时，ConcurrentHashMap<span class="jill"></span>会触发扩容操作，即创建一个新的数组并将旧数组中的元素重新散列到新数组中。</span></div></div><h2 id="7SgPu8Myq8BRjXRaaQwEsX" class="wolai-block"><span class="wolai-serial-number">19.5</span><span class="inline-wrap">分段锁技术</span></h2><div id="9vCWQY7apyrjxBASXHcwJZ" class="wolai-block wolai-text"><div><span class="inline-wrap">尽管<span class="jill"></span>JDK1.8<span class="jill"></span>的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>不再依赖分段锁，但在一些写操作中仍然使用了锁来保证线程安全。</span></div></div><div id="sHuRCkNPQy3wcQg2iW7W5V" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="2mx8xjyxp62K5ajydEmypG" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，JDK1.8<span class="jill"></span>中的<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>通过这些细节设计实现了高效的并发操作，同时保持了数据的线程安全性。</span></div></div><div id="mf8zNNwNYyKyAh9d5jETmQ" class="wolai-block wolai-text"><div></div></div><div id="weYircteQ4odgQY4Ljr9a5" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="wC2UZkGY7twiyFNtxiVW7Y" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">HashSet<span class="jill"></span>的去重原理</span></h1><h2 id="wyx1N6Y6o36LQaEhVa9oSn" class="wolai-block"><span class="wolai-serial-number">20.1</span><span class="inline-wrap">背记</span></h2><div id="imS9jTx1aDCi8GKLHwf9hz" class="wolai-block wolai-text"><div><span class="inline-wrap">HashSet<span class="jill"></span>的去重原理主要基于<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>key<span class="jill"></span>不重复特性。</span></div></div><div id="jQzy1qgDjsqTq1oAd7zM69" class="wolai-block wolai-text"><div><span class="inline-wrap">HashSet<span class="jill"></span>底层使用了一个<span class="jill"></span>HashMap<span class="jill"></span>来存储元素，所有放入<span class="jill"></span>HashSet<span class="jill"></span>中的元素实际上都被存储在<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>key<span class="jill"></span>中，而此时<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>value<span class="jill"></span>则是一个常量对象。</span></div></div><div id="eJxV21nuZWXjggAgqqZSyX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="u2aTGbFF1NR97sZGQ44MLD" class="wolai-block"><span class="wolai-serial-number">20.2</span><span class="inline-wrap">理解</span></h2><div id="iRTrmzFTRuAfRp7gGKPkg1" class="wolai-block wolai-text"><div><span class="inline-wrap">详细来说，HashSet<span class="jill"></span>底层使用了一个<span class="jill"></span>HashMap<span class="jill"></span>来存储元素，所有放入<span class="jill"></span>HashSet<span class="jill"></span>中的元素实际上都被存储在<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>key<span class="jill"></span>中，而<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>value<span class="jill"></span>则是一个常量对象。</span></div></div><div id="SjyKXdLNJKCwBRf6kuRqX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="dpNDWFFJkDVR8s8oyG6Umg" class="wolai-block wolai-text"><div><span class="inline-wrap">下面是<span class="jill"></span>HashSet<span class="jill"></span>实现去重的具体步骤：</span></div></div><ul class="wolai-block"><li id="m82F9BaJQtPjTGFYKHZrir"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">哈希值计算：当一个元素被添加到<span class="jill"></span>HashSet<span class="jill"></span>时，首先会调用该元素的<span class="jill"></span>hashCode()方法来计算其哈希值。</span></li><li id="4J4pgT6pL3vBQpFyTp3snw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存储位置确定：根据计算出的哈希值，确定该元素在<span class="jill"></span>HashMap<span class="jill"></span>中的存储位置。</span></li><li id="pcqP6uGWVXzU9WGEDLYB1a"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重复性检查：如果<span class="jill"></span>HashMap<span class="jill"></span>在该位置已经存有其他元素，HashSet<span class="jill"></span>会调用现有元素的<span class="jill"></span>equals() 方法与新添加的元素进行比较。</span></li><li id="2ypRc1vZztujxdsUxAd6Ma"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">去重决策：如果<span class="jill"></span>equals()方法返回<span class="jill"></span>true，表明两个元素相等，新元素将不会被添加到<span class="jill"></span>HashSet<span class="jill"></span>中，从而实现了去重的效果。</span></li></ul><div id="aEUk9fPWjnHC5eabS2ZEYh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="oqvQE9TCbihmoSKFsqimFP" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，对于基本数据类型或者<span class="jill"></span>String<span class="jill"></span>类型的集合，HashSet<span class="jill"></span>能够成功实现去重是因为这些类型已经正确地覆盖了<span class="jill"></span>hashCode()和<span class="jill"></span>equals() 方法。</span></div></div><div id="kFoE51KXXxFVTfWZGtJ5bS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="m2QU6mn7YMt7uUJxYu5frr" class="wolai-block wolai-text"><div><span class="inline-wrap">对于自定义类，如果想要在<span class="jill"></span>HashSet<span class="jill"></span>中正确去重，也必须重写这两个方法，确保相等的对象有相同的哈希码，这样<span class="jill"></span>HashSet<span class="jill"></span>才能识别它们为相同的元素并去除重复项。</span></div></div><div id="eZ7ZYxMVpMi6sK9ZVC6J4L" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="64wFmPvEKZWXXi251E8Unm" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，HashSet<span class="jill"></span>利用<span class="jill"></span>HashMap<span class="jill"></span>的<span class="jill"></span>key<span class="jill"></span>不能重复的特性来实现去重，通过覆写<span class="jill"></span>hashCode()和<span class="jill"></span>equals()方法来确保唯一性</span></div></div><div id="dGqHq4emYHaxEGjJfJsjKY" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="dDSpEkpB4Vh5J3rn3JhCPY" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">集合与数组的区别</span></h1><div id="q7CouvGELESMND3Wzsq3ni" class="wolai-block wolai-text"><div><span class="inline-wrap">集合与数组在<span class="jill"></span>Java<span class="jill"></span>中是两种不同的数据结构，它们在元素类型、大小可变性、存储类型以及成员方法上有显著的区别。</span></div></div><div id="2wemgEUgdytWG9aFoBxgxc" class="wolai-block wolai-text"><div><span class="inline-wrap">具体分析如下：</span></div></div><h2 id="4ovSyVwF92stTPUTMDukXx" class="wolai-block"><span class="wolai-serial-number">21.1</span><span class="inline-wrap">元素类型</span></h2><ul class="wolai-block"><li id="m15mdLCWUNi7MSctk4Gyzu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组在声明时需要指定元素的类型，且所有元素的类型必须一致。</span></li><li id="4AFvLX2czU9ty1MxmKvjND"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集合不强制要求元素的类型一致性，可以存储不同类型的数据。</span></li></ul><div id="fvVdzuRV4FrgP7WE4KpX5T" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="52PVUsg4PqEL8Nim5CcyZP" class="wolai-block"><span class="wolai-serial-number">21.2</span><span class="inline-wrap">大小可变性</span></h2><ul class="wolai-block"><li id="9EsmKa9Nj6XNCrnCspReHM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组的大小是固定的，一旦创建后无法更改其容量。</span></li><li id="rjVf26wB8X7kvLjPEdr4i"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集合的大小是动态的，可以根据需要扩展或缩减其容量。</span></li></ul><div id="rQn4aZLHn4QByQcowzXdnT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="sEDw56KAmW7HRSFnGJk4U7" class="wolai-block"><span class="wolai-serial-number">21.3</span><span class="inline-wrap">存储类型</span></h2><ul class="wolai-block"><li id="69ajTuG1j2iuq2K4XgqqFo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组可以存储基本数据类型和引用类型。</span></li><li id="pV6L1CrPmhNyiKU8ekzYne"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集合只能存储引用类型，不能直接存储基本数据类型。</span></li></ul><div id="nn6SkZcnPcgs2wvpr4XtCG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rS4hBYZJxTWJg7MNXzEJdQ" class="wolai-block"><span class="wolai-serial-number">21.4</span><span class="inline-wrap">成员方法</span></h2><ul class="wolai-block"><li id="tv3Ua3v9YNSH6YnztJ7PDo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">集合提供了丰富的内置方法，如<span class="jill"></span>add、remove、contains<span class="jill"></span>等，这些方法使得集合的操作更加灵活和方便。</span></li><li id="boZypMyBoHBnRsLUHoaaex"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组的方法相对较少，主要依赖于<span class="jill"></span>Array<span class="jill"></span>类的静态方法进行操作。</span></li></ul><div id="cqJK2o9E4nqB1mMoPcPSCc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="aEKD6wL3R7JtEEp3yYRtUv" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，集合提供了比数组更高级的功能，包括动态调整大小、存储不同类型的对象以及提供多样化的成员方法。</span></div></div><div id="f6bJFvc3omoo8XM6tAyD5" class="wolai-block wolai-text"><div><span class="inline-wrap">而数组则在声明时需要确定大小和类型，但在处理大量同类型数据时可能更高效。</span></div></div><div id="aV5wKvtwp7uYBgCpLhVYtL" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="f4ZKciQcVpBkNdnxqLijzu" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">TreeSet<span class="jill"></span>和<span class="jill"></span>HashSet<span class="jill"></span>的区别</span></h1><h2 id="s9fcWYZRPKQ3GbdzJj8wRd" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">背记</span></h2><div id="3Cmbphqh8mR5mQV33HsMzy" class="wolai-block wolai-text"><div><span class="inline-wrap">TreeSet<span class="jill"></span>和<span class="jill"></span>HashSet<span class="jill"></span>在<span class="jill"></span>Java<span class="jill"></span>中都是用于存储不重复元素的集合类。</span></div></div><h3 id="7umoJoM2qy6SuaYgm3a7NB" class="wolai-block"><span class="wolai-serial-number">22.1.1</span><span class="inline-wrap">底层数据结构</span></h3><ul class="wolai-block"><li id="hVpYyot9XY26WjHgoPQkTh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashSet<span class="jill"></span>是基于</span><span class="blue inline-wrap"><u><b>哈希表</b></u></span><span class="inline-wrap">实现的</span></li><li id="gKiSB86vq8E3nj32M87ta6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TreeSet<span class="jill"></span>是基于</span><span class="blue inline-wrap"><u><b>红黑树</b></u></span><span class="inline-wrap">（一种</span><span class="blue inline-wrap"><u><b>自平衡的二叉查找树</b></u></span><span class="inline-wrap">）实现的</span></li></ul><div id="eNh1RaJzTEHXeszjJahY7B" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="tbuB996mHn37Res3Q45Rys" class="wolai-block"><span class="wolai-serial-number">22.1.2</span><span class="inline-wrap">元素顺序</span></h3><ul class="wolai-block"><li id="49wkh2zEQhSkSJcaAALkMy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashSet<span class="jill"></span>不保证元素的顺序，元素是无序存放的；</span></li><li id="aviLeJjCQmDSgeeH7x4H6P"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TreeSet<span class="jill"></span>可以保证元素的顺序，元素会按照自然顺序或者根据提供的比较器进行排序</span></li></ul><div id="iPSGaa7YNw8ganE3RCgRdL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="bHq7hbC2RMXqTB1iVrpxBB" class="wolai-block"><span class="wolai-serial-number">22.1.3</span><span class="inline-wrap">null<span class="jill"></span>元素</span></h3><ul class="wolai-block"><li id="pWYTy16WKQCKAyuHKB9zot"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HashSet<span class="jill"></span>允许放入<span class="jill"></span>null<span class="jill"></span>值，因为哈希表可以使用<span class="jill"></span>null<span class="jill"></span>作为键；</span></li><li id="gCEWamr532ArH7JEBFe3Tw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TreeSet<span class="jill"></span>不允许放入<span class="jill"></span>null<span class="jill"></span>值，因为在二叉查找树中<span class="jill"></span>null<span class="jill"></span>无法进行比较</span></li></ul><div id="kfwR2ee8i4ZSpS3GrqRSuP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jRYuWwuWijGN6azc7zRzpE" class="wolai-block"><span class="wolai-serial-number">22.1.4</span><span class="inline-wrap">性能特点</span></h3><div id="a9qmKU2Lw7mVYD4UbEbYvn" class="wolai-block wolai-text"><div><span class="inline-wrap">在大多数情况下，HashSet<span class="jill"></span>的性能要优于<span class="jill"></span>TreeSet，尤其是在添加和检索元素时，因为哈希表的操作通常具有常数时间复杂度。</span></div></div><div id="cyvnmSnZ9AnEg7bVnMGuSP" class="wolai-block wolai-text"><div><span class="inline-wrap">但是，如果需要对集合进行排序操作，TreeSet<span class="jill"></span>会更适合，因为它内部维持了元素的有序状态。</span></div></div><div id="oZCc29H2HkFhZNysqKq5jC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7U2hnzFshm6wMd9xnmfWBR" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">理解</span></h2><div id="s2x4azkyG9RZa7pZyUQVWN" class="wolai-block wolai-text"><div><span class="inline-wrap">TreeSet<span class="jill"></span>和<span class="jill"></span>HashSet<span class="jill"></span>的底层原理要点涉及它们各自的数据结构实现和操作机制。</span></div></div><div id="42EbE4Gr87QXmTTTQWdw6K" class="wolai-block wolai-text"><div><span class="inline-wrap">具体来看：</span></div></div><h3 id="n9WQvjpcDTfm4CsFft3Zud" class="wolai-block"><span class="wolai-serial-number">22.2.1</span><span class="inline-wrap">二叉树与二叉查找树</span></h3><div id="fpwJ6MqwwTkbSyxjq7pwWC" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>TreeSet<span class="jill"></span>中，元素的存储是基于二叉查找树（BST）的数据结构。</span></div></div><div id="kJLvzp4vtrc3XYJz9weAWD" class="wolai-block wolai-text"><div><span class="inline-wrap">二叉查找树是一种特殊的二叉树，其中左子节点的值总是小于其父节点，右子节点的值总是大于其父节点。</span></div></div><div id="MY8V2xHG2FmDFoVY96SzX" class="wolai-block wolai-text"><div><span class="inline-wrap">这种结构保证了元素会自动按照排序顺序存储。</span></div></div><div id="5XW6tJ1qnkigUmJrrtidpD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jbokfmjf9mVWKTDNaCkF6f" class="wolai-block"><span class="wolai-serial-number">22.2.2</span><span class="inline-wrap">哈希表</span></h3><div id="8GeyfgzDLUdPfDixHCvPDE" class="wolai-block wolai-text"><div><span class="inline-wrap">HashSet<span class="jill"></span>的底层实现基于<span class="jill"></span>HashMap，它使用数组加链表的方式来存储元素。</span></div></div><div id="hCEiC5buKAKbWX7kzp7ewk" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个对象被加入<span class="jill"></span>HashSet<span class="jill"></span>时，首先会计算对象的哈希值，然后通过移位运算确定该对象在哈希表中的位置。</span></div></div><div id="fKvQ8xFMdGUFeqLV8Gx1u8" class="wolai-block wolai-text"><div><span class="inline-wrap">如果该位置没有其他元素，则直接存储；如果有，则以链表的形式存储在这个位置上。</span></div></div><div id="2qrQiNcWrv8zWh4BsFAweZ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="h35BTMW69cLJhQQLD8wycB" class="wolai-block"><span class="wolai-serial-number">22.2.3</span><span class="inline-wrap">hashCode()和<span class="jill"></span>equals()方法的重要性</span></h3><div id="9BJniYShF8RPNoTGHxggvc" class="wolai-block wolai-text"><div><span class="inline-wrap">对于<span class="jill"></span>HashMap<span class="jill"></span>和<span class="jill"></span>HashSet<span class="jill"></span>来说，hashCode()方法和<span class="jill"></span>equals()方法至关重要。</span></div></div><div id="t24RjHBRh8ryy6zgDzfe69" class="wolai-block wolai-text"><div><span class="inline-wrap">hashCode()方法用于计算对象的哈希值，而<span class="jill"></span>equals()方法用于比较两个对象是否相等。</span></div></div><div id="d9ec4YQoXJg2AwHjUh5AiK" class="wolai-block wolai-text"><div><span class="inline-wrap">这两个方法的正确实现对于集合类的性能和准确性至关重要。</span></div></div><div id="u4na9sXEpDGs6MM1f4wMBg" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="rwPVHN7fFoXj6NmEGMkhzx" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，TreeSet<span class="jill"></span>和<span class="jill"></span>HashSet<span class="jill"></span>的底层原理主要区别在于它们采用的数据结构不同，这导致了它们在性能和功能上的不同。</span></div></div><div id="sBy355yLHoGYyuhHiBQxm8" class="wolai-block wolai-text"><div><span class="inline-wrap">TreeSet<span class="jill"></span>基于二叉查找树，保证了元素的有序性和范围查询的能力；</span></div></div><div id="fvRNfXddtmHMAQ5GmUTd9v" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>HashSet<span class="jill"></span>基于<span class="jill"></span>HashMap，提供了快速的插入和查询操作，但不保证元素的顺序。</span></div></div><div id="rTPWHeGpmSsaRnSkxVqYSt" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="jjWThqBXfPmD68tTGAnxM" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">如何遍历一个<span class="jill"></span>Map<span class="jill"></span>集合？</span></h1><h2 id="rnEFhVyLJM9t7bCRmYoJn6" class="wolai-block"><span class="wolai-serial-number">23.1</span><span class="inline-wrap">背记</span></h2><div id="pQccxeydEXd9N6hXKZEqNg" class="wolai-block wolai-text"><div><span class="inline-wrap">遍历<span class="jill"></span>Map<span class="jill"></span>一共有三种方式：</span></div></div><ul class="wolai-block"><li id="gPS78TAcWjWoaWE5ZLNyyu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方式一：KeySet<span class="jill"></span>迭代</span></li><li id="wS39dmyUrYf9CZzJpwyxA7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方式二：EntrySet<span class="jill"></span>迭代</span></li><li id="qUjPvVkkDf6i1TMEuxq6Tm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方式三：基于<span class="jill"></span>Lambda<span class="jill"></span>表达式的增强<span class="jill"></span>for<span class="jill"></span>循环</span></li></ul><div id="7FXK2ewnvTwWzyv7xmi3YP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="tSRtqFca4a4Vdxwwpsq8oD" class="wolai-block"><span class="wolai-serial-number">23.2</span><span class="inline-wrap">理解</span></h2><div id="t7kZonar4VhJ3kmcbhS8dp" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Java<span class="jill"></span>中，Map<span class="jill"></span>集合的三种常见遍历方式包括</span><span class="blue inline-wrap"><u><b>键找值的方式</b></u></span><span class="inline-wrap">遍历、</span><span class="blue inline-wrap"><u><b>键值对的方式</b></u></span><span class="inline-wrap">遍历以及</span><span class="blue inline-wrap"><u><b>使用<span class="jill"></span>Lambda<span class="jill"></span>表达式</b></u></span><span class="inline-wrap">遍历。具体思路如下：</span></div></div><h3 id="iBBSsPCkLz8DjW25u5b2WZ" class="wolai-block"><span class="wolai-serial-number">23.2.1</span><span class="inline-wrap">键找值的方式</span></h3><ul class="wolai-block"><li id="8ueymzgFkFywjRpKSNVncn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">首先通过<span class="jill"></span>Map<span class="jill"></span>集合的 keySet() 方法获取所有的键，这将返回一个包含所有键的<span class="jill"></span>Set<span class="jill"></span>集合。</span></li><li id="e2tbUd24StNmYa3yyR69V3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">然后遍历这个<span class="jill"></span>Set<span class="jill"></span>集合，对于集合中的每个键，使用 get(key) 方法来获取对应的值。</span></li><li id="i4Fwd1U8YWhbgoJ45C5CA7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这种方式的优点是直观简单，但需要两次查找操作，一次是从<span class="jill"></span>Set<span class="jill"></span>中找到键，另一次是从<span class="jill"></span>Map<span class="jill"></span>中通过键找到值。</span></li></ul><code-block id="mz2jmqKXYqyheiQomoWPws" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key01"</span><span class="token punctuation">,</span> <span class="token string">"value01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key02"</span><span class="token punctuation">,</span> <span class="token string">"value02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key03"</span><span class="token punctuation">,</span> <span class="token string">"value03"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keySet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 示例代码</pre></div></code-block><div id="pfXMDfFHsGqKeGK6esEmx1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="be2ehACbNCCPSuT7JhWEiz" class="wolai-block"><span class="wolai-serial-number">23.2.2</span><span class="inline-wrap">键值对的方式</span></h3><ul class="wolai-block"><li id="jfyvuta2842SMRf957fsfZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用<span class="jill"></span>Map<span class="jill"></span>集合的 entrySet() 方法获取包含所有键值对的<span class="jill"></span>Set<span class="jill"></span>集合，每个元素是一个<span class="jill"></span>Entry<span class="jill"></span>对象，包含了键和值。</span></li><li id="h9zurBHox1rek4n374bpjC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">遍历这个<span class="jill"></span>Set<span class="jill"></span>集合，对于每个<span class="jill"></span>Entry<span class="jill"></span>对象，可以通过 getKey() 和 getValue() 方法分别获取键和值。</span></li><li id="ofb1UpdpyrVmH2Jmd8tNUS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这种方式将键和值作为一个整体进行遍历，可以一次性获取到键和值，效率较高。</span></li></ul><code-block id="8J3U76KMX2wwPSMKnFCugR" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key01"</span><span class="token punctuation">,</span> <span class="token string">"value01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key02"</span><span class="token punctuation">,</span> <span class="token string">"value02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key03"</span><span class="token punctuation">,</span> <span class="token string">"value03"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 示例代码</pre></div></code-block><div id="4t16XJCPSybyzRxpBS4Uri" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="tpfWGi13BAcupYENH69enB" class="wolai-block"><span class="wolai-serial-number">23.2.3</span><span class="inline-wrap">Lambda<span class="jill"></span>表达式遍历（JDK 1.8<span class="jill"></span>及以上版本）</span></h3><ul class="wolai-block"><li id="gAcqr33svWJHdAw5vik26j"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">利用<span class="jill"></span>Java 8<span class="jill"></span>引入的<span class="jill"></span>Lambda<span class="jill"></span>表达式，可以更加简洁地遍历<span class="jill"></span>Map<span class="jill"></span>集合。</span></li><li id="vhwnfbV1CwSJB7sj4ofEZ7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">使用 forEach 方法，传入一个<span class="jill"></span>Lambda<span class="jill"></span>表达式，该表达式接受一个<span class="jill"></span>Entry<span class="jill"></span>参数，可以直接在表达式中处理键和值。</span></li><li id="ageiEQu7AXqk7WRgXNjJH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这种方式的代码更加简洁，且易于阅读，是现代<span class="jill"></span>Java<span class="jill"></span>编程中推荐的做法。</span></li></ul><code-block id="5YqBHQUwKMDTcGdxWPZ5pJ" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key01"</span><span class="token punctuation">,</span> <span class="token string">"value01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key02"</span><span class="token punctuation">,</span> <span class="token string">"value02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key03"</span><span class="token punctuation">,</span> <span class="token string">"value03"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 示例代码</pre></div></code-block><div id="oqjqvoKBNastyQ1GYNc9KT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="jumDK6Q2BabiR2N2zRJDSY" class="wolai-block"><span class="wolai-serial-number">23.2.4</span><span class="inline-wrap">补充：仅遍历所有值</span></h3><ul class="wolai-block"><li id="mE2xEqVxoPHex1WpyHQRdq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果不关心<span class="jill"></span>Map<span class="jill"></span>中的<span class="jill"></span>key，也可以只遍历<span class="jill"></span>Map<span class="jill"></span>中的值</span></li></ul><code-block id="92eTrev6YWu4WXf4UAGdhe" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key01"</span><span class="token punctuation">,</span> <span class="token string">"value01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key02"</span><span class="token punctuation">,</span> <span class="token string">"value02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key03"</span><span class="token punctuation">,</span> <span class="token string">"value03"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 示例代码</pre></div></code-block><div id="csgh7VoF6QoMfcDGYPqMjn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="tgGSfSzKD5ycCC3Rx4WSEa" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="mVNNoq6VuYs8smw3ju7RiK" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">HashMap<span class="jill"></span>与<span class="jill"></span>HashTable 的区别</span></h1><h2 id="tf25QYNMzBsBwkFajAYgZe" class="wolai-block"><span class="wolai-serial-number">24.1</span><span class="inline-wrap">背记</span></h2><div id="bQYgWfGrtyuSZmWNepnPFz" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>和<span class="jill"></span>HashTable<span class="jill"></span>在继承关系、线程安全性和使用<span class="jill"></span>null<span class="jill"></span>作为键值方面存在差异</span></div></div><h3 id="oTj92FrqbhuHTZeZYbPwas" class="wolai-block"><span class="wolai-serial-number">24.1.1</span><span class="inline-wrap">继承关系</span></h3><div id="f9qHasDfVx5EvvuuUmstT" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>继承自<span class="jill"></span>AbstractMap<span class="jill"></span>类，而<span class="jill"></span>HashTable<span class="jill"></span>继承自<span class="jill"></span>Dictionary<span class="jill"></span>抽象类</span></div></div><div id="t6TffgP1MKfCysryQ8cu3a" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="4hd2n6oCPX8ASgtXjSBA7g" class="wolai-block"><span class="wolai-serial-number">24.1.2</span><span class="inline-wrap">线程安全性</span></h3><div id="j7SLHTm11XxA7hD2XG7qy8" class="wolai-block wolai-text"><div><span class="inline-wrap">HashTable<span class="jill"></span>的方法是同步的，这意味着它是线程安全的，可以直接在多线程环境中使用</span></div></div><div id="gNsSXoQQUpZWtXe2x927qt" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>HashMap<span class="jill"></span>是非同步的，如果在多线程环境下使用，需要外部同步或者通过<span class="jill"></span>Collections.synchronizedMap() 来获取一个线程安全的集合</span></div></div><div id="86pTC3tM55RKphVdsjRcg7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="rdaYAfhcF1q1xr3hqUJ6jf" class="wolai-block"><span class="wolai-serial-number">24.1.3</span><span class="inline-wrap">使用<span class="jill"></span>null<span class="jill"></span>作为键值</span></h3><div id="d5sNZiEnmMLY6KGGKACXRf" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>允许使用<span class="jill"></span>null<span class="jill"></span>作为键和值，虽然可以存储<span class="jill"></span>null<span class="jill"></span>键，但建议避免这样做，因为这样会导致所有的<span class="jill"></span>null<span class="jill"></span>键都存储在<span class="jill"></span>table<span class="jill"></span>数组的第一个节点上</span></div></div><div id="qVfP5dUMSUznxrUsuAYQPv" class="wolai-block wolai-text"><div><span class="inline-wrap">而<span class="jill"></span>HashTable<span class="jill"></span>不允许<span class="jill"></span>null<span class="jill"></span>作为键或值，这是为了避免潜在的<span class="jill"></span>NullPointerException<span class="jill"></span>问题</span></div></div><div id="c8gbYqdN2yPQ7J8BQvRXtC" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="xxsijTPtGeQKdtBJBXwgbw" class="wolai-block"><span class="wolai-serial-number">24.2</span><span class="inline-wrap">理解</span></h2><div id="m64nTnoL873YhdvgePeRJu" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>和<span class="jill"></span>HashTable<span class="jill"></span>在底层实现上主要基于散列表，但它们的存储结构、线程安全性和使用限制等方面存在差异</span></div></div><div id="vGrJXYowFj3fH5LuJNtr4D" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5zzqJkDKWGmBRKarhjpKjH" class="wolai-block"><span class="wolai-serial-number">24.2.1</span><span class="inline-wrap">存储结构</span></h3><div id="6mghERay2AJaipVfynpEDa" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>的底层实现是数组加链表（JDK1.8<span class="jill"></span>之前），在<span class="jill"></span>JDK1.8<span class="jill"></span>及以后版本中，为了提高性能，当链表长度超过一定阈值时，链表会转换为红黑树。这种结构既保证了查询效率，也便于元素的增加和删除。</span></div></div><div id="wtVgiF7PRyQhf4uKv1oh6a" class="wolai-block wolai-text"><div><span class="inline-wrap">Hashtable<span class="jill"></span>的底层也是基于散列表，但它只使用链表来解决冲突，不支持<span class="jill"></span>JDK1.8<span class="jill"></span>中<span class="jill"></span>HashMap<span class="jill"></span>的红黑树优化。</span></div></div><div id="cnTX2jg9nr1ayFc9Jj6KvD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="YXALi8esiuds6sVkqmtWN" class="wolai-block"><span class="wolai-serial-number">24.2.2</span><span class="inline-wrap">线程安全性</span></h3><div id="f1r8v4NdQMQG8uPpRpvhQB" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>是非线程安全的，这意味着在多线程环境下直接使用可能会出现并发问题</span></div></div><div id="afU9zDxzfRL1SNb3ZEkcEV" class="wolai-block wolai-text"><div><span class="inline-wrap">如果需要在多线程环境中使用，可以考虑使用 Collections.synchronizedMap() 方法来包装<span class="jill"></span>HashMap，或者使用<span class="jill"></span>ConcurrentHashMap<span class="jill"></span>作为替代方案</span></div></div><div id="34sgqkS13HRzPRKejvPvgG" class="wolai-block wolai-text"><div><span class="inline-wrap">HashTable<span class="jill"></span>是线程安全的，因为它的方法是同步的</span></div></div><div id="j99udXCQNAfK2ekKKpeWC" class="wolai-block wolai-text"><div><span class="inline-wrap">这确保了在多线程环境下的安全性，但也因此牺牲了一定的性能，因为所有线程在执行方法时都需要获得对象的锁</span></div></div><div id="jatRotvTszScVq6cnmGyxU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="w5zhguu4iWqDz1p8R6Wu9T" class="wolai-block"><span class="wolai-serial-number">24.2.3</span><span class="inline-wrap">使用限制</span></h3><div id="mak1on3TUmyeFJvU595nfe" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>允许<span class="jill"></span>null<span class="jill"></span>值和<span class="jill"></span>null<span class="jill"></span>键，虽然可以使用<span class="jill"></span>null<span class="jill"></span>作为键，但是这样会导致所有的<span class="jill"></span>null<span class="jill"></span>键都存储在<span class="jill"></span>table<span class="jill"></span>数组的第一个节点上，可能会引起性能问题</span></div></div><div id="dh9TxEM6WHDaFByF6523GP" class="wolai-block wolai-text"><div><span class="inline-wrap">Hashtable<span class="jill"></span>不允许<span class="jill"></span>null<span class="jill"></span>作为键或值，这是为了避免潜在的<span class="jill"></span>NullPointerException<span class="jill"></span>问题</span></div></div><div id="nJZPMhY6tRpMWc5EgFx7RT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9g8LRJPVZFEbH3UNckCvWF" class="wolai-block"><span class="wolai-serial-number">24.2.4</span><span class="inline-wrap">初始容量和加载因子</span></h3><div id="j28bSRB1Kws23vePmepzcH" class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>的初始容量为<span class="jill"></span>16，加载因子为<span class="jill"></span>0.75。</span></div></div><div id="napJL2A1dCEDfihknVhfQW" class="wolai-block wolai-text"><div><span class="inline-wrap">加载因子越大，就是启用扩容的阈值越大，这表明<span class="jill"></span>HashMap<span class="jill"></span>所占的内存越少，但是某一数组上挂载的链表长度越长，所以搜索速度越慢。</span></div></div><div id="4ShyUDG3wgdND2Hg6uWUYL" class="wolai-block wolai-text"><div><span class="inline-wrap">Hashtable<span class="jill"></span>的初始默认容量为<span class="jill"></span>11<span class="jill"></span>个，负载因子也是<span class="jill"></span>0.75。</span></div></div><div id="oNr3JZ7JL5VQxVFepHFnTD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="d3c2XctSW2jxcVKnqiMvge" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，HashMap<span class="jill"></span>和<span class="jill"></span>HashTable<span class="jill"></span>虽然都是基于散列表的实现，但它们在存储结构、线程安全性、使用限制以及初始容量和加载因子上有所不同。</span></div></div><div id="k1xM1wpLSBUtR75PJvaWQC" class="wolai-block wolai-text"><div><span class="inline-wrap">这些差异决定了它们在不同场景下的适用性和性能表现。</span></div></div><div id="vcxzBEJVkPy1AmP8nsV6Um" class="wolai-block wolai-text"><div><span class="inline-wrap">在实际开发中，选择合适的数据结构应根据具体的应用场景和需求来决定。</span></div></div><div id="bUHRNbsbPHhFh8om9AqydA" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6VTMixEgs4LLaCAs25GNG8" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><h1 id="kHVLLeYa5kuLB1r7Cwa9p8" class="wolai-block"><span class="wolai-serial-number">25</span><span class="inline-wrap">ArrayList<span class="jill"></span>和<span class="jill"></span>LinkedList<span class="jill"></span>的区别</span></h1><h2 id="ah9ta3Dyk5N8f2ebpBjNfN" class="wolai-block"><span class="wolai-serial-number">25.1</span><span class="inline-wrap">背记</span></h2><h3 id="FZaDwbQEzuhnqR85nCfGM" class="wolai-block"><span class="wolai-serial-number">25.1.1</span><span class="inline-wrap">内部实现</span></h3><ul class="wolai-block"><li id="izfVtHLAb6xt8FrXZq5sY4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ArrayList<span class="jill"></span>基于动态数组实现，这意味着它在底层使用一个可变长度的数组来存储元素。这种结构使得<span class="jill"></span>ArrayList<span class="jill"></span>在随机访问时非常高效。</span></li><li id="fG2ueDsSqp3BL5beuLb7Bg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedList<span class="jill"></span>基于双向链表实现，它在底层通过节点和指针来存储元素。这种方式使得<span class="jill"></span>LinkedList<span class="jill"></span>在执行插入和删除操作时更为高效。</span></li></ul><div id="fie6F37PttDzJLYJcKspE8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="vpNgu4a4YFSorAF5S8b7yB" class="wolai-block"><span class="wolai-serial-number">25.1.2</span><span class="inline-wrap">随机访问</span></h3><ul class="wolai-block"><li id="2J1kGZjJkACnApaggDRYBK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于<span class="jill"></span>ArrayList<span class="jill"></span>是基于数组的，它支持快速的随机访问，即可以通过索引直接访问任何位置的元素，时间复杂度为<span class="jill"></span>O(1)。</span></li><li id="icgTyfSgZcULRLyitEs5yv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedList<span class="jill"></span>不支持快速随机访问，要访问特定位置的元素需要从头或从尾遍历列表，因此时间复杂度为<span class="jill"></span>O(n)。</span></li></ul><div id="74drANw4b9o1d5RY8wgg16" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3U9gNje2Mj2pZhW7QPoAyk" class="wolai-block"><span class="wolai-serial-number">25.1.3</span><span class="inline-wrap">内存占用</span></h3><ul class="wolai-block"><li id="nk3EkeLTu9mdeJmADA5EZN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ArrayList<span class="jill"></span>在频繁进行插入和删除操作时可能会造成内存浪费，因为它需要移动其他元素来维护连续的内存空间。</span></li><li id="bGeGFpdJTcd2aq6JroEk2d"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LinkedList<span class="jill"></span>在每个元素上都需要额外的空间来存储指针信息，因此在内存占用上相对较高。</span></li></ul><div id="9Wf5dDAZztYRAmYZKcRRUn" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="a4g4Y99aEKKAoSwhK5xAGJ" class="wolai-block"><span class="wolai-serial-number">25.1.4</span><span class="inline-wrap">插入和删除操作</span></h3><div id="ft4K7294k8ASmmz1SLhWAc" class="wolai-block wolai-text"><div><span class="inline-wrap">对于频繁的插入和删除操作，LinkedList<span class="jill"></span>通常比<span class="jill"></span>ArrayList<span class="jill"></span>更高效，因为<span class="jill"></span>LinkedList<span class="jill"></span>只需要改变指针指向，而不需要移动其他元素的位置。</span></div></div><div id="v3iG1j5xBvcfgMvtWKW2V" class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList<span class="jill"></span>在进行插入和删除操作时，可能需要移动大量元素以保持数组的连续性，这会导致性能下降。</span></div></div><div id="5XpmmbUYKFvCMna8ByNzhS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mVCthbNsVV1RqunBMRbaaX" class="wolai-block"><span class="wolai-serial-number">25.2</span><span class="inline-wrap">理解</span></h2><div id="c2pHYDeafJhb2v1oLs5WZi" class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList<span class="jill"></span>的底层实现是基于动态数组，而<span class="jill"></span>LinkedList<span class="jill"></span>的底层实现是基于双向链表。</span></div></div><div id="ifCqJCdpZDTj6GwKwq82eb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="hA3GnWU4BfyTtAcRD54HDn" class="wolai-block"><span class="wolai-serial-number">25.2.1</span><span class="inline-wrap">ArrayList<span class="jill"></span>底层实现</span></h3><div id="tzeEfdbQbQywp8sJA8Yr2S" class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList<span class="jill"></span>在底层使用一个 Object 类型的数组来存储元素。</span></div></div><div id="5kpj6ELqcJE94gAtXDn6" class="wolai-block wolai-text"><div><span class="inline-wrap">这个数组在实例化时会被初始化为一个固定的长度，这个长度会随着元素的增加而动态扩展。</span></div></div><div id="hZWtuEZUpxLxuyD2Q8HrXZ" class="wolai-block wolai-text"><div><span class="inline-wrap">当 ArrayList 需要扩展容量时，它会创建一个新的数组，长度为原数组长度的<span class="jill"></span>1.5<span class="jill"></span>倍加<span class="jill"></span>1，然后将原数组中的元素复制到新数组中。</span></div></div><div id="iRq1AkDzDmQEUa4Ep9ATUE" class="wolai-block wolai-text"><div><span class="inline-wrap">这个过程称为动态扩容。</span></div></div><div id="5mEwQivNywipmgddKHwJaD" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9t1HJXAs32Cx2e37jN99QC" class="wolai-block"><span class="wolai-serial-number">25.2.2</span><span class="inline-wrap">LinkedList<span class="jill"></span>底层实现</span></h3><div id="hcSbTA478zCFCzfMJ5zpWQ" class="wolai-block wolai-text"><div><span class="inline-wrap">LinkedList<span class="jill"></span>在底层使用双向链表来实现。每个元素都被封装在一个节点对象中，每个节点包含指向前一个和后一个节点的引用。</span></div></div><div id="s3Kv3Ue1h8mg45qvq34NaB" class="wolai-block wolai-text"><div><span class="inline-wrap">这种结构使得在链表中添加或删除节点时，只需要改变相应的指针指向即可。</span></div></div><div id="7yg2Y6tugzyxTMJdGWox29" class="wolai-block wolai-text"><div><span class="inline-wrap">由于链表的特性，LinkedList<span class="jill"></span>在插入和删除操作上具有优势，因为这些操作不需要移动大量元素，只需要调整相邻节点的指针即可。</span></div></div><div id="eTtLwSY46KBUGThaWrihuZ" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，如果应用场景中随机访问操作较多，则 ArrayList 可能更适合；如果应用场景中插入和删除操作较多，则 LinkedList 可能更合适。</span></div></div><div id="4oiERD97ETX3oZhGeW4rxm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="u8QEEzJbQTkwmqDKZZzYSg" class="bg-fluorescent_purple2 wolai-block wolai-text"><div><span class="inline-wrap">            </span><br/></div></div><div id="8V7UEXgzXa88n4eigA2bEi" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>