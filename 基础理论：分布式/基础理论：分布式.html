<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>基础理论：分布式 - wolai 笔记</title><link rel="shortcut icon"></link></head><body class="full-width"><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;media/java-2410.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="基础理论：分布式" class="main-title"></div></div></header><article><h1 id="fdZxYjY3i7fTKARUvbSN8J" class="wolai-block"><span class="wolai-serial-number">1</span><span class="inline-wrap">负载均衡的意义是什么？</span></h1><div id="atX6siDPfV8YwLFvJZhHd1" class="wolai-block wolai-text"><div><span class="inline-wrap">负载均衡（Load Balancing）是指将网络或计算资源分配给多个服务器或设备，以达到提高系统性能、可扩展性和可靠性的目的。它在分布式系统中起到重要的作用，具有以下几个重要的意义：</span></div></div><ol class="wolai-block"><li id="gwB9wuE4oaaYoG5o1aGaAw"><div class="marker"></div><span class="inline-wrap"><b>提高系统性能</b></span><span class="inline-wrap">：负载均衡将请求均匀地分配给多个服务器，避免了单个服务器过载的情况。通过合理地分配负载，可以充分利用系统的资源，提高系统的吞吐量和响应速度。  </span></li><li id="8irvsFiTojTTxqbaSeqdmr"><div class="marker"></div><span class="inline-wrap"><b>实现高可用性</b></span><span class="inline-wrap">：通过将请求分发到多个服务器，即使其中某个服务器发生故障或不可用，仍然可以继续提供服务。负载均衡器能够检测到故障服务器，并将请求转发到其他正常工作的服务器，从而实现系统的高可用性和容错性。</span></li><li id="sdnqxFmCWw3f6h2Nkrp4BW"><div class="marker"></div><span class="inline-wrap"><b>支持系统扩展</b></span><span class="inline-wrap">：随着用户量和业务需求的增加，单个服务器可能无法满足系统的需求。负载均衡器可以根据实际情况动态地添加或删除服务器，实现系统的水平扩展。通过增加服务器数量，可以提高系统的处理能力和并发性能。</span></li><li id="4qG4mnaDjX9EUg62QSftgS"><div class="marker"></div><span class="inline-wrap"><b>优化资源利用</b></span><span class="inline-wrap">：负载均衡器可以根据服务器的负载情况智能地分配请求，使每个服务器的负载相对均衡。这样可以避免某些服务器过载而其他服务器处于空闲状态的情况，最大限度地提高资源的利用率。  </span></li><li id="n3KBGnGBPCXr98aB98xrS"><div class="marker"></div><span class="inline-wrap"><b>简化系统管理</b></span><span class="inline-wrap">：通过使用负载均衡器，可以将多个服务器组织成一个逻辑集群，对外提供统一的入口。这样可以简化系统的管理和维护工作，减少对客户端的影响，提高系统的可维护性和可管理性。  </span></li></ol><div id="4zhoiTeM2b98A75Q7nZVAp" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，负载均衡在分布式系统中具有重要的意义。它能够提高系统性能、可用性和可扩展性，优化资源利用，简化系统管理。通过合理地分配负载，负载均衡器能够实现高效、稳定和可靠的系统运行。</span></div></div><div id="rT1rCSnSSNRgQknnhcC6mF" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="v85gjuJ6ad4HKT2CZwpdXp" class="wolai-block"><span class="wolai-serial-number">2</span><span class="inline-wrap">分布式和微服务的区别是什么？</span></h1><div id="tYrB9yuxzFViChCaH9HWUW" class="wolai-block wolai-text"><div><span class="inline-wrap">分布式系统和微服务是两个相关但不同的概念，它们都涉及到软件架构中的组织和设计原则。以下是它们的区别：</span></div></div><h2 id="ftBJTJ5Yt2xH4gGuQ4NFtQ" class="wolai-block"><span class="wolai-serial-number">2.1</span><span class="inline-wrap">定义和范围</span></h2><div id="uC8zwkaLd8pzE2taubDQ9H" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：分布式系统是由多台计算机或服务器协同工作，通过网络通信来完成共同的任务。这些计算机可以分布在不同的地理位置，但它们通过网络连接进行协作。</span></div></div><div id="nLR1fyBbP3XRZmpmTVJLpB" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>微服务</b></span><span class="inline-wrap">：微服务是一种软件架构风格，将一个大型应用程序拆分成一组小型、独立的服务。每个微服务都专注于执行一个特定的业务功能，可以独立开发、部署和扩展。</span></div></div><div id="bCpRyEnqixkfox3gfXC32f" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pD6nNLRB8cRK8fpWeLWGk2" class="wolai-block"><span class="wolai-serial-number">2.2</span><span class="inline-wrap">关注点</span></h2><div id="stb1WKNFkcR7eRnLvWmW3E" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：关注于如何将不同的计算机或服务器连接起来，以实现高性能、高可用性和负载均衡等目标。</span></div></div><div id="8DtNhx4A3MeApYT9AEzSwb" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>微服务</b></span><span class="inline-wrap">：关注于如何将大型应用程序拆分成更小、更可管理的部分，并通过松耦合的方式来实现更灵活的开发、部署和维护。</span></div></div><div id="pxLBaswtqzaZPdvqevjJZF" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="m3k5Wr6ghtZ1NtmpzELARJ" class="wolai-block"><span class="wolai-serial-number">2.3</span><span class="inline-wrap">通信方式</span></h2><div id="4HzSrhYKyYJXSZp2STVpof" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：分布式系统中的组件之间需要进行网络通信，常见的通信方式包括远程过程调用（RPC）、消息队列等。</span></div></div><div id="bDr3CHcSasYcX6yvRExnVw" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>微服务</b></span><span class="inline-wrap">：微服务之间通常使用<span class="jill"></span>HTTP<span class="jill"></span>等协议进行通信，可以通过<span class="jill"></span>RESTful API<span class="jill"></span>或其他通信方式来实现。</span></div></div><div id="cMrMZrFmF5JcianmEMejp1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="m87dU3cApLmKFKTVtNVjb2" class="wolai-block"><span class="wolai-serial-number">2.4</span><span class="inline-wrap">数据一致性</span></h2><div id="hs13aYg6zufFpCnscgNH42" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：在分布式系统中，确保数据一致性是一个挑战，需要考虑分布式事务、数据复制等问题。</span></div></div><div id="uGh9vdFWMKpzaWex6E1B2t" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>微服务</b></span><span class="inline-wrap">：每个微服务可以拥有自己的数据存储，因此可以根据需求选择适当的数据库类型，并更容易管理数据一致性。</span></div></div><div id="w4r3jkXC2G38LhRZjjeT2c" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kXvNJsrqUtJrPRWbf6tBgn" class="wolai-block"><span class="wolai-serial-number">2.5</span><span class="inline-wrap">部署和扩展</span></h2><div id="wSjNUjUaANDQhufAw6uXWi" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分布式系统</b></span><span class="inline-wrap">：需要关注整体系统的部署和扩展，可能需要考虑多台服务器的管理和配置。</span></div></div><div id="33ipa3B6VmQTrME3T7jnNb" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>微服务</b></span><span class="inline-wrap">：每个微服务都可以独立部署和扩展，使得开发团队更容易管理和调整特定功能。</span></div></div><div id="ghvsXD7zvZXoDb8nC1JMzc" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="txfg3H2zA84v8kVHZNpFQs" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，分布式系统是一种基础架构模式，而微服务是一种架构风格。微服务通常可以在分布式系统中实现，但并不是所有分布式系统都采用微服务架构。微服务架构的主要目标是使开发、部署和维护更加灵活，适用于复杂的应用场景。</span></div></div><div id="7Er4kgYx1kkjr9CdJ3jDfv" class="wolai-block wolai-text"><div></div></div><div id="3TUe8RsM1AeRjSxy6s3SLG" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4jipmubaHYoWFmYv51DENN" class="wolai-block"><span class="wolai-serial-number">3</span><span class="inline-wrap">什么是微服务架构？优势？特点？</span></h1><div id="7inSC59ogvuirUatkRUkf6" class="wolai-block wolai-text"><div><span class="inline-wrap">微服务架构是一种软件架构风格，将一个大型的应用程序拆分成多个小型、自治的服务单元，每个服务单元都专注于执行特定的业务功能。每个微服务可以独立开发、部署、扩展和维护，通过轻量级通信机制协同工作。微服务架构的优势和特点包括：</span></div></div><ol class="wolai-block"><li id="4Cuue7vnncDZpWu1QJR2yN"><div class="marker"></div><span class="inline-wrap"><b>模块化与自治性</b></span><span class="inline-wrap">：微服务架构通过拆分应用为多个服务单元，使得开发团队可以更加专注于各自的业务领域。每个微服务都是独立的，有自己的代码、数据库、API<span class="jill"></span>等，可以在不影响其他服务的情况下进行修改和更新。</span></li><li id="9FNgzZ4oW8LJHEHLPuWEcN"><div class="marker"></div><span class="inline-wrap"><b>灵活性与快速交付</b></span><span class="inline-wrap">：微服务的自治性使得团队可以独立地开发、测试、部署和发布服务。这种独立性加速了开发周期，使团队能够更快地交付新功能和更新。</span></li><li id="vs1NWJ3TxnBeXHkiensNEh"><div class="marker"></div><span class="inline-wrap"><b>可扩展性</b></span><span class="inline-wrap">：微服务架构允许单独扩展每个服务，根据需求动态分配资源。这使得系统更具弹性，能够应对高负载和流量峰值。</span></li><li id="7Hm9aZamzboTtUhS47En7W"><div class="marker"></div><span class="inline-wrap"><b>技术多样性</b></span><span class="inline-wrap">：不同的微服务可以使用不同的技术栈，因为它们之间通过<span class="jill"></span>API<span class="jill"></span>通信。这允许团队选择最适合其任务的技术，而不受整个应用的技术限制。</span></li><li id="8LFN8XyRMsSwisSnuse1U2"><div class="marker"></div><span class="inline-wrap"><b>容错性与隔离性</b></span><span class="inline-wrap">：由于微服务是自治的，一个服务的故障不会影响整个系统。故障在较小的范围内隔离，从而提高了整体系统的容错性。</span></li><li id="g2nrWN9Wkqi4tRPekeMEbx"><div class="marker"></div><span class="inline-wrap"><b>持续集成与持续交付</b></span><span class="inline-wrap">：微服务架构有助于实现持续集成和持续交付，因为每个服务可以独立地构建、测试和发布。这有助于减少部署的风险，并快速响应用户需求。</span></li><li id="vmziLmY9BoPCsHWR4WWj1A"><div class="marker"></div><span class="inline-wrap"><b>灵活的团队组织</b></span><span class="inline-wrap">：微服务架构鼓励小团队负责特定的微服务，使得团队更加灵活，能够快速做出决策和调整。</span></li></ol><div id="96kty8kBpajTmiJbT2RGnX" class="wolai-block wolai-text"><div><span class="inline-wrap">然而，微服务架构也带来了一些挑战，如分布式系统的复杂性、服务间通信的管理、数据一致性等问题。对于不同的应用场景，需仔细权衡微服务的优势与挑战，以确定是否采用这种架构。</span></div></div><div id="tBSy38UmC265ZpozyNK3td" class="wolai-block wolai-text"><div></div></div><div id="4rQDDscHSYFBFpK4xU45Vc" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="t8odgqQnoVUgRRAT4ybuT8" class="wolai-block"><span class="wolai-serial-number">4</span><span class="inline-wrap">负载均衡算法、类型</span></h1><h2 id="2KYvKPUKEa1CCNVgUNvLd3" class="wolai-block"><span class="wolai-serial-number">4.1</span><span class="inline-wrap">算法</span></h2><h3 id="cnq94Dr4PaopsdSjt4SyK9" class="wolai-block"><span class="wolai-serial-number">4.1.1</span><span class="inline-wrap">轮询法</span></h3><div id="dmYfRwUwwHXdjuyHr6Xv4c" class="wolai-block wolai-text"><div><span class="inline-wrap">将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</span></div></div><div id="sGdbF8Q4jnFgtYCz5e3Lh" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="tZLxGdUV9AioJaWsFeiFjT" class="wolai-block"><span class="wolai-serial-number">4.1.2</span><span class="inline-wrap">随机法</span></h3><div id="iwpszxV4E7Yc9kmm6h8LX9" class="wolai-block wolai-text"><div><span class="inline-wrap">通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</span></div></div><div id="5WJGJ5ud7ZZRQc4oPvenr2" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="63FeFUHzzHr6Yczp5m6kBY" class="wolai-block"><span class="wolai-serial-number">4.1.3</span><span class="inline-wrap">源地址哈希法</span></h3><div id="2gwt1bMkiayLEXudMwvmj7" class="wolai-block wolai-text"><div><span class="inline-wrap">源地址哈希的思想是根据获取客户端的<span class="jill"></span>IP<span class="jill"></span>地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一<span class="jill"></span>IP<span class="jill"></span>地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</span></div></div><div id="tKc5He9Aubo5jHRRRJmWJP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wefrMTR5sDG8dQCzuhsUEK" class="wolai-block"><span class="wolai-serial-number">4.1.4</span><span class="inline-wrap">加权轮询法</span></h3><div id="b59vpS13EvP7rYKZatAjVq" class="wolai-block wolai-text"><div><span class="inline-wrap">不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</span></div></div><div id="i5da9xXnkkvwNzdQAcHRJb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3caaCWo12W5ThwhTuYGDAQ" class="wolai-block"><span class="wolai-serial-number">4.1.5</span><span class="inline-wrap">加权随机法</span></h3><div id="gLkdvEnujA1atiUebKActE" class="wolai-block wolai-text"><div><span class="inline-wrap">与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</span></div></div><div id="rJwiMSGBuSrHMeoSGswVxK" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="5MyX7CatEPa6krSwExMy7D" class="wolai-block"><span class="wolai-serial-number">4.1.6</span><span class="inline-wrap">最小连接数法</span></h3><div id="7MBrEGcvSrBHteVhjXHRSu" class="wolai-block wolai-text"><div><span class="inline-wrap">最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</span></div></div><div id="jzEsQbAH7P8wXPGerMzMwT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="mh35aoTzHQGxcmsQudJfoo" class="wolai-block"><span class="wolai-serial-number">4.2</span><span class="inline-wrap">类型  </span></h2><div id="vRmg28FZac7S7bYpf2nRRL" class="wolai-block wolai-text"><div><span class="inline-wrap">1、DNS 方式实现负载均衡</span></div></div><div id="xkKW8jQr1EJ1PBqv6AQu5W" class="wolai-block wolai-text"><div><span class="inline-wrap">2、硬件负载均衡：F5 和 A10</span></div></div><div id="naREYftuLB7w9Hh8fwGh6N" class="wolai-block wolai-text"><div><span class="inline-wrap">3、软件负载均衡：Nginx 、 HAproxy 、 LVS</span></div></div><div id="3M3tFD1uyKMM58iVLL8xPU" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="rwNBF8CdnQW7Rh8MffUDwq" class="wolai-block"><span class="wolai-serial-number">4.3</span><span class="inline-wrap">产品落地</span></h2><ul class="wolai-block"><li id="4K9FMqk3tmceoxtTJp4U1z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Nginx ：七层负载均衡，支持 HTTP、E-mail 协议，同时也支持 4 层负载均衡；  </span></li><li id="5z9jBisAkS1jiH1fC2qsuT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">HAproxy ：支持七层规则的，性能也很不错。OpenStack 默认使用的负载均衡软件就是<span class="jill"></span>HAproxy；  </span></li><li id="s4KZXA626i2aG4bB4jpn1q"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">LVS ：运行在内核态，性能是软件负载均衡中最高的，严格来说工作在三层，所以更通用一些，适用各种应用服务。</span></li></ul><div id="kMaXQiC83LcLRfb8WA1xkF" class="wolai-block wolai-text"><div></div></div><div id="47ETXVzuvVWshF8fAqtiEx" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="s13y38DA68E9Vfx1N9hrSm" class="wolai-block"><span class="wolai-serial-number">5</span><span class="inline-wrap">分布式架构下，Session 共享有什么方案</span></h1><h2 id="9uFHiSaehcWVDXJHqM4NaD" class="wolai-block"><span class="wolai-serial-number">5.1</span><span class="inline-wrap">方案一：无状态服务</span></h2><div id="8hqKSv93Csi7sme6YJFGVS" class="wolai-block wolai-text"><div><span class="inline-wrap">采用无状态服务，抛弃<span class="jill"></span>Session，使用中间件存储，比如<span class="jill"></span>MySQL/Redis<span class="jill"></span>等。</span></div></div><ul class="wolai-block"><li id="8trYWTxvL8ojbDT6T91Uy6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">把共享信息放到<span class="jill"></span>Redis<span class="jill"></span>中存储，虽然架构上变得复杂，并且需要多访问一次<span class="jill"></span>Redis ，但是这种方案带来的好处也是很大的。</span></li><li id="6zf8bcjgZxLsUtUrigpTyK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">把共享信息存入<span class="jill"></span>Cookie（要考虑跨域问题，且有安全风险）</span></li><li id="uQPfTVtjbjD5rDVdtJPct8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Tomcat<span class="jill"></span>集群<span class="jill"></span>Session<span class="jill"></span>同步使用<span class="jill"></span>Spring-Session</span></li></ul><div id="vQpU1vvg2zexE9KxTcpqJk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5ouFXhVhPJg7MrDWpx6FNj" class="wolai-block"><span class="wolai-serial-number">5.2</span><span class="inline-wrap">方案二：</span><span class="inline-wrap">IP 绑定策略</span></h2><div id="7hNvsJsbTFU8b1uWvqE2a8" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>Nginx（或其他复杂均衡软硬件）中的<span class="jill"></span>IP<span class="jill"></span>绑定策略，同一个<span class="jill"></span>IP<span class="jill"></span>只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；</span></div></div><div id="bX16QDRKfznzMikHkycVN3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="vKzc5m86HTDCA54psujUBv" class="wolai-block"><span class="wolai-serial-number">5.3</span><span class="inline-wrap">实现了 Session 共享好处</span></h2><div id="gTYNbgLUfBUd4T9AtNviTb" class="wolai-block wolai-text"><div><span class="inline-wrap">1、可以水平扩展（增加 Redis 服务器）；</span></div></div><div id="sroAm1HzPWcedEsgHA6vTc" class="wolai-block wolai-text"><div><span class="inline-wrap">2、服务器重启 Session 不丢失（不过也要注意 数据在 Redis 中的刷新/失效机制）；</span></div></div><div id="5rpsAkCzwrwxZz36uyeWx5" class="wolai-block wolai-text"><div><span class="inline-wrap">3、不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）；</span></div></div><div id="veupyA2o8nRadzFGMJveTp" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="7YUukoS917d5EVvVqDkGsF" class="wolai-block"><span class="wolai-serial-number">6</span><span class="inline-wrap">CAP<span class="jill"></span>理论</span></h1><h2 id="acEbMMrqbPPK4EJFu1Hr2Y" class="wolai-block"><span class="wolai-serial-number">6.1</span><span class="inline-wrap">概念</span></h2><h3 id="pb5NxEAJgPL1uD9ph15uJy" class="wolai-block"><span class="wolai-serial-number">6.1.1</span><span class="inline-wrap">Consistency（一致性）</span></h3><div id="wSHCNDsDhhWJNURSmyFmNr" class="wolai-block wolai-text"><div><span class="inline-wrap">即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新后如何复制分布到整个系统，以保证数据最终一致。</span></div></div><div id="g9fN7V6iMUuBunCKpVgiqP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="6AVdrjiG53NQ6yznhHzAbj" class="wolai-block"><span class="wolai-serial-number">6.1.2</span><span class="inline-wrap">Availability（可用性）</span></h3><div id="u2CUENiK7wPcK5pqM3nBpn" class="wolai-block wolai-text"><div><span class="inline-wrap">即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</span></div></div><div id="4CirULwwZpfMZirvwLZqyo" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="3XYAKxVLaVNphVqYgTmF5o" class="wolai-block"><span class="wolai-serial-number">6.1.3</span><span class="inline-wrap">Partition Tolerance（分区容错性）</span></h3><div id="9LcLDyvEuqX86phSvXaRhH" class="wolai-block wolai-text"><div><span class="inline-wrap">即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</span></div></div><div id="dAw8V4eqrUV4PcNfjYH71m" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="9YZXYBQuFxSMqkEiXEUxbv" class="wolai-block"><span class="wolai-serial-number">6.2</span><span class="inline-wrap">规则</span></h2><div id="eJfr77bcfeEcsuFTvw6kCr" class="wolai-block wolai-text"><div><span class="inline-wrap">分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能<span class="jill"></span>2<span class="jill"></span>选<span class="jill"></span>1。</span></div></div><div id="aaukqMRqbGYgPnJikgTCWj" class="wolai-block wolai-text"><div><span class="inline-wrap">所以<span class="jill"></span>CAP<span class="jill"></span>中只有<span class="jill"></span>CP<span class="jill"></span>和<span class="jill"></span>AP<span class="jill"></span>两种情况成立</span></div></div><div id="a4mS8hdDQ2iKk6EdJG6D1i" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="jPbukDdMqoLrWiHmn9M8YW" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="jHSgdJxBJBHn4TMj8TqXt7" class="wolai-block"><span class="wolai-serial-number">7</span><span class="inline-wrap">BASE<span class="jill"></span>定理</span></h1><h2 id="oXwQTjWnxuKC3jpaGhXpVP" class="wolai-block"><span class="wolai-serial-number">7.1</span><span class="inline-wrap">名词解释</span></h2><div id="8P3dx5VXFCFhUVnRmG6CWB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="3xHTiYGpS2PgAXZ32ziphZ" class="wolai-block"><span class="wolai-serial-number">7.2</span><span class="inline-wrap">定理含义</span></h2><div id="25TN1411mMsgNQA5zYgony" class="wolai-block wolai-text"><div><span class="inline-wrap">BASE<span class="jill"></span>理论是对<span class="jill"></span>CAP<span class="jill"></span>中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于<span class="jill"></span>CAP<span class="jill"></span>定理逐步演化而来的。</span></div></div><div id="wU9xNMEncm97GBc1nAwmPT" class="wolai-block wolai-text"><div><span class="inline-wrap">BASE<span class="jill"></span>理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</span></div></div><div id="o1pfba8NWsuKVM19pfkD4Y" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>BASE<span class="jill"></span>理论下允许系统在某一小段时间内暂时数据不一致，以换取性能（可用性）的进一步提升，系统只要最终进入一致性状态即可。</span></div></div><div id="mUro1SyrnCZbxL1ZLh2bUd" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="o7LnDMMhNzjBqmj5KgigEt" class="wolai-block"><span class="wolai-serial-number">7.3</span><span class="inline-wrap">相关概念</span></h2><ol class="wolai-block"><li id="oUN2UnZxxthr9WXrpPcnUp"><div class="marker"></div><span class="inline-wrap"><b>基本可用性（Basic Availability）</b></span><span class="inline-wrap">：系统应该尽可能地保持可用，即使在部分组件出现故障的情况下。这意味着系统不应该因为一个或多个组件的故障而完全停止服务。</span></li><li id="dzpxJAPBnJopXK6MvXDPWT"><div class="marker"></div><span class="inline-wrap"><b>软状态（Soft State）</b></span><span class="inline-wrap">：系统中的数据可以有一定的不一致性，这种不一致性可以通过后台进程来逐步解决。软状态允许系统在面对故障时仍然能够继续运行，而不是立即进入不可用状态。</span></li><li id="auj5QT8xt6nq7B6cbaw2Am"><div class="marker"></div><span class="inline-wrap"><b>最终一致性（Eventual Consistency）</b></span><span class="inline-wrap">：系统不需要始终保持强一致性，但最终所有的数据副本都会达到一致的状态。这意味着在短时间内，不同的节点可能会看到不同的数据状态，但随着时间的推移，所有节点上的数据将趋于一致。</span></li></ol><div id="sMgVg3RxA1cCc1doJ7R3y7" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="412UaPhEZpRxSm834xMDu4" class="wolai-block"><span class="wolai-serial-number">7.4</span><span class="inline-wrap">特征举例</span></h2><ol class="wolai-block"><li id="kVNRXV561DtSELhy46m5L3"><div class="marker"></div><span class="inline-wrap"><b>电商购物车系统</b></span><ul class="wolai-block"><li id="v32W7kA6dxVCKEiREGGihc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本可用性</b></span><span class="inline-wrap">：在双十一等大型促销活动期间，即使部分节点出现故障，系统也能继续处理用户的购物车操作，只是可能会通过限流或排队来保护系统的稳定性。</span></li><li id="3G2aSYTAPucx5Jq4k2KHZz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>软状态</b></span><span class="inline-wrap">：用户将商品添加到购物车后，该操作可能不会立即在所有节点上同步，导致短时间内不同节点上的数据不一致。</span></li><li id="qt22gmPVPgduNSNUVKXVTx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>最终一致性</b></span><span class="inline-wrap">：通过异步通信、消息队列解耦、分布式锁、幂等性消费者以及定时任务校正机制，确保购物车数据最终在所有节点上达到一致状态。</span></li></ul></li><li id="gnygznd8ySNzu1UXxSSnj9"><div class="marker"></div><span class="inline-wrap"><b>消息队列系统</b></span><ul class="wolai-block"><li id="n5R2mUwqiaYQbBt6Dp5HE5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本可用性</b></span><span class="inline-wrap">：消息队列系统如<span class="jill"></span>Kafka、RabbitMQ<span class="jill"></span>等，在网络分区或节点故障时，仍能保证消息的传递和消费，只是可能会有短暂的延迟或顺序调整。</span></li><li id="nm5W5QMDRW5xLzz7pJd2LG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>软状态</b></span><span class="inline-wrap">：消息在被生产者发送到队列后，可能需要一段时间才能被所有消费者接收并处理，这期间消息的状态是“软”的。</span></li><li id="u99r4GKbU2UigK8bgxwiPd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>最终一致性</b></span><span class="inline-wrap">：尽管消息的顺序和实时性可能有所偏差，但系统最终会确保所有消息都被正确消费，达到最终一致性。</span></li></ul></li><li id="vQVbHvQL1vRC1oAvmTkgGp"><div class="marker"></div><span class="inline-wrap"><b>分布式数据库</b></span><ul class="wolai-block"><li id="6si9pcfxm6wNuv9Vckxi4i"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本可用性</b></span><span class="inline-wrap">：在分布式数据库系统中，即使部分节点出现故障，系统也能继续处理读写请求，只是响应时间可能会延长。</span></li><li id="hv4ag1JF8ukwpKZWBg3Nie"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>软状态</b></span><span class="inline-wrap">：数据的更新操作可能不会立即在所有节点上同步，导致短时间内数据不一致。</span></li><li id="emMN3SvHo3uQnf2W6mLZGW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>最终一致性</b></span><span class="inline-wrap">：通过异步复制、读时修复、写时修复等策略，确保数据最终在所有节点上达到一致状态。</span></li></ul></li></ol><div id="91AtTmdDLxaRoBFcnSxZ8m" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="tbmxvHD9gqwQ5riSDMMDX" class="wolai-block"><span class="wolai-serial-number">8</span><span class="inline-wrap">分布式<span class="jill"></span>Id<span class="jill"></span>生成方案</span></h1><h2 id="vNppHpz6FXyiDdj4FuJ3qi" class="wolai-block"><span class="wolai-serial-number">8.1</span><span class="inline-wrap">UUID</span></h2><h3 id="7mkbq2Nj1YGrD4hnWN5QWJ" class="wolai-block"><span class="wolai-serial-number">8.1.1</span><span class="inline-wrap">概念</span></h3><div id="jU2wccwT33FMm4w2d2hEmr" class="wolai-block wolai-text"><div><span class="inline-wrap">UUID（Universally Unique Identifier）是一种标准的标识符格式，用于为信息分配唯一的标识符。UUID<span class="jill"></span>通常由<span class="jill"></span>32<span class="jill"></span>个<span class="jill"></span>16<span class="jill"></span>进制数字构成，分为五个连字符分隔的部分，例如：550e8400-e29b-41d4-a716-446655440000。</span></div></div><div id="zf9Lo9U8VxDFhtZFoRjWJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="7NBjb3zw86k4jFgm63Prfr" class="wolai-block"><span class="wolai-serial-number">8.1.2</span><span class="inline-wrap">UUID<span class="jill"></span>的生成算法</span></h3><ol class="wolai-block"><li id="jH9LfHHpESpQUS47aeRzWz"><div class="marker"></div><span class="inline-wrap"><b>基于时间的<span class="jill"></span>UUID</b></span><span class="inline-wrap">：版本<span class="jill"></span>1<span class="jill"></span>的<span class="jill"></span>UUID<span class="jill"></span>主要依赖当前的时间戳及机器的<span class="jill"></span>MAC<span class="jill"></span>地址来生成。时间值占<span class="jill"></span>60<span class="jill"></span>位，表示从<span class="jill"></span>UTC 1582<span class="jill"></span>年<span class="jill"></span>10<span class="jill"></span>月<span class="jill"></span>15<span class="jill"></span>日以来的<span class="jill"></span>100<span class="jill"></span>纳秒间隔计数。时钟序列和节点值分别占<span class="jill"></span>14<span class="jill"></span>位和<span class="jill"></span>48<span class="jill"></span>位，用于确保在同一时刻生成的<span class="jill"></span>UUID<span class="jill"></span>也是唯一的。</span></li><li id="jbJ7X1YnoVRosHyWgYW9uC"><div class="marker"></div><span class="inline-wrap"><b>基于随机数的<span class="jill"></span>UUID</b></span><span class="inline-wrap">：版本<span class="jill"></span>4<span class="jill"></span>的<span class="jill"></span>UUID<span class="jill"></span>完全基于随机数或伪随机数生成。这种生成方式简单且高效，但需要使用高质量的随机数生成器以确保唯一性。</span></li><li id="ij1vsbRjPM5bnZnkMYqMxB"><div class="marker"></div><span class="inline-wrap"><b>基于名称空间的<span class="jill"></span>UUID</b></span><span class="inline-wrap">：版本<span class="jill"></span>3<span class="jill"></span>和版本<span class="jill"></span>5<span class="jill"></span>的<span class="jill"></span>UUID<span class="jill"></span>是基于名称空间和名称的散列值生成的。版本<span class="jill"></span>3<span class="jill"></span>使用<span class="jill"></span>MD5<span class="jill"></span>散列算法，而版本<span class="jill"></span>5<span class="jill"></span>使用<span class="jill"></span>SHA-1<span class="jill"></span>散列算法。这些<span class="jill"></span>UUID<span class="jill"></span>在不同的命名空间和名称下是唯一的。</span></li></ol><div id="gszgwTGHNn9bzKvMvzd5j8" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wyWz6cLXtBRJCYR8AsfoAR" class="wolai-block"><span class="wolai-serial-number">8.1.3</span><span class="inline-wrap">优点</span></h3><ol class="wolai-block"><li id="cK4anJ8CXYXeYKnLEdN81W"><div class="marker"></div><span class="inline-wrap"><b>唯一性</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="6w5MyDHC81SyHhiuvJc2Go"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UUID<span class="jill"></span>基于时间和机器<span class="jill"></span>MAC<span class="jill"></span>地址（对于版本<span class="jill"></span>1<span class="jill"></span>的<span class="jill"></span>UUID）或其他因素（如随机数或散列值，对于其他版本的<span class="jill"></span>UUID）生成，几乎可以保证全球唯一。</span></li></ul></li><li id="uBpgjsH9Q4mbKCVA36m6EA"><div class="marker"></div><span class="inline-wrap"><b>简单易用</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="k5XbBSNvshvcA1MkdMFB2R"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UUID<span class="jill"></span>的生成过程相对简单，不需要复杂的配置或额外的组件支持。大多数编程语言都提供了内置的库来生成<span class="jill"></span>UUID。</span></li></ul></li><li id="55tLmH63SrhdQpsTXi2ELo"><div class="marker"></div><span class="inline-wrap"><b>本地生成</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="qU7TLwth7dLp92DhtmdLvm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UUID<span class="jill"></span>可以在本地生成，无需通过网络请求或依赖外部服务，因此没有网络消耗，且生成速度快。</span></li></ul></li></ol><div id="gkvWgooGXDJKhMveRYersF" class="wolai-block wolai-text"><div></div></div><h3 id="cApe5eVFUSt6J9x4vgRgT4" class="wolai-block"><span class="wolai-serial-number">8.1.4</span><span class="inline-wrap">缺点</span></h3><ol class="wolai-block"><li id="cZhuKDVs43RyipRzyHHkaf"><div class="marker"></div><span class="inline-wrap"><b>长度过长</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="uJzaEN3Q9FkKkHo1A5HLan"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UUID<span class="jill"></span>通常由<span class="jill"></span>36<span class="jill"></span>个字符组成（包括<span class="jill"></span>4<span class="jill"></span>个连字符），长度较长，不适合作为数据库主键或需要短<span class="jill"></span>ID<span class="jill"></span>的应用场景。</span></li></ul></li><li id="hLfXKAaF1VU8ZLM7XbaVqb"><div class="marker"></div><span class="inline-wrap"><b>无序性</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="5DZFV7UaFveudaqBXBUQos"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">UUID<span class="jill"></span>是无序的字符串，不具备趋势自增特性，这在某些需要有序<span class="jill"></span>ID<span class="jill"></span>的场景下可能是一个问题。</span></li></ul></li><li id="wfxMuh3THC2Ycf7RwQeCGn"><div class="marker"></div><span class="inline-wrap"><b>查询效率低</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="ucdYrCwSHhnkPsH3c2vYg8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于<span class="jill"></span>UUID<span class="jill"></span>的无序性和长度，其在数据库中的查询效率相对较低，尤其是在大量数据的情况下。</span></li></ul></li><li id="oycb43MibyyWzHFVKkTZ1T"><div class="marker"></div><span class="inline-wrap"><b>信息泄露风险</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="iwrM6wu1ZTdbLoEimfed2e"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于<span class="jill"></span>MAC<span class="jill"></span>地址生成的<span class="jill"></span>UUID<span class="jill"></span>可能会暴露生成该<span class="jill"></span>UUID<span class="jill"></span>的机器的<span class="jill"></span>MAC<span class="jill"></span>地址，从而引发信息泄露的风险。</span></li></ul></li><li id="vFwZcR24q4DSgTgZCrmKE9"><div class="marker"></div><span class="inline-wrap"><b>存储成本高</b></span><span class="inline-wrap">：</span><ul class="wolai-block"><li id="caMxtxqXMDrZf955Np28JA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">由于<span class="jill"></span>UUID<span class="jill"></span>的长度较长，其存储成本相对较高，尤其是在需要存储大量<span class="jill"></span>UUID<span class="jill"></span>的系统中。</span></li></ul></li></ol><div id="e8Dv8uXC5B2hNPhCMKp891" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，UUID<span class="jill"></span>作为分布式<span class="jill"></span>ID<span class="jill"></span>生成方案，在唯一性、简单易用和本地生成方面具有显著优势，但也存在长度过长、无序性、查询效率低、信息泄露风险和存储成本高等缺点。在选择是否使用<span class="jill"></span>UUID<span class="jill"></span>作为分布式<span class="jill"></span>ID<span class="jill"></span>生成方案时，需要根据实际需求和场景进行权衡。</span></div></div><div id="8eR4hn5ofbVtS2y1oVZ8up" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oWqcWenU9ZZKQR7u3YJuJc" class="wolai-block"><span class="wolai-serial-number">8.2</span><span class="inline-wrap">数据库自增序列</span></h2><h3 id="bagmg4JDPjjUxJgnVQGSQN" class="wolai-block"><span class="wolai-serial-number">8.2.1</span><span class="inline-wrap">单机模式</span></h3><h4 id="5XwJx8CVV8uij9bACJsbEi" class="wolai-block"><span class="wolai-serial-number">8.2.1.1</span><span class="inline-wrap">优点</span></h4><ul class="wolai-block"><li id="gUP8zJPwjhRniYmfMJcw9Y"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">实现简单，依靠数据库即可，成本小。</span></li><li id="9J3AW4C6zjQmjJbtD39ixP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ID<span class="jill"></span>数字化，单调自增，满足数据库存储和查询性能。</span></li><li id="kptBtiZdWPPfsPbuTGrvMi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">具有一定的业务可读性。（结合业务代码）</span></li></ul><div id="4AL3bAZdfFgSCdEP11rWTS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="uLAERuSkh7ZrkzmCRq9nYz" class="wolai-block"><span class="wolai-serial-number">8.2.1.2</span><span class="inline-wrap">缺点</span></h4><ul class="wolai-block"><li id="njVi6gXZhfYDUhGUokta6g"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">强依赖<span class="jill"></span>DB，存在单点问题，如果数据库宕机，则业务不可用。</span></li><li id="bFcWTzeaX3zZjhLHC4iSCV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">DB<span class="jill"></span>生成<span class="jill"></span>ID<span class="jill"></span>性能有限，单点数据库压力大，无法扛高并发场景。</span></li><li id="m9uqe4SuBB7Rj7Pm1cKZiN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">信息安全问题，比如暴露订单量，url<span class="jill"></span>查询改一下<span class="jill"></span>id<span class="jill"></span>查到别人的订单</span></li><li id="gLUn8gRVWTbyt7UTBEGDeo"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分布式下生成的<span class="jill"></span>id<span class="jill"></span>会重复</span></li></ul><div id="h618PKzVYtwB8CaDApnHGQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kUZ59PeGP6eEjJRXJUbtWj" class="wolai-block"><span class="wolai-serial-number">8.2.2</span><span class="inline-wrap">集群模式（数据库高可用背景下）</span></h3><h4 id="5vJ3B4db8ZqEovzTfjrtm7" class="wolai-block"><span class="wolai-serial-number">8.2.2.1</span><span class="inline-wrap">方案描述</span></h4><div id="mjaEkfsf72LQXYB9cbV8uJ" class="wolai-block wolai-text"><div><span class="inline-wrap">具体操作方案是：多主模式做负载均衡，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于等于节点数。例如：</span></div></div><span class="inline-wrap"></span><br/><span class="inline-wrap"></span><br/><div id="vYJcE7McToEgyLCHQQsw3F" class="wolai-block wolai-text"><div><span class="inline-wrap">初始值</span></div></div><span class="inline-wrap"></span><br/><div id="94qW4j1RDuNNwK78g38Krz" class="wolai-block wolai-text"><div><span class="inline-wrap">1</span></div></div><span class="inline-wrap"></span><br/><div id="8mFHsSojw1aQUWs63axCZg" class="wolai-block wolai-text"><div><span class="inline-wrap">2</span></div></div><span class="inline-wrap"></span><br/><div id="ufuCApLhhtncV778F6T9hY" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="qVwxbD3bdeeiGsCKNYmKtn" class="wolai-block wolai-text"><div><span class="inline-wrap">步长</span></div></div><span class="inline-wrap"></span><br/><div id="kLoRqFYS7tm23RDgdLKpyr" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="b6PdAdkb7AVm9Ki7dNzR8F" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="LrbcjiXddYKn9GcnDibdE" class="wolai-block wolai-text"><div><span class="inline-wrap">3</span></div></div><span class="inline-wrap"></span><br/><div id="prPtmwtYiZ6VSybCBxMkoy" class="wolai-block wolai-text"><div><span class="inline-wrap">一步</span></div></div><span class="inline-wrap"></span><br/><div id="jpNx8fD31JMD8hz4By2vTr" class="wolai-block wolai-text"><div><span class="inline-wrap">4</span></div></div><span class="inline-wrap"></span><br/><div id="j49kHc1QRgAKinfVANSkXd" class="wolai-block wolai-text"><div><span class="inline-wrap">5</span></div></div><span class="inline-wrap"></span><br/><div id="bDxMignQYhonVnkZnm4VAT" class="wolai-block wolai-text"><div><span class="inline-wrap">6</span></div></div><span class="inline-wrap"></span><br/><div id="wmwvUPyDzc66dA18GbMGbw" class="wolai-block wolai-text"><div><span class="inline-wrap">两步</span></div></div><span class="inline-wrap"></span><br/><div id="fMUMqKX6m4ppn3LJBV6hjq" class="wolai-block wolai-text"><div><span class="inline-wrap">7</span></div></div><span class="inline-wrap"></span><br/><div id="uDtg7z2mTb6Zuj582BS1d1" class="wolai-block wolai-text"><div><span class="inline-wrap">8</span></div></div><span class="inline-wrap"></span><br/><div id="nSeBsygNVqvuxhEnJRKed5" class="wolai-block wolai-text"><div><span class="inline-wrap">9</span></div></div><span class="inline-wrap"></span><br/><div id="ovBHbbCaUisEuQfWxB7nvJ" class="wolai-block wolai-text"><div><span class="inline-wrap">三步</span></div></div><span class="inline-wrap"></span><br/><div id="6yfxRpigUYjHVyMYNkaDEt" class="wolai-block wolai-text"><div><span class="inline-wrap">10</span></div></div><span class="inline-wrap"></span><br/><div id="a5KdjKc1k8zEXYQJJRS5tt" class="wolai-block wolai-text"><div><span class="inline-wrap">11</span></div></div><span class="inline-wrap"></span><br/><div id="6w1kTMmNc3QAu4Js1WzAhM" class="wolai-block wolai-text"><div><span class="inline-wrap">12</span></div></div><span class="inline-wrap"></span><br/><div id="fLPPkwC5P6NzddEJmjBWaw" class="wolai-block wolai-text"><div><span class="inline-wrap">……</span></div></div><span class="inline-wrap"></span><br/><div id="pVwP5PrKEp895Ci8mwPFC2" class="wolai-block wolai-text"><div><span class="inline-wrap">……</span></div></div><span class="inline-wrap"></span><br/><div id="tSvj6fYwe3QovVprGewEqm" class="wolai-block wolai-text"><div><span class="inline-wrap">……</span></div></div><span class="inline-wrap"></span><br/><div id="d2ZvZbdieJaGcwNLDApKmr" class="wolai-block wolai-text"><div><span class="inline-wrap">……</span></div></div><div id="iedSk5k1namVH69s8wD1Y5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="3pZDrkAFQXJzVHkFgqX4vb" class="wolai-block"><span class="wolai-serial-number">8.2.2.2</span><span class="inline-wrap">优点</span></h4><ul class="wolai-block"><li id="ei44Bwc5hTSNfH9uJs4fnm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">解决了<span class="jill"></span>ID<span class="jill"></span>生成的单点问题，同时平衡了负载。</span></li><li id="qV3SaAkbB75oQRAw5G9SJz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">解决了分布式环境下<span class="jill"></span>id<span class="jill"></span>重复问题。</span></li></ul><div id="7vSAL5AwxJiVe1SGSWMQxT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 id="bEBJdWrH2UkfBEhhQ6cewJ" class="wolai-block"><span class="wolai-serial-number">8.2.2.3</span><span class="inline-wrap">缺点</span></h4><ul class="wolai-block"><li id="tDH6o1CkMLQXVyWfcHsjc3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。</span></li><li id="rAVGXuLJ9MoFg4Gez1oj7f"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">主从同步延迟：向<span class="jill"></span>master<span class="jill"></span>写入数据后，再<span class="jill"></span>select<span class="jill"></span>查询有可能因为同步延迟导致查询不到</span></li></ul><div id="rZykFDbhGYaK8wUp5t3xgi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4fXoxSGpACcnNmszZmLkhN" class="wolai-block"><span class="wolai-serial-number">8.3</span><span class="inline-wrap">基于<span class="jill"></span>Redis、</span><span class="inline-wrap">MongoDB</span><span class="inline-wrap">、</span><span class="inline-wrap">ZooKeeper</span><span class="inline-wrap">等中间件生成</span></h2><h3 id="8Pv6kHbHsAPrZxJQ8Exyjt" class="wolai-block"><span class="wolai-serial-number">8.3.1</span><span class="inline-wrap">一、Redis</span></h3><ol class="wolai-block"><li id="vbU4QXhiVQhRnEvxiH36CJ"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="SQnWyovT7baczSr4NC6qW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高性能</b></span><span class="inline-wrap">：Redis<span class="jill"></span>作为内存数据库，读写速度非常快，能够提供高效的<span class="jill"></span>ID<span class="jill"></span>生成服务。</span></li><li id="d3e8x6B2ieoyTeiw1AMyfT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>唯一性保证</b></span><span class="inline-wrap">：Redis<span class="jill"></span>支持原子操作如<span class="jill"></span>INCR，可以确保<span class="jill"></span>ID<span class="jill"></span>的唯一性和顺序递增。</span></li><li id="vBymgQBHFFYKwfLCdKDUck"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>灵活性</b></span><span class="inline-wrap">：可以根据业务需求自定义<span class="jill"></span>ID<span class="jill"></span>生成规则，如引入时间、随机数等元素。</span></li><li id="x3cNtbvQSnTphvKw8yNHep"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>持久化</b></span><span class="inline-wrap">：支持持久化选项，可以保证生成的<span class="jill"></span>ID<span class="jill"></span>在<span class="jill"></span>Redis<span class="jill"></span>重启后不丢失。</span></li></ul></li><li id="iBByBZHWnMLPZTjgMxnEcr"><div class="marker"></div><span class="inline-wrap"><b>缺点</b></span><ul class="wolai-block"><li id="87WdfHq2iZPoaBWKiVNjCC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>依赖组件</b></span><span class="inline-wrap">：如果系统中没有<span class="jill"></span>Redis，需要额外引入并配置该组件，增加了系统复杂度。</span></li><li id="6sdWfyfcnEuGTE5dDvVBMJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>编码配置量大</b></span><span class="inline-wrap">：实现过程中需要编写较多的代码并进行相应的配置。</span></li><li id="8RC8SFrDvTRVRsNYERnvWN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>单节点性能瓶颈</b></span><span class="inline-wrap">：虽然<span class="jill"></span>Redis<span class="jill"></span>本身是分布式系统，但单节点的性能可能成为瓶颈，需要考虑使用<span class="jill"></span>Redis<span class="jill"></span>集群来提高吞吐量。</span></li></ul></li></ol><h3 id="63Vubto1UYeLF82vkbEQ5W" class="wolai-block"><span class="wolai-serial-number">8.3.2</span><span class="inline-wrap">二、MongoDB</span></h3><ol class="wolai-block"><li id="czYfnn44RwYE24ARPxC4bm"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="hH91RNe4o6uRwEtfg4KMZh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>ObjectId<span class="jill"></span>生成机制</b></span><span class="inline-wrap">：MongoDB<span class="jill"></span>自带的<span class="jill"></span>ObjectId<span class="jill"></span>生成机制简单易用，且能保证全局唯一性。</span></li><li id="iXadrkTwjYsytc4S7zonZL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>趋势递增</b></span><span class="inline-wrap">：ObjectId<span class="jill"></span>中的时间戳部分使得<span class="jill"></span>ID<span class="jill"></span>具有趋势递增的特性。</span></li><li id="8Re6gUdJApbDK9s3dBpsqC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>无需额外组件</b></span><span class="inline-wrap">：对于已经使用<span class="jill"></span>MongoDB<span class="jill"></span>的系统来说，无需额外引入组件即可实现分布式<span class="jill"></span>ID<span class="jill"></span>生成。</span></li></ul></li><li id="6aHSPTQJ2WriHnm4QVDwF8"><div class="marker"></div><span class="inline-wrap"><b>缺点</b></span><ul class="wolai-block"><li id="9VNDhvKr8njomW3WPdKMP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>长度较长</b></span><span class="inline-wrap">：ObjectId<span class="jill"></span>的长度较长，可能不适合对<span class="jill"></span>ID<span class="jill"></span>长度有严格要求的场景。</span></li><li id="inEZyUcKuWfSkz1mT8119A"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>无序性问题</b></span><span class="inline-wrap">：在某些特定场景下，可能需要对<span class="jill"></span>ObjectId<span class="jill"></span>进行转换或处理以满足有序性要求。</span></li></ul></li></ol><h3 id="9a7oVrkYB4esU7A5DS3hSc" class="wolai-block"><span class="wolai-serial-number">8.3.3</span><span class="inline-wrap">三、ZooKeeper（ZK）</span></h3><ol class="wolai-block"><li id="skAskhXPGmee25h3HwTofJ"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="r2qjwct5HCHvfdpDbCvEbH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高可用性</b></span><span class="inline-wrap">：ZooKeeper<span class="jill"></span>作为一个分布式协调服务，具有高可用性和稳定性。</span></li><li id="nCZKkB5zxzovuYmZfbTThN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临时节点特性</b></span><span class="inline-wrap">：利用<span class="jill"></span>ZooKeeper<span class="jill"></span>的临时节点特性，可以实现分布式<span class="jill"></span>ID<span class="jill"></span>的生成和管理。</span></li><li id="bb5sShFdZZeiLM7B5Mn2Ca"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>灵活的<span class="jill"></span>ID<span class="jill"></span>生成策略</b></span><span class="inline-wrap">：可以根据业务需求自定义<span class="jill"></span>ID<span class="jill"></span>生成策略，如引入时间、机器标识等信息。</span></li></ul></li><li id="3A4TcUS88ALY3E2soRhf9C"><div class="marker"></div><span class="inline-wrap"><b>缺点</b></span><ul class="wolai-block"><li id="9EqjyEWFUDDbnZvzF9B6m7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>依赖组件</b></span><span class="inline-wrap">：与<span class="jill"></span>Redis<span class="jill"></span>类似，如果系统中没有<span class="jill"></span>ZooKeeper，需要额外引入并配置该组件。</span></li><li id="oUtPgEMy8H6fLQ7Xv5rmpT"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>性能问题</b></span><span class="inline-wrap">：在高并发场景下，ZooKeeper<span class="jill"></span>的性能可能成为瓶颈，需要考虑优化策略。</span></li><li id="hERDHvAmLeRPdQr9EbWW84"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>实现复杂</b></span><span class="inline-wrap">：相比其他中间件，ZooKeeper<span class="jill"></span>的<span class="jill"></span>ID<span class="jill"></span>生成实现可能更为复杂，需要编写更多的代码和配置。</span></li></ul></li></ol><div id="p3sYJuruqbkk3jJxNxE4So" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，基于<span class="jill"></span>Redis、MongoDB、ZooKeeper<span class="jill"></span>等中间件生成分布式<span class="jill"></span>ID<span class="jill"></span>的方案各有优劣。在选择具体方案时，需要根据实际业务需求、系统架构以及团队技术栈等因素进行综合考虑。</span></div></div><div id="utXzNqmSajusCVnCYpvcUB" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="WMTDrvNgSdTpEkpzmXWfs" class="wolai-block"><span class="wolai-serial-number">8.4</span><span class="inline-wrap">雪花算法</span></h2><div id="d1cD4VwqWTrPtj81b1xRic" class="wolai-block wolai-text"><div><span class="inline-wrap">雪花算法（Snowflake）是一种分布式<span class="jill"></span>ID<span class="jill"></span>生成算法，其生成机制和优缺点具体如下：</span></div></div><h3 id="osuN1hL7QadgvheWsy5hVc" class="wolai-block"><span class="wolai-serial-number">8.4.1</span><span class="inline-wrap">生成机制</span></h3><ol class="wolai-block"><li id="trwwJEMroioiKwZTfaaUd8"><div class="marker"></div><span class="inline-wrap"><b>基本结构</b></span><span class="inline-wrap">：雪花算法生成的<span class="jill"></span>ID<span class="jill"></span>是一个<span class="jill"></span>64<span class="jill"></span>位的<span class="jill"></span>long<span class="jill"></span>型数值，主要分为四个部分。</span><ul class="wolai-block"><li id="ak8WptL4fduh1T7tfKVeEq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>1<span class="jill"></span>位符号位</b></span><span class="inline-wrap">：始终为<span class="jill"></span>0，因为生成的<span class="jill"></span>ID<span class="jill"></span>是正数。</span></li><li id="hp2j5X15k2cskrxRdsBuXq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>41<span class="jill"></span>位时间戳</b></span><span class="inline-wrap">：记录当前时间与某个固定时间的差值（通常是系统开始运行的时间），以毫秒为单位。这<span class="jill"></span>41<span class="jill"></span>位可以表示约<span class="jill"></span>69<span class="jill"></span>年的时间范围。</span></li><li id="f2Cw2hmTHjX2BbJk1eCVqa"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>10<span class="jill"></span>位机器标识</b></span><span class="inline-wrap">：包括<span class="jill"></span>5<span class="jill"></span>位数据中心<span class="jill"></span>ID<span class="jill"></span>和<span class="jill"></span>5<span class="jill"></span>位机器<span class="jill"></span>ID，用于区分不同的节点。最多可以部署在<span class="jill"></span>1024<span class="jill"></span>个节点上。</span></li><li id="k3xF333jvbmy87jguWEWTw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>12<span class="jill"></span>位序列号</b></span><span class="inline-wrap">：用于确保在同一毫秒内生成的<span class="jill"></span>ID<span class="jill"></span>是唯一的。每毫秒可生成<span class="jill"></span>4096<span class="jill"></span>个不重复的<span class="jill"></span>ID。</span></li></ul></li><li id="tr91ZdZyH9YG5AXhZMFVfV"><div class="marker"></div><span class="inline-wrap"><b>生成过程</b></span><span class="inline-wrap">：在生成<span class="jill"></span>ID<span class="jill"></span>时，首先获取当前的时间戳。如果当前时间戳与上次生成<span class="jill"></span>ID<span class="jill"></span>的时间戳相同，则序列号加<span class="jill"></span>1；否则，序列号置为<span class="jill"></span>0，并更新时间戳。最后，将时间戳、机器标识和序列号组合成<span class="jill"></span>64<span class="jill"></span>位的长整型值，形成一个唯一的<span class="jill"></span>ID。</span></li></ol><h3 id="uuN8cBjqJjo6NKvxuDXuot" class="wolai-block"><span class="wolai-serial-number">8.4.2</span><span class="inline-wrap">优点</span></h3><ol class="wolai-block"><li id="6tjc23PKMX6Wq4DxGYC7y9"><div class="marker"></div><span class="inline-wrap"><b>高并发性能</b></span><span class="inline-wrap">：在高并发环境下，每秒可生成百万级别的不重复<span class="jill"></span>ID。</span></li><li id="aWLfr7uuH7rjAaFKqKJptR"><div class="marker"></div><span class="inline-wrap"><b>唯一性保证</b></span><span class="inline-wrap">：通过结合时间戳、机器<span class="jill"></span>ID<span class="jill"></span>和序列号，可以确保生成的<span class="jill"></span>ID<span class="jill"></span>在分布式系统中的唯一性。</span></li><li id="cqRUAjuvHbMYrNiNkKf9c2"><div class="marker"></div><span class="inline-wrap"><b>趋势递增</b></span><span class="inline-wrap">：基于时间戳生成<span class="jill"></span>ID，可以保证<span class="jill"></span>ID<span class="jill"></span>的基本有序递增，满足某些业务场景的需求。</span></li><li id="sKwhXQHHnuTcoabcEQesyH"><div class="marker"></div><span class="inline-wrap"><b>灵活性</b></span><span class="inline-wrap">：可以根据需要自定义<span class="jill"></span>ID<span class="jill"></span>结构，如调整时间戳、机器标识和序列号的位数。</span></li></ol><h3 id="gCPqteHgTaPUWZsvoiWJvd" class="wolai-block"><span class="wolai-serial-number">8.4.3</span><span class="inline-wrap">缺点</span></h3><ol class="wolai-block"><li id="cRRCvRwTCZBtrncPyFH6fm"><div class="marker"></div><span class="inline-wrap"><b>依赖服务器时间</b></span><span class="inline-wrap">：生成的<span class="jill"></span>ID<span class="jill"></span>依赖于服务器的时钟，如果服务器时钟回拨或不同机器之间的时钟不同步，可能会导致生成重复的<span class="jill"></span>ID。</span></li><li id="ov2Di4uSezUhpy344x8wLh"><div class="marker"></div><span class="inline-wrap"><b>有限的并发性</b></span><span class="inline-wrap">：虽然雪花算法支持高并发，但在极端情况下仍可能出现并发问题。</span></li></ol><div id="abW4zDtKccRtv7Djo2SKPk" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，雪花算法是一种高效、可靠的分布式<span class="jill"></span>ID<span class="jill"></span>生成算法，适用于大规模分布式系统。然而，由于其依赖服务器时间的特性，需要在实际应用中注意时钟同步和回拨问题。</span></div></div><div id="vcfmpSr6qWYT7PBBNdTGpq" class="wolai-block wolai-text"><div></div></div><div id="vRY79qL5UxpwMR1dJ3zfxN" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vTcqhXZo6tLoNdRbBDZvJC" class="wolai-block"><span class="wolai-serial-number">9</span><span class="inline-wrap">分布式锁的解决方案</span></h1><div id="s2MNP6Zpq2ANwVJPcAQnYi" class="wolai-block wolai-text"><div><span class="inline-wrap">需要这个锁独立于每一个服务之外，而不是在服务里面。</span></div></div><h2 id="qLm2P2jNcAtsGwwejHdMPE" class="wolai-block"><span class="wolai-serial-number">9.1</span><span class="inline-wrap">使用<span class="jill"></span>MySQL<span class="jill"></span>实现</span></h2><div id="3h5RZNYQnn4iTEbD3zPSv3" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 可以通过一些技巧来实现分布式锁，但需要注意的是，这并不是 MySQL 的原生功能，因此需要一些额外的设计和编码工作。</span></div></div><div id="jJHSyrnWQwyb4cf2xDxGkC" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是使用 MySQL 实现分布式锁的一种常见方法：</span></div></div><h3 id="shqBNJrR4B2UAiw544oBzL" class="wolai-block"><span class="wolai-serial-number">9.1.1</span><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>GET_LOCK()</code></span><span class="inline-wrap"> 函数</span></h3><div id="32eCiCnznqtm5Nr2rb5A2G" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 提供了 </span><span class="inline-wrap"><code>GET_LOCK()</code></span><span class="inline-wrap"> 函数用于获取一个命名锁。如果锁不存在，则该函数会创建一个锁并返回<span class="jill"></span>1；如果锁已经存在，则返回<span class="jill"></span>0。</span></div></div><code-block id="7PQbqmhprSTxVsK1aFT7Sv" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> GET_LOCK<span class="token punctuation">(</span><span class="token string">'my_lock'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 尝试获取名为 'my_lock' 的锁，等待时间为10秒</span></pre></div></code-block><h3 id="nhLomgBhmz5LpfCsHHpqMH" class="wolai-block"><span class="wolai-serial-number">9.1.2</span><span class="inline-wrap">释放锁</span></h3><div id="hL63Ay3TFXFwpMfitgz7Rh" class="wolai-block wolai-text"><div><span class="inline-wrap">MySQL 提供了 </span><span class="inline-wrap"><code>RELEASE_LOCK()</code></span><span class="inline-wrap"> 函数用于释放锁。</span></div></div><code-block id="bYai8TSpzMBJL2CiQBf6Fo" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DO</span> RELEASE_LOCK<span class="token punctuation">(</span><span class="token string">'my_lock'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h3 id="7ddwFjwBmj5GAZoV9VygWp" class="wolai-block"><span class="wolai-serial-number">9.1.3</span><span class="inline-wrap">示例代码</span></h3><div id="67EZW3mHzrGSChvWAMf1xe" class="wolai-block wolai-text"><div><span class="inline-wrap">假设我们有一个表 </span><span class="inline-wrap"><code>orders</code></span><span class="inline-wrap">，我们希望在插入新订单时加锁以避免并发问题。</span></div></div><h4 id="abftumezCVBP4wm1zA3pYJ" class="wolai-block"><span class="wolai-serial-number">9.1.3.1</span><span class="inline-wrap">Step 1: 获取锁</span></h4><code-block id="cC9bL1agY68Rd8mWZzvuiS" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SET</span> <span class="token variable">@lock_acquired</span> <span class="token operator">=</span> GET_LOCK<span class="token punctuation">(</span><span class="token string">'orders_mutex'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 尝试获取锁，等待10秒</span>
<span class="token keyword">IF</span> <span class="token variable">@lock_acquired</span> <span class="token keyword">THEN</span>
    <span class="token comment">-- 执行业务逻辑，例如插入订单</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> orders <span class="token punctuation">(</span>order_id<span class="token punctuation">,</span> order_details<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'order details here'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">COMMIT</span><span class="token punctuation">;</span> <span class="token comment">-- 确保提交事务以释放锁</span>
<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span></pre></div></code-block><h4 id="x2WkquNRj7nHgwaTn1cr4L" class="wolai-block"><span class="wolai-serial-number">9.1.3.2</span><span class="inline-wrap">Step 2: 释放锁</span></h4><code-block id="9YpJyeJKe2t7r6aPH3BpRy" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">DO</span> RELEASE_LOCK<span class="token punctuation">(</span><span class="token string">'orders_mutex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><h3 id="5GqHSM8AyXZsH1sSyUt7zZ" class="wolai-block"><span class="wolai-serial-number">9.1.4</span><span class="inline-wrap">结合应用程序代码</span></h3><div id="vFe2RRCpUaguAmuXHwmTc1" class="wolai-block wolai-text"><div><span class="inline-wrap">通常我们会在应用层结合上述 SQL 语句来控制分布式锁。以下是一个简化的伪代码示例（假设使用 Python 和 pymysql）：</span></div></div><code-block id="eLVMHJoERUQwGwLhminkar" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> pymysql

<span class="token comment"># 数据库连接参数</span>
conn <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">'password'</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token string">'test'</span><span class="token punctuation">)</span>
cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 尝试获取锁</span>
lock_name <span class="token operator">=</span> <span class="token string">'orders_mutex'</span>
wait_timeout <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment"># 等待时间为10秒</span>

<span class="token keyword">try</span><span class="token punctuation">:</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"SELECT GET_LOCK('</span><span class="token interpolation"><span class="token punctuation">{</span>lock_name<span class="token punctuation">}</span></span><span class="token string">', </span><span class="token interpolation"><span class="token punctuation">{</span>wait_timeout<span class="token punctuation">}</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
    lock_acquired <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span>
    
    <span class="token keyword">if</span> lock_acquired<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token comment"># 执行业务逻辑，例如插入订单</span>
            cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"INSERT INTO orders (order_id, order_details) VALUES (NULL, 'order details here')"</span><span class="token punctuation">)</span>
            conn<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">finally</span><span class="token punctuation">:</span>
            <span class="token comment"># 确保释放锁</span>
            cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"DO RELEASE_LOCK('</span><span class="token interpolation"><span class="token punctuation">{</span>lock_name<span class="token punctuation">}</span></span><span class="token string">')"</span></span><span class="token punctuation">)</span>
            conn<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"未能获取到锁"</span><span class="token punctuation">)</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    cursor<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></div></code-block><h3 id="mzVFnaJegC2Cjjy1ikYdWT" class="wolai-block"><span class="wolai-serial-number">9.1.5</span><span class="inline-wrap">注意事项</span></h3><ol class="wolai-block"><li id="3QyobVGaY2mRMLk4c5XJ7D"><div class="marker"></div><span class="inline-wrap"><b>超时时间</b></span><span class="inline-wrap">：确保设置合理的等待时间，避免长时间阻塞。</span></li><li id="wuiBoULWb9ncts7Y1dWWma"><div class="marker"></div><span class="inline-wrap"><b>事务</b></span><span class="inline-wrap">：确保在事务中获取和释放锁，以保证操作的原子性。</span></li><li id="sScE5Dzye94LXHATiLhEPP"><div class="marker"></div><span class="inline-wrap"><b>错误处理</b></span><span class="inline-wrap">：在实际应用中要添加更多的错误处理机制，如网络异常、数据库连接失败等。</span></li><li id="vAtyNH25FWJ551VDkv8J7Z"><div class="marker"></div><span class="inline-wrap"><b>性能</b></span><span class="inline-wrap">：频繁获取和释放锁可能会影响性能，需要权衡使用。</span></li><li id="aRpDokKEWAbvQt51x56PFX"><div class="marker"></div><span class="inline-wrap"><b>锁粒度</b></span><span class="inline-wrap">：根据实际需求选择合适的锁粒度，避免过度锁定导致系统瓶颈。</span></li></ol><div id="qjNAxDuSk2kqvvy5NACSu1" class="wolai-block wolai-text"><div><span class="inline-wrap">通过以上步骤和注意事项，您可以使用 MySQL 实现一个简单的分布式锁机制。不过，对于更复杂的场景，建议使用专门的分布式锁服务，如 Zookeeper、Redis 或者 Etcd 等。</span></div></div><h2 id="vuLyaxRVnxD6uFWep8by9D" class="wolai-block"><span class="wolai-serial-number">9.2</span><span class="inline-wrap">使用<span class="jill"></span>Zookeeper<span class="jill"></span>实现</span></h2><div id="mQg1nBf4vVvg6gjfWGbRAk" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>Zookeeper<span class="jill"></span>实现分布式锁是一种常见的方法，可以确保在分布式系统中的多个节点上对共享资源进行互斥访问。下面将详细介绍如何使用<span class="jill"></span>Zookeeper<span class="jill"></span>实现分布式锁：</span></div></div><h3 id="7X6HcgRefVLj7HM4Mfz4r7" class="wolai-block"><span class="wolai-serial-number">9.2.1</span><span class="inline-wrap">Zookeeper<span class="jill"></span>简介</span></h3><div id="aWgothQWchwqD1XX1vNUrj" class="wolai-block wolai-text"><div><span class="inline-wrap">ZooKeeper<span class="jill"></span>是一个开源的分布式协调服务，提供了高可用、高性能的分布式锁机制。它通过在集群中的多个节点之间共享数据来实现分布式锁的管理，确保只有一个节点能够获取到锁。</span></div></div><h3 id="7yECgTjrfET1zBPn2DdBgA" class="wolai-block"><span class="wolai-serial-number">9.2.2</span><span class="inline-wrap">Zookeeper<span class="jill"></span>实现分布式锁的原理</span></h3><div id="9QeTgagM8DqstUnfa4DFzx" class="wolai-block wolai-text"><div><span class="inline-wrap">Zookeeper<span class="jill"></span>的分布式锁是基于临时顺序节点（Ephemeral Sequential Znode）和<span class="jill"></span>Watcher<span class="jill"></span>监听器机制实现的。具体实现步骤如下：</span></div></div><ol class="wolai-block"><li id="vu26MqiggLvPX3xjLf7VNG"><div class="marker"></div><span class="inline-wrap"><b>创建一个持久性的父节点</b></span><span class="inline-wrap">：在<span class="jill"></span>ZooKeeper<span class="jill"></span>中创建一个持久性的父节点，用于存储所有的锁。</span></li><li id="avfxEXbm52mrxkKfebr1bY"><div class="marker"></div><span class="inline-wrap"><b>每个请求尝试创建一个临时顺序节点</b></span><span class="inline-wrap">：当一个节点需要获取锁时，它在上述创建的父节点下创建一个临时顺序节点。</span></li><li id="oh3zx4bgsoASaFSnJHPb46"><div class="marker"></div><span class="inline-wrap"><b>获取节点列表并判断是否为最小节点</b></span><span class="inline-wrap">：节点获取父节点下的所有子节点，并对它们进行排序。如果当前节点是所有子节点中最小的节点，则表示该节点获取了锁；否则，该节点需要监听比它小的前一个节点的删除事件。</span></li><li id="juKKZ6fXZefsoLpjEEtETQ"><div class="marker"></div><span class="inline-wrap"><b>等待前一个节点释放锁</b></span><span class="inline-wrap">：如果节点不是最小的节点，它会监听比它小的前一个节点的变化事件。一旦前一个节点被删除，它再次尝试获取锁，重复步骤<span class="jill"></span>3<span class="jill"></span>和步骤<span class="jill"></span>4，直到获取到锁为止。</span></li><li id="r9TUqdeJ3hzPQSEuhfvZvX"><div class="marker"></div><span class="inline-wrap"><b>释放锁</b></span><span class="inline-wrap">：当节点使用完共享资源后，它删除自己创建的临时顺序节点，从而释放锁。</span></li></ol><h3 id="cEV8tcTp1hUw3BLgt26uQz" class="wolai-block"><span class="wolai-serial-number">9.2.3</span><span class="inline-wrap">Zookeeper<span class="jill"></span>实现分布式锁的代码示例</span></h3><div id="jsbRxQm9FLZVeDfNEzcvF7" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是一个使用<span class="jill"></span>Java<span class="jill"></span>语言和<span class="jill"></span>Zookeeper<span class="jill"></span>原生<span class="jill"></span>API<span class="jill"></span>实现分布式锁的简化示例：</span></div></div><code-block id="wXXUKuYtLzq8QPqhw2jCUf" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>data<span class="token punctuation">.</span></span><span class="token class-name">Stat</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistributedLockExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ZOOKEEPER_CONNECTION_STRING</span> <span class="token operator">=</span> <span class="token string">"localhost:2181"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SESSION_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">LOCK_PATH</span> <span class="token operator">=</span> <span class="token string">"/distributed_lock"</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">ZooKeeper</span> zooKeeper<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> currentZnodeName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DistributedLockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>zooKeeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span><span class="token constant">ZOOKEEPER_CONNECTION_STRING</span><span class="token punctuation">,</span> <span class="token constant">SESSION_TIMEOUT</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Watcher实现</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquireLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">KeeperException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">createLockNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> children <span class="token operator">=</span> zooKeeper<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> smallestNode <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentZnodeName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> smallestNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">waitForLock</span><span class="token punctuation">(</span>children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> currentZnodeName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createLockNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">KeeperException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zooKeeper<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            zooKeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">ZooDefs<span class="token punctuation">.</span>Ids</span><span class="token punctuation">.</span><span class="token constant">OPEN_ACL_UNSAFE</span><span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        currentZnodeName <span class="token operator">=</span> zooKeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span> <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">ZooDefs<span class="token punctuation">.</span>Ids</span><span class="token punctuation">.</span><span class="token constant">OPEN_ACL_UNSAFE</span><span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span><span class="token constant">EPHEMERAL_SEQUENTIAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> prevZnodeName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">KeeperException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zooKeeper<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token constant">LOCK_PATH</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> prevZnodeName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Event<span class="token punctuation">.</span>EventType<span class="token punctuation">.</span>NodeDeleted</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">KeeperException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        zooKeeper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>currentZnodeName<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        zooKeeper<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">DistributedLockExample</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DistributedLockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">acquireLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行业务逻辑</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟业务执行时间</span>
        lock<span class="token punctuation">.</span><span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><h3 id="cs6KUCfCrw3ZjzguZoiHB5" class="wolai-block"><span class="wolai-serial-number">9.2.4</span><span class="inline-wrap">注意事项</span></h3><ul class="wolai-block"><li id="j2sWUVa5e7nNMeziZmQovR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>临时节点的创建和删除必须是原子性的</b></span><span class="inline-wrap">：否则会出现多个节点同时创建或删除的情况，导致锁的失效。</span></li><li id="wWgpH2A7cD1rvKMuKfrD6c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>避免死锁</b></span><span class="inline-wrap">：如果一个进程或节点创建临时节点但没有及时删除，就会造成死锁，因为其他进程或节点永远也无法获取到锁。</span></li><li id="9uBPfqmQArQcMYPB14ax9C"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>处理异常情况</b></span><span class="inline-wrap">：如果一个进程或节点获取到锁后因为某些原因没有及时释放锁，就会导致其他进程或节点一直等待，降低了系统的性能。因此，在实现分布式锁时，需要考虑锁的可靠性、高效性和容错性，并对异常情况进行处理，以确保锁的正确性和系统的稳定性。</span></li></ul><div id="21win8g4uXumExEG3EPfu2" class="wolai-block wolai-text"><div><span class="inline-wrap">以上是使用<span class="jill"></span>Zookeeper<span class="jill"></span>实现分布式锁的基本方法和注意事项，实际应用中可能还需要考虑超时处理、重试机制等细节。</span></div></div><h2 id="gGbMLYwQtScgSNCHbjAjn6" class="wolai-block"><span class="wolai-serial-number">9.3</span><span class="inline-wrap">使用<span class="jill"></span>Redis<span class="jill"></span>实现</span></h2><div id="vQ8LLafqzdEfVc78qf9vP1" class="wolai-block wolai-text"><div><span class="inline-wrap">Redis<span class="jill"></span>是一种高性能的键值存储系统，因其读写速度快、支持多种数据结构以及高并发性能，被广泛应用于分布式锁的实现。以下是使用<span class="jill"></span>Redis<span class="jill"></span>实现分布式锁的具体方法：</span></div></div><ol class="wolai-block"><li id="6xuCzCRwJ2WhPRhx9gjoR5"><div class="marker"></div><span class="inline-wrap"><b>SETNX<span class="jill"></span>命令</b></span><ul class="wolai-block"><li id="sTtmox7FQWzZvcWEVwXSr2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本概念</b></span><span class="inline-wrap">：SETNX（SET if Not eXists）是<span class="jill"></span>Redis<span class="jill"></span>提供的一个命令，用于在键不存在时设置键的值。如果键已经存在，则不做任何操作。这可以用于实现简单的分布式锁。</span></li><li id="3coamAkuaJiEHtb7VTNWXr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">：</span><code-block id="m66KFWX9ze5nqyKHK9oX7q" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> redis

r <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
lock_key <span class="token operator">=</span> <span class="token string">"my_lock"</span>
lock_value <span class="token operator">=</span> <span class="token string">"unique_value"</span>

<span class="token comment"># 尝试获取锁</span>
<span class="token keyword">if</span> r<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>lock_key<span class="token punctuation">,</span> lock_value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquired"</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行业务逻辑</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token comment"># 释放锁</span>
        r<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>lock_key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquisition failed"</span><span class="token punctuation">)</span></pre></div></code-block></li></ul></li><li id="3KRLU2C296a5myMHrr8waJ"><div class="marker"></div><span class="inline-wrap"><b>EXPIRE<span class="jill"></span>命令</b></span><ul class="wolai-block"><li id="esDsZE9phX9pqhRv17wA6H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本概念</b></span><span class="inline-wrap">：为了防止死锁，可以在获取锁后设置一个过期时间。当锁的持有者发生异常或崩溃时，锁会自动释放。</span></li><li id="3FbzNKLmexRubL9yWdDa8T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">：</span><code-block id="7m9VuvVHZAyJXkwSR6QdXn" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> redis

r <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
lock_key <span class="token operator">=</span> <span class="token string">"my_lock"</span>
lock_value <span class="token operator">=</span> <span class="token string">"unique_value"</span>

<span class="token comment"># 尝试获取锁并设置过期时间</span>
<span class="token keyword">if</span> r<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>lock_key<span class="token punctuation">,</span> lock_value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    r<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>lock_key<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 设置过期时间为10秒</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquired"</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行业务逻辑</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token comment"># 释放锁</span>
        r<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>lock_key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquisition failed"</span><span class="token punctuation">)</span></pre></div></code-block></li></ul></li><li id="igQXYhsbP6JJqSjtaCmS18"><div class="marker"></div><span class="inline-wrap"><b>Lua<span class="jill"></span>脚本</b></span><ul class="wolai-block"><li id="7UaVA5hVjUeorUFBRJnpzX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本概念</b></span><span class="inline-wrap">：为了确保加锁和设置过期时间的原子性，可以使用<span class="jill"></span>Lua<span class="jill"></span>脚本。Lua<span class="jill"></span>脚本在<span class="jill"></span>Redis<span class="jill"></span>中以原子方式执行，避免了中间状态的问题。</span></li><li id="5naz67nvNNm7ZHe5xY7yfp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">：</span><code-block id="7CqTaJgSiFjTYy7BdnmDux" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> redis

r <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
lock_key <span class="token operator">=</span> <span class="token string">"my_lock"</span>
lock_value <span class="token operator">=</span> <span class="token string">"unique_value"</span>
expire_time <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment"># 过期时间10秒</span>

lua_script <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
local res = redis.call('setnx', KEYS[1], ARGV[1])
if res then
    redis.call('expire', KEYS[1], ARGV[2])
return res
else
return 0
end
"""</span>

<span class="token comment"># 使用eval命令执行Lua脚本</span>
<span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>lua_script<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lock_key<span class="token punctuation">,</span> lock_value<span class="token punctuation">,</span> expire_time<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquired"</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行业务逻辑</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token comment"># 释放锁</span>
        r<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>lock_key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquisition failed"</span><span class="token punctuation">)</span></pre></div></code-block></li></ul></li><li id="hA5u7jhzj3UngQrAdSuXy2"><div class="marker"></div><span class="inline-wrap"><b>Redlock<span class="jill"></span>算法</b></span><ul class="wolai-block"><li id="knG538jV8oVyoCst72fGQ7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>基本概念</b></span><span class="inline-wrap">：Redlock<span class="jill"></span>算法通过在多个独立的<span class="jill"></span>Redis<span class="jill"></span>实例上获取锁来提高可靠性。客户端需要在大多数实例上成功获取锁才能认为真正获取了锁。</span></li><li id="q3wg3eTshqCurUm94u1By8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>示例代码</b></span><span class="inline-wrap">：</span><code-block id="wYmDYmXLTfqimoS9EqVt5c" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">import</span> redis
<span class="token keyword">from</span> redis<span class="token punctuation">.</span>lock <span class="token keyword">import</span> Lock<span class="token punctuation">,</span> LOCK_EXPIRE<span class="token punctuation">,</span> LOCK_TIMEOUT

<span class="token comment"># 定义多个Redis实例</span>
redises <span class="token operator">=</span> <span class="token punctuation">[</span>
    redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6380</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>

<span class="token comment"># 创建Redlock对象</span>
redlock <span class="token operator">=</span> Lock<span class="token punctuation">(</span>redises<span class="token punctuation">,</span> <span class="token string">"my_lock"</span><span class="token punctuation">,</span> expire<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>

<span class="token comment"># 尝试获取锁</span>
<span class="token keyword">if</span> redlock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span>blocking<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquired"</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行业务逻辑</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token comment"># 释放锁</span>
        redlock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Lock acquisition failed"</span><span class="token punctuation">)</span></pre></div></code-block></li></ul></li></ol><div id="XpoAHEnnymHjcmpgS6Dyi" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，使用<span class="jill"></span>Redis<span class="jill"></span>实现分布式锁有多种方法，每种方法都有其优缺点和适用场景。在实际应用中，需要根据具体需求选择合适的方案，并注意处理可能出现的异常情况，以确保系统的高可用性和稳定性。</span></div></div><div id="ttcCGQ29wZMYtvpzoKYKMS" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="t9NgFrWLfvgE37pVUTZUv4" class="wolai-block"><span class="wolai-serial-number">10</span><span class="inline-wrap">相对于手动实现，Redisson<span class="jill"></span>框架解决了哪些问题？</span></h1><div id="qdo1oHyKjkVXMjn5y1L8mZ" class="wolai-block wolai-text"><div><span class="inline-wrap">Redisson<span class="jill"></span>框架在分布式锁的实现中解决了多个关键问题，使得其在高并发场景下更为可靠和高效。以下是<span class="jill"></span>Redisson<span class="jill"></span>框架解决的主要问题：</span></div></div><ol class="wolai-block"><li id="qTSNwwMxYFcYNZR2XU9oEZ"><div class="marker"></div><span class="inline-wrap"><b>死锁问题</b></span><span class="inline-wrap">：在使用<span class="jill"></span>SETNX<span class="jill"></span>命令时，如果没有设置过期时间，可能会导致锁忘记删除或加锁线程宕机，从而造成死锁。Redisson<span class="jill"></span>通过设置分布式锁的过期时间来避免这种情况，确保锁不会一直被占用。</span></li><li id="d18WAjCDzfEx6oxqK6hDBR"><div class="marker"></div><span class="inline-wrap"><b>锁误删问题</b></span><span class="inline-wrap">：SETNX<span class="jill"></span>命令设置了超时时间后，如果执行时间太长，锁可能会在超时时间内自动释放，但线程可能不知道这一点，导致其他线程的锁被误删。Redisson<span class="jill"></span>通过为每个锁关联一个线程<span class="jill"></span>ID<span class="jill"></span>和重入次数作为分布锁<span class="jill"></span>value<span class="jill"></span>的一部分存储在<span class="jill"></span>Redis<span class="jill"></span>中，避免了锁误删的问题。</span></li><li id="n4HQSreTLRjjLUvZovHAXU"><div class="marker"></div><span class="inline-wrap"><b>不可重入问题</b></span><span class="inline-wrap">：同一线程在已经获取了某个锁的情况下，如果再次请求获取该锁，请求会失败。Redisson<span class="jill"></span>允许同一个线程对已经持有的锁进行重复锁定，解决了不可重入的问题。</span></li><li id="avqbR74wAmh3bGRPAkf7uQ"><div class="marker"></div><span class="inline-wrap"><b>自动续期问题</b></span><span class="inline-wrap">：线程在持有锁期间，如果任务未能执行完成，锁可能会因为超时而自动释放。Redisson<span class="jill"></span>提供了自动续期的功能，通过定时任务（看门狗）定期延长锁的有效期，确保在业务未完成前锁不会被其他线程获取。</span></li><li id="6nBKBgdZmQWfGwXuBZEg59"><div class="marker"></div><span class="inline-wrap"><b>简化操作与高级功能</b></span><span class="inline-wrap">：Redisson<span class="jill"></span>是一个开源的用于操作<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>Java<span class="jill"></span>框架，它提供了许多简化<span class="jill"></span>Redis<span class="jill"></span>操作的高级<span class="jill"></span>API，并支持分布式对象、分布式锁、分布式集合等特性。这些高级功能大大降低了设计和研发大规模分布式系统的难度。</span></li><li id="jXrKhUk1JLWdi8dJnhEjBW"><div class="marker"></div><span class="inline-wrap"><b>优化策略</b></span><span class="inline-wrap">：Redisson<span class="jill"></span>还提供了多种优化策略，如选择合适的锁类型（如读锁、写锁等）、控制锁的持有时间、使用超时设置等，以提高系统的并发性能和可靠性。</span></li></ol><div id="thpPN1dcGhPbKUX8kJ3PzH" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，Redisson<span class="jill"></span>框架在分布式锁的实现中解决了死锁、锁误删、不可重入、自动续期等多个关键问题，并通过提供高级<span class="jill"></span>API<span class="jill"></span>和优化策略来降低分布式系统设计的复杂度和提高系统的并发性能。</span></div></div><div id="xvSEgnS2oqNxAwwX23Wv18" class="wolai-block wolai-text"><div></div></div><div id="6Qx2BMUdrsF1pqy3qJDWyY" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vAgLMr7stWWReVj7wVNLpJ" class="wolai-block"><span class="wolai-serial-number">11</span><span class="inline-wrap">实现一个分布式锁需要考虑哪些问题？</span></h1><div id="qSqa4TNeHZkzaJtc1EcW3b" class="wolai-block wolai-text"><div><span class="inline-wrap">实现一个分布式锁时，需要考虑以下几个问题：</span></div></div><ol class="wolai-block"><li id="4hbzArqKkdZzudQ6noqZeg"><div class="marker"></div><span class="inline-wrap"><b>锁的唯一性</b></span><span class="inline-wrap">：在分布式环境下，需要确保同一把锁在不同的节点之间是唯一的。可以使用全局唯一标识符（例如基于<span class="jill"></span>ZooKeeper<span class="jill"></span>或<span class="jill"></span>Redis<span class="jill"></span>的分布式锁）来确保锁的唯一性。  </span></li><li id="61qVh7iQcFkqfx7g6GYs7P"><div class="marker"></div><span class="inline-wrap"><b>死锁和活锁</b></span><span class="inline-wrap">：分布式环境下的死锁和活锁是需要避免的问题。死锁是指多个节点互相等待对方释放锁的情况，而活锁是指多个节点不断争夺锁资源，但没有一个节点能够成功获取锁。为了避免死锁和活锁，可以使用超时机制、重试机制、随机等待时间等策略来解决。</span></li><li id="8k5L1ozmLAz6kfgsY5TuD7"><div class="marker"></div><span class="inline-wrap"><b>锁的可重入性</b></span><span class="inline-wrap">：分布式锁是否支持可重入是需要考虑的问题。可重入意味着同一个线程可以多次获取同一把锁，而不会发生死锁。在实现分布式锁时，需要考虑是否支持可重入，并在实现时进行相应的处理。</span></li><li id="hrMkoETFtzZ9yg8sgfypmR"><div class="marker"></div><span class="inline-wrap"><b>锁的粒度</b></span><span class="inline-wrap">：锁的粒度是指锁的范围，即锁定的是整个系统、模块、方法还是更细粒度的资源。在分布式环境下，锁的粒度需要根据实际需求进行选择，避免锁的范围大或过小。</span></li><li id="aFLERCXkM3po8iSCmCSRnm"><div class="marker"></div><span class="inline-wrap"><b>锁的性能和可靠性</b></span><span class="inline-wrap">：分布式锁的性能和可靠性是需要考虑的问题。锁的获取和释放需要保证高效且可靠，同时要考虑网络延迟、节点故障等因素对锁性能和可靠性的影响。</span></li><li id="h3nbA4b3uPWz4h4NBytFEm"><div class="marker"></div><span class="inline-wrap"><b>锁的容错和容量</b></span><span class="inline-wrap">：在分布式环境下，需要考虑节点故障和网络分区等异常情况对锁的影响。可以使用多个节点进行容错和冗余，以确保锁的可用性和容量。</span></li></ol><div id="8rS3MRywX1SkuFfi8fsxV6" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，实现一个分布式锁需要考虑锁的唯一性、死锁和活锁、锁的可重入性、锁的粒度、锁的性能和可靠性，以及锁的容错和容量等问题。根据具体需求选择适合的分布式锁方案，并在实现时合理处理这些问题。</span></div></div><div id="iF3CizeTrVMAgBBBNX8Qkx" class="wolai-block wolai-text"><div></div></div><div id="sBtL8sH2QfJY55VkFMvgvT" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qFzqgAfTSVSV2Mwff8cSvS" class="wolai-block"><span class="wolai-serial-number">12</span><span class="inline-wrap">什么是分布式事务</span></h1><div id="EkKG4Rh4zrSehBVLD5esk" class="wolai-block wolai-text"><div><span class="inline-wrap">分布式事务是指在分布式系统中涉及多个独立的数据库或服务的事务操作，它需要确保这些操作要么全部成功执行，要么全部回滚，以保持数据的一致性和可靠性。</span></div></div><div id="dxdupfq6hLrTorNqUEcysS" class="wolai-block wolai-text"><div><span class="inline-wrap">分布式事务的目标是在不同的系统之间维护数据的一致性，即使在出现故障或部分操作失败的情况下也能够保持数据的正确性。</span></div></div><div id="dd71YxWm6xt7H82HkCzKwe" class="wolai-block wolai-text"><div><span class="inline-wrap">在传统的单一数据库事务中，事务是由数据库管理系统负责管理和保障的，但在分布式环境下，涉及到多个独立的数据库或服务，各自拥有独立的事务管理机制，因此需要特殊的方法来确保分布式事务的一致性。</span></div></div><div id="tZfcGqa7Nx7c4WcdB3LeiT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="aLCc4x4V29ViXfN38VBDt" class="wolai-block wolai-text"><div><span class="inline-wrap">分布式事务面临的挑战和问题包括：</span></div></div><ul class="wolai-block"><li id="tr1tDtffamoe4Qy5xQdg24"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>原子性（Atomicity）</b></span><span class="inline-wrap">： 分布式事务需要确保涉及的所有操作要么都成功执行，要么都回滚，不能出现部分操作成功而部分操作失败的情况。</span></li><li id="9BwBmWrv8bBsLGmusmk24s"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>一致性（Consistency）</b></span><span class="inline-wrap">： 分布式事务需要保证各个参与方的数据保持一致性，即在事务开始和结束时，系统的数据状态应该满足特定的约束。</span></li><li id="3YLXMgruysC64aCEHPfVoK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>隔离性（Isolation）</b></span><span class="inline-wrap">： 分布式事务的操作应该与其他事务隔离，避免不同事务之间的干扰和冲突。</span></li><li id="rTDxx5BemCWK4czkprXrUz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>持久性（Durability）</b></span><span class="inline-wrap">： 分布式事务需要确保在事务提交后，其结果被可靠地持久化，以防止数据丢失。</span></li></ul><div id="stL44bosW71ynnmJkWkfph" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="h3HWAR6RQiB8zkGjaphwz8" class="wolai-block wolai-text"><div><span class="inline-wrap">为了实现分布式事务，有一些常见的方法和技术，包括两阶段提交（Two-Phase Commit，2PC）、三阶段提交（Three-Phase Commit，3PC）、补偿事务（Compensating Transaction）等。这些方法在不同的场景下有不同的适用性和权衡，开发人员需要根据系统的需求和复杂性选择适合的方法来处理分布式事务。同时，分布式事务的实现也需要考虑到性能、可靠性和复杂性等方面的因素。</span></div></div><div id="922GmcoepQ4ipefrRsfaAj" class="wolai-block wolai-text"><div></div></div><div id="mK8LqkiYaKhi6goBcfJmR6" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="b1ptxrSnjoHoda9NwL16FC" class="wolai-block"><span class="wolai-serial-number">13</span><span class="inline-wrap">请介绍一下分布式事务解决方案中的<span class="jill"></span>XA<span class="jill"></span>规范</span></h1><h2 id="mezLcaqvAV5R6va3GbBmFr" class="wolai-block"><span class="wolai-serial-number">13.1</span><span class="inline-wrap">简介</span></h2><div id="5nNVSy9pcJPo4CtmEXeHBD" class="wolai-block wolai-text"><div><span class="inline-wrap">XA<span class="jill"></span>协议是一种基于两阶段提交（Two-Phase Commit，2PC）协议的分布式事务解决方案，用于解决分布式系统中多个资源管理器之间的事务一致性问题</span></div></div><div id="nEfR4QGrCwh8hyRpssLbms" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7KWgXK2AKvRFuWomY79xxm" class="wolai-block"><span class="wolai-serial-number">13.2</span><span class="inline-wrap">基础概念</span></h2><h3 id="aMLHPp27WSeEAmjxy4GnDW" class="wolai-block"><span class="wolai-serial-number">13.2.1</span><span class="inline-wrap">四个角色</span></h3><ol class="wolai-block"><li id="qRz2RSbL3BpSK32Q5M1Sev"><div class="marker"></div><span class="inline-wrap"><b>事务管理器（Transaction Manager，TM）</b></span><span class="inline-wrap">：负责管理分布式事务的整个生命周期，包括事务的提交、回滚和恢复等。</span></li><li id="iUkbGijdWaZMFd7knap7ny"><div class="marker"></div><span class="inline-wrap"><b>资源管理器（Resource Manager，RM）</b></span><span class="inline-wrap">：管理事务处理过程中涉及到的各种资源，如数据库、消息队列等。</span></li><li id="2cLHsFKqRHwGbeLBRTHdQi"><div class="marker"></div><span class="inline-wrap"><b>应用程序（Application Program，AP）</b></span><span class="inline-wrap">：执行业务逻辑，并发起或参与分布式事务。</span></li><li id="gAeBDHZwpd9AnkuLgtAykp"><div class="marker"></div><span class="inline-wrap"><b>通信资源管理器（Communication Resource Manager，CRM）</b></span><span class="inline-wrap">：主要用来进行跨服务的事务的传播。</span></li></ol><div id="5UzUJNTnRjmkCrfM45EB7X" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="6NptGjigT5H6E6GEGp7hMY" class="wolai-block"><span class="wolai-serial-number">13.2.2</span><span class="inline-wrap">全局事务</span></h3><div id="9JEcmjZi5uR4MJ6PDTP6iY" class="wolai-block wolai-text"><div><span class="inline-wrap">一个横跨多个数据库的事务，要么全部提交、要么全部回滚</span></div></div><div id="814Q1ZrNnETvt3g1TvZxSR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="25RUuBbTrQRMiNsozPRv7q" class="wolai-block"><span class="wolai-serial-number">13.2.3</span><span class="inline-wrap">JTA</span></h3><div id="kVRLWqnKt3S9AkEAmqotG" class="wolai-block wolai-text"><div><span class="inline-wrap">JTA<span class="jill"></span>事务是<span class="jill"></span>Java<span class="jill"></span>对<span class="jill"></span>XA<span class="jill"></span>规范的实现，对应<span class="jill"></span>JDBC<span class="jill"></span>的单库事务</span></div></div><div id="hmKQFY2m9AumaAqWBzyXbE" class="wolai-block"><figure class="wolai-center" style="width: 755.3333333333334px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><div id="raKiFLVP4XiV1pVU3oB9hs" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="6TmC5nZEzo1jmEjgciwyWG" class="wolai-block"><span class="wolai-serial-number">13.3</span><span class="inline-wrap">工作流程</span></h2><ol class="wolai-block"><li id="7B3f8d73oE6m7Wj4VixPex"><div class="marker"></div><span class="inline-wrap"><b>开始事务</b></span><span class="inline-wrap">：应用程序（AP）向事务管理器（TM）发送开始事务请求。</span></li><li id="vcZ2EAUpr2feX9xDi2aPnJ"><div class="marker"></div><span class="inline-wrap"><b>准备阶段</b></span><span class="inline-wrap">：事务管理器（TM）向所有的资源管理器（RM）发送事务开始通知。各个资源管理器（RM）接收到通知后，执行事务操作，并将操作结果和事务状态通知事务管理器（TM）。</span></li><li id="jhjsudXjstX6BtXQ8tt9C3"><div class="marker"></div><span class="inline-wrap"><b>提交或回滚</b></span><span class="inline-wrap">：事务管理器（TM）接收到各资源管理器（RM）的操作结果和事务状态后，如果所有操作都成功，并且所有资源管理器（RM）都确认事务可以提交，则发送提交请求给各个资源管理器（RM）。如果有任何一个参与者出现问题，就进入回滚阶段，让所有参与者回滚事务。</span></li><li id="iq2GrhoPLKZLauEGb6WwRu"><div class="marker"></div><span class="inline-wrap"><b>完成事务</b></span><span class="inline-wrap">：资源管理器（RM）接收到提交请求后，会执行提交操作，并将结果通知事务管理器（TM）。事务管理器（TM）接收到各资源管理器（RM）的提交结果后，如果所有资源管理器（RM）都成功提交，则发送完成事务请求给各个资源管理器（RM）。资源管理器（RM）接收到完成事务请求后，会完成事务的处理，并将结果通知事务管理器（TM）。事务管理器（TM）接收到各资源管理器（RM）的完成通知后，结束事务。</span></li></ol><div id="tEwrXF2Qu8zu6onfjGCW2F" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="tAaWTfmVdtB1xubgoBooQV" class="wolai-block"><span class="wolai-serial-number">13.4</span><span class="inline-wrap">特殊情况</span></h2><div id="etgTKzu5tgKbAcyom1rQBV" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>XA<span class="jill"></span>方案中，如果事务管理器（TM）通知所有资源管理器（RM）提交事务，但其中一个或多个<span class="jill"></span>RM<span class="jill"></span>在提交时宕机或失去应答，没有完成提交操作，那么系统需要采取一些措施来处理这种情况。以下是可能的处理步骤：</span></div></div><ol class="wolai-block"><li id="r9kPERPqbNs14H9jiwT9rS"><div class="marker"></div><span class="inline-wrap"><b>重试机制</b></span><span class="inline-wrap">：事务管理器可以在一定时间内多次尝试联系那些未响应的<span class="jill"></span>RM，以确认它们是否已经成功提交了事务。如果在重试期间某个<span class="jill"></span>RM<span class="jill"></span>恢复了并确认了提交，那么整个事务就可以被认为已经成功提交。</span></li><li id="gMqKXXUykHnu5jToGdx8Q8"><div class="marker"></div><span class="inline-wrap"><b>超时处理</b></span><span class="inline-wrap">：如果事务管理器在规定的时间内无法联系到所有的<span class="jill"></span>RM，或者无法确定某些<span class="jill"></span>RM<span class="jill"></span>是否已经提交了事务，那么它可以选择回滚整个事务。这是因为在分布式系统中，确保数据的一致性和完整性比追求高性能更为重要。</span></li><li id="pfdsABk7Ejg6c2yW8rJX77"><div class="marker"></div><span class="inline-wrap"><b>日志记录</b></span><span class="inline-wrap">：为了应对可能的系统故障，事务管理器和各个<span class="jill"></span>RM<span class="jill"></span>应该实现详细的日志记录功能。这样，即使系统在某个时刻出现故障，也可以通过查看日志来恢复未完成的事务状态，从而避免数据不一致的问题。</span></li><li id="jPTqfA4PfFqMskTWPMrqDT"><div class="marker"></div><span class="inline-wrap"><b>补偿事务</b></span><span class="inline-wrap">：在某些情况下，可能需要设计补偿事务来撤销已经执行的操作。例如，如果一个<span class="jill"></span>RM<span class="jill"></span>已经提交了一部分事务，但其他<span class="jill"></span>RM<span class="jill"></span>未能提交，那么可能需要执行一系列补偿操作来撤销已经提交的部分事务，以确保系统的一致性。</span></li><li id="jvhbhLBvgdWFZtsaRcS71d"><div class="marker"></div><span class="inline-wrap"><b>人工干预</b></span><span class="inline-wrap">：在一些极端情况下，如果自动恢复机制无法解决问题，可能需要人工介入来手动解决数据不一致的问题。这可能包括检查数据库的状态、手动执行必要的<span class="jill"></span>SQL<span class="jill"></span>语句来修复数据等。</span></li><li id="e7TJHLHZ4CT6xb2nWrnXox"><div class="marker"></div><span class="inline-wrap"><b>监控和报警</b></span><span class="inline-wrap">：为了及时发现和处理类似的问题，系统应该实现全面的监控和报警机制。当检测到<span class="jill"></span>RM<span class="jill"></span>宕机或无法响应时，系统应该立即触发报警，以便管理员能够及时采取措施。</span></li></ol><div id="6Bnr6H2wjyxEFKUceK91nn" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，面对<span class="jill"></span>RM<span class="jill"></span>宕机或失去应答的情况，XA<span class="jill"></span>方案需要结合重试机制、超时处理、日志记录、补偿事务、人工干预以及监控和报警等多种手段来确保系统的可靠性和数据的一致性。这些措施可以帮助系统在面对故障时尽可能地保持正常运行，并最小化对业务的影响。</span></div></div><div id="8GQdmfeEhSHgGruPYW5FRR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dPFzYgLi1fV5WpsQZpcwH5" class="wolai-block"><span class="wolai-serial-number">13.5</span><span class="inline-wrap">方案</span><span class="inline-wrap"><b>优点</b></span></h2><ol class="wolai-block"><li id="6frXxunr1G6KSVogaFVKvM"><div class="marker"></div><span class="inline-wrap"><b>保证数据一致性</b></span><span class="inline-wrap">：XA<span class="jill"></span>协议能够确保在分布式环境中，所有参与节点的数据保持一致，遵循<span class="jill"></span>ACID<span class="jill"></span>特性（原子性、一致性、隔离性、持久性）。</span></li><li id="2ehUM3ejXtvyJArLU1WSLK"><div class="marker"></div><span class="inline-wrap"><b>支持多种数据库</b></span><span class="inline-wrap">：XA<span class="jill"></span>协议不仅支持关系型数据库，还支持非关系型数据库，这使得它在不同的数据库系统之间具有很好的兼容性。</span></li><li id="fcA5CGBeLfgeDvhbS1H1uR"><div class="marker"></div><span class="inline-wrap"><b>易于集成</b></span><span class="inline-wrap">：由于<span class="jill"></span>XA<span class="jill"></span>协议是标准化的，因此它很容易与各种数据库和应用程序集成，无需对现有系统进行大量修改。</span></li><li id="9zgfGsHHk7yrrFUrDmVj2a"><div class="marker"></div><span class="inline-wrap"><b>灵活性高</b></span><span class="inline-wrap">：XA<span class="jill"></span>协议允许在事务处理过程中动态地添加或删除参与者，这使得它在处理复杂的业务逻辑时具有很高的灵活性。</span></li></ol><div id="cAi9VU24NdqyvJQDKmdems" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fAUuRKPXFhbTwA9kL8xktA" class="wolai-block"><span class="wolai-serial-number">13.6</span><span class="inline-wrap">方案</span><span class="inline-wrap"><b>缺点</b></span></h2><ol class="wolai-block"><li id="gjhQHFnB5XZAVYxy1JWw5R"><div class="marker"></div><span class="inline-wrap"><b>单点故障问题</b></span><span class="inline-wrap">：在<span class="jill"></span>XA<span class="jill"></span>协议中，事务管理器是整个系统的协调者，如果事务管理器出现故障，可能会导致整个系统无法正常工作。</span></li><li id="jxA9fnjPLsdPU9Ja2Hmum1"><div class="marker"></div><span class="inline-wrap"><b>性能瓶颈</b></span><span class="inline-wrap">：由于<span class="jill"></span>XA<span class="jill"></span>协议需要在所有参与者之间进行多次通信，这可能会导致系统的性能下降，特别是在大规模分布式系统中。</span></li><li id="DCtXvg2VihaMKUVciUTqF"><div class="marker"></div><span class="inline-wrap"><b>数据不一致的风险</b></span><span class="inline-wrap">：虽然<span class="jill"></span>XA<span class="jill"></span>协议旨在保证数据的一致性，但由于网络分区、超时等问题，仍然存在一定的数据不一致风险。</span></li><li id="xzQBkeUfq5ArSvQvgDzZzM"><div class="marker"></div><span class="inline-wrap"><b>实现复杂</b></span><span class="inline-wrap">：XA<span class="jill"></span>协议的实现相对复杂，需要对底层数据库进行深度定制和优化，这可能会增加开发和维护的难度。</span></li></ol><div id="v3D32YPeqeHiJMRoieTNgR" class="wolai-block wolai-text"><div></div></div><div id="7W7nqyiSeEexB4QwaqWU9Q" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="edWVXV7GbxGkTcE8uzJpDd" class="wolai-block"><span class="wolai-serial-number">14</span><span class="inline-wrap">请介绍一下分布式事务解决方案中的两阶段提交</span></h1><h2 id="qUG2L754ZeC1BmMtmErybx" class="wolai-block"><span class="wolai-serial-number">14.1</span><span class="inline-wrap">简介</span></h2><div id="55xa4d5QVELoXWBZCXUmRH" class="wolai-block wolai-text"><div><span class="inline-wrap">两阶段提交（Two-Phase Commit，2PC）是一种用于分布式系统中的事务管理协议，旨在确保多个参与者节点之间的数据一致性和完整性。该协议通过两个阶段的提交过程来实现这一目标，即准备阶段和提交阶段。</span></div></div><div id="4LNwnujncRCbqLZQCMrE2x" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="h27ji2eY4YY4cCHU691j1u" class="wolai-block"><span class="wolai-serial-number">14.2</span><span class="inline-wrap">结构</span></h2><div id="wUF93dAaodp7C8g3J8hFFu" class="wolai-block"><figure class="wolai-center" style="width: 754px; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="hEwGrRRRWgdSnsemPQxAkP" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dJKvPvJsh4YBVncKbRqY1g" class="wolai-block"><span class="wolai-serial-number">14.3</span><span class="inline-wrap">工作流程</span></h2><ol class="wolai-block"><li id="ozz5QhDjV7iVRygGDuHeNb"><div class="marker"></div><span class="inline-wrap"><b>准备阶段</b></span><span class="inline-wrap">：在这个阶段已经执行完<span class="jill"></span>SQL<span class="jill"></span>语句，事务协调者向所有参与者发送一个“准备”请求，询问它们是否准备好提交事务。每个参与者都会执行相应的操作来准备提交事务，并将结果返回给协调者。如果所有参与者都准备好了，那么协调者就会进入下一个阶段；否则，它会中止事务并回滚所有已经准备好的操作。</span></li><li id="kG4NX3h2MHboaTEePNdcMW"><div class="marker"></div><span class="inline-wrap"><b>提交阶段</b></span><span class="inline-wrap">：在这个阶段，如果所有参与者都准备好了，事务协调者会向所有参与者发送一个“提交”请求，要求它们正式提交事务。每个参与者都会执行相应的操作来提交事务，并将结果返回给协调者。如果所有参与者都成功提交了事务，那么整个事务就被认为是成功的；否则，它会中止事务并回滚所有已经提交的操作。</span></li></ol><div id="hmkcocWYkCp6EJVE1GuCJL" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pLSLZuSvRw73zvLNa9XTzh" class="wolai-block"><span class="wolai-serial-number">14.4</span><span class="inline-wrap">缺点</span></h2><ol class="wolai-block"><li id="aWQFRsBmxu3r9zbPNWU7aS"><div class="marker"></div><span class="inline-wrap"><b>单点故障</b></span><span class="inline-wrap">：在两阶段提交协议中，协调者是整个事务的关键节点。如果协调者出现故障，可能会导致整个事务无法完成，甚至可能导致数据不一致。因此，协调者的可靠性和稳定性对于整个系统至关重要。</span></li><li id="nzZnG6Y2U7Nq7Hw4Aprv3Y"><div class="marker"></div><span class="inline-wrap"><b>性能瓶颈</b></span><span class="inline-wrap">：两阶段提交协议需要在所有参与者之间进行多次通信，这可能会导致系统的性能下降，特别是在大规模分布式系统中。每次通信都需要时间，而且网络延迟和带宽限制也可能影响通信的效率。</span></li><li id="igjoyrHeaTD1ythgaUBvVU"><div class="marker"></div><span class="inline-wrap"><b>数据不一致的风险</b></span><span class="inline-wrap">：尽管两阶段提交协议旨在保证数据的一致性，但由于网络分区、超时等问题，仍然存在一定的数据不一致风险。例如，如果在某个参与者提交事务后，另一个参与者由于网络问题未能收到提交请求，就可能导致数据不一致。</span></li><li id="i51Rr8hGHPe3oktzYA23aU"><div class="marker"></div><span class="inline-wrap"><b>实现复杂</b></span><span class="inline-wrap">：两阶段提交协议的实现相对复杂，需要对底层数据库进行深度定制和优化。这可能需要大量的开发工作和专业知识，增加了实现的难度和成本。</span></li><li id="thiCWRPTY2aK4rn6GD39Db"><div class="marker"></div><span class="inline-wrap"><b>阻塞问题</b></span><span class="inline-wrap">：在两阶段提交过程中，如果某个参与者长时间未响应，可能会导致整个事务被阻塞。这会影响系统的吞吐量和响应时间，进而影响用户体验。</span></li><li id="hH7crWkJuVCeaac5GRYT52"><div class="marker"></div><span class="inline-wrap"><b>缺乏灵活性</b></span><span class="inline-wrap">：两阶段提交协议要求所有参与者都支持该协议，并且需要严格按照协议的规定执行操作。这在一定程度上限制了系统的灵活性和可扩展性。</span></li><li id="2qnH4za2UMJXnAQcb8NfEe"><div class="marker"></div><span class="inline-wrap"><b>资源占用高</b></span><span class="inline-wrap">：在两阶段提交过程中，需要占用大量的系统资源，如内存、CPU<span class="jill"></span>等。这可能会对系统的性能产生影响，特别是在资源有限的环境中。</span></li><li id="8Dfb4az3XU3VYNRwByv5JP"><div class="marker"></div><span class="inline-wrap"><b>难以处理复杂业务逻辑</b></span><span class="inline-wrap">：对于一些复杂的业务逻辑，两阶段提交协议可能难以满足需求。例如，如果业务逻辑涉及到多个子事务的嵌套或者需要动态调整参与者列表等情况，两阶段提交协议可能无法很好地支持。</span></li></ol><div id="5jDxQiEEnnVJZnzMXCnk8L" class="wolai-block wolai-text"><div></div></div><div id="cSjY6Rsdz1o2NTYjcuvF5c" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="vmK4MHNWjNMoLFdZQi4kNr" class="wolai-block"><span class="wolai-serial-number">15</span><span class="inline-wrap">请介绍一下分布式事务解决方案中的三阶段提交</span></h1><div id="i3oT3d9GxjagFicEN1qukj" class="wolai-block wolai-text"><div><span class="inline-wrap">三阶段提交（Three-Phase Commit, 3PC）是两阶段提交（2PC）的一种改进版本，旨在解决两阶段提交协议中的一些局限性，如单点故障和阻塞问题。三阶段提交通过引入一个额外的阶段——预提交阶段，来提高分布式事务的可靠性和性能。</span></div></div><h2 id="kBEcbqdPGe3tX1Xi4nZDDv" class="wolai-block"><span class="wolai-serial-number">15.1</span><span class="inline-wrap">一、三阶段提交的基本流程</span></h2><ol class="wolai-block"><li id="kTEAEHfN3fUW2gw9yj4P5p"><div class="marker"></div><span class="inline-wrap"><b>阶段一：CanCommit<span class="jill"></span>阶段</b></span><span class="inline-wrap">，协调者询问事务参与者，是否有能力完成此次事务。</span><ol class="wolai-block"><li id="5aoUbpStqZmkfyXeTaBwY5"><div class="marker"></div><span class="inline-wrap">如果都返回<span class="jill"></span>yes，则进入第二阶段</span></li><li id="nYUYGGmWzUaqPMgo8H7Qhx"><div class="marker"></div><span class="inline-wrap">有一个返回<span class="jill"></span>no<span class="jill"></span>或等待响应超时，则中断事务，并向所有参与者发送<span class="jill"></span>abort<span class="jill"></span>请求</span></li></ol></li><li id="4K4DEtgMFqikvngAPN2PNc"><div class="marker"></div><span class="inline-wrap"><b>阶段二：PreCommit<span class="jill"></span>阶段</b></span><span class="inline-wrap">，此时协调者会向所有的参与者发送<span class="jill"></span>PreCommit<span class="jill"></span>请求，参与者收到后开始执行<span class="jill"></span>SQL<span class="jill"></span>语句。参与者执行完<span class="jill"></span>SQL<span class="jill"></span>语句后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</span></li><li id="navXqZZtX8pKUpw4sfud2X"><div class="marker"></div><span class="inline-wrap"><b>阶段三：DoCommit<span class="jill"></span>阶段</b></span><span class="inline-wrap">， 在阶段二中如果所有的参与者节点都返回了<span class="jill"></span>Ack，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送&quot;doCommit&quot;请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的<span class="jill"></span>Ack<span class="jill"></span>消息后完成事务。相反，如果有一个参与者节点未完成<span class="jill"></span>PreCommit<span class="jill"></span>的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送<span class="jill"></span>abort<span class="jill"></span>请求，从而中断事务。</span></li></ol><h2 id="rzZKjPyjSohZLUBVjHBSAg" class="wolai-block"><span class="wolai-serial-number">15.2</span><span class="inline-wrap">二、三阶段提交的优点</span></h2><ol class="wolai-block"><li id="j1uMRi4Wc42jqa4cJw6ju4"><div class="marker"></div><span class="inline-wrap"><b>提高可靠性</b></span><span class="inline-wrap">：通过引入预提交阶段，三阶段提交可以在协调者出现故障时继续完成事务，从而提高了系统的可靠性。即使协调者在第二阶段出现问题，参与者仍然可以根据自己的状态来决定是否提交事务。</span></li><li id="ibntAFFaCHDkuw2twEtWVK"><div class="marker"></div><span class="inline-wrap"><b>减少阻塞</b></span><span class="inline-wrap">：三阶段提交允许参与者在预提交阶段超时时自行决定是否提交事务，从而减少了整个事务被阻塞的可能性。这有助于提高系统的性能和吞吐量。</span></li><li id="5roRJ3SJDrumawKTcueRoX"><div class="marker"></div><span class="inline-wrap"><b>灵活性高</b></span><span class="inline-wrap">：与两阶段提交相比，三阶段提交更加灵活，能够更好地处理复杂的业务逻辑和动态调整参与者列表的情况。这使得它更适用于实际的生产环境。</span></li></ol><h2 id="qWvhvRDytwbt7UFBpvAu7a" class="wolai-block"><span class="wolai-serial-number">15.3</span><span class="inline-wrap">三、三阶段提交的缺点</span></h2><ol class="wolai-block"><li id="5no5DA1zJKqdzRGUbVe4yV"><div class="marker"></div><span class="inline-wrap"><b>实现复杂</b></span><span class="inline-wrap">：三阶段提交的实现比两阶段提交更为复杂，需要对底层数据库进行深度定制和优化。这可能需要更多的开发工作和专业知识。</span></li><li id="gv2yuojooXPUvZbhSHBDSa"><div class="marker"></div><span class="inline-wrap"><b>性能开销</b></span><span class="inline-wrap">：虽然三阶段提交可以减少阻塞，但额外的预提交阶段可能会增加系统的通信开销和延迟。特别是在网络环境较差的情况下，这种开销可能会更加明显。</span></li><li id="eKfLa7Jz74kM5VgfiZ3eAu"><div class="marker"></div><span class="inline-wrap"><b>数据不一致的风险仍然存在</b></span><span class="inline-wrap">：尽管三阶段提交提高了系统的可靠性，但由于网络分区、超时等问题，仍然存在一定的数据不一致风险。因此，在使用三阶段提交时仍然需要谨慎处理各种异常情况。</span></li><li id="mYUupvj2yeUX5TfkFmUNBS"><div class="marker"></div><span class="inline-wrap"><b>资源占用高</b></span><span class="inline-wrap">：在三阶段提交过程中，需要占用大量的系统资源，如内存、CPU<span class="jill"></span>等。这可能会对系统的性能产生影响，特别是在资源有限的环境中。</span></li><li id="7sKGS1gvkpGASpwfzpUe9s"><div class="marker"></div><span class="inline-wrap"><b>难以处理复杂业务逻辑</b></span><span class="inline-wrap">：对于一些复杂的业务逻辑，三阶段提交可能难以满足需求。例如，如果业务逻辑涉及到多个子事务的嵌套或者需要动态调整参与者列表等情况，三阶段提交可能无法很好地支持。</span></li><li id="b5uptFDxcTSexUu7sUotW8"><div class="marker"></div><span class="inline-wrap"><b>缺乏标准化</b></span><span class="inline-wrap">：目前，三阶段提交并没有一个统一的标准或规范，不同的数据库和系统可能有不同的实现方式。这可能导致在不同系统之间进行集成时出现兼容性问题。</span></li><li id="yoBwf25kfQbXREc2U4CsZ"><div class="marker"></div><span class="inline-wrap"><b>维护成本高</b></span><span class="inline-wrap">：由于三阶段提交的复杂性，其维护成本也相对较高。开发者需要投入更多的时间和精力来确保系统的稳定性和可靠性。</span></li><li id="gs7AADQVnyh6SuxPvpEhBL"><div class="marker"></div><span class="inline-wrap"><b>适用场景有限</b></span><span class="inline-wrap">：虽然三阶段提交可以提高系统的可靠性和性能，但它并不适合所有的分布式事务场景。在某些情况下，可能需要结合其他技术或策略来实现更好的效果。</span></li></ol><div id="rvfdpnxtg8Ky7LnLzytXdW" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，三阶段提交是两阶段提交的一种改进方案，通过引入预提交阶段来提高分布式事务的可靠性和性能。然而，它也带来了实现复杂、性能开销和数据不一致风险等问题。因此，在使用三阶段提交时需要根据具体的业务需求和系统架构进行权衡和选择。</span></div></div><div id="5RyYgLkNREREUSir5FKDJZ" class="wolai-block wolai-text"><div></div></div><div id="4GCuwdqJLEnCg6qmjCLmFv" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4FeieKN7qEK7PmKydK2B2y" class="wolai-block"><span class="wolai-serial-number">16</span><span class="inline-wrap">TCC（补偿事务）</span></h1><div id="2mxv3cRcgi6uLqvxVjDVBY" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC（Try-Confirm-Cancel）补偿事务是一种分布式事务解决方案，它通过三个阶段来保证分布式系统中的操作成功完成或在失败时进行补偿。以下是对<span class="jill"></span>TCC<span class="jill"></span>补偿事务的简要介绍：</span></div></div><ol class="wolai-block"><li id="iC5sXzS2nri3H8zZwAxZjm"><div class="marker"></div><span class="inline-wrap"><b>概述</b></span><ul class="wolai-block"><li id="bFRuZ4Bgn8uRBzEsQVY8nf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">TCC<span class="jill"></span>补偿事务模式由<span class="jill"></span>Atomikos<span class="jill"></span>公司提出，并在其商业版本事务管理器<span class="jill"></span>ExtremeTransactions<span class="jill"></span>中实现了该方案。</span></li><li id="2mBNPTHG7FV2pKDD33Zg4T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">这种模式要求应用的每个服务提供<span class="jill"></span>try、confirm、cancel<span class="jill"></span>三个接口，通过对资源的预留(提供中间态，如账户状态、冻结金额等)，尽早释放对资源的加锁。</span></li></ul></li><li id="mc8DWRYy1C2gnCdfoF2Mw4"><div class="marker"></div><span class="inline-wrap"><b>工作流程</b></span><ul class="wolai-block"><li id="9NQYMCMRzBLWk6nGqFsi2T"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Try<span class="jill"></span>阶段</b></span><span class="inline-wrap">：尝试执行业务操作，完成所有业务检查并预留必要的业务资源。如果<span class="jill"></span>Try<span class="jill"></span>阶段成功，进入<span class="jill"></span>Confirm<span class="jill"></span>阶段；否则，执行<span class="jill"></span>Cancel<span class="jill"></span>阶段。</span></li><li id="3j18CvhmnwchCpFfU1BU7h"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Confirm<span class="jill"></span>阶段</b></span><span class="inline-wrap">：确认执行业务操作，使用<span class="jill"></span>Try<span class="jill"></span>阶段预留的业务资源，并且满足幂等性。此阶段通常认为不会出错，但若出错需引入重试机制或人工处理。</span></li><li id="85y1sAgQtGD1p38tVVTXVS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>Cancel<span class="jill"></span>阶段</b></span><span class="inline-wrap">：取消执行业务操作，释放<span class="jill"></span>Try<span class="jill"></span>阶段预留的业务资源，并撤销之前的操作。Cancel<span class="jill"></span>阶段同样需要满足幂等性，以便在出现异常时能够重试。</span></li></ul></li><li id="8CFn9W8hx6AReFtwUQHc4C"><div class="marker"></div><span class="inline-wrap"><b>优点</b></span><ul class="wolai-block"><li id="5xVHNt1W2iLiVdz4SDAsmN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高可靠性和一致性</b></span><span class="inline-wrap">：通过在事务执行过程中引入确认和取消机制，确保了即使在出现错误或异常情况下，系统状态仍然保持一致。</span></li><li id="5gyWrSrWPKMZxqNz3YrM1z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>灵活控制事务边界</b></span><span class="inline-wrap">：TCC<span class="jill"></span>模式通过明确的三个阶段来控制分布式事务的边界，可以灵活地控制事务的粒度和范围。</span></li><li id="u3MYHK1kSAwXJfVxdEruB5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>提高系统的并发性能</b></span><span class="inline-wrap">：TCC<span class="jill"></span>模式可以将事务的过程拆分成多个阶段，每个阶段可以并发执行，从而提高系统的并发性能和吞吐量。</span></li><li id="dttPM3sihJ87kUjnu6jEm6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>降低分布式事务的复杂度</b></span><span class="inline-wrap">：TCC<span class="jill"></span>模式将分布式事务的复杂度降低到可控的范围内，便于管理和维护。</span></li></ul></li><li id="mAbNuVkBmf65F4qhX9SCE5"><div class="marker"></div><span class="inline-wrap"><b>缺点</b></span><ul class="wolai-block"><li id="ffz3NGYiZKv2ntTvYLbkfi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>实现复杂度较高</b></span><span class="inline-wrap">：需要对业务逻辑进行深入的理解和设计，以实现<span class="jill"></span>try、confirm、cancel<span class="jill"></span>三个阶段的业务逻辑。</span></li><li id="5LsvyZauAXJYG8SP6hkyAN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>可能存在性能问题</b></span><span class="inline-wrap">：多次网络通信和状态转换可能会对系统的性能产生影响，尤其是在高并发场景下。</span></li><li id="aTs58c9HkMt2xQBjic3saW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>事务边界难以确定</b></span><span class="inline-wrap">：在某些场景下，事务的边界难以确定，容易出现事务处理失败的情况。</span></li><li id="7zPCZnQi9PCM3sDrt1uc27"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>补偿操作复杂性高</b></span><span class="inline-wrap">：需要对每个参与者进行相应的补偿操作，补偿操作的复杂性取决于业务场景和实现方式。</span></li></ul></li></ol><div id="93N8ctfAHVFhT9issLzb59" class="wolai-block wolai-text"><div><span class="inline-wrap">综上所述，TCC<span class="jill"></span>补偿事务是一种有效的分布式事务解决方案，它提供了更高的可靠性和一致性，但也需要更多的系统资源和处理时间。在实施这种机制时，需要权衡其优缺点，并确保它适合特定应用的需求。</span></div></div><div id="62HrKkqhMXVYsLW2o7PQTd" class="wolai-block wolai-text"><div></div></div><div id="bQpZK5kmyonztv3xKdcAkL" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="iqUodAW1p3Cxi233siSe1p" class="wolai-block"><span class="wolai-serial-number">17</span><span class="inline-wrap">如何使用消息队列实现分布式事事务？</span></h1><div id="jPLc1DJtNAogD5TuegEvbn" class="wolai-block wolai-text"><div><span class="inline-wrap">使用消息队列实现分布式事务的关键在于</span><span class="inline-wrap"><b>通过消息的异步处理和事务性控制，来保证在分布式系统中各个服务之间的数据一致性和完整性</b></span><span class="inline-wrap">。以下是使用消息队列实现分布式事务的具体步骤：</span></div></div><ol class="wolai-block"><li id="247gccwwnH9TqBn1Kisr9K"><div class="marker"></div><span class="inline-wrap"><b>开启事务</b></span><span class="inline-wrap">：生产者（如订单系统）开始一个新的事务，并在消息队列上发送一个“半消息”。这个半消息包含了完整的消息内容，但在事务提交之前，对于消费者来说是不可见的。</span></li><li id="qtbkqtt4eEm5pAao6vsKS5"><div class="marker"></div><span class="inline-wrap"><b>执行本地事务</b></span><span class="inline-wrap">：生产者执行本地数据库事务操作，例如在订单库中插入一条订单记录。</span></li><li id="5gBoVK85nDBtLJHSnAuXj6"><div class="marker"></div><span class="inline-wrap"><b>提交或回滚事务</b></span><span class="inline-wrap">：根据本地事务的执行结果，生产者决定是提交还是回滚事务。如果本地事务执行成功，则向消息队列发送提交事务的消息，此时购物车系统可以消费到这条消息，并继续后续的流程；如果本地事务执行失败，则向消息队列发送回滚事务的消息，购物车系统将不会收到这条消息。</span></li><li id="7FNoxLGLDpuR9XpnzEMGVv"><div class="marker"></div><span class="inline-wrap"><b>处理异常情况</b></span><span class="inline-wrap">：如果在提交事务消息时发生网络异常或其他问题，Kafka<span class="jill"></span>会直接抛出异常，让用户自行处理。在这种情况下，可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。RocketMQ<span class="jill"></span>则提供了事务反查机制来解决这一问题。当<span class="jill"></span>Producer<span class="jill"></span>在提交或回滚事务消息时发生网络异常，Broker<span class="jill"></span>没有收到请求时，它会定期去<span class="jill"></span>Producer<span class="jill"></span>上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或回滚这个事务。</span></li></ol><div id="pXmRJWkyjab3eo1rtVXjgq" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，使用消息队列实现分布式事务是一种有效的解决方案，它能够在保证数据一致性和完整性的同时，提高系统的可用性和可扩展性。然而，需要注意的是，不同的消息队列产品可能具有不同的特性和限制，因此在实际应用中需要根据具体需求选择合适的消息队列产品和技术方案。</span></div></div><div id="aQouzvk9AQXGVaxviFZqCX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="kYnTFvkg65oL6NRuEav215" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cLpWvTSZGkdNSYCHRwADiB" class="wolai-block"><span class="wolai-serial-number">18</span><span class="inline-wrap">如何使用本地消息表的方式实现分布式事务？</span></h1><div id="tLigsJST8VQ7D1ZxMvUR7n" class="wolai-block wolai-text"><div><span class="inline-wrap">使用本地消息表实现分布式事务，是一种常见的解决方案，主要用于在分布式系统中保证数据的一致性和可靠性。这种方法的核心思想是将业务操作和消息记录放在同一个本地事务中，确保它们要么同时成功，要么同时失败，然后通过一个独立的消息调度器异步地将消息发送到消息队列中，从而实现跨服务的事务一致性。以下是使用本地消息表实现分布式事务的一般步骤：</span></div></div><ol class="wolai-block"><li id="9mXGoKJMbJhEF1z3Bt46fv"><div class="marker"></div><span class="inline-wrap"><b>创建本地消息表</b></span><span class="inline-wrap">：在数据库中创建一个本地消息表，用于存储待发送的消息以及消息的发送状态和相关信息。表结构可以包含字段如</span><span class="inline-wrap"><code>message_id</code></span><span class="inline-wrap">（消息唯一标识）、</span><span class="inline-wrap"><code>message_body</code></span><span class="inline-wrap">（消息内容）、</span><span class="inline-wrap"><code>status</code></span><span class="inline-wrap">（消息状态，如待发送、已发送等）和</span><span class="inline-wrap"><code>create_time</code></span><span class="inline-wrap">（消息创建时间）。</span></li><li id="tHyKzymUJGcd7qKVuFTD8g"><div class="marker"></div><span class="inline-wrap"><b>业务处理与消息记录</b></span><span class="inline-wrap">：在业务逻辑中，当需要发送消息时，首先将消息插入到本地消息表中，设置状态为待发送。然后执行业务逻辑，并将业务变更信息与消息记录插入操作放在同一个本地事务中。</span></li><li id="tro75jrp3UL9VgMo1d2r2g"><div class="marker"></div><span class="inline-wrap"><b>消息发送</b></span><span class="inline-wrap">：创建一个后台线程或定时任务，定时扫描本地消息表中状态为待发送的消息，并将这些消息发送到消息队列。在成功发送到消息队列后，将消息表中对应的状态修改为已发送。</span></li><li id="rEt56pi6tHKfLzLWUtHEjN"><div class="marker"></div><span class="inline-wrap"><b>消息消费</b></span><span class="inline-wrap">：其他服务从消息队列中消费消息，并执行相应的业务逻辑处理。此步骤必须保证幂等性，即多次消费相同的消息不会导致数据不一致。</span></li><li id="ggNGTMGXhe9xLWvFAkGV3M"><div class="marker"></div><span class="inline-wrap"><b>消息状态确认</b></span><span class="inline-wrap">：当消息消费完成后，进行状态变更。如果消费失败，需要根据失败原因进行重试或人工处理。</span></li></ol><div id="wBuVwUwSRacG5vcf4udBGA" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，使用本地消息表实现分布式事务的优点在于简单易实现、高性能和高可靠性。然而，它也有一些不足之处，如开发复杂度较高、可能存在延迟性问题以及需要确保消息的幂等性。因此，在实际应用中，需要根据具体需求进行权衡和优化。</span></div></div><div id="rdLr2CeYPxn8SYacRaFwmr" class="wolai-block wolai-text"><div></div></div><div id="hWjBweWv8bRiyzhySdQnEK" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="cotwWTdAxSR3hsgbT6w4PK" class="wolai-block"><span class="wolai-serial-number">19</span><span class="inline-wrap">你了解哪些分布式事事务的解决方案？</span></h1><div id="xu2451Ng8fXrw5SmS5gqHc" class="wolai-block wolai-text"><div><span class="inline-wrap">分布式事务的实现方案主要包括</span><span class="inline-wrap"><b>基于可靠消息服务、最大努力通知、TX-LCN、X/Open DTP<span class="jill"></span>模型、阿里<span class="jill"></span>DTS、华为<span class="jill"></span>ServiceComb<span class="jill"></span>和阿里<span class="jill"></span>GTS<span class="jill"></span>等等</b></span><span class="inline-wrap">。以下是对这七种方案的具体介绍：</span></div></div><ol class="wolai-block"><li id="nCzBvNMKscG7Fm6w7WNFei"><div class="marker"></div><span class="inline-wrap"><b>基于可靠消息服务</b></span><span class="inline-wrap">：基于可靠消息服务的分布式事务方案通过对发送到消息中间件的消息进行“两阶段提交”，即先提交，执行完本地事务后再确认消息，给事务的回滚提供了可能。该方案能保证事务的最终原子性和持久性，但无法保证一致性和隔离性。适用于对业务的实时一致性以及事务的隔离性要求都不高的内部系统。</span></li><li id="nBMrho8ZuE8NkMMLE5DYgf"><div class="marker"></div><span class="inline-wrap"><b>最大努力通知</b></span><span class="inline-wrap">：最大努力通知方案依赖于消息中间件，不需要保证消息的可靠性，而是依靠额外的校对系统或者报警系统来保障事务的正确完成。该方案同样只能保证事务的最终原子性和持久性，无法保证一致性和隔离性。适用于对实时一致性和事务隔离性要求不高的内部系统或跨企业的业务活动中。</span></li><li id="9p9BnoGQk2Qt487KZRtwQ6"><div class="marker"></div><span class="inline-wrap"><b>TX-LCN</b></span><span class="inline-wrap">：TX-LCN<span class="jill"></span>的核心原理是通过协调本地事务来实现分布式事务，分布式事务的实现依赖于本地事务。如果本地事务都能保证<span class="jill"></span>ACID<span class="jill"></span>特性，那么基于<span class="jill"></span>LCN<span class="jill"></span>的分布式事务也能满足<span class="jill"></span>ACID。并发性能可能会降低，因为需要等待所有参与方的响应。</span></li><li id="4sMGwaCjN4B7mjwYYMYGos"><div class="marker"></div><span class="inline-wrap"><b>X/Open DTP<span class="jill"></span>模型</b></span><span class="inline-wrap">：X/Open DTP<span class="jill"></span>模型是一种严格的分布式事务模型，遵循<span class="jill"></span>XA<span class="jill"></span>规范，通过两阶段提交实现事务的全局一致性。这种方案在实际应用中较为复杂，且对性能有一定影响。</span></li><li id="otMFB7iHn5TriDGsDeSyPM"><div class="marker"></div><span class="inline-wrap"><b>阿里<span class="jill"></span>DTS</b></span><span class="inline-wrap">：阿里<span class="jill"></span>DTS<span class="jill"></span>是基于<span class="jill"></span>TCC（Try-Confirm-Cancel）模型的分布式事务解决方案，通过补偿机制确保事务的最终一致性。适用于对数据一致性要求极高的场景，如金融交易等。</span></li><li id="iWmZ6cCUwhgKMNMWjgjhfP"><div class="marker"></div><span class="inline-wrap"><b>华为<span class="jill"></span>ServiceComb</b></span><span class="inline-wrap">：华为<span class="jill"></span>ServiceComb<span class="jill"></span>是对<span class="jill"></span>SAGA<span class="jill"></span>模式的一种实现，强调服务的自治性和灵活性，通过一系列本地事务和补偿事务的组合来实现分布式事务。适用于微服务架构下的分布式事务处理。</span></li><li id="hTbbm4RNg6p9kpW9R2MHLk"><div class="marker"></div><span class="inline-wrap"><b>阿里<span class="jill"></span>GTS</b></span><span class="inline-wrap">：阿里<span class="jill"></span>GTS<span class="jill"></span>是开源产品<span class="jill"></span>Seata/Fescar<span class="jill"></span>的实现，对<span class="jill"></span>XA<span class="jill"></span>协议进行了改进后的分布式事务解决方案，支持多种事务模式，包括<span class="jill"></span>AT、TCC、SAGA<span class="jill"></span>等。适用于各种复杂的分布式事务场景，特别是在微服务架构下。</span></li></ol><div id="ik7hexDGFE53y9jae9jc4S" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，每种方案都有其特定的适用场景和优缺点，选择哪种方案应根据具体的业务需求和技术条件来决定。</span></div></div><div id="k4z5f2RxPu6XjdjJjun98o" class="wolai-block wolai-text"><div></div></div><div id="tQz8PWagqg77sP1SXppijj" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="ahumTkzgQy16v1QCdqZwwF" class="wolai-block"><span class="wolai-serial-number">20</span><span class="inline-wrap">什么是<span class="jill"></span>TCC，和<span class="jill"></span>2PC<span class="jill"></span>有什么区别？</span></h1><div id="vEhpW961Wddi4mcctu2FaY" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC（Try-Confirm-Cancel）和<span class="jill"></span>2PC（Two-Phase Commit）都是用于处理分布式事务的协议，但它们在处理方式和适用场景上存在一些区别。</span></div></div><div id="97BDAMyAnLUAgQueY3amtN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="qojKr5HP1BXjjWHsJSpeZL" class="wolai-block"><span class="wolai-serial-number">20.1</span><span class="inline-wrap">TCC (Try-Confirm-Cancel)</span></h2><div id="4X9NELn6VmzSdfMWag1ZPP" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>是一种分布式事务处理方法，它将事务拆分为三个阶段：尝试（Try）、确认（Confirm）和取消（Cancel）。每个阶段都有相应的操作。在尝试阶段，参与者尝试执行事务操作，检查是否满足执行条件。如果所有参与者的尝试都成功，进入确认阶段，参与者确认执行事务。如果任何一个参与者的尝试失败或确认阶段失败，将进入取消阶段，执行事务的补偿操作来恢复系统到一致状态。TCC<span class="jill"></span>注重于事务的补偿机制，以确保数据的一致性。</span></div></div><div id="9YhRVVnVCMLNQBy9EuHZe5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="QTrzTMqgBcVBkk7fhHV4f" class="wolai-block"><span class="wolai-serial-number">20.2</span><span class="inline-wrap">2PC (Two-Phase Commit)</span></h2><div id="v5StT1JvUgrDyHDSz79xDj" class="wolai-block wolai-text"><div><span class="inline-wrap">2PC<span class="jill"></span>是另一种分布式事务处理协议，它在全局协调器和多个参与者之间进行通信。它有两个阶段：准备（Prepare）和提交（Commit）。在准备阶段，全局协调器将询问所有参与者是否可以执行事务，参与者会回复“可以”或“不可以”。如果所有参与者都回复“可以”，则进入提交阶段，在此阶段全局协调器通知所有参与者提交事务。如果任何一个参与者回复“不可以”，全局协调器会通知所有参与者中止事务。2PC<span class="jill"></span>依赖于中心化的协调器，其缺点包括单点故障和阻塞的可能性。</span></div></div><div id="vrS72UZ7Nrp5V5HSNi177A" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="73Te3pgZZRg4d49za8o56e" class="wolai-block"><span class="wolai-serial-number">20.3</span><span class="inline-wrap">区别</span></h2><h3 id="oBmFaBkVWAjh3d8JHGpQs1" class="wolai-block"><span class="wolai-serial-number">20.3.1</span><span class="inline-wrap">处理方式</span></h3><div id="3jADZzhXeioaHmUm4qAAKc" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>采用尝试-确认-取消的模式，强调补偿机制，而<span class="jill"></span>2PC<span class="jill"></span>采用两阶段提交的方式，依赖全局协调器来决定提交或中止事务。</span></div></div><div id="fd96sRWEbM3xRvHQE2gBHS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="x237HawHEuBLNsg7BySigf" class="wolai-block"><span class="wolai-serial-number">20.3.2</span><span class="inline-wrap">灵活性</span></h3><div id="piAtya2NxHWhSQMCLVXfMb" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>相对更加灵活，因为它允许开发人员在尝试和确认阶段之间插入补偿逻辑。2PC<span class="jill"></span>较为严格，需要参与者在准备阶段做出确定性的回应。</span></div></div><div id="97NyCBQWYCbwwmhYyovDGk" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="8rTYWS2CQpEhqgqzve1KDa" class="wolai-block"><span class="wolai-serial-number">20.3.3</span><span class="inline-wrap">复杂性和性能</span></h3><div id="uED9q8i1hyJre2Yh5zyXbt" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>通常比<span class="jill"></span>2PC<span class="jill"></span>更适用于高并发环境，因为它的操作相对较轻，而<span class="jill"></span>2PC<span class="jill"></span>的中心化协调可能导致性能瓶颈。</span></div></div><div id="sXKLVSUdA5guvcpJSax7Ye" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="kvb1vvZ7wyeex4PtGJiJRC" class="wolai-block"><span class="wolai-serial-number">20.3.4</span><span class="inline-wrap">可用性</span></h3><div id="igWQivJkxiPL8fahmZDE9T" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>通常在局部事务级别上具有更好的可用性，因为每个参与者可以独立决定是否尝试事务。在选择<span class="jill"></span>TCC<span class="jill"></span>还是<span class="jill"></span>2PC<span class="jill"></span>时，需要根据系统的需求、复杂性和可靠性等因素进行权衡。</span></div></div><div id="kH9yaEsacFxX2rtxAcr66e" class="wolai-block wolai-text"><div></div></div><div id="rHUMZsEy8WYC632TYWLFLd" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="aUdNg5w2PJCQ57Mei9mveJ" class="wolai-block"><span class="wolai-serial-number">21</span><span class="inline-wrap">什么是柔性事务？</span></h1><h2 id="w6B3yUQ5CxBSZ5RoQdPtUQ" class="wolai-block"><span class="wolai-serial-number">21.1</span><span class="inline-wrap">概念</span></h2><div id="rc3QjumA2TV8Tus7ZsBCQK" class="wolai-block wolai-text"><div><span class="inline-wrap">柔性事务是相对于刚性事务来说的。刚性事务要求严格遵守<span class="jill"></span>ACID，而柔性事务则是基于<span class="jill"></span>BASE<span class="jill"></span>定理，满足基本可用和最终一致性。</span></div></div><div id="amVQ2hY4N72CbK9DCde7iD" class="wolai-block wolai-text"><div><span class="inline-wrap">从实际情况来看，柔性事务可以说都是分布式事务，各自的名称只是因为侧重的角度不同：</span></div></div><ul class="wolai-block"><li id="sitRSE6JULfDiZwDa9QwKb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分布式事务：从结构性角度来看事务问题</span></li><li id="eaNA1UMP6RccXBr6ffH9MQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">柔性事务：从规则遵照执行的程度来看事务问题</span></li></ul><div id="tYb1dmkZQtc4HAHE9wNtgV" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fUBRnK2q3k4wc96eR6ibkr" class="wolai-block"><span class="wolai-serial-number">21.2</span><span class="inline-wrap">细节对比</span></h2><div id="udzHskpiw4qqPHyXZEBgWC" class="wolai-block wolai-text"><div><span class="inline-wrap">刚性事务严格遵守的<span class="jill"></span>ACID<span class="jill"></span>属性，在柔性事务中：</span></div></div><ul class="wolai-block"><li id="9NgtpCkymu1CZFxh6SV1hf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原子性（A）：严格遵守</span></li><li id="d3dTEDhn3wm5arrpMZDRyd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一致性（C）：事务执行过程中放宽一致性要求，事务执行完成后要求严格遵守</span></li><li id="iiSrssdDS9XJZq6prvQ62G"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">隔离性（I）：要求并行事务之间互不干扰，事务执行过程中结果可见性允许安全放宽</span></li><li id="jc4omAEH8E9KWvnKihuMY9"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">持久性（D）：严格遵守</span></li></ul><div id="o8TDG4rxX6Acd4pkcFVM67" class="wolai-block wolai-text"><div></div></div><div id="hTp6NgKpeEdLjqAkbYkw8L" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="wHMAbGmv6pddTqBv8yLJFj" class="wolai-block"><span class="wolai-serial-number">22</span><span class="inline-wrap">什么是<span class="jill"></span>Seata？他有哪几种模式？</span></h1><div id="5Mctv5VPeDyHqdktNsedTJ" class="wolai-block wolai-text"><div><span class="inline-wrap">Seata<span class="jill"></span>是由阿里巴巴开源的一款分布式事务解决方案落地产品，旨在解决分布式系统中的数据一致性问题。</span></div></div><div id="7zSciSrEQMQkpp1PWak2hY" class="wolai-block wolai-text"><div><span class="inline-wrap">Seata<span class="jill"></span>提供了一套事务管理的解决方案，支持对分布式事务进行管理和协调。</span></div></div><div id="dyy96RunJ4962RQmYy73uZ" class="wolai-block wolai-text"><div><span class="inline-wrap">Seata<span class="jill"></span>有以下三种常见的模式：</span></div></div><div id="ne2SkUMXj2Btek58Voihc6" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="fTcR7knFZ94Q4cEodJRGBd" class="wolai-block"><span class="wolai-serial-number">22.1</span><span class="inline-wrap">AT<span class="jill"></span>模式（Automatic Transaction）</span></h2><div id="7JSxnxwf4vYwT9QD3D9Yed" class="wolai-block wolai-text"><div><span class="inline-wrap">AT<span class="jill"></span>模式是<span class="jill"></span>Seata<span class="jill"></span>最常用的模式，它基于数据库的本地事务实现分布式事务的一致性。</span></div></div><div id="tmGBe3G6FymPXeoFtoqsuB" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>AT<span class="jill"></span>模式下，Seata<span class="jill"></span>通过拦截数据访问层的<span class="jill"></span>SQL<span class="jill"></span>操作，并将这些操作封装在一个全局事务中。</span></div></div><div id="k4K7Zau3G3g9WfGjt126b1" class="wolai-block wolai-text"><div><span class="inline-wrap">Seata<span class="jill"></span>通过将事务信息存储在全局事务上下文中，并协调各个分支事务的提交或回滚来实现式事务的一致性。</span></div></div><div id="tf5XB7VoDyziDoWBAg32e3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="2BTDQXUSuxE7R9K5UgXEpH" class="wolai-block"><span class="wolai-serial-number">22.2</span><span class="inline-wrap">TCC<span class="jill"></span>模式（Try-Confirm-Cancel）</span></h2><div id="rQxNuSQC9qJU28hQguHfhh" class="wolai-block wolai-text"><div><span class="inline-wrap">TCC<span class="jill"></span>模式是一种补偿型的分布式事务模式。</span></div></div><div id="ttegxNwiY9UAL6pLVmv2WU" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>TCC<span class="jill"></span>模式下，Seata<span class="jill"></span>通过定义三个阶段的操作：Try<span class="jill"></span>阶段尝试执行业务操作、Confirm<span class="jill"></span>阶段确认执行操作、Cancel<span class="jill"></span>阶段撤销执行操作。</span></div></div><div id="dP2W5CLSeoEerEgT3KydRP" class="wolai-block wolai-text"><div><span class="inline-wrap">Seata<span class="jill"></span>通过补偿机制来保证分布式事务的一致性，即使在异常情况下也能够进行回滚或补偿。  </span></div></div><div id="wneu1smBDTnUY4JiatmGCm" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="asW68PpNLPM4Z5P94eVkJg" class="wolai-block"><span class="wolai-serial-number">22.3</span><span class="inline-wrap">Saga<span class="jill"></span>模式</span></h2><div id="hNqSTqjZsXLn1bRPr1CJ55" class="wolai-block wolai-text"><div><span class="inline-wrap">Saga<span class="jill"></span>模式是一种长事务的分布式事务模式，通过将业务操作分解为一系列的子事务来实现。</span></div></div><div id="oK6D7oCYsN4tqy8Pdecmux" class="wolai-block wolai-text"><div><span class="inline-wrap">每个子事务都有自己的回滚操作，从而实现了分布式事务的逐步提交和回滚。Saga<span class="jill"></span>模式通过异步消息和补偿机制来实现事务的提交和回滚。</span></div></div><div id="ewBCjQ1ASpe85tNFjP7rct" class="wolai-block wolai-text"><div><span class="inline-wrap">这三种模式在不同的场景下可以根据实际需求进行选择和组合使用，以满足分布式系统的事务管理需求。</span></div></div><div id="fmAqfgUZMBevaT2BhRme14" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="4zNEXS13kjEEP3jnjeWe2N" class="wolai-block"><span class="wolai-serial-number">23</span><span class="inline-wrap">如何实现接口的幂等性</span></h1><h2 id="2g3S32yfoNfuuDVnoSqTJM" class="wolai-block"><span class="wolai-serial-number">23.1</span><span class="inline-wrap">幂等性要应对的问题</span></h2><div id="e4DNifQ4WsR2StKonGYLGE" class="wolai-block wolai-text"><div><span class="inline-wrap">在服务调用过程中，网络传输存在不确定性：</span></div></div><div id="rPx2LWTJd1ZaQSpLaSxGYq" class="wolai-block"><figure class="wolai-center" style="width: 606.6666666666666px; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="5rCDVGKwFrRPCv89hxW6Kw" class="wolai-block wolai-text"><div><span class="inline-wrap">当服务器消费端发出请求后，没有接收到服务提供端的响应，那么此时存在如下可能：</span></div></div><ul class="wolai-block"><li id="cA4k7LTHPzh5T3euebEpAg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">网络传输故障，服务提供端没有接收到请求</span></li><li id="nrppSTJ3TVV2Krc3FmBmXs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">服务提供端接收到了请求，且处理成功，但由于网络传输故障导致服务消费端没有接收到响应</span></li><li id="hT9WrNok2RqMrR9h69e6CH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">服务提供端接收到了请求，但处理失败导致没有返回响应</span></li></ul><div id="txzMzAGduQnQhZaxkWhWQX" class="wolai-block wolai-text"><div><span class="inline-wrap">面对这种情况，作为服务消费端不知道发生了什么，只能选择『多次重试』——同一个请求（同一个业务数据）多次重复发送，期望至少能成功一次</span></div></div><div id="d1F5jWHYxaQLLSFmBuPHLo" class="wolai-block wolai-text"><div><span class="inline-wrap">但是这样就会导致服务提供端多次重复接收到同一个请求，进而有可能导致计算完成后业务数据错误</span></div></div><div id="mvNd6TDVqznvM6iDMCxuty" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="dkM913dSnfbRFajN11Z8nR" class="wolai-block"><span class="wolai-serial-number">23.2</span><span class="inline-wrap">幂等性概念</span></h2><div id="sVFcf5Na6RBTH4zjkhsZhp" class="wolai-block wolai-text"><div><span class="inline-wrap">为了应对上述问题，为了让服务提供端保护业务数据不被多次重试请求破坏，提出幂等性概念：如果一个接口调用一次和调用多次对系统和系统中的数据的影响是一样的，那么就说这个接口满足幂等性</span></div></div><div id="6jRmhj5tt7iCoZ3fVinoGx" class="wolai-block wolai-text"><div><span class="inline-wrap">有了这个标准，我们就可以说：只有对满足幂等性的接口才能多次重试调用</span></div></div><div id="sNG6ZhB8vU9MRs7zjWP2Cs" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="5z6Z1QKMtai9U6LFhZBFSy" class="wolai-block"><span class="wolai-serial-number">23.3</span><span class="inline-wrap">幂等性实现方案：SQL<span class="jill"></span>层</span></h2><h3 id="oQxa3UcrRdeszSje4Ld2ww" class="wolai-block"><span class="wolai-serial-number">23.3.1</span><span class="inline-wrap">天然满足幂等性的<span class="jill"></span>SQL<span class="jill"></span>语句</span></h3><ul class="wolai-block"><li id="tf7HBA6niNGpwJRCFD58Kv"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">所有查询语句天然满足幂等性</span></li><li id="uRZiuU1h1vEkXdWpCwgUCf"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于指定<span class="jill"></span>id<span class="jill"></span>的删除语句：delete from xxx where id=&#39;固定值&#39;</span></li><li id="rzRQELtVXY5SgwozvEToPG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基于指定<span class="jill"></span>id<span class="jill"></span>的自适应增改：</span><ul class="wolai-block"><li id="eERCD9mXL63fEPPg7Na9YK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当<span class="jill"></span>id<span class="jill"></span>对应的数据不存在时：执行<span class="jill"></span>insert<span class="jill"></span>操作</span></li><li id="reQbsW6uQKpbP7syCAx29R"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当<span class="jill"></span>id<span class="jill"></span>对应的数据已存在时：执行<span class="jill"></span>update<span class="jill"></span>操作</span></li></ul></li></ul><div id="4h7irPsKuZY7rNPbPdKjhS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="atoiPU1oFvY33bMFtbazCp" class="wolai-block"><span class="wolai-serial-number">23.3.2</span><span class="inline-wrap">数据库悲观锁</span></h3><div id="g5d14WCwKWv4zdrxVvxUBx" class="wolai-block wolai-text"><div><span class="inline-wrap">数据库悲观锁是对并发操作上锁，而不是对数据上锁，所以悲观锁存在期间内只能有一个事务执行操作成功，此时可以保证幂等性；</span></div></div><div id="gLcohT2sWmM8TXeZyjxxW3" class="wolai-block"><figure class="wolai-center" style="width: 144px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><div id="uZQYmfDC7c8LKEQBBZuFqN" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="eVRFqJcnFTk1JeHybuyHzD" class="wolai-block wolai-text"><div><span class="inline-wrap">如果两个事务<span class="jill"></span>A<span class="jill"></span>和<span class="jill"></span>B，A<span class="jill"></span>事务提交之后再执行<span class="jill"></span>B<span class="jill"></span>事务，就无法保证幂等性了。</span></div></div><div id="bo3zA535oPTuq8jpHz8UHD" class="wolai-block"><figure class="wolai-center" style="width: 227.33333333333334px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><blockquote id="4LJAiwp3XLGHP4SMY7dMbt" class="wolai-block"><span class="inline-wrap">没有任何单个方案是万能的，在不同场景需要选择不同的适配方案，或者需要多个方案去组合起来解决综合性的问题</span></blockquote><div id="gi7pLwYUDgJ6AWATEPEbsb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pZ6CL6vaiJGGmFTK75ZWYx" class="wolai-block"><span class="wolai-serial-number">23.3.3</span><span class="inline-wrap">数据库乐观锁</span></h3><div id="3PVgBwHTKUvRwxGLhR76u6" class="wolai-block wolai-text"><div><span class="inline-wrap">先看下面这条<span class="jill"></span>SQL<span class="jill"></span>语句：</span></div></div><code-block id="wBS45WcKQfTGF8a6s67nJ8" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">update</span> t_goods <span class="token keyword">set</span> count <span class="token operator">=</span> count <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">where</span> good_id<span class="token operator">=</span><span class="token number">2</span> 虽然锁定了id，但是不满足幂等性</pre></div></code-block><div id="jmYEFBbx4BLRmPoynro8oo" class="wolai-block wolai-text"><div><span class="inline-wrap">解决方案是使用乐观锁：</span></div></div><code-block id="8q81v9fEVfMnSgN4QnrXPz" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">update</span> t_goods <span class="token keyword">set</span> count <span class="token operator">=</span> count <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> version <span class="token operator">=</span> version <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">where</span> good_id<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">and</span> version <span class="token operator">=</span> <span class="token number">1</span> 乐观锁的核心思想是：只允许基于最新版修改</pre></div></code-block><ul class="wolai-block"><li id="5SkTM3wcDGAxijFxfoJ7N2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">version<span class="jill"></span>初始值为<span class="jill"></span>1</span></li><li id="7UiE8sD8boXWpU66LbWkQU"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>事务第一次执行上述<span class="jill"></span>SQL<span class="jill"></span>语句，事务提交后，version<span class="jill"></span>值变成<span class="jill"></span>2</span></li><li id="9fKLtmG1JL8pqrDjackzKw"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B<span class="jill"></span>事务再次执行上述<span class="jill"></span>SQL<span class="jill"></span>语句，但<span class="jill"></span>B<span class="jill"></span>事务手里拿的<span class="jill"></span>version<span class="jill"></span>值还是<span class="jill"></span>1，version = 2<span class="jill"></span>的条件判断不成立所以无法更新，实现防重效果</span></li></ul><div id="mTc6xmKTNVcf8mTEbrMXx1" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="8ais3SaNARNa1Mtxocvfzo" class="wolai-block wolai-text"><div><span class="inline-wrap">乐观锁的局限性：每一次执行<span class="jill"></span>SQL<span class="jill"></span>时使用的<span class="jill"></span>version<span class="jill"></span>都需要先执行<span class="jill"></span>select<span class="jill"></span>语句查询，所以并发情况下可以防重，但串行情况不行</span></div></div><ul class="wolai-block"><li id="55Qcm5x41PSgw5HPo7f7im"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>事务查询<span class="jill"></span>version<span class="jill"></span>得到值<span class="jill"></span>8</span></li><li id="9WRuSJGfcw6sk5V75WQZzQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>事务基于<span class="jill"></span>8<span class="jill"></span>执行更新成功，version+1<span class="jill"></span>后变成<span class="jill"></span>9</span></li><li id="hs8TwosPv1w8HUE6W9Y8e7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">A<span class="jill"></span>事务提交之后结束</span></li><li id="kf9V7Lr4gAu6e6nvEg5cFV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B<span class="jill"></span>事务查询<span class="jill"></span>version<span class="jill"></span>得到值<span class="jill"></span>9</span></li><li id="7kwgHx4GFTB8VeqyscT5Uc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">B<span class="jill"></span>事务基于<span class="jill"></span>9<span class="jill"></span>执行更新仍然能够成功</span></li></ul><div id="2A7gxWkz1c3K41vD5U8Ldz" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><blockquote id="54gwGf9irRznc7keWHCwXZ" class="wolai-block"><span class="inline-wrap">没有任何单个方案是万能的，在不同场景需要选择不同的适配方案，或者需要多个方案去组合起来解决综合性的问题</span></blockquote><div id="5kRNwAtj5BgiTGJDo7tWXS" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="41QoqzKbLBFDxduHX4DwvV" class="wolai-block"><span class="wolai-serial-number">23.3.4</span><span class="inline-wrap">唯一性约束</span></h3><div id="xonURUnJG2Eayn8iphLvZx" class="wolai-block wolai-text"><div><span class="inline-wrap">插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。</span></div></div><div id="9xaxR2Vfcpwb7r5PSzqNJu" class="wolai-block wolai-text"><div><span class="inline-wrap">我们在数据库层面防止重复。这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。</span></div></div><div id="fdS31rhTnfh1kHzfqZa4GK" class="wolai-block wolai-text"><div><span class="inline-wrap">如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</span></div></div><div id="nY8tpUsiTBzrGa4G1yzNA5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pFouauCs9o9vUBCksbWhZt" class="wolai-block"><span class="wolai-serial-number">23.3.5</span><span class="inline-wrap">数据库中额外创建“防重表”</span></h3><div id="t6qgrSdvXcpBXtUcvYyscJ" class="wolai-block wolai-text"><div><span class="inline-wrap">使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。</span></div></div><div id="gkFm8kPP7EYMbacVQmpeuZ" class="wolai-block wolai-text"><div><span class="inline-wrap">这个保证了重复请求时，因为去重表有唯一约束，导致请求失败、事务回滚，从而避免了重复执行的问题。</span></div></div><div id="tW2Yy83Gd6nNiKJKPFVPvC" class="wolai-block wolai-text"><div><span class="inline-wrap">这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</span></div></div><div id="2TMyYNCacTSzVJ7YXhjAVi" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="9aV6sEZ6vtojz8yAu639M2" class="wolai-block"><span class="wolai-serial-number">23.3.6</span><span class="inline-wrap">特别提醒</span></h3><div id="8pF4kb62aLL6mQn4AH3i3W" class="wolai-block wolai-text"><div><span class="inline-wrap">一个接口中很可能会包含多条<span class="jill"></span>SQL<span class="jill"></span>语句操作，此时要求所有<span class="jill"></span>SQL<span class="jill"></span>语句都满足幂等性才能保证<span class="jill"></span>SQL<span class="jill"></span>所在接口满足幂等性；有任何一条<span class="jill"></span>SQL<span class="jill"></span>语句不满足幂等性，这个接口就需要附加其它措施才能保证幂等性。所以该问题一定要站在全局角度综合考虑，不能以偏概全</span></div></div><div id="eYEmRj2sqX24MAUGQsv6Ri" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="ke51whvVCL8zbeh25HN9iE" class="wolai-block"><span class="wolai-serial-number">23.4</span><span class="inline-wrap">幂等性实现方案：基于<span class="jill"></span>Redis Set<span class="jill"></span>防重</span></h2><h3 id="sNBLm4XYLEoRJYmYR5TrVb" class="wolai-block"><span class="wolai-serial-number">23.4.1</span><span class="inline-wrap">业务要求</span></h3><div id="oVF2WcoctekdpXn2wVST8A" class="wolai-block wolai-text"><div><span class="inline-wrap">有很多业务数据需要处理，且每条数据只能处理一次</span></div></div><div id="7Ydgewa5Cv6XCeMQZhzBXW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="ndMJtTqn5QAPYhjfUE6G3v" class="wolai-block"><span class="wolai-serial-number">23.4.2</span><span class="inline-wrap">解决方案</span></h3><div id="nTxFvHnmTrJ1y3FgMbZFci" class="wolai-block"><figure class="wolai-center" style="width: 682px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><ul class="wolai-block"><li id="mjpE3t42z48niAg1UDtTU2"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不同业务数据经过<span class="jill"></span>MD5<span class="jill"></span>计算会得到不同的值</span></li><li id="qsqQTpqci4RmwUCkXzeUMW"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在业务执行过程中，处理每一条数据之前先检查<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>SET<span class="jill"></span>集合中<span class="jill"></span>MD5<span class="jill"></span>值是否存在</span><ul class="wolai-block"><li id="mjeF4oZRSCVWr97VFAomjb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">存在：说明此前曾经执行过业务计算，流程终止</span></li><li id="sS9gGNptcFZVrQ3cJXJBfx"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不存在：说明此前没有执行过业务计算，所以执行业务操作后，计算<span class="jill"></span>MD5<span class="jill"></span>值存入<span class="jill"></span>Redis<span class="jill"></span>的<span class="jill"></span>SET<span class="jill"></span>集合</span></li></ul></li></ul><div id="k5XSgLSN4UnZMiuvrAYWZ5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oKYmcGywxPCQxFLbEkMiJa" class="wolai-block"><span class="wolai-serial-number">23.5</span><span class="inline-wrap">幂等性实现方案：业务层分布式锁</span></h2><div id="uThz5fPumK55fE3LPQn7N3" class="wolai-block wolai-text"><div><span class="inline-wrap">如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。</span></div></div><div id="eRGkk6kt9dxf8S7BxCTJ8V" class="wolai-block wolai-text"><div><span class="inline-wrap">获取到锁的必须先判断这个数据是否被处理过。</span></div></div><div id="jTeVeArKiG6KsGk18W7kmJ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="nr8Z6nKL7zj1VP3J7SmnSF" class="wolai-block"><span class="wolai-serial-number">23.6</span><span class="inline-wrap">幂等性实现方案：基于<span class="jill"></span>token<span class="jill"></span>防重</span></h2><h3 id="3X926vT43ssyPFMigiUGLc" class="wolai-block"><span class="wolai-serial-number">23.6.1</span><span class="inline-wrap">工作机制</span></h3><div id="3L5vzYszYhwSFrjx9EhLni" class="wolai-block wolai-text"><div><span class="inline-wrap">1、服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。  </span></div></div><div id="bkJSwuuUtaGgBr32vABo6z" class="wolai-block wolai-text"><div><span class="inline-wrap">2、然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。</span></div></div><div id="8qboR75bDjbPKHKb3ktkhb" class="wolai-block wolai-text"><div><span class="inline-wrap">3、服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token,继续执行业务。</span></div></div><div id="6VkvCZSky8YrPBdmcvBgws" class="wolai-block wolai-text"><div><span class="inline-wrap">4、如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</span></div></div><div id="3VTm8ce7KUsnuwU12TQfrR" class="wolai-block"><figure class="wolai-center" style="width: 733.3333333333334px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div><div id="eJaWUcYfbVmiW8ymeqVjan" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="uCuqJ8sCCACeUJgLTv12VD" class="wolai-block"><figure class="wolai-center" style="width: 733.3333333333334px; flex-direction: column"><img src="media/image_7.png" style="width: 100%"/></figure></div><div id="6fuKk5r378PkyKgbVScZXW" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="uDckkqBHBTaNnnuoUSPu7b" class="wolai-block"><figure class="wolai-center" style="width: 733.3333333333334px; flex-direction: column"><img src="media/image_8.png" style="width: 100%"/></figure></div><div id="kfX7eKkvARyKHYUBDyfHyq" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="pE82AGgjtSsJam5mDATUaz" class="wolai-block"><span class="wolai-serial-number">23.6.2</span><span class="inline-wrap">危险性</span></h3><div id="w3VcVQCynzWLZTcyCAgSNH" class="wolai-block wolai-text"><div><span class="inline-wrap">1、先删除 token 还是后删除 token；  </span></div></div><div id="tNQ9eSBDTvxVNRHq56M57r" class="wolai-block wolai-text"><div><span class="inline-wrap">(1) 先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致，请求还是不能执行。</span></div></div><div id="f9vWvuGnYhCiV3yvtXYBtR" class="wolai-block wolai-text"><div><span class="inline-wrap">(2) 后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别人继续重试，导致业务被执行两边</span></div></div><div id="mRPJYHDwBtrWMKH1fYCPFC" class="wolai-block wolai-text"><div><span class="inline-wrap">(3) 我们最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。</span></div></div><div id="hzPjGCm1NbGLPkVMyAhZQL" class="wolai-block wolai-text"><div><span class="inline-wrap">2、Token 获取、比较和删除必须是原子性</span></div></div><div id="cBgFEjVgywqFq7PoKoRTzC" class="wolai-block wolai-text"><div><span class="inline-wrap">(1) redis.get(token) 、token.equals、redis.del(token)如果这两个操作不是原子，可能导致，高并发下，都 get 到同样的数据，判断都成功，继续业务并发执行</span></div></div><div id="9j5sEhZdU8xHvn56bMDSRY" class="wolai-block wolai-text"><div><span class="inline-wrap">(2) 可以在 redis 使用 lua 脚本完成这个操作。</span></div></div><code-block id="7Jk46E1dFa2oVswhoViYrc" class="wolai-block"><div class="wolai-pre"><div data-lang="Lua" class="marker"></div><pre><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span> <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span>
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">end</span></pre></div></code-block><blockquote id="agF3GWo99Awh8ykKN39tqr" class="wolai-block"><span class="inline-wrap">没有任何单个方案是万能的，在不同场景需要选择不同的适配方案，或者需要多个方案去组合起来解决综合性的问题</span></blockquote><div id="r6p6FriE9UTe8PCwmHtDvG" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="vmui5kDWsGwk6aGnG31614" class="bg-lavender_blue wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="qug75UMe4gLpN2vt3cK9GD" class="wolai-block"><span class="wolai-serial-number">24</span><span class="inline-wrap">微服务架构的服务治理包括哪些方面？</span></h1><h2 id="jrF35qN33xbpNx233kmiKz" class="wolai-block"><span class="wolai-serial-number">24.1</span><span class="inline-wrap">服务注册与发现</span></h2><div id="oEjLnEx42q1GVVszYoEPQ1" class="wolai-block wolai-text"><div><span class="inline-wrap">使用服务注册表来管理所有微服务的信息，包括服务名称、地址、版本等。</span></div></div><div id="v6euDdYkFHU1PuzqeydM71" class="wolai-block wolai-text"><div><span class="inline-wrap">服务提供者将自己的信息注册到注册表中，服务消费者通过注册表来发现可用的服务。</span></div></div><div id="wQaNX4SZk9FZa2QX4ep7qH" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的服务注册与发现工具有<span class="jill"></span>Consul、ZooKeeper<span class="jill"></span>和<span class="jill"></span>etcd<span class="jill"></span>等。</span></div></div><div id="gX5LKZaVVWEwPng6Faq97Q" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wvNRB2U1mV5e165GZgge9A" class="wolai-block"><span class="wolai-serial-number">24.2</span><span class="inline-wrap">负载均衡</span></h2><div id="3PPvTytZtZQ6LcRyQE8yK2" class="wolai-block wolai-text"><div><span class="inline-wrap">通过在服务提供者与服务消费者之间引入负载均衡器，将请求平均分配到多个服务实例上，以提高系统的可伸缩性和可用性。</span></div></div><div id="NiwqRN6AXJHo29EsVk8u9" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的负载均衡器有<span class="jill"></span>Nginx、HAProxy<span class="jill"></span>和<span class="jill"></span>Envoy<span class="jill"></span>等。  </span></div></div><div id="qe1krPBsxtKEAMrqg7DCum" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="4D91ujYPyQp8RK4m1dcic" class="wolai-block"><span class="wolai-serial-number">24.3</span><span class="inline-wrap">健康检查与容错机制</span></h2><div id="fLe7qJoEGgbSj3jVs1tsrx" class="wolai-block wolai-text"><div><span class="inline-wrap">通过定期的健康检查来监测服务的可用性和状态，并根据检查结果进行容错处理，比如自动剔除不可用的服务实例。</span></div></div><div id="bvpJuCprHaVCv2UraToCm7" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的健康检查工具有<span class="jill"></span>Spring Cloud<span class="jill"></span>的<span class="jill"></span>Spring Boot Admin、Netflix<span class="jill"></span>的<span class="jill"></span>Hystrix<span class="jill"></span>和<span class="jill"></span>Istio<span class="jill"></span>等。</span></div></div><div id="wMav1DrhbS7bqrDoGBB1t4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="pEKCddTEtcX1xFWT1UuXKA" class="wolai-block"><span class="wolai-serial-number">24.4</span><span class="inline-wrap">熔断器与降级</span></h2><div id="2D4rESBbYsdmzsgRiG1WpY" class="wolai-block wolai-text"><div><span class="inline-wrap">在高并发或异常情况下，通过熔断器来控制请求的流量，避免服务的雪崩效应。</span></div></div><div id="jCQRH6qD1BABv96NiDe9SC" class="wolai-block wolai-text"><div><span class="inline-wrap">同时可以通过降级策略，在服务不可用时返回默认值或者静态数据，保证系统的可用性。</span></div></div><div id="25Qq2KPWDGxUdEpNYL4u34" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的熔断器和降级工具有<span class="jill"></span>Netflix<span class="jill"></span>的<span class="jill"></span>Hystrix<span class="jill"></span>和<span class="jill"></span>Sentinel<span class="jill"></span>等。</span></div></div><div id="mLx2gVnkQLgcik5ES43QVe" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="kbeVWzbTiTqGjTry6f22ow" class="wolai-block"><span class="wolai-serial-number">24.5</span><span class="inline-wrap">配置中心</span></h2><div id="oHu24sqyuxwzeRZBfEnrRY" class="wolai-block wolai-text"><div><span class="inline-wrap">将微服务的配置集中管理，实现配置的动态更新和版本控制。通过配置中心，可以动态修改微服务的配置，而无需重启服务。</span></div></div><div id="oRdm3G2AiFDUBawSJxbPHP" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的配置中心有<span class="jill"></span>Spring Cloud Config、Apollo<span class="jill"></span>和<span class="jill"></span>Consul<span class="jill"></span>等。</span></div></div><div id="uJuJeCzrtrneJQ2CHYU4QT" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="wyCmtCh5EfEoZYH84cEVNt" class="wolai-block"><span class="wolai-serial-number">24.6</span><span class="inline-wrap">API 网关</span></h2><div id="tg79vYQ5y2Jrz3xTQcPHE" class="wolai-block wolai-text"><div><span class="inline-wrap">通过引入 API 网关来对外暴露微服务的统一接口，实现请求的路由、转发和过滤等功能。</span></div></div><div id="sv2EMgXZwKThibpP1cTEoC" class="wolai-block wolai-text"><div><span class="inline-wrap">API 网关可以对请求进行鉴权和限流，提供统一的访问控制和监控。</span></div></div><div id="dt4SwsDGwXVFdD747k5urJ" class="wolai-block wolai-text"><div><span class="inline-wrap">常见的 API 网关有<span class="jill"></span>Spring Cloud Gateway、Netflix<span class="jill"></span>的<span class="jill"></span>Zuul<span class="jill"></span>和<span class="jill"></span>Kong<span class="jill"></span>等。</span></div></div><div id="x1SNdX6ttCWFtRb5z9mnGp" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>